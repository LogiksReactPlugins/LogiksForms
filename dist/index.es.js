import Xd, { useState as qb, useRef as N3, useEffect as Ip, useMemo as MY, lazy as FQ, Suspense as LQ } from "react";
import bu from "axios";
import * as pu from "yup";
import { useFormik as f7 } from "formik";
var d7 = { exports: {} }, ZN = {};
/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var zX;
function HQ() {
  if (zX) return ZN;
  zX = 1;
  var V = Symbol.for("react.transitional.element"), me = Symbol.for("react.fragment");
  function pt(rt, Nt, mt) {
    var nn = null;
    if (mt !== void 0 && (nn = "" + mt), Nt.key !== void 0 && (nn = "" + Nt.key), "key" in Nt) {
      mt = {};
      for (var De in Nt)
        De !== "key" && (mt[De] = Nt[De]);
    } else mt = Nt;
    return Nt = mt.ref, {
      $$typeof: V,
      type: rt,
      key: nn,
      ref: Nt !== void 0 ? Nt : null,
      props: mt
    };
  }
  return ZN.Fragment = me, ZN.jsx = pt, ZN.jsxs = pt, ZN;
}
var GN = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var VX;
function zQ() {
  return VX || (VX = 1, process.env.NODE_ENV !== "production" && function() {
    function V(he) {
      if (he == null) return null;
      if (typeof he == "function")
        return he.$$typeof === jt ? null : he.displayName || he.name || null;
      if (typeof he == "string") return he;
      switch (he) {
        case un:
          return "Fragment";
        case In:
          return "Profiler";
        case Xe:
          return "StrictMode";
        case On:
          return "Suspense";
        case Ot:
          return "SuspenseList";
        case Gn:
          return "Activity";
      }
      if (typeof he == "object")
        switch (typeof he.tag == "number" && console.error(
          "Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."
        ), he.$$typeof) {
          case pn:
            return "Portal";
          case U:
            return (he.displayName || "Context") + ".Provider";
          case lt:
            return (he._context.displayName || "Context") + ".Consumer";
          case Ye:
            var ue = he.render;
            return he = he.displayName, he || (he = ue.displayName || ue.name || "", he = he !== "" ? "ForwardRef(" + he + ")" : "ForwardRef"), he;
          case oe:
            return ue = he.displayName || null, ue !== null ? ue : V(he.type) || "Memo";
          case Yt:
            ue = he._payload, he = he._init;
            try {
              return V(he(ue));
            } catch {
            }
        }
      return null;
    }
    function me(he) {
      return "" + he;
    }
    function pt(he) {
      try {
        me(he);
        var ue = !1;
      } catch {
        ue = !0;
      }
      if (ue) {
        ue = console;
        var bt = ue.error, cn = typeof Symbol == "function" && Symbol.toStringTag && he[Symbol.toStringTag] || he.constructor.name || "Object";
        return bt.call(
          ue,
          "The provided key is an unsupported type %s. This value must be coerced to a string before using it here.",
          cn
        ), me(he);
      }
    }
    function rt(he) {
      if (he === un) return "<>";
      if (typeof he == "object" && he !== null && he.$$typeof === Yt)
        return "<...>";
      try {
        var ue = V(he);
        return ue ? "<" + ue + ">" : "<...>";
      } catch {
        return "<...>";
      }
    }
    function Nt() {
      var he = X.A;
      return he === null ? null : he.getOwner();
    }
    function mt() {
      return Error("react-stack-top-frame");
    }
    function nn(he) {
      if (se.call(he, "key")) {
        var ue = Object.getOwnPropertyDescriptor(he, "key").get;
        if (ue && ue.isReactWarning) return !1;
      }
      return he.key !== void 0;
    }
    function De(he, ue) {
      function bt() {
        St || (St = !0, console.error(
          "%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://react.dev/link/special-props)",
          ue
        ));
      }
      bt.isReactWarning = !0, Object.defineProperty(he, "key", {
        get: bt,
        configurable: !0
      });
    }
    function et() {
      var he = V(this.type);
      return A[he] || (A[he] = !0, console.error(
        "Accessing element.ref was removed in React 19. ref is now a regular prop. It will be removed from the JSX Element type in a future release."
      )), he = this.props.ref, he !== void 0 ? he : null;
    }
    function Tt(he, ue, bt, cn, fn, Fn, ye, He) {
      return bt = Fn.ref, he = {
        $$typeof: Cn,
        type: he,
        key: ue,
        props: Fn,
        _owner: fn
      }, (bt !== void 0 ? bt : null) !== null ? Object.defineProperty(he, "ref", {
        enumerable: !1,
        get: et
      }) : Object.defineProperty(he, "ref", { enumerable: !1, value: null }), he._store = {}, Object.defineProperty(he._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: 0
      }), Object.defineProperty(he, "_debugInfo", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: null
      }), Object.defineProperty(he, "_debugStack", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: ye
      }), Object.defineProperty(he, "_debugTask", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: He
      }), Object.freeze && (Object.freeze(he.props), Object.freeze(he)), he;
    }
    function $n(he, ue, bt, cn, fn, Fn, ye, He) {
      var P = ue.children;
      if (P !== void 0)
        if (cn)
          if (ns(P)) {
            for (cn = 0; cn < P.length; cn++)
              Mt(P[cn]);
            Object.freeze && Object.freeze(P);
          } else
            console.error(
              "React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead."
            );
        else Mt(P);
      if (se.call(ue, "key")) {
        P = V(he);
        var ro = Object.keys(ue).filter(function(oo) {
          return oo !== "key";
        });
        cn = 0 < ro.length ? "{key: someKey, " + ro.join(": ..., ") + ": ...}" : "{key: someKey}", jo[P + cn] || (ro = 0 < ro.length ? "{" + ro.join(": ..., ") + ": ...}" : "{}", console.error(
          `A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`,
          cn,
          P,
          ro,
          P
        ), jo[P + cn] = !0);
      }
      if (P = null, bt !== void 0 && (pt(bt), P = "" + bt), nn(ue) && (pt(ue.key), P = "" + ue.key), "key" in ue) {
        bt = {};
        for (var Ln in ue)
          Ln !== "key" && (bt[Ln] = ue[Ln]);
      } else bt = ue;
      return P && De(
        bt,
        typeof he == "function" ? he.displayName || he.name || "Unknown" : he
      ), Tt(
        he,
        P,
        Fn,
        fn,
        Nt(),
        bt,
        ye,
        He
      );
    }
    function Mt(he) {
      typeof he == "object" && he !== null && he.$$typeof === Cn && he._store && (he._store.validated = 1);
    }
    var vn = Xd, Cn = Symbol.for("react.transitional.element"), pn = Symbol.for("react.portal"), un = Symbol.for("react.fragment"), Xe = Symbol.for("react.strict_mode"), In = Symbol.for("react.profiler"), lt = Symbol.for("react.consumer"), U = Symbol.for("react.context"), Ye = Symbol.for("react.forward_ref"), On = Symbol.for("react.suspense"), Ot = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), Yt = Symbol.for("react.lazy"), Gn = Symbol.for("react.activity"), jt = Symbol.for("react.client.reference"), X = vn.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, se = Object.prototype.hasOwnProperty, ns = Array.isArray, an = console.createTask ? console.createTask : function() {
      return null;
    };
    vn = {
      "react-stack-bottom-frame": function(he) {
        return he();
      }
    };
    var St, A = {}, No = vn["react-stack-bottom-frame"].bind(
      vn,
      mt
    )(), ot = an(rt(mt)), jo = {};
    GN.Fragment = un, GN.jsx = function(he, ue, bt, cn, fn) {
      var Fn = 1e4 > X.recentlyCreatedOwnerStacks++;
      return $n(
        he,
        ue,
        bt,
        !1,
        cn,
        fn,
        Fn ? Error("react-stack-top-frame") : No,
        Fn ? an(rt(he)) : ot
      );
    }, GN.jsxs = function(he, ue, bt, cn, fn) {
      var Fn = 1e4 > X.recentlyCreatedOwnerStacks++;
      return $n(
        he,
        ue,
        bt,
        !0,
        cn,
        fn,
        Fn ? Error("react-stack-top-frame") : No,
        Fn ? an(rt(he)) : ot
      );
    };
  }()), GN;
}
var UX;
function VQ() {
  return UX || (UX = 1, process.env.NODE_ENV === "production" ? d7.exports = HQ() : d7.exports = zQ()), d7.exports;
}
var ie = VQ();
const UQ = ["jpg", "jpeg", "png", "gif", "svg", "webp"], jQ = ["mp4", "webm", "ogg"], WQ = ["txt", "json", "csv"], ZQ = ["pdf"];
function GQ(V) {
  return V.template === "accordion" ? "accordion" : V.template === "simple" ? "simple" : V.template === "cards" ? "cards" : Object.values(V.fields || {}).some((rt) => rt.group) ? "tab" : "simple";
}
function qQ(V, me = "create", pt = "Info") {
  const rt = {};
  let Nt = !1;
  if (Object.values(V).forEach((nn) => {
    nn.group && (Nt = !0);
  }), !Nt) return {};
  const mt = [];
  return Object.entries(V).forEach(([nn, De]) => {
    if (De.vmode === "edit" && me === "create") return;
    const et = { ...De, name: nn };
    if (De.group) {
      const Tt = De.group;
      rt[Tt] || (rt[Tt] = []), rt[Tt].push(et);
    } else
      mt.push(et);
  }), mt.length > 0 ? {
    [pt]: mt,
    ...rt
  } : rt;
}
function jX(V, me = "create") {
  const pt = {};
  return Object.keys(V).forEach((rt) => {
    V[rt].vmode === "edit" && me === "create" || (pt[rt] = {
      label: rt,
      required: V[rt].required ?? !1
    });
  }), pt;
}
const YN = (V, me, pt, rt, Nt, mt) => {
  const nn = mt === "create" && Nt ? RQ(Nt) : {};
  V.forEach((De) => {
    const et = De?.name;
    if (!et) return;
    let Tt = rt?.[et];
    const $n = mt === "create" && Nt ? DQ(De) : null;
    mt === "create" && $n && nn[$n] !== void 0 && Tt == null && (Tt = nn[$n]), Tt == null && (Tt = De.default), De.multiple === !0 || De.type === "checkbox" || De.type === "tags" ? me[et] = Array.isArray(Tt) ? Tt : typeof Tt == "string" ? Tt.split(",").map((vn) => vn.trim()).filter(Boolean) : [] : De.type === "json" ? me[et] = typeof Tt == "object" && Tt !== null ? JSON.stringify(Tt, null, 2) : Tt ?? "" : De.type === "date" ? me[et] = typeof Tt == "string" ? Tt.slice(0, 10) : "" : De.type === "time" ? typeof Tt == "string" ? Tt.includes("T") ? me[et] = Tt.slice(11, 16) : me[et] = Tt.slice(0, 5) : me[et] = "" : et === "blocked" || et === "blacklist" ? me[et] = String(Tt ?? "false") : me[et] = Tt ?? "";
    let Mt;
    De.type === "file" ? Mt = De.multiple ? pu.array().of(pu.mixed()) : pu.mixed() : De.multiple === !0 || De.type === "checkbox" || De.type === "tags" ? Mt = pu.array().of(pu.string()) : De.type === "email" ? Mt = pu.string().email("Invalid email") : De.type === "number" ? Mt = pu.number().typeError("Must be a number") : De.type === "json" ? Mt = pu.string().test("json", "Invalid JSON", (vn) => {
      if (!vn) return !0;
      try {
        return JSON.parse(vn), !0;
      } catch {
        return !1;
      }
    }) : Mt = pu.string(), De.required && (Mt = Mt.required(
      De.error_message || `${De.label || et} is required`
    )), De?.validate?.regex && typeof De.validate.regex == "string" && (Mt = Mt.matches(
      new RegExp(De?.validate?.regex),
      De?.error_message || "Invalid input format"
    )), De?.validate && Object.entries(De.validate).forEach(([vn, Cn]) => {
      switch (vn) {
        case "email":
          Cn && (Mt = Mt.email("Invalid email format"));
          break;
        case "mobile":
          Mt = Mt.matches(
            /^[1-9][0-9]*$/,
            "Invalid mobile number format"
          );
          break;
        case "regex":
          Mt = Mt.matches(
            new RegExp(Cn),
            `Must match pattern: ${Cn}`
          );
          break;
        case "date":
          Mt = pu.date().typeError("Invalid date format (expected dd/MM/yyyy or dd-MM-yyyy)").transform((pn, un) => {
            if (typeof un == "string") {
              const Xe = un.replace(/-/g, "/"), [In, lt, U] = Xe.split("/");
              if (In && lt && U)
                return /* @__PURE__ */ new Date(`${U}-${lt}-${In}`);
            }
            return pn;
          });
          break;
        case "time":
          Mt = Mt.matches(
            /^([0-1][0-9]|2[0-3])[:\-]([0-5][0-9])$/,
            "Invalid time format (HH:MM)"
          );
          break;
        case "timesec":
          Mt = Mt.matches(
            /^([0-1][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/,
            "Invalid time format (HH:MM:SS)"
          );
          break;
        case "number":
        case "numeric":
          Mt = pu.number().typeError("Must be numeric");
          break;
        case "float":
        case "decimal":
          Mt = pu.number().typeError("Must be a decimal").transform((pn, un) => {
            if (un == null || un === "") return;
            const Xe = Number(un);
            if (isNaN(Xe)) return pn;
            if (typeof pn == "number" && !isNaN(pn)) {
              const In = Number(pn);
              return Number.isInteger(In) ? Number(Xe.toFixed(In)) : Xe;
            }
            return Xe;
          });
          break;
        case "alphanumeric":
          Mt = Mt.matches(
            /^[a-z0-9]+$/i,
            "Must be alphanumeric"
          );
          break;
        case "alpha":
          Mt = Mt.matches(
            /^[a-zA-Z]+$/,
            "Must contain only letters"
          );
          break;
        case "upper":
          Mt = Mt.transform(
            (pn) => pn && pn.toUpperCase()
          );
          break;
        case "lower":
          Mt = Mt.transform(
            (pn) => pn && pn.toLowerCase()
          );
          break;
        case "length-min": {
          const pn = Number(Cn);
          isNaN(pn) || (Mt = Mt.min(pn, `Minimum length is ${pn}`));
          break;
        }
        case "length-max": {
          const pn = Number(Cn);
          isNaN(pn) || (Mt = Mt.max(pn, `Maximum length is ${pn}`));
          break;
        }
      }
    }), pt[et] = Mt;
  });
}, XN = {
  12: "lg:col-span-12",
  11: "lg:col-span-11",
  10: "lg:col-span-10",
  9: "lg:col-span-9",
  8: "lg:col-span-8",
  7: "lg:col-span-7",
  6: "lg:col-span-6",
  5: "lg:col-span-5",
  4: "lg:col-span-4",
  3: "lg:col-span-3",
  2: "lg:col-span-2",
  1: "lg:col-span-1"
};
function QN(V) {
  return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12].includes(V) ? V : 6;
}
const g7 = (V) => V === !0 || V === "true", Kb = (V, me) => typeof V == "string" ? V.replace(
  /#(\w+)#/g,
  (pt, rt) => me[rt] !== void 0 ? String(me[rt]) : pt
) : Array.isArray(V) ? V.map((pt) => Kb(pt, me)) : V && typeof V == "object" ? Object.fromEntries(
  Object.entries(V).map(([pt, rt]) => [
    Kb(pt, me),
    Kb(rt, me)
  ])
) : V, D3 = (V, me, pt, rt) => {
  if (!Array.isArray(pt) || pt.length === 0) return {};
  const Nt = rt ?? (pt[0] && typeof pt[0] == "object" && "category" in pt[0] ? "category" : void 0);
  if (!Nt) {
    const nn = {};
    return pt.forEach((De) => {
      const et = De[V], Tt = De[me];
      et != null && Tt != null && (nn[String(et)] = String(Tt));
    }), nn;
  }
  const mt = {};
  return pt.forEach((nn) => {
    const De = nn[Nt] ?? "Others", et = nn[V], Tt = nn[me];
    et == null || Tt == null || (mt[De] || (mt[De] = {}), mt[De][String(et)] = String(Tt));
  }), mt;
}, PY = (V, me) => {
  if (!V || me == null) return;
  const pt = String(me);
  if (typeof Object.values(V)[0] == "string")
    return V[pt];
  for (const Nt of Object.values(V))
    if (pt in Nt)
      return Nt[pt];
}, KQ = (V) => {
  if (!V) return [];
  if (Array.isArray(V))
    return V.map(
      (rt) => [
        String(rt.value),
        String(rt.title ?? rt.label ?? rt.value)
      ]
    );
  const me = Object.values(V);
  return me.length ? typeof me[0] == "string" ? Object.entries(V).map(([rt, Nt]) => [String(rt), Nt]) : Object.values(V).flatMap(
    (rt) => Object.entries(rt).map(
      ([Nt, mt]) => [String(Nt), mt]
    )
  ) : [];
}, WX = (V) => {
  if (!V || typeof V != "object") return !1;
  const me = Object.values(V)[0];
  return typeof me == "object" && me !== null && !Array.isArray(me);
};
async function YQ() {
  if (!("geolocation" in navigator))
    throw new Error(
      "Geolocation is not supported by this browser. You cannot access this portal."
    );
  try {
    const V = await new Promise(
      (rt, Nt) => {
        navigator.geolocation.getCurrentPosition(rt, Nt, {
          enableHighAccuracy: !1,
          timeout: 3e4,
          maximumAge: 12e4
        });
      }
    ), { latitude: me, longitude: pt } = V.coords;
    return `${me},${pt}`;
  } catch (V) {
    if (!(V instanceof GeolocationPositionError))
      throw new Error("Failed to get your location.");
    switch (V.code) {
      case V.PERMISSION_DENIED:
        throw new Error("Please allow location access in browser settings.");
      case V.POSITION_UNAVAILABLE:
        throw new Error(
          "Unable to detect your location. Try connecting to Wi-Fi."
        );
      case V.TIMEOUT:
        throw new Error("Your device took too long to fetch GPS position.");
      default:
        throw new Error("Failed to get your location.");
    }
  }
}
const XQ = (V) => Object.entries(V ?? {}).filter(([, me]) => me.type === "geolocation").map(([me]) => me);
function QQ(V, me = "create") {
  return Object.entries(V).filter(([, pt]) => !(pt.vmode === "edit" && me === "create")).map(([pt, rt]) => ({
    ...rt,
    name: pt
  }));
}
function qN(V, me, pt) {
  const rt = DQ(me);
  rt && pt && nJ(pt, rt, V);
}
function JQ(V) {
  return typeof V == "object" && V !== null && typeof V.target == "string" && typeof V.src == "object" && V.src !== null && typeof V.src.table == "string";
}
function eJ(V) {
  return V.split(",").map((me) => me.trim()).map((me) => {
    const pt = me.match(/^(.+?)\s+as\s+.+$/i);
    return pt ? pt[1]?.trim() : me;
  }).filter((me) => !!me);
}
const R3 = (V) => {
  if (V == null || typeof V != "object")
    return { value: V, title: V };
  const me = {};
  for (const [pt, rt] of Object.entries(V)) {
    const Nt = pt.includes(".") ? pt.split(".").pop() : pt;
    if (Nt in me) {
      console.warn(`Duplicate key after normalization: ${Nt}`);
      continue;
    }
    me[Nt] = rt;
  }
  return me;
}, tJ = "__form_persist__", OQ = (V) => `${tJ}:${V}`;
function DQ(V) {
  return V.persistent ? V.persistent === !0 ? V.name : typeof V.persistent == "string" ? V.persistent : null : null;
}
function RQ(V) {
  try {
    return JSON.parse(localStorage.getItem(OQ(V)) || "{}");
  } catch {
    return {};
  }
}
function nJ(V, me, pt) {
  const rt = RQ(V);
  localStorage.setItem(
    OQ(V),
    JSON.stringify({
      ...rt,
      [me]: pt
    })
  );
}
function oJ(V = "") {
  return V.split(".").pop()?.toLowerCase() ?? "";
}
function sJ(V) {
  return UQ.includes(V) ? "image" : jQ.includes(V) ? "video" : ZQ.includes(V) ? "pdf" : WQ.includes(V) ? "text" : "other";
}
const ZX = {
  image: "fa fa-file-image",
  pdf: "fa fa-file-pdf",
  video: "fa fa-file-video",
  text: "fa fa-file-lines",
  other: "fa fa-file"
}, KN = (V) => ({
  Authorization: `Bearer ${V.accessToken}`
}), DY = async (V) => (await bu.get(
  V.baseURL + V.dbopsGetHash,
  { headers: KN(V) }
)).data.refhash, RY = async (V, me) => (await bu.post(
  V.baseURL + V.dbopsGetRefId,
  me,
  { headers: KN(V) }
)).data.refid, rJ = {
  async fetch(V, me, pt, rt) {
    const Nt = await DY(V);
    let mt = !1, nn;
    pt && (mt = !0, nn = pt), mt || (nn = await RY(V, {
      operation: "fetch",
      source: me.source,
      fields: me.fields ?? {},
      datahash: Nt,
      srcid: rt
    }));
    const De = await bu.post(
      V.baseURL + V.dbopsFetch,
      { refid: nn, datahash: Nt },
      { headers: KN(V) }
    );
    return De.data?.data ?? De.data;
  },
  async create(V, me, pt) {
    const rt = await DY(V), Nt = await RY(V, {
      operation: "create",
      source: me.source,
      fields: me.values,
      datahash: rt,
      srcid: pt
    });
    return (await bu.post(
      V.baseURL + V.dbopsCreate,
      { refid: Nt, fields: me.values, datahash: rt },
      { headers: KN(V) }
    )).data;
  },
  async update(V, me, pt) {
    const rt = await DY(V), Nt = await RY(V, {
      operation: "update",
      source: me.source,
      fields: me.values,
      datahash: rt,
      srcid: pt
    });
    return (await bu.post(
      V.baseURL + V.dbopsUpdate,
      { refid: Nt, fields: me.values, datahash: rt },
      { headers: KN(V) }
    )).data;
  }
};
async function m7(V, me, pt, rt = void 0, Nt = void 0, mt = {}) {
  try {
    let nn = pt;
    return nn || (nn = (await bu({
      method: "POST",
      url: V.baseURL + V.registerQuery,
      data: { query: me ?? {}, srcid: Nt },
      headers: {
        Authorization: `Bearer ${V?.accessToken}`
      }
    })).data.queryid), await bu({
      method: "POST",
      url: V.baseURL + V.runQuery,
      data: {
        queryid: nn,
        filter: mt,
        refid: rt,
        page: 0,
        limit: 1e4
      },
      headers: {
        Authorization: `Bearer ${V?.accessToken}`
      }
    });
  } catch (nn) {
    throw nn;
  }
}
async function NQ(V, me) {
  let pt = me.previewPath ?? "/api/files/preview";
  const rt = await bu.get(
    `${me.baseURL}${pt}?uri=${encodeURIComponent(V)}`,
    {
      responseType: "blob",
      headers: {
        Authorization: `Bearer ${me?.accessToken}`
      }
    }
  );
  return URL.createObjectURL(rt.data);
}
async function MQ(V, me) {
  if (!V?.uploadURL)
    throw new Error("Upload URL missing");
  const pt = V.baseURL + V.uploadURL;
  return Promise.all(
    Array.from(me).map(async (rt) => {
      const Nt = new FormData();
      return Nt.append("file", rt), (await bu.post(pt, Nt, {
        headers: {
          "Content-Type": "multipart/form-data",
          Authorization: `Bearer ${V.accessToken}`
        }
      })).data;
    })
  );
}
function aJ({
  field: V,
  formik: me,
  methods: pt = {},
  sqlOpsUrls: rt,
  refid: Nt,
  module_refid: mt = "menuManager.main",
  optionsOverride: nn,
  setFieldOptions: De
}) {
  const [et, Tt] = qb(!1), [$n, Mt] = qb(
    nn ?? V.options ?? {}
  );
  N3(null);
  const vn = N3(null), [Cn, pn] = qb(""), [un, Xe] = qb(0), In = N3(null), lt = N3(null), [U, Ye] = qb(!1), On = N3(Cn), Ot = V.disabled === !0;
  Ip(() => {
    On.current = Cn;
  }, [Cn]);
  const oe = (ue) => {
    if (Ot) {
      ue.preventDefault(), lt.current?.removeAttribute("open");
      return;
    }
    ue.currentTarget.open || pn("");
  };
  Ip(() => {
    nn && Object.keys(nn).length !== 0 && Mt(nn);
  }, [nn]), Ip(() => {
    const ue = (bt) => {
      lt.current && !lt.current.contains(bt.target) && (lt.current.open = !1, pn(""));
    };
    return document.addEventListener("mousedown", ue), () => {
      document.removeEventListener("mousedown", ue);
    };
  }, []);
  const Yt = V.name;
  Ip(() => {
    let ue = !0;
    return (async () => {
      let cn = V.valueKey ?? "value", fn = V.labelKey ?? "title";
      if (V?.options) {
        if (typeof V.options == "object" && !Array.isArray(V.options)) {
          const ro = Object.values(V.options);
          if (ro.length && typeof ro[0] == "string") {
            Mt(V.options);
            return;
          }
        }
        const He = (Array.isArray(V.options) ? V.options : [V.options]).map(R3), P = D3(
          cn,
          fn,
          He,
          V.groupKey
          // auto-uses `category` if present
        );
        Mt(P);
        return;
      }
      const Fn = V?.source ?? {};
      if (V.type === "dataMethod") {
        const ye = V.method, He = ye ? pt[ye] : void 0;
        if (He)
          try {
            const P = await He(), ro = Array.isArray(P?.data?.data) ? P.data.data : Array.isArray(P?.data) ? P.data : P;
            if (typeof ro == "object" && !Array.isArray(ro)) {
              const ao = Object.values(ro);
              if (ao.length && typeof ao[0] == "string") {
                Mt(ro);
                return;
              }
            }
            const Ln = Array.isArray(ro) ? ro.map(R3) : [], oo = D3(cn, fn, Ln, V.groupKey);
            ue && Mt(oo);
          } catch (P) {
            console.error("Method execution failed:", P), ue && Mt({});
          }
        else
          ue && Mt({});
      }
      if (Fn.type === "api" && Fn.url)
        try {
          const ye = await bu({
            method: Fn.method || "GET",
            url: Fn.url,
            data: Fn.body ?? {},
            params: Fn.params ?? {},
            headers: Fn.headers ?? {}
          }), He = Array.isArray(ye?.data?.data) ? ye.data.data : Array.isArray(ye?.data) ? ye.data : ye;
          if (typeof He == "object" && !Array.isArray(He)) {
            const Ln = Object.values(He);
            if (Ln.length && typeof Ln[0] == "string") {
              Mt(He);
              return;
            }
          }
          const P = Array.isArray(He) ? He.map(R3) : [], ro = D3(cn, fn, P, V.groupKey);
          ue && Mt(ro);
        } catch (ye) {
          console.error("API execution failed:", ye), ue && Mt({});
        }
      if (V.table || V.type === "dataSelector" || V.queryid) {
        if (!rt) {
          console.error("SQL source requires formJson.endPoints but it is missing");
          return;
        }
        try {
          let ye;
          if (V.type === "dataSelector")
            ye = {
              table: "do_lists",
              cols: "title,value",
              where: {
                groupid: V.groupid ?? ""
              }
            };
          else if (!V.queryid) {
            if (!V.table || !V.columns) {
              console.error("Invalid SQL field config", V);
              return;
            }
            ye = {
              table: V.table,
              cols: V.columns,
              where: V.where ? Nt ? Kb(V.where, { refid: Nt }) : V.where : void 0
            };
          }
          const He = await m7(rt, ye, V?.queryid, void 0, mt), P = Array.isArray(He?.data?.data) ? He.data.data : Array.isArray(He?.data) ? He.data : He;
          if (typeof P == "object" && !Array.isArray(P)) {
            const oo = Object.values(P);
            if (oo.length && typeof oo[0] == "string") {
              Mt(P);
              return;
            }
          }
          const ro = Array.isArray(P) ? P.map(R3) : [], Ln = D3(cn, fn, ro, V.groupKey);
          ue && Mt(Ln);
        } catch (ye) {
          console.error("API fetch failed:", ye);
        }
      }
    })(), () => {
      ue = !1;
    };
  }, [
    V.options,
    V.source,
    V.table,
    V.columns,
    V.where,
    Nt,
    V.queryid,
    V.groupKey,
    V.valueKey,
    V.labelKey
  ]);
  const Gn = `
  w-full px-4 py-2 rounded-lg border transition-all duration-300
  backdrop-blur-sm text-gray-800 placeholder-gray-400
  focus:outline-none focus:ring-0

  ${Ot ? "bg-gray-100 border-gray-200 text-gray-500 cursor-not-allowed" : "bg-white border-gray-300 hover:border-gray-400 focus:border-indigo-500 focus:shadow-md"}
`, jt = `
    border-gradient-to-r 
    focus:border-gray-400 focus:shadow-lg focus:shadow-gray-100/50
  `, X = `
    block text-sm font-semibold mb-1  transition-all duration-300 text-gray-700
  `, se = MY(
    () => KQ($n),
    [$n]
  ), ns = se.length, an = MY(() => V.search || !Cn ? se : se.filter(
    ([, ue]) => ue.toLowerCase().includes(Cn.toLowerCase())
  ), [V.search, Cn, se]), St = (ue, bt) => {
    if (lt.current?.open === !0 || U === !0)
      if (ue.key === "ArrowDown")
        ue.preventDefault(), Xe(
          (cn) => cn + 1 < an.length ? cn + 1 : 0
        );
      else if (ue.key === "ArrowUp")
        ue.preventDefault(), Xe(
          (cn) => cn - 1 >= 0 ? cn - 1 : an.length - 1
        );
      else if (ue.key === "Enter") {
        ue.preventDefault();
        const [cn] = an[un] || [];
        if (cn) {
          let fn = bt ? cn : [...me.values[V.name], cn];
          me.setFieldValue(V.name, fn), qN(fn, V, mt);
        }
        lt.current && (lt.current.open = !1);
      } else ue.key === "Escape" && (lt.current.open = !1, pn(""), Ye(!1));
  };
  Ip(() => {
    In.current?.querySelector(
      `[data-index="${un}"]`
    )?.scrollIntoView({ block: "nearest" });
  }, [un]), Ip(() => {
    un >= an.length && Xe(0);
  }, [an, un]), Ip(() => {
    const ue = V.autocomplete, bt = V.ajaxchain;
    if (!ue && !bt) return;
    const cn = me.values[V.name];
    if (!cn) return;
    const fn = Array.isArray(bt) ? bt : bt ? [bt] : [];
    (async () => {
      try {
        if (JQ(ue)) {
          const ye = ue.src;
          if (!ye || !rt) return;
          const He = Kb(ye.where ?? {}, {
            refid: cn
          }), P = {
            ...ye,
            table: ye.table,
            cols: ye.columns,
            where: He
          }, { data: ro } = await m7(rt, P, V?.queryid, void 0, mt), Ln = Array.isArray(ro?.data) ? ro.data[0] : ro?.data;
          Ln && ue.target.split(",").map((oo) => oo.trim()).forEach((oo) => {
            Ln[oo] !== void 0 && me.setFieldValue(oo, Ln[oo]);
          });
        }
        for (const ye of fn) {
          const He = ye.src;
          if (!ye || typeof ye != "object" || !He || typeof He != "object" || !rt) continue;
          let P;
          if (!He.queryid) {
            if (!He.table || !He.columns)
              throw new Error("SQL query requires field.table");
            const po = Kb(He?.where ?? {}, {
              refid: cn
            });
            P = {
              ...He,
              table: He.table,
              cols: He.columns,
              where: po
            };
          }
          const { data: ro } = await m7(rt, P, He?.queryid, cn, mt);
          let Ln = V.valueKey ?? "value", oo = V.labelKey ?? "title";
          const ao = Array.isArray(ro?.data?.data) ? ro.data.data : Array.isArray(ro?.data) ? ro.data : ro, ur = Array.isArray(ao) ? ao.map(R3) : [], Lt = D3(
            Ln,
            oo,
            ur,
            V.groupKey
          );
          De?.(ye.target, Lt);
        }
      } catch (ye) {
        console.error("Autocomplete / AjaxChain fetch failed", ye);
      }
    })();
  }, [me.values[V.name]]), Ip(() => {
    if (!V.search || !Cn.trim() || !V.table || !rt) return;
    const ue = eJ(V.columns ?? ""), bt = new AbortController(), cn = setTimeout(async () => {
      try {
        let fn;
        if (!V.queryid) {
          if (!V.table || !V.cols)
            throw new Error("SQL query requires field.table");
          const ao = Nt ? Kb(V.where ?? {}, {
            refid: Nt
          }) : V.where;
          fn = {
            ...V,
            table: V.table,
            cols: V.columns || V.cols,
            where: ao
          };
        }
        let Fn = {};
        Array.isArray(ue) && ue.forEach((ao) => {
          Fn[ao] = [Cn, "LIKE"];
        });
        let ye = V.valueKey ?? "value", He = V.labelKey ?? "title";
        const { data: P } = await m7(rt, fn, V?.queryid, void 0, mt, Fn), ro = Array.isArray(P?.data?.data) ? P.data.data : Array.isArray(P?.data) ? P.data : P, Ln = Array.isArray(ro) ? ro.map(R3) : [], oo = D3(
          ye,
          He,
          Ln,
          V.groupKey
        );
        Mt(oo);
      } catch (fn) {
        if (bu.isCancel(fn)) return;
        console.error("Search fetch failed", fn);
      }
    }, 500);
    return () => {
      clearTimeout(cn), bt.abort();
    };
  }, [Cn, Nt]);
  const A = async (ue) => {
    if (ue.length === 0) {
      console.error("No file");
      return;
    }
    try {
      const bt = await MQ(rt, ue), cn = V.multiple ? bt.map((fn) => fn.path) : bt[0]?.path;
      me.setFieldValue(
        Yt,
        cn
      ), qN(cn, V, mt);
    } catch (bt) {
      console.error("File upload failed", bt), me.setFieldError(Yt, "File upload failed");
    }
  }, No = async (ue, bt, cn) => {
    const fn = bt[ue];
    if (!fn) return;
    const Fn = pt?.[fn];
    if (typeof Fn != "function") {
      console.error(`Method "${String(fn)}" not found`);
      return;
    }
    try {
      await Promise.resolve(Fn(cn));
    } catch (ye) {
      console.error(`Method "${String(fn)}" failed`, ye);
    }
  }, ot = (ue) => {
    if (Ot) return;
    const bt = ue.target.value;
    pn(bt), Xe(0), bt.trim() ? Ye(!0) : (Ye(!1), me.setFieldValue(Yt, ""));
  }, jo = (ue) => {
    me.setFieldValue(Yt, ue), qN(ue, V, mt), pn(""), Ye(!1), No("onChange", V, `${Yt}-${ue}`);
  };
  function he(ue) {
    const bt = ue.currentTarget.files;
    bt && A(bt);
  }
  return {
    setHighlightedIndex: Xe,
    executeFieldMethod: No,
    handleFileUpload: A,
    handleKeyDown: St,
    handleToggle: oe,
    setSearch: pn,
    setOpen: Ye,
    setIsFocused: Tt,
    handleInputChange: ot,
    handleSelect: jo,
    handlePersist: qN,
    handleFileChange: he,
    optionCount: ns,
    baseInputClasses: Gn,
    focusClasses: jt,
    labelClasses: X,
    search: Cn,
    highlightedIndex: un,
    options: $n,
    isDisabled: Ot,
    key: Yt,
    filteredOptions: an,
    open: U,
    listRef: In,
    inputRef: vn,
    detailsRef: lt,
    isFocused: et
  };
}
const cJ = ({ fileUrl: V, category: me }) => V ? me === "image" ? /* @__PURE__ */ ie.jsx("img", { src: V, className: "max-h-[80vh] mx-auto" }) : me === "pdf" || me === "text" ? /* @__PURE__ */ ie.jsx("iframe", { src: V, className: "w-full h-[80vh]" }) : me === "video" ? /* @__PURE__ */ ie.jsx("video", { controls: !0, className: "w-full max-h-[80vh]", children: /* @__PURE__ */ ie.jsx("source", { src: V }) }) : /* @__PURE__ */ ie.jsxs("div", { className: "text-center p-4", children: [
  /* @__PURE__ */ ie.jsx("p", { children: "Preview not available" }),
  /* @__PURE__ */ ie.jsx("a", { href: V, download: !0, className: "text-blue-600 underline", children: "Download file" })
] }) : null;
function lJ(V) {
  const me = ZX[V] ?? ZX.other;
  return /* @__PURE__ */ ie.jsx("i", { className: `${me} text-2xl text-gray-600` });
}
const iJ = ({ filePath: V, sqlOpsUrls: me }) => {
  const [pt, rt] = qb(null), [Nt, mt] = qb(!1), nn = oJ(V), De = sJ(nn);
  Ip(() => {
    if (!me || De !== "image" && !Nt) return;
    let Tt = !0, $n = null;
    return NQ(V, me).then((Mt) => {
      Tt && ($n = Mt, rt(Mt));
    }), () => {
      Tt = !1, $n && URL.revokeObjectURL($n);
    };
  }, [De, Nt, V, me]);
  let et = V.split("/").pop();
  return /* @__PURE__ */ ie.jsxs(ie.Fragment, { children: [
    De === "image" && pt ? /* @__PURE__ */ ie.jsx(
      "img",
      {
        src: pt,
        alt: et,
        title: "Click to preview",
        onClick: () => mt(!0),
        className: "h-16 w-16 object-cover rounded  cursor-pointer hover:opacity-90"
      }
    ) : /* @__PURE__ */ ie.jsxs(
      "div",
      {
        role: "button",
        tabIndex: 0,
        onClick: () => mt(!0),
        onKeyDown: (Tt) => Tt.key === "Enter" && mt(!0),
        className: "inline-flex cursor-pointer items-center gap-1",
        title: "Click to preview",
        children: [
          lJ(De),
          /* @__PURE__ */ ie.jsx("span", { className: "text-sm", children: et })
        ]
      }
    ),
    Nt && /* @__PURE__ */ ie.jsx("div", { className: "fixed inset-0 bg-black/60 z-50 flex items-center justify-center", children: /* @__PURE__ */ ie.jsxs("div", { className: "bg-white rounded-lg p-4 max-w-5xl w-full", children: [
      /* @__PURE__ */ ie.jsx(
        "button",
        {
          className: "float-right text-sm",
          onClick: () => mt(!1),
          children: "✕"
        }
      ),
      pt ? /* @__PURE__ */ ie.jsx(cJ, { fileUrl: pt, category: De }) : /* @__PURE__ */ ie.jsx("div", { className: "text-center p-8", children: "Loading preview…" })
    ] }) })
  ] });
};
function GX({
  field: V,
  isDisabled: me,
  handleToggle: pt,
  detailsRef: rt,
  handleKeyDown: Nt,
  valueArray: mt,
  labelClasses: nn,
  listRef: De,
  search: et,
  filteredOptions: Tt,
  highlightedIndex: $n,
  setSearch: Mt,
  formik: vn,
  setHighlightedIndex: Cn,
  executeFieldMethod: pn,
  handlePersist: un,
  module_refid: Xe,
  options: In
}) {
  const lt = V.name;
  return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
    /* @__PURE__ */ ie.jsxs("label", { className: nn, children: [
      V.label,
      V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
    ] }),
    /* @__PURE__ */ ie.jsxs(
      "details",
      {
        className: `relative w-full ${me ? " opacity-70" : ""}`,
        onToggle: pt,
        ref: rt,
        onKeyDown: (U) => {
          me || Nt(U, !1);
        },
        children: [
          /* @__PURE__ */ ie.jsxs(
            "summary",
            {
              className: `
    select-none border rounded-lg px-4 py-2.5 flex justify-between items-center
    ${me ? "bg-gray-100 border-gray-200 text-gray-500 cursor-not-allowed" : "bg-white border-gray-300 cursor-pointer"}
  `,
              children: [
                /* @__PURE__ */ ie.jsx("span", { className: "text-sm text-gray-700", children: mt?.length > 0 ? mt.map((U) => PY(In, U) ?? U).join(", ") : `Select ${V.label}` }),
                /* @__PURE__ */ ie.jsx(
                  "svg",
                  {
                    className: "w-4 h-4 text-gray-500",
                    fill: "none",
                    stroke: "currentColor",
                    viewBox: "0 0 24 24",
                    children: /* @__PURE__ */ ie.jsx(
                      "path",
                      {
                        strokeLinecap: "round",
                        strokeLinejoin: "round",
                        strokeWidth: 2,
                        d: "M19 9l-7 7-7-7"
                      }
                    )
                  }
                )
              ]
            }
          ),
          !me && /* @__PURE__ */ ie.jsxs("div", { ref: De, className: "absolute mt-1 w-full border border-gray-200 rounded-lg bg-white shadow-md z-10 max-h-60 overflow-y-auto p-2", children: [
            V.search && /* @__PURE__ */ ie.jsx("div", { className: "sticky top-0 bg-white p-1", children: /* @__PURE__ */ ie.jsx(
              "input",
              {
                type: "text",
                value: et,
                onChange: (U) => {
                  me || (Mt(U.target.value), Cn(0));
                },
                placeholder: "Search...",
                className: `px-2 py-[5px] rounded w-full border border-gray-200 transition-all duration-300 
                bg-white/80 backdrop-blur-sm text-gray-800 placeholder-gray-400
                focus:outline-none focus:ring-0`
              }
            ) }),
            Tt.length > 0 ? Tt.map(([U, Ye], On) => /* @__PURE__ */ ie.jsxs(
              "label",
              {
                htmlFor: `${lt}-${U}`,
                className: `flex items-center gap-x-2 px-2 py-1 hover:bg-gray-50 rounded cursor-pointer text-sm
                        ${mt?.includes(U) ? "bg-indigo-50 text-indigo-600 font-medium" : $n === On ? "bg-gray-100" : "hover:bg-gray-50"}`,
                children: [
                  /* @__PURE__ */ ie.jsx(
                    "input",
                    {
                      id: `${lt}-${U}`,
                      type: "checkbox",
                      checked: mt?.includes(U),
                      onChange: (Ot) => {
                        const oe = Ot.target.checked ? [...mt, U] : mt?.filter((Yt) => Yt !== U);
                        vn.setFieldValue(lt, oe), un(oe, V, Xe), pn("onChange", V, `${lt}-${U}`);
                      },
                      onBlur: vn.handleBlur,
                      disabled: me,
                      className: "h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500"
                    }
                  ),
                  Ye
                ]
              },
              U
            )) : /* @__PURE__ */ ie.jsx("div", { className: "px-2 py-1 text-gray-400 text-sm", children: "No results" })
          ] })
        ]
      }
    ),
    vn.touched[lt] && vn.errors[lt] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500 ml-2", children: String(vn.errors[lt]) })
  ] });
}
function uJ({ filePath: V, field_name: me, sqlOpsUrls: pt }) {
  const [rt, Nt] = qb(null);
  return Ip(() => {
    if (!open || !pt) return;
    let mt = !0, nn = null;
    return NQ(V, pt).then((De) => {
      mt && (nn = De, Nt(De));
    }), () => {
      mt = !1, nn && URL.revokeObjectURL(nn);
    };
  }, [open, V, pt]), rt ? /* @__PURE__ */ ie.jsx(
    "img",
    {
      alt: me,
      title: me,
      src: rt,
      className: "h-24 w-24 object-cover rounded border border-dashed  cursor-pointer hover:opacity-90"
    }
  ) : null;
}
function PQ({
  formik: V,
  field: me,
  sqlOpsUrls: pt,
  module_refid: rt
}) {
  let Nt = me?.name;
  const mt = N3(null), nn = async (De) => {
    const et = De.currentTarget.files;
    if (!(!et || et.length === 0))
      try {
        const Tt = await MQ(pt, et), $n = me.multiple ? Tt.map((Mt) => Mt.path) : Tt[0]?.path;
        V.setFieldValue(
          Nt,
          $n
        ), qN($n, me, rt);
      } catch (Tt) {
        console.error("File upload failed", Tt), V.setFieldError(Nt, "File upload failed");
      }
  };
  return /* @__PURE__ */ ie.jsxs("div", { children: [
    /* @__PURE__ */ ie.jsx("label", { className: "block text-sm font-semibold mb-1  transition-all duration-300 text-gray-700", children: me.label }),
    /* @__PURE__ */ ie.jsx(
      "input",
      {
        ref: mt,
        type: "file",
        accept: "image/*",
        className: "hidden",
        onChange: nn
      }
    ),
    /* @__PURE__ */ ie.jsx(
      "div",
      {
        onClick: () => mt.current?.click(),
        children: V.values[Nt] ? /* @__PURE__ */ ie.jsx(uJ, { field_name: Nt, filePath: V.values[Nt], sqlOpsUrls: pt }) : /* @__PURE__ */ ie.jsx("div", { className: "flex items-center justify-center h-full text-gray-400", children: /* @__PURE__ */ ie.jsx("i", { className: "fa-solid fa-user" }) })
      }
    )
  ] });
}
var NY = { exports: {} }, qX;
function dJ() {
  return qX || (qX = 1, function(V) {
    (function() {
      var me = function(e) {
        if (e === null)
          return "null";
        if (e === void 0)
          return "undefined";
        var t = typeof e;
        return t === "object" && (Array.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "Array") ? "array" : t === "object" && (String.prototype.isPrototypeOf(e) || e.constructor && e.constructor.name === "String") ? "string" : t;
      }, pt = function(e) {
        return ["undefined", "boolean", "number", "string", "function", "xml", "null"].indexOf(e) !== -1;
      }, rt = function(e, t) {
        var o = Array.prototype.slice.call(e);
        return o.sort(t);
      }, Nt = function(e, t) {
        return mt(function(o, r) {
          return e.eq(t(o), t(r));
        });
      }, mt = function(e) {
        return { eq: e };
      }, nn = mt(function(e, t) {
        return e === t;
      }), De = nn, et = function(e) {
        return mt(function(t, o) {
          if (t.length !== o.length)
            return !1;
          for (var r = t.length, c = 0; c < r; c++)
            if (!e.eq(t[c], o[c]))
              return !1;
          return !0;
        });
      }, Tt = function(e, t) {
        return Nt(et(e), function(o) {
          return rt(o, t);
        });
      }, $n = function(e) {
        return mt(function(t, o) {
          var r = Object.keys(t), c = Object.keys(o);
          if (!Tt(De).eq(r, c))
            return !1;
          for (var u = r.length, f = 0; f < u; f++) {
            var b = r[f];
            if (!e.eq(t[b], o[b]))
              return !1;
          }
          return !0;
        });
      }, Mt = mt(function(e, t) {
        if (e === t)
          return !0;
        var o = me(e), r = me(t);
        return o !== r ? !1 : pt(o) ? e === t : o === "array" ? et(Mt).eq(e, t) : o === "object" ? $n(Mt).eq(e, t) : !1;
      });
      const vn = Object.getPrototypeOf, Cn = (e, t, o) => o(e, t.prototype) ? !0 : e.constructor?.name === t.name, pn = (e) => {
        const t = typeof e;
        return e === null ? "null" : t === "object" && Array.isArray(e) ? "array" : t === "object" && Cn(e, String, (o, r) => r.isPrototypeOf(o)) ? "string" : t;
      }, un = (e) => (t) => pn(t) === e, Xe = (e) => (t) => typeof t === e, In = (e) => (t) => e === t, lt = (e, t) => Ye(e) && Cn(e, t, (o, r) => vn(o) === r), U = un("string"), Ye = un("object"), On = (e) => lt(e, Object), Ot = un("array"), oe = In(null), Yt = Xe("boolean"), Gn = In(void 0), jt = (e) => e == null, X = (e) => !jt(e), se = Xe("function"), ns = Xe("number"), an = (e, t) => {
        if (Ot(e)) {
          for (let o = 0, r = e.length; o < r; ++o)
            if (!t(e[o]))
              return !1;
          return !0;
        }
        return !1;
      }, St = () => {
      }, A = (e, t) => (...o) => e(t.apply(null, o)), No = (e, t) => (o) => e(t(o)), ot = (e) => () => e, jo = (e) => e, he = (e, t) => e === t;
      function ue(e, ...t) {
        return (...o) => {
          const r = t.concat(o);
          return e.apply(null, r);
        };
      }
      const bt = (e) => (t) => !e(t), cn = (e) => () => {
        throw new Error(e);
      }, fn = (e) => e(), Fn = (e) => {
        e();
      }, ye = ot(!1), He = ot(!0);
      class P {
        tag;
        value;
        // Sneaky optimisation: every instance of Optional.none is identical, so just
        // reuse the same object
        static singletonNone = new P(!1);
        // The internal representation has a `tag` and a `value`, but both are
        // private: able to be console.logged, but not able to be accessed by code
        constructor(t, o) {
          this.tag = t, this.value = o;
        }
        // --- Identities ---
        /**
         * Creates a new `Optional<T>` that **does** contain a value.
         */
        static some(t) {
          return new P(!0, t);
        }
        /**
         * Create a new `Optional<T>` that **does not** contain a value. `T` can be
         * any type because we don't actually have a `T`.
         */
        static none() {
          return P.singletonNone;
        }
        /**
         * Perform a transform on an `Optional` type. Regardless of whether this
         * `Optional` contains a value or not, `fold` will return a value of type `U`.
         * If this `Optional` does not contain a value, the `U` will be created by
         * calling `onNone`. If this `Optional` does contain a value, the `U` will be
         * created by calling `onSome`.
         *
         * For the FP enthusiasts in the room, this function:
         * 1. Could be used to implement all of the functions below
         * 2. Forms a catamorphism
         */
        fold(t, o) {
          return this.tag ? o(this.value) : t();
        }
        /**
         * Determine if this `Optional` object contains a value.
         */
        isSome() {
          return this.tag;
        }
        /**
         * Determine if this `Optional` object **does not** contain a value.
         */
        isNone() {
          return !this.tag;
        }
        // --- Functor (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value. If
         * you provide a function to turn a T into a U, this is the function you use
         * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
         * a value then the output will also contain a value (that value being the
         * output of `mapper(this.value)`), and if this **does not** contain a value
         * then neither will the output.
         */
        map(t) {
          return this.tag ? P.some(t(this.value)) : P.none();
        }
        // --- Monad (name stolen from Haskell / maths) ---
        /**
         * Perform a transform on an `Optional` object, **if** there is a value.
         * Unlike `map`, here the transform itself also returns an `Optional`.
         */
        bind(t) {
          return this.tag ? t(this.value) : P.none();
        }
        // --- Traversable (name stolen from Haskell / maths) ---
        /**
         * For a given predicate, this function finds out if there **exists** a value
         * inside this `Optional` object that meets the predicate. In practice, this
         * means that for `Optional`s that do not contain a value it returns false (as
         * no predicate-meeting value exists).
         */
        exists(t) {
          return this.tag && t(this.value);
        }
        /**
         * For a given predicate, this function finds out if **all** the values inside
         * this `Optional` object meet the predicate. In practice, this means that
         * for `Optional`s that do not contain a value it returns true (as all 0
         * objects do meet the predicate).
         */
        forall(t) {
          return !this.tag || t(this.value);
        }
        filter(t) {
          return !this.tag || t(this.value) ? this : P.none();
        }
        // --- Getters ---
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.
         */
        getOr(t) {
          return this.tag ? this.value : t;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value.  Unlike `getOr`, in this method the `replacement` object is also
         * `Optional` - meaning that this method will always return an `Optional`.
         */
        or(t) {
          return this.tag ? this : t;
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided `Optional` object does not contain a
         * value. Unlike `getOr`, in this method the `replacement` value is
         * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
         * pass a function which (if called) will **return** the `value` you want to
         * use.
         */
        getOrThunk(t) {
          return this.tag ? this.value : t();
        }
        /**
         * Get the value out of the inside of the `Optional` object, using a default
         * `replacement` value if the provided Optional object does not contain a
         * value.
         *
         * Unlike `or`, in this method the `replacement` value is "thunked" - that is
         * to say that you don't pass a value to `orThunk`, you pass a function which
         * (if called) will **return** the `value` you want to use.
         *
         * Unlike `getOrThunk`, in this method the `replacement` value is also
         * `Optional`, meaning that this method will always return an `Optional`.
         */
        orThunk(t) {
          return this.tag ? this : t();
        }
        /**
         * Get the value out of the inside of the `Optional` object, throwing an
         * exception if the provided `Optional` object does not contain a value.
         *
         * WARNING:
         * You should only be using this function if you know that the `Optional`
         * object **is not** empty (otherwise you're throwing exceptions in production
         * code, which is bad).
         *
         * In tests this is more acceptable.
         *
         * Prefer other methods to this, such as `.each`.
         */
        getOrDie(t) {
          if (this.tag)
            return this.value;
          throw new Error(t ?? "Called getOrDie on None");
        }
        // --- Interop with null and undefined ---
        /**
         * Creates an `Optional` value from a nullable (or undefined-able) input.
         * Null, or undefined, is converted to `None`, and anything else is converted
         * to `Some`.
         */
        static from(t) {
          return X(t) ? P.some(t) : P.none();
        }
        /**
         * Converts an `Optional` to a nullable type, by getting the value if it
         * exists, or returning `null` if it does not.
         */
        getOrNull() {
          return this.tag ? this.value : null;
        }
        /**
         * Converts an `Optional` to an undefined-able type, by getting the value if
         * it exists, or returning `undefined` if it does not.
         */
        getOrUndefined() {
          return this.value;
        }
        // --- Utilities ---
        /**
         * If the `Optional` contains a value, perform an action on that value.
         * Unlike the rest of the methods on this type, `.each` has side-effects. If
         * you want to transform an `Optional<T>` **into** something, then this is not
         * the method for you. If you want to use an `Optional<T>` to **do**
         * something, then this is the method for you - provided you're okay with not
         * doing anything in the case where the `Optional` doesn't have a value inside
         * it. If you're not sure whether your use-case fits into transforming
         * **into** something or **doing** something, check whether it has a return
         * value. If it does, you should be performing a transform.
         */
        each(t) {
          this.tag && t(this.value);
        }
        /**
         * Turn the `Optional` object into an array that contains all of the values
         * stored inside the `Optional`. In practice, this means the output will have
         * either 0 or 1 elements.
         */
        toArray() {
          return this.tag ? [this.value] : [];
        }
        /**
         * Turn the `Optional` object into a string for debugging or printing. Not
         * recommended for production code, but good for debugging. Also note that
         * these days an `Optional` object can be logged to the console directly, and
         * its inner value (if it exists) will be visible.
         */
        toString() {
          return this.tag ? `some(${this.value})` : "none()";
        }
      }
      const ro = Array.prototype.slice, Ln = Array.prototype.indexOf, oo = Array.prototype.push, ao = (e, t) => Ln.call(e, t), ur = (e, t) => {
        const o = ao(e, t);
        return o === -1 ? P.none() : P.some(o);
      }, Lt = (e, t) => ao(e, t) > -1, po = (e, t) => {
        for (let o = 0, r = e.length; o < r; o++) {
          const c = e[o];
          if (t(c, o))
            return !0;
        }
        return !1;
      }, en = (e, t) => {
        const o = e.length, r = new Array(o);
        for (let c = 0; c < o; c++) {
          const u = e[c];
          r[c] = t(u, c);
        }
        return r;
      }, xe = (e, t) => {
        for (let o = 0, r = e.length; o < r; o++) {
          const c = e[o];
          t(c, o);
        }
      }, We = (e, t) => {
        for (let o = e.length - 1; o >= 0; o--) {
          const r = e[o];
          t(r, o);
        }
      }, st = (e, t) => {
        const o = [], r = [];
        for (let c = 0, u = e.length; c < u; c++) {
          const f = e[c];
          (t(f, c) ? o : r).push(f);
        }
        return { pass: o, fail: r };
      }, ze = (e, t) => {
        const o = [];
        for (let r = 0, c = e.length; r < c; r++) {
          const u = e[r];
          t(u, r) && o.push(u);
        }
        return o;
      }, no = (e, t) => {
        if (e.length === 0)
          return [];
        {
          let o = t(e[0]);
          const r = [];
          let c = [];
          for (let u = 0, f = e.length; u < f; u++) {
            const b = e[u], v = t(b);
            v !== o && (r.push(c), c = []), o = v, c.push(b);
          }
          return c.length !== 0 && r.push(c), r;
        }
      }, qn = (e, t, o) => (We(e, (r, c) => {
        o = t(o, r, c);
      }), o), Io = (e, t, o) => (xe(e, (r, c) => {
        o = t(o, r, c);
      }), o), Jc = (e, t, o) => {
        for (let r = 0, c = e.length; r < c; r++) {
          const u = e[r];
          if (t(u, r))
            return P.some(u);
          if (o(u, r))
            break;
        }
        return P.none();
      }, _o = (e, t) => Jc(e, t, ye), Ql = (e, t) => {
        for (let o = 0, r = e.length; o < r; o++) {
          const c = e[o];
          if (t(c, o))
            return P.some(o);
        }
        return P.none();
      }, jm = (e, t) => {
        for (let o = e.length - 1; o >= 0; o--)
          if (t(e[o], o))
            return P.some(o);
        return P.none();
      }, ga = (e) => {
        const t = [];
        for (let o = 0, r = e.length; o < r; ++o) {
          if (!Ot(e[o]))
            throw new Error("Arr.flatten item " + o + " was not an array, input: " + e);
          oo.apply(t, e[o]);
        }
        return t;
      }, xo = (e, t) => ga(en(e, t)), qa = (e, t) => {
        for (let o = 0, r = e.length; o < r; ++o) {
          const c = e[o];
          if (t(c, o) !== !0)
            return !1;
        }
        return !0;
      }, ds = (e) => {
        const t = ro.call(e, 0);
        return t.reverse(), t;
      }, Bs = (e, t) => ze(e, (o) => !Lt(t, o)), vu = (e, t) => {
        const o = {};
        for (let r = 0, c = e.length; r < c; r++) {
          const u = e[r];
          o[String(u)] = t(u, r);
        }
        return o;
      }, Tl = (e, t) => {
        const o = ro.call(e, 0);
        return o.sort(t), o;
      }, Gr = (e, t) => t >= 0 && t < e.length ? P.some(e[t]) : P.none(), js = (e) => Gr(e, 0), dr = (e) => Gr(e, e.length - 1), rs = se(Array.from) ? Array.from : (e) => ro.call(e), cc = (e, t) => {
        for (let o = 0; o < e.length; o++) {
          const r = t(e[o], o);
          if (r.isSome())
            return r;
        }
        return P.none();
      }, Ka = (e, t) => {
        const o = [], r = se(t) ? (c) => po(o, (u) => t(u, c)) : (c) => Lt(o, c);
        for (let c = 0, u = e.length; c < u; c++) {
          const f = e[c];
          r(f) || o.push(f);
        }
        return o;
      }, Vt = Object.keys, mo = Object.hasOwnProperty, Un = (e, t) => {
        const o = Vt(e);
        for (let r = 0, c = o.length; r < c; r++) {
          const u = o[r], f = e[u];
          t(f, u);
        }
      }, lc = (e, t) => Ma(e, (o, r) => ({
        k: r,
        v: t(o, r)
      })), Ma = (e, t) => {
        const o = {};
        return Un(e, (r, c) => {
          const u = t(r, c);
          o[u.k] = u.v;
        }), o;
      }, Pt = (e) => (t, o) => {
        e[o] = t;
      }, Di = (e, t, o, r) => {
        Un(e, (c, u) => {
          (t(c, u) ? o : r)(c, u);
        });
      }, as = (e, t) => {
        const o = {}, r = {};
        return Di(e, t, Pt(o), Pt(r)), { t: o, f: r };
      }, Ri = (e, t) => {
        const o = {};
        return Di(e, t, Pt(o), St), o;
      }, ic = (e, t) => {
        const o = [];
        return Un(e, (r, c) => {
          o.push(t(r, c));
        }), o;
      }, Pa = (e) => ic(e, jo), Wo = (e, t) => kn(e, t) ? P.from(e[t]) : P.none(), kn = (e, t) => mo.call(e, t), Zo = (e, t) => kn(e, t) && e[t] !== void 0 && e[t] !== null, rd = (e, t, o = Mt) => $n(o).eq(e, t), el = {
        generate: (e) => {
          if (!Ot(e))
            throw new Error("cases must be an array");
          if (e.length === 0)
            throw new Error("there must be at least one case");
          const t = [], o = {};
          return xe(e, (r, c) => {
            const u = Vt(r);
            if (u.length !== 1)
              throw new Error("one and only one name per case");
            const f = u[0], b = r[f];
            if (o[f] !== void 0)
              throw new Error("duplicate key detected:" + f);
            if (f === "cata")
              throw new Error("cannot have a case named cata (sorry)");
            if (!Ot(b))
              throw new Error("case arguments must be an array");
            t.push(f), o[f] = (...v) => {
              const S = v.length;
              if (S !== b.length)
                throw new Error("Wrong number of arguments to case " + f + ". Expected " + b.length + " (" + b + "), got " + S);
              return {
                fold: (...R) => {
                  if (R.length !== e.length)
                    throw new Error("Wrong number of arguments to fold. Expected " + e.length + ", got " + R.length);
                  return R[c].apply(null, v);
                },
                match: (R) => {
                  const M = Vt(R);
                  if (t.length !== M.length)
                    throw new Error("Wrong number of arguments to match. Expected: " + t.join(",") + `
Actual: ` + M.join(","));
                  if (!qa(t, (J) => Lt(M, J)))
                    throw new Error("Not all branches were specified when using match. Specified: " + M.join(", ") + `
Required: ` + t.join(", "));
                  return R[f].apply(null, v);
                },
                // NOTE: Only for debugging.
                log: (R) => {
                  console.log(R, {
                    constructors: t,
                    constructor: f,
                    params: v
                  });
                }
              };
            };
          }), o;
        }
      }, Wt = (e) => {
        let t = e;
        return {
          get: () => t,
          set: (c) => {
            t = c;
          }
        };
      }, Ba = (e) => {
        const t = (u) => u(e), o = ot(e), r = () => c, c = {
          // Debug info
          tag: !0,
          inner: e,
          // Actual Result methods
          fold: (u, f) => f(e),
          isValue: He,
          isError: ye,
          map: (u) => xr.value(u(e)),
          mapError: r,
          bind: t,
          exists: t,
          forall: t,
          getOr: o,
          or: r,
          getOrThunk: o,
          orThunk: r,
          getOrDie: o,
          each: (u) => {
            u(e);
          },
          toOptional: () => P.some(e)
        };
        return c;
      }, Or = (e) => {
        const t = () => o, o = {
          // Debug info
          tag: !1,
          inner: e,
          // Actual Result methods
          fold: (r, c) => r(e),
          isValue: ye,
          isError: He,
          map: t,
          mapError: (r) => xr.error(r(e)),
          bind: t,
          exists: ye,
          forall: He,
          getOr: jo,
          or: jo,
          getOrThunk: fn,
          orThunk: fn,
          getOrDie: cn(String(e)),
          each: St,
          toOptional: P.none
        };
        return o;
      }, xr = {
        value: Ba,
        error: Or,
        fromOption: (e, t) => e.fold(() => Or(t), Ba)
      }, Qd = typeof window < "u" ? window : Function("return this;")(), os = () => {
        const e = window.crypto.getRandomValues(new Uint8Array(16));
        return e[6] = e[6] & 15 | 64, e[8] = e[8] & 63 | 128, e;
      }, Ni = () => {
        const e = os(), t = (o, r) => {
          let c = "";
          for (let u = o; u <= r; ++u) {
            const f = e[u].toString(16).padStart(2, "0");
            c += f;
          }
          return c;
        };
        return `${t(0, 3)}-${t(4, 5)}-${t(6, 7)}-${t(8, 9)}-${t(10, 15)}`;
      }, ad = (e, t, o) => Math.min(Math.max(e, t), o), Jl = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;
      let Nc = 0;
      const nr = (e) => {
        const o = (/* @__PURE__ */ new Date()).getTime(), r = Math.floor(Jl() * 1e9);
        return Nc++, e + "_" + r + Nc + String(o);
      }, Mi = () => window.isSecureContext ? window.crypto.randomUUID() : Ni(), Cu = (e, t) => t, Ct = (e, t) => On(e) && On(t) ? xu(e, t) : t, Ya = (e) => (...t) => {
        if (t.length === 0)
          throw new Error("Can't merge zero objects");
        const o = {};
        for (let r = 0; r < t.length; r++) {
          const c = t[r];
          for (const u in c)
            kn(c, u) && (o[u] = e(o[u], c[u]));
        }
        return o;
      }, xu = Ya(Ct), kl = Ya(Cu), Ho = (e, t, o = he) => e.exists((r) => o(r, t)), cd = (e, t, o = he) => Xs(e, t, o).getOr(e.isNone() && t.isNone()), uc = (e) => {
        const t = [], o = (r) => {
          t.push(r);
        };
        for (let r = 0; r < e.length; r++)
          e[r].each(o);
        return t;
      }, Xs = (e, t, o) => e.isSome() && t.isSome() ? P.some(o(e.getOrDie(), t.getOrDie())) : P.none(), Al = (e, t, o, r) => e.isSome() && t.isSome() && o.isSome() ? P.some(r(e.getOrDie(), t.getOrDie(), o.getOrDie())) : P.none(), ld = (e) => e.bind(jo), $a = (e, t) => e ? P.some(t) : P.none(), Pr = (e, t) => {
        let o = t ?? Qd;
        for (let r = 0; r < e.length && o !== void 0 && o !== null; ++r)
          o = o[e[r]];
        return o;
      }, tl = (e, t) => {
        const o = e.split(".");
        return Pr(o, t);
      };
      el.generate([
        { bothErrors: ["error1", "error2"] },
        { firstError: ["error1", "value2"] },
        { secondError: ["value1", "error2"] },
        { bothValues: ["value1", "value2"] }
      ]);
      const Br = (e) => {
        const t = [], o = [];
        return xe(e, (r) => {
          r.fold((c) => {
            t.push(c);
          }, (c) => {
            o.push(c);
          });
        }), { errors: t, values: o };
      }, mh = (e) => {
        const t = Wt(P.none()), o = () => t.get().each(e);
        return {
          clear: () => {
            o(), t.set(P.none());
          },
          isSet: () => t.get().isSome(),
          get: () => t.get(),
          set: (b) => {
            o(), t.set(P.some(b));
          }
        };
      }, Jd = (e) => {
        const t = Wt(P.none()), o = () => t.get().each((b) => clearInterval(b));
        return {
          clear: () => {
            o(), t.set(P.none());
          },
          isSet: () => t.get().isSome(),
          get: () => t.get(),
          set: (b) => {
            o(), t.set(P.some(setInterval(b, e)));
          }
        };
      }, Mc = () => {
        const e = mh(St);
        return {
          ...e,
          on: (o) => e.get().each(o)
        };
      }, _l = (e, t) => e.substring(t), ei = (e, t, o) => t === "" || e.length >= t.length && e.substr(o, o + t.length) === t, Zm = (e, t) => hn(e, t) ? _l(e, t.length) : e, As = (e, t, o = 0, r) => {
        const c = e.indexOf(t, o);
        return c !== -1 ? Gn(r) ? !0 : c + t.length <= r : !1;
      }, hn = (e, t) => ei(e, t, 0), qr = (e, t) => ei(e, t, e.length - t.length), Kr = (e) => (t) => t.replace(e, ""), _s = Kr(/^\s+|\s+$/g), em = Kr(/^\s+/g), Pi = Kr(/\s+$/g), ms = (e) => e.length > 0, ti = (e) => !ms(e), nl = (e, t) => t <= 0 ? "" : new Array(t + 1).join(e), Jf = (e, t = 10) => {
        const o = parseInt(e, t);
        return isNaN(o) ? P.none() : P.some(o);
      }, vt = (e, t) => {
        let o = null;
        return {
          cancel: () => {
            oe(o) || (clearTimeout(o), o = null);
          },
          throttle: (...u) => {
            oe(o) && (o = setTimeout(() => {
              o = null, e.apply(null, u);
            }, t));
          }
        };
      }, ni = (e, t) => {
        let o = null;
        const r = () => {
          oe(o) || (clearTimeout(o), o = null);
        };
        return {
          cancel: r,
          throttle: (...u) => {
            r(), o = setTimeout(() => {
              o = null, e.apply(null, u);
            }, t);
          }
        };
      }, ha = (e) => {
        let t = !1, o;
        return (...r) => (t || (t = !0, o = e.apply(null, r)), o);
      }, Pc = "\uFEFF", $s = " ", eg = "…", Xa = (e) => e === Pc, Bc = (e) => e.replace(/\uFEFF/g, ""), Gm = (e) => {
        const t = {};
        return xe(e, (o) => {
          t[o] = {};
        }), Vt(t);
      }, tg = (e) => e.length !== void 0, oi = Array.isArray, ng = (e) => {
        if (oi(e))
          return e;
        {
          const t = [];
          for (let o = 0, r = e.length; o < r; o++)
            t[o] = e[o];
          return t;
        }
      }, Su = (e, t, o) => {
        if (!e)
          return !1;
        if (o = o || e, tg(e)) {
          for (let r = 0, c = e.length; r < c; r++)
            if (t.call(o, e[r], r, e) === !1)
              return !1;
        } else
          for (const r in e)
            if (kn(e, r) && t.call(o, e[r], r, e) === !1)
              return !1;
        return !0;
      }, si = (e, t) => {
        const o = [];
        return Su(e, (r, c) => {
          o.push(t(r, c, e));
        }), o;
      }, wu = (e, t) => {
        const o = [];
        return Su(e, (r, c) => {
          (!t || t(r, c, e)) && o.push(r);
        }), o;
      }, at = (e, t) => {
        if (e) {
          for (let o = 0, r = e.length; o < r; o++)
            if (e[o] === t)
              return o;
        }
        return -1;
      }, Bi = (e, t, o, r) => {
        let c = Gn(o) ? e[0] : o;
        for (let u = 0; u < e.length; u++)
          c = t.call(r, c, e[u], u);
        return c;
      }, tm = (e, t, o) => {
        for (let r = 0, c = e.length; r < c; r++)
          if (t.call(o, e[r], r, e))
            return r;
        return -1;
      }, ol = (e) => e[e.length - 1], dc = (e, t, o, r) => {
        const c = e.isiOS() && /ipad/i.test(o) === !0, u = e.isiOS() && !c, f = e.isiOS() || e.isAndroid(), b = f || r("(pointer:coarse)"), v = c || !u && f && r("(min-device-width:768px)"), S = u || f && !v, O = t.isSafari() && e.isiOS() && /safari/i.test(o) === !1, R = !S && !v && !O;
        return {
          isiPad: ot(c),
          isiPhone: ot(u),
          isTablet: ot(v),
          isPhone: ot(S),
          isTouch: ot(b),
          isAndroid: e.isAndroid,
          isiOS: e.isiOS,
          isWebView: ot(O),
          isDesktop: ot(R)
        };
      }, id = (e, t) => {
        for (let o = 0; o < e.length; o++) {
          const r = e[o];
          if (r.test(t))
            return r;
        }
      }, pa = (e, t) => {
        const o = id(e, t);
        if (!o)
          return { major: 0, minor: 0 };
        const r = (c) => Number(t.replace(o, "$" + c));
        return ri(r(1), r(2));
      }, Ol = (e, t) => {
        const o = String(t).toLowerCase();
        return e.length === 0 ? $i() : pa(e, o);
      }, $i = () => ri(0, 0), ri = (e, t) => ({ major: e, minor: t }), zo = {
        nu: ri,
        detect: Ol,
        unknown: $i
      }, ud = (e, t) => cc(t.brands, (o) => {
        const r = o.brand.toLowerCase();
        return _o(e, (c) => r === c.brand?.toLowerCase()).map((c) => ({
          current: c.name,
          version: zo.nu(parseInt(o.version, 10), 0)
        }));
      }), B = (e, t) => {
        const o = String(t).toLowerCase();
        return _o(e, (r) => r.search(o));
      }, G = (e, t) => B(e, t).map((o) => {
        const r = zo.detect(o.versionRegexes, t);
        return {
          current: o.name,
          version: r
        };
      }), re = (e, t) => B(e, t).map((o) => {
        const r = zo.detect(o.versionRegexes, t);
        return {
          current: o.name,
          version: r
        };
      }), Pe = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Ht = (e) => (t) => As(t, e), Jn = [
        // This is legacy Edge
        {
          name: "Edge",
          versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
          search: (e) => As(e, "edge/") && As(e, "chrome") && As(e, "safari") && As(e, "applewebkit")
        },
        // This is Google Chrome and Chromium Edge
        {
          name: "Chromium",
          brand: "Chromium",
          versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, Pe],
          search: (e) => As(e, "chrome") && !As(e, "chromeframe")
        },
        {
          name: "IE",
          versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
          search: (e) => As(e, "msie") || As(e, "trident")
        },
        // INVESTIGATE: Is this still the Opera user agent?
        {
          name: "Opera",
          versionRegexes: [Pe, /.*?opera\/([0-9]+)\.([0-9]+).*/],
          search: Ht("opera")
        },
        {
          name: "Firefox",
          versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
          search: Ht("firefox")
        },
        {
          name: "Safari",
          versionRegexes: [Pe, /.*?cpu os ([0-9]+)_([0-9]+).*/],
          search: (e) => (As(e, "safari") || As(e, "mobile/")) && As(e, "applewebkit")
        }
      ], Vo = [
        {
          name: "Windows",
          search: Ht("win"),
          versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "iOS",
          search: (e) => As(e, "iphone") || As(e, "ipad"),
          versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
        },
        {
          name: "Android",
          search: Ht("android"),
          versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
        },
        {
          name: "macOS",
          search: Ht("mac os x"),
          versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
        },
        {
          name: "Linux",
          search: Ht("linux"),
          versionRegexes: []
        },
        {
          name: "Solaris",
          search: Ht("sunos"),
          versionRegexes: []
        },
        {
          name: "FreeBSD",
          search: Ht("freebsd"),
          versionRegexes: []
        },
        {
          name: "ChromeOS",
          search: Ht("cros"),
          versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
        }
      ], Sr = {
        browsers: ot(Jn),
        oses: ot(Vo)
      }, Yr = "Edge", Qa = "Chromium", I = "IE", ee = "Opera", fe = "Firefox", _e = "Safari", it = () => It({
        current: void 0,
        version: zo.unknown()
      }), It = (e) => {
        const t = e.current, o = e.version, r = (c) => () => t === c;
        return {
          current: t,
          version: o,
          isEdge: r(Yr),
          isChromium: r(Qa),
          // NOTE: isIe just looks too weird
          isIE: r(I),
          isOpera: r(ee),
          isFirefox: r(fe),
          isSafari: r(_e)
        };
      }, Mn = {
        unknown: it,
        nu: It
      }, wo = "Windows", co = "iOS", ba = "Android", Ws = "Linux", Eu = "macOS", qm = "Solaris", nm = "FreeBSD", Dl = "ChromeOS", Yb = () => Xb({
        current: void 0,
        version: zo.unknown()
      }), Xb = (e) => {
        const t = e.current, o = e.version, r = (c) => () => t === c;
        return {
          current: t,
          version: o,
          isWindows: r(wo),
          // TODO: Fix capitalisation
          isiOS: r(co),
          isAndroid: r(ba),
          isMacOS: r(Eu),
          isLinux: r(Ws),
          isSolaris: r(qm),
          isFreeBSD: r(nm),
          isChromeOS: r(Dl)
        };
      }, Fp = {
        unknown: Yb,
        nu: Xb
      }, Qb = {
        detect: (e, t, o) => {
          const r = Sr.browsers(), c = Sr.oses(), u = t.bind((v) => ud(r, v)).orThunk(() => G(r, e)).fold(Mn.unknown, Mn.nu), f = re(c, e).fold(Fp.unknown, Fp.nu), b = dc(f, u, e, o);
          return {
            browser: u,
            os: f,
            deviceType: b
          };
        }
      }, Jb = (e) => window.matchMedia(e).matches;
      let jy = ha(() => Qb.detect(window.navigator.userAgent, P.from(window.navigator.userAgentData), Jb));
      const Ii = () => jy(), Wy = (e, t) => tl(e, t), Zy = (e, t) => {
        const o = Wy(e, t);
        if (o == null)
          throw new Error(e + " not available on this browser");
        return o;
      }, Lp = Object.getPrototypeOf, Hp = (e) => Zy("HTMLElement", e), NS = (e) => {
        const t = tl("ownerDocument.defaultView", e);
        return Ye(e) && (Hp(t).prototype.isPrototypeOf(e) || /^HTML\w*Element$/.test(Lp(e).constructor.name));
      }, Gy = window.navigator.userAgent, zp = Ii(), Fi = zp.browser, sl = zp.os, om = zp.deviceType, qy = Gy.indexOf("Windows Phone") !== -1, fo = {
        /**
         * Transparent image data url.
         *
         * @property transparentSrc
         * @type Boolean
         * @final
         */
        transparentSrc: "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7",
        /**
         * Returns the IE document mode. For non IE browsers, this will fake IE 10 document mode.
         *
         * @property documentMode
         * @type Number
         */
        documentMode: Fi.isIE() ? document.documentMode || 7 : 10,
        cacheSuffix: null,
        container: null,
        /**
         * Constant if CSP mode is possible or not. Meaning we can't use script urls for the iframe.
         */
        canHaveCSP: !Fi.isIE(),
        windowsPhone: qy,
        /**
         * @include ../../../../../tools/docs/tinymce.Env.js
         */
        browser: {
          current: Fi.current,
          version: Fi.version,
          isChromium: Fi.isChromium,
          isEdge: Fi.isEdge,
          isFirefox: Fi.isFirefox,
          isIE: Fi.isIE,
          isOpera: Fi.isOpera,
          isSafari: Fi.isSafari
        },
        os: {
          current: sl.current,
          version: sl.version,
          isAndroid: sl.isAndroid,
          isChromeOS: sl.isChromeOS,
          isFreeBSD: sl.isFreeBSD,
          isiOS: sl.isiOS,
          isLinux: sl.isLinux,
          isMacOS: sl.isMacOS,
          isSolaris: sl.isSolaris,
          isWindows: sl.isWindows
        },
        deviceType: {
          isDesktop: om.isDesktop,
          isiPad: om.isiPad,
          isiPhone: om.isiPhone,
          isPhone: om.isPhone,
          isTablet: om.isTablet,
          isTouch: om.isTouch,
          isWebView: om.isWebView
        }
      }, Ky = /^\s*|\s*$/g, fh = (e) => jt(e) ? "" : ("" + e).replace(Ky, ""), Qs = (e, t) => t ? t === "array" && oi(e) ? !0 : typeof e === t : e !== void 0, MS = (e, t, o = {}) => {
        const r = U(e) ? e.split(t || ",") : e || [];
        let c = r.length;
        for (; c--; )
          o[r[c]] = {};
        return o;
      }, Vp = kn, PS = (e, ...t) => {
        for (let o = 0; o < t.length; o++) {
          const r = t[o];
          for (const c in r)
            if (kn(r, c)) {
              const u = r[c];
              u !== void 0 && (e[c] = u);
            }
        }
        return e;
      }, e0 = function(e, t, o, r) {
        r = r || this, e && (o && (e = e[o]), Su(e, (c, u) => t.call(r, c, u, o) === !1 ? !1 : (e0(c, t, o, r), !0)));
      }, Je = {
        trim: fh,
        /**
         * Returns true/false if the object is an array or not.
         *
         * @method isArray
         * @param {Object} obj Object to check.
         * @return {Boolean} true/false state if the object is an array or not.
         */
        isArray: oi,
        is: Qs,
        /**
         * Converts the specified object into a real JavaScript array.
         *
         * @method toArray
         * @param {Object} obj Object to convert into array.
         * @return {Array} Array object based in input.
         */
        toArray: ng,
        makeMap: MS,
        /**
         * Performs an iteration of all items in a collection such as an object or array. This method will execute the
         * callback function for each item in the collection, if the callback returns false the iteration will terminate.
         * The callback has the following format: `cb(value, key_or_index)`.
         *
         * @method each
         * @param {Object} o Collection to iterate.
         * @param {Function} cb Callback function to execute for each item.
         * @param {Object} s Optional scope to execute the callback in.
         * @example
         * // Iterate an array
         * tinymce.each([ 1,2,3 ], (v, i) => {
         *   console.debug("Value: " + v + ", Index: " + i);
         * });
         *
         * // Iterate an object
         * tinymce.each({ a: 1, b: 2, c: 3 }, (v, k) => {
         *   console.debug("Value: " + v + ", Key: " + k);
         * });
         */
        each: Su,
        /**
         * Creates a new array by the return value of each iteration function call. This enables you to convert
         * one array list into another.
         *
         * @method map
         * @param {Array} array Array of items to iterate.
         * @param {Function} callback Function to call for each item. It's return value will be the new value.
         * @return {Array} Array with new values based on function return values.
         */
        map: si,
        /**
         * Filters out items from the input array by calling the specified function for each item.
         * If the function returns false the item will be excluded if it returns true it will be included.
         *
         * @method grep
         * @param {Array} a Array of items to loop though.
         * @param {Function} f Function to call for each item. Include/exclude depends on it's return value.
         * @return {Array} New array with values imported and filtered based in input.
         * @example
         * // Filter out some items, this will return an array with 4 and 5
         * const items = tinymce.grep([ 1,2,3,4,5 ], (v) => v > 3);
         */
        grep: wu,
        /**
         * Returns an index of the item or -1 if item is not present in the array.
         *
         * @method inArray
         * @param {any} item Item to search for.
         * @param {Array} arr Array to search in.
         * @return {Number} index of the item or -1 if item was not found.
         */
        inArray: at,
        hasOwn: Vp,
        extend: PS,
        walk: e0,
        resolve: (e, t = window) => {
          const o = e.split(".");
          for (let r = 0, c = o.length; r < c && (t = t[o[r]], !!t); r++)
            ;
          return t;
        },
        explode: (e, t) => Ot(e) ? e : e === "" ? [] : si(e.split(t || ","), fh),
        _addCacheSuffix: (e) => {
          const t = fo.cacheSuffix;
          return t && (e += (e.indexOf("?") === -1 ? "?" : "&") + t), e;
        }
      }, $c = (e, t) => {
        const r = (t || document).createElement("div");
        if (r.innerHTML = e, !r.hasChildNodes() || r.childNodes.length > 1) {
          const c = "HTML does not have a single root node";
          throw console.error(c, e), new Error(c);
        }
        return Km(r.childNodes[0]);
      }, og = (e, t) => {
        const r = (t || document).createElement(e);
        return Km(r);
      }, Nl = (e, t) => {
        const r = (t || document).createTextNode(e);
        return Km(r);
      }, Km = (e) => {
        if (e == null)
          throw new Error("Node cannot be null or undefined");
        return {
          dom: e
        };
      }, te = {
        fromHtml: $c,
        fromTag: og,
        fromText: Nl,
        fromDom: Km,
        fromPoint: (e, t, o) => P.from(e.dom.elementFromPoint(t, o)).map(Km)
      }, mc = (e, t) => {
        t.fold((o) => {
          e.setStartBefore(o.dom);
        }, (o, r) => {
          e.setStart(o.dom, r);
        }, (o) => {
          e.setStartAfter(o.dom);
        });
      }, dd = (e, t) => {
        t.fold((o) => {
          e.setEndBefore(o.dom);
        }, (o, r) => {
          e.setEnd(o.dom, r);
        }, (o) => {
          e.setEndAfter(o.dom);
        });
      }, jp = (e, t, o) => {
        const r = e.document.createRange();
        return mc(r, t), dd(r, o), r;
      }, Ym = (e, t, o, r, c) => {
        const u = e.document.createRange();
        return u.setStart(t.dom, o), u.setEnd(r.dom, c), u;
      }, va = el.generate([
        { ltr: ["start", "soffset", "finish", "foffset"] },
        { rtl: ["start", "soffset", "finish", "foffset"] }
      ]), fc = (e, t, o) => t(te.fromDom(o.startContainer), o.startOffset, te.fromDom(o.endContainer), o.endOffset), Wp = (e, t) => t.match({
        domRange: (o) => ({
          ltr: ot(o),
          rtl: P.none
        }),
        relative: (o, r) => ({
          ltr: ha(() => jp(e, o, r)),
          rtl: ha(() => P.some(jp(e, r, o)))
        }),
        exact: (o, r, c, u) => ({
          ltr: ha(() => Ym(e, o, r, c, u)),
          rtl: ha(() => P.some(Ym(e, c, u, o, r)))
        })
      }), Zp = (e, t) => {
        const o = t.ltr();
        return o.collapsed ? t.rtl().filter((c) => c.collapsed === !1).map((c) => (
          // We need to use "reversed" here, because the original only has one point (collapsed)
          va.rtl(te.fromDom(c.endContainer), c.endOffset, te.fromDom(c.startContainer), c.startOffset)
        )).getOrThunk(() => fc(e, va.ltr, o)) : fc(e, va.ltr, o);
      }, sg = (e, t) => {
        const o = Wp(e, t);
        return Zp(e, o);
      };
      va.ltr, va.rtl;
      const gc = 8, Gp = 9, Li = 11, rg = 1, qp = 3, Ic = (e, t) => {
        const o = e.dom;
        if (o.nodeType !== rg)
          return !1;
        {
          const r = o;
          if (r.matches !== void 0)
            return r.matches(t);
          if (r.msMatchesSelector !== void 0)
            return r.msMatchesSelector(t);
          if (r.webkitMatchesSelector !== void 0)
            return r.webkitMatchesSelector(t);
          if (r.mozMatchesSelector !== void 0)
            return r.mozMatchesSelector(t);
          throw new Error("Browser lacks native selectors");
        }
      }, Kp = (e) => (
        // Only elements, documents and shadow roots support querySelector
        // shadow root element type is DOCUMENT_FRAGMENT
        e.nodeType !== rg && e.nodeType !== Gp && e.nodeType !== Li || // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
        e.childElementCount === 0
      ), ai = (e, t) => {
        const o = t === void 0 ? document : t.dom;
        return Kp(o) ? [] : en(o.querySelectorAll(e), te.fromDom);
      }, md = (e, t) => {
        const o = t === void 0 ? document : t.dom;
        return Kp(o) ? P.none() : P.from(o.querySelector(e)).map(te.fromDom);
      }, Qn = (e, t) => e.dom === t.dom, Ja = (e, t) => {
        const o = e.dom, r = t.dom;
        return o === r ? !1 : o.contains(r);
      }, Xm = Ic, t0 = (e, t) => {
        const o = [], r = (u) => (o.push(u), t(u));
        let c = t(e);
        do
          c = c.bind(r);
        while (c.isSome());
        return o;
      }, Hn = (e) => e.dom.nodeName.toLowerCase(), Tu = (e) => e.dom.nodeType, mr = (e) => (t) => Tu(t) === e, ci = (e) => Tu(e) === gc || Hn(e) === "#comment", li = (e) => Is(e) && NS(e.dom), Is = mr(rg), Eo = mr(qp), Xy = mr(Gp), Qy = mr(Li), fr = (e) => (t) => Is(t) && Hn(t) === e, Ml = (e) => te.fromDom(e.dom.ownerDocument), Pl = (e) => Xy(e) ? e : Ml(e), gr = (e) => te.fromDom(Pl(e).dom.documentElement), ii = (e) => te.fromDom(Pl(e).dom.defaultView), ec = (e) => P.from(e.dom.parentNode).map(te.fromDom), Fc = (e) => P.from(e.dom.parentElement).map(te.fromDom), ya = (e, t) => {
        const o = se(t) ? t : ye;
        let r = e.dom;
        const c = [];
        for (; r.parentNode !== null && r.parentNode !== void 0; ) {
          const u = r.parentNode, f = te.fromDom(u);
          if (c.push(f), o(f) === !0)
            break;
          r = u;
        }
        return c;
      }, Oo = (e) => {
        const t = (o) => ze(o, (r) => !Qn(e, r));
        return ec(e).map(Os).map(t).getOr([]);
      }, rl = (e) => P.from(e.dom.previousSibling).map(te.fromDom), tc = (e) => P.from(e.dom.nextSibling).map(te.fromDom), Xr = (e) => ds(t0(e, rl)), $r = (e) => t0(e, tc), Os = (e) => en(e.dom.childNodes, te.fromDom), Bl = (e, t) => {
        const o = e.dom.childNodes;
        return P.from(o[t]).map(te.fromDom);
      }, Ir = (e) => Bl(e, 0), or = (e) => Bl(e, e.dom.childNodes.length - 1), fd = (e) => e.dom.childNodes.length, Yp = (e) => {
        const t = e.dom.head;
        if (t == null)
          throw new Error("Head is not available yet");
        return te.fromDom(t);
      }, gh = (e) => Qy(e) && X(e.dom.host), Fr = (e) => te.fromDom(e.dom.getRootNode()), Xp = (e) => gh(e) ? e : Yp(Pl(e)), n0 = (e) => (
        // Can't use SugarBody.body without causing a circular module reference (since SugarBody.inBody uses SugarShadowDom)
        gh(e) ? e : te.fromDom(Pl(e).dom.body)
      ), rm = (e) => {
        const t = Fr(e);
        return gh(t) ? P.some(t) : P.none();
      }, ln = (e) => te.fromDom(e.dom.host), Qp = (e) => {
        if (X(e.target)) {
          const t = te.fromDom(e.target);
          if (Is(t) && Dr(t) && e.composed && e.composedPath) {
            const o = e.composedPath();
            if (o)
              return js(o);
          }
        }
        return P.from(e.target);
      }, Dr = (e) => X(e.dom.shadowRoot), Qr = (e, t, o, r, c, u, f) => ({
        target: e,
        x: t,
        y: o,
        stop: r,
        prevent: c,
        kill: u,
        raw: f
      }), Jr = (e) => {
        const t = te.fromDom(Qp(e).getOr(e.target)), o = () => e.stopPropagation(), r = () => e.preventDefault(), c = A(r, o);
        return Qr(t, e.clientX, e.clientY, o, r, c, e);
      }, fs = (e, t) => (o) => {
        e(o) && t(Jr(o));
      }, gd = (e, t, o, r, c) => {
        const u = fs(o, r);
        return e.dom.addEventListener(t, u, c), {
          unbind: ue(al, e, t, u, c)
        };
      }, hh = (e, t, o, r) => gd(e, t, o, r, !1), al = (e, t, o, r) => {
        e.dom.removeEventListener(t, o, r);
      }, ui = He, ag = (e, t, o) => hh(e, t, ui, o), ph = () => te.fromDom(document), cg = (e, t = !1) => e.dom.focus({ preventScroll: t }), Hi = (e) => {
        const t = Fr(e).dom;
        return e.dom === t.activeElement;
      }, $l = (e = ph()) => P.from(e.dom.activeElement).map(te.fromDom), Jp = (e) => $l(Fr(e)).filter((t) => e.dom.contains(t.dom)), ca = (e, t) => {
        ec(e).each((r) => {
          r.dom.insertBefore(t.dom, e.dom);
        });
      }, cl = (e, t) => {
        tc(e).fold(() => {
          ec(e).each((c) => {
            bo(c, t);
          });
        }, (r) => {
          ca(r, t);
        });
      }, zi = (e, t) => {
        Ir(e).fold(() => {
          bo(e, t);
        }, (r) => {
          e.dom.insertBefore(t.dom, r.dom);
        });
      }, bo = (e, t) => {
        e.dom.appendChild(t.dom);
      }, Lc = (e, t) => {
        ca(e, t), bo(t, e);
      }, o0 = (e, t) => {
        xe(t, (o) => {
          ca(e, o);
        });
      }, lg = (e, t) => {
        xe(t, (o, r) => {
          const c = r === 0 ? e : t[r - 1];
          cl(c, o);
        });
      }, ll = (e, t) => {
        xe(t, (o) => {
          bo(e, o);
        });
      }, gn = (e, t, o) => {
        if (U(o) || Yt(o) || ns(o))
          e.setAttribute(t, o + "");
        else
          throw console.error("Invalid call to Attribute.set. Key ", t, ":: Value ", o, ":: Element ", e), new Error("Attribute value was not simple");
      }, Ss = (e, t, o) => {
        gn(e.dom, t, o);
      }, ea = (e, t) => {
        const o = e.dom;
        Un(t, (r, c) => {
          gn(o, c, r);
        });
      }, gs = (e, t) => {
        const o = e.dom.getAttribute(t);
        return o === null ? void 0 : o;
      }, il = (e, t) => P.from(gs(e, t)), Cs = (e, t) => {
        const o = e.dom;
        return o && o.hasAttribute ? o.hasAttribute(t) : !1;
      }, sr = (e, t) => {
        e.dom.removeAttribute(t);
      }, Qm = (e) => {
        const t = e.dom.attributes;
        return t == null || t.length === 0;
      }, Kn = (e) => Io(e.dom.attributes, (t, o) => (t[o.name] = o.value, t), {}), Il = (e) => {
        e.dom.textContent = "", xe(Os(e), (t) => {
          qo(t);
        });
      }, qo = (e) => {
        const t = e.dom;
        t.parentNode !== null && t.parentNode.removeChild(t);
      }, hc = (e) => {
        const t = Os(e);
        t.length > 0 && lg(e, t), qo(e);
      }, hr = (e, t) => te.fromDom(e.dom.cloneNode(t)), pr = (e) => hr(e, !1), Vi = (e) => hr(e, !0), Jm = (e, t) => {
        const o = te.fromTag(t), r = Kn(e);
        return ea(o, r), o;
      }, ku = (e, t) => {
        const o = Jm(e, t);
        cl(e, o);
        const r = Os(e);
        return ll(o, r), qo(e), o;
      }, hd = (e, t) => {
        const r = (t || document).createElement("div");
        return r.innerHTML = e, Os(te.fromDom(r));
      }, pd = (e) => en(e, te.fromDom), la = (e) => e.dom.innerHTML, Au = (e, t) => {
        const r = Ml(e).dom, c = te.fromDom(r.createDocumentFragment()), u = hd(t, r);
        ll(c, u), Il(e), bo(e, c);
      }, Jy = (e) => {
        const t = te.fromTag("div"), o = te.fromDom(e.dom.cloneNode(!0));
        return bo(t, o), la(t);
      }, bd = (e) => e.style !== void 0 && se(e.style.getPropertyValue), Mo = (e) => {
        const t = Eo(e) ? e.dom.parentNode : e.dom;
        if (t == null || t.ownerDocument === null)
          return !1;
        const o = t.ownerDocument;
        return rm(te.fromDom(t)).fold(() => o.body.contains(t), No(Mo, ln));
      }, e1 = (e, t, o) => {
        if (!U(o))
          throw console.error("Invalid call to CSS.set. Property ", t, ":: Value ", o, ":: Element ", e), new Error("CSS value must be a string: " + o);
        bd(e) && e.style.setProperty(t, o);
      }, ef = (e, t) => {
        bd(e) && e.style.removeProperty(t);
      }, Ca = (e, t, o) => {
        const r = e.dom;
        e1(r, t, o);
      }, pc = (e, t) => {
        const o = e.dom;
        Un(t, (r, c) => {
          e1(o, c, r);
        });
      }, Ls = (e, t) => {
        const o = e.dom, c = window.getComputedStyle(o).getPropertyValue(t);
        return c === "" && !Mo(e) ? _u(o, t) : c;
      }, _u = (e, t) => bd(e) ? e.style.getPropertyValue(t) : "", rr = (e, t) => {
        const o = e.dom, r = _u(o, t);
        return P.from(r).filter((c) => c.length > 0);
      }, tf = (e) => {
        const t = {}, o = e.dom;
        if (bd(o))
          for (let r = 0; r < o.style.length; r++) {
            const c = o.style.item(r);
            t[c] = o.style[c];
          }
        return t;
      }, bh = (e, t) => {
        const o = e.dom;
        ef(o, t), Ho(il(e, "style").map(_s), "") && sr(e, "style");
      }, t1 = (e) => e.dom.offsetWidth, di = ((e, t) => {
        const o = (b, v) => {
          if (!ns(v) && !v.match(/^[0-9]+$/))
            throw new Error(e + ".set accepts only positive integer values. Value was " + v);
          const S = b.dom;
          bd(S) && (S.style[e] = v + "px");
        }, r = (b) => {
          const v = t(b);
          if (v <= 0 || v === null) {
            const S = Ls(b, e);
            return parseFloat(S) || 0;
          }
          return v;
        }, c = r, u = (b, v) => Io(v, (S, O) => {
          const R = Ls(b, O), M = R === void 0 ? 0 : parseInt(R, 10);
          return isNaN(M) ? S : S + M;
        }, 0);
        return {
          set: o,
          get: r,
          getOuter: c,
          aggregate: u,
          max: (b, v, S) => {
            const O = u(b, S);
            return v > O ? v - O : 0;
          }
        };
      })("height", (e) => {
        const t = e.dom;
        return Mo(e) ? t.getBoundingClientRect().height : t.offsetHeight;
      }), e2 = (e) => di.get(e), n1 = (e, t) => ({
        left: e,
        top: t,
        translate: (r, c) => n1(e + r, t + c)
      }), mi = n1, s0 = (e) => {
        const t = e.getBoundingClientRect();
        return mi(t.left, t.top);
      }, nf = (e, t) => e !== void 0 ? e : t !== void 0 ? t : 0, ig = (e) => {
        const t = e.dom.ownerDocument, o = t.body, r = t.defaultView, c = t.documentElement;
        if (o === e.dom)
          return mi(o.offsetLeft, o.offsetTop);
        const u = nf(r?.pageYOffset, c.scrollTop), f = nf(r?.pageXOffset, c.scrollLeft), b = nf(c.clientTop, o.clientTop), v = nf(c.clientLeft, o.clientLeft);
        return ug(e).translate(f - v, u - b);
      }, ug = (e) => {
        const t = e.dom, r = t.ownerDocument.body;
        return r === t ? mi(r.offsetLeft, r.offsetTop) : Mo(e) ? s0(t) : mi(0, 0);
      }, o1 = (e) => {
        const t = e !== void 0 ? e.dom : document, o = t.body.scrollLeft || t.documentElement.scrollLeft, r = t.body.scrollTop || t.documentElement.scrollTop;
        return mi(o, r);
      }, r0 = (e, t, o) => {
        const c = (o !== void 0 ? o.dom : document).defaultView;
        c && c.scrollTo(e, t);
      }, Fl = (e, t) => {
        Ii().browser.isSafari() && se(e.dom.scrollIntoViewIfNeeded) ? e.dom.scrollIntoViewIfNeeded(!1) : e.dom.scrollIntoView(t);
      }, t2 = (e, t) => {
        const o = (u) => {
          if (!e(u))
            throw new Error("Can only get " + t + " value of a " + t + " node");
          return r(u).getOr("");
        }, r = (u) => e(u) ? P.from(u.dom.nodeValue) : P.none();
        return {
          get: o,
          getOption: r,
          set: (u, f) => {
            if (!e(u))
              throw new Error("Can only set raw " + t + " value of a " + t + " node");
            u.dom.nodeValue = f;
          }
        };
      }, vd = (e, t) => {
        const r = document.createDocumentFragment();
        return xe(e, (c) => {
          r.appendChild(c.dom);
        }), te.fromDom(r);
      }, Po = t2(Eo, "text"), xa = (e) => Po.get(e), Ui = (e) => Po.getOption(e), s1 = (e, t) => Po.set(e, t), yd = (e, t) => {
        const o = gs(e, t);
        return o === void 0 || o === "" ? [] : o.split(" ");
      }, r1 = (e, t, o) => {
        const c = yd(e, t).concat([o]);
        return Ss(e, t, c.join(" ")), !0;
      }, a0 = (e, t, o) => {
        const r = ze(yd(e, t), (c) => c !== o);
        return r.length > 0 ? Ss(e, t, r.join(" ")) : sr(e, t), !1;
      };
      var ji = (e, t, o, r, c) => e(o, r) ? P.some(o) : se(c) && c(o) ? P.none() : t(o, r, c);
      const Wi = (e, t, o) => {
        let r = e.dom;
        const c = se(o) ? o : ye;
        for (; r.parentNode; ) {
          r = r.parentNode;
          const u = te.fromDom(r);
          if (t(u))
            return P.some(u);
          if (c(u))
            break;
        }
        return P.none();
      }, Uo = (e, t, o) => ji((c, u) => u(c), Wi, e, t, o), c0 = (e, t) => {
        const o = e.dom;
        return o.parentNode ? Ds(te.fromDom(o.parentNode), (r) => !Qn(e, r) && t(r)) : P.none();
      }, Ds = (e, t) => {
        const o = (c) => t(te.fromDom(c));
        return _o(e.dom.childNodes, o).map(te.fromDom);
      }, of = (e, t) => {
        const o = (r) => {
          for (let c = 0; c < r.childNodes.length; c++) {
            const u = te.fromDom(r.childNodes[c]);
            if (t(u))
              return P.some(u);
            const f = o(r.childNodes[c]);
            if (f.isSome())
              return f;
          }
          return P.none();
        };
        return o(e.dom);
      }, ar = (e, t, o) => Wi(e, (r) => Ic(r, t), o), Zi = (e, t) => md(t, e), ia = (e, t, o) => ji((c, u) => Ic(c, u), ar, e, t, o), Ou = (e) => e.dom.classList !== void 0, vh = (e) => yd(e, "class"), a1 = (e, t) => r1(e, "class", t), c1 = (e, t) => a0(e, "class", t), n2 = (e, t) => Lt(vh(e), t) ? c1(e, t) : a1(e, t), bc = (e, t) => {
        Ou(e) ? e.dom.classList.add(t) : a1(e, t);
      }, fi = (e) => {
        (Ou(e) ? e.dom.classList : vh(e)).length === 0 && sr(e, "class");
      }, cr = (e, t) => {
        Ou(e) ? e.dom.classList.remove(t) : c1(e, t), fi(e);
      }, Lr = (e, t) => {
        const o = Ou(e) ? e.dom.classList.toggle(t) : n2(e, t);
        return fi(e), o;
      }, yh = (e, t) => Ou(e) && e.dom.classList.contains(t), dg = (e, t) => {
        xe(t, (o) => {
          bc(e, o);
        });
      }, Ch = (e, t) => {
        xe(t, (o) => {
          cr(e, o);
        });
      }, l0 = (e) => ia(e, "[contenteditable]"), Ll = (e, t = !1) => Mo(e) ? e.dom.isContentEditable : l0(e).fold(ot(t), (o) => $S(o) === "true"), $S = (e) => e.dom.contentEditable, w = (e, t) => {
        e.dom.contentEditable = t ? "true" : "false";
      }, k = (e, t, o) => ze(ya(e, o), t), F = (e, t) => ze(Os(e), t), q = (e, t) => {
        let o = [];
        return xe(Os(e), (r) => {
          t(r) && (o = o.concat([r])), o = o.concat(q(r, t));
        }), o;
      }, de = (e, t, o) => (
        // It may surprise you to learn this is exactly what JQuery does
        // TODO: Avoid all this wrapping and unwrapping
        k(e, (r) => Ic(r, t), o)
      ), Ne = (e, t) => ai(t, e), ft = (e, t, o) => Wi(e, t, o).isSome(), Zt = (e, t) => c0(e, t).isSome(), Dn = (e, t) => of(e, t).isSome(), Vn = (e, t) => ft(e, ue(Qn, t)), ss = (e, t, o) => ar(e, t, o).isSome(), ws = (e, t, o) => ia(e, t, o).isSome(), lr = (e) => se(e) ? e : ye, Hc = (e, t, o) => {
        let r = e.dom;
        const c = lr(o);
        for (; r.parentNode; ) {
          r = r.parentNode;
          const u = te.fromDom(r), f = t(u);
          if (f.isSome())
            return f;
          if (c(u))
            break;
        }
        return P.none();
      }, gi = (e, t, o) => {
        const r = t(e), c = lr(o);
        return r.orThunk(() => c(e) ? P.none() : Hc(e, t, c));
      }, Du = (e) => Ui(e).filter((t) => (
        // For the purposes of finding cursor positions only allow text nodes with content,
        // but trim removes &nbsp; and that's allowed
        t.trim().length !== 0 || t.indexOf($s) > -1
      )).isSome(), Hl = (e) => li(e) && gs(e, "contenteditable") === "false", l1 = ["img", "br"], sf = (e) => Du(e) || Lt(l1, Hn(e)) || Hl(e), mg = (e) => of(e, sf), gg = {
        create: (e, t, o, r) => ({
          start: e,
          soffset: t,
          finish: o,
          foffset: r
        })
      }, rf = el.generate([
        { before: ["element"] },
        { on: ["element", "offset"] },
        { after: ["element"] }
      ]), xh = (e, t, o, r) => e.fold(t, o, r), o2 = (e) => e.fold(jo, jo, jo), s2 = rf.before, vo = rf.on, Hs = rf.after, Gs = {
        before: s2,
        on: vo,
        after: Hs,
        cata: xh,
        getStart: o2
      }, Sa = el.generate([
        { domRange: ["rng"] },
        { relative: ["startSitu", "finishSitu"] },
        { exact: ["start", "soffset", "finish", "foffset"] }
      ]), Sh = (e) => Sa.exact(e.start, e.soffset, e.finish, e.foffset), hg = (e) => e.match({
        domRange: (t) => te.fromDom(t.startContainer),
        relative: (t, o) => Gs.getStart(t),
        exact: (t, o, r, c) => t
      }), wh = Sa.domRange, Eh = Sa.relative, IS = Sa.exact, am = (e) => {
        const t = hg(e);
        return ii(t);
      }, i1 = gg.create, af = {
        domRange: wh,
        relative: Eh,
        exact: IS,
        exactFromRange: Sh,
        getWin: am,
        range: i1
      }, M3 = (e, t, o) => P.from(e.caretPositionFromPoint?.(t, o)).bind((r) => {
        if (r.offsetNode === null)
          return P.none();
        const c = e.createRange();
        return c.setStart(r.offsetNode, r.offset), c.collapse(), P.some(c);
      }), Rr = (e, t, o) => P.from(e.caretRangeFromPoint?.(t, o)), wr = (e, t, o) => e.caretPositionFromPoint ? M3(e, t, o) : e.caretRangeFromPoint ? Rr(e, t, o) : P.none(), cf = (e, t, o) => {
        const r = e.document;
        return wr(r, t, o).map((c) => gg.create(te.fromDom(c.startContainer), c.startOffset, te.fromDom(c.endContainer), c.endOffset));
      }, cm = (e, t) => {
        const o = Hn(e);
        return o === "input" ? Gs.after(e) : Lt(["br", "img"], o) ? t === 0 ? Gs.before(e) : Gs.after(e) : Gs.on(e, t);
      }, r2 = (e, t) => {
        const o = e.fold(Gs.before, cm, Gs.after), r = t.fold(Gs.before, cm, Gs.after);
        return af.relative(o, r);
      }, Ia = (e, t, o, r) => {
        const c = cm(e, t), u = cm(o, r);
        return af.relative(c, u);
      }, a2 = (e) => e.match({
        domRange: (t) => {
          const o = te.fromDom(t.startContainer), r = te.fromDom(t.endContainer);
          return Ia(o, t.startOffset, r, t.endOffset);
        },
        relative: r2,
        exact: Ia
      }), lf = (e) => {
        const t = af.getWin(e).dom, o = (c, u, f, b) => Ym(t, c, u, f, b), r = a2(e);
        return sg(t, r).match({
          ltr: o,
          rtl: o
        });
      }, i0 = (e, t, o) => cf(e, t, o), zl = (e) => {
        const t = e === void 0 ? window : e;
        return Ii().browser.isFirefox() ? P.none() : P.from(t.visualViewport);
      }, c2 = (e, t, o, r) => ({
        x: e,
        y: t,
        width: o,
        height: r,
        right: e + o,
        bottom: t + r
      }), ul = (e) => {
        const t = e === void 0 ? window : e, o = t.document, r = o1(te.fromDom(o));
        return zl(t).fold(() => {
          const c = t.document.documentElement, u = c.clientWidth, f = c.clientHeight;
          return c2(r.left, r.top, u, f);
        }, (c) => (
          // iOS doesn't update the pageTop/pageLeft when element.scrollIntoView() is called, so we need to fallback to the
          // scroll position which will always be less than the page top/left values when page top/left are accurate/correct.
          c2(Math.max(c.pageLeft, r.left), Math.max(c.pageTop, r.top), c.width, c.height)
        ));
      };
      class Js {
        rootNode;
        node;
        constructor(t, o) {
          this.node = t, this.rootNode = o, this.current = this.current.bind(this), this.next = this.next.bind(this), this.prev = this.prev.bind(this), this.prev2 = this.prev2.bind(this);
        }
        /**
         * Returns the current node.
         *
         * @method current
         * @return {Node/undefined} Current node where the walker is, or undefined if the walker has reached the end.
         */
        current() {
          return this.node;
        }
        /**
         * Walks to the next node in tree.
         *
         * @method next
         * @return {Node/undefined} Current node where the walker is after moving to the next node, or undefined if the walker has reached the end.
         */
        next(t) {
          return this.node = this.findSibling(this.node, "firstChild", "nextSibling", t), this.node;
        }
        /**
         * Walks to the previous node in tree.
         *
         * @method prev
         * @return {Node/undefined} Current node where the walker is after moving to the previous node, or undefined if the walker has reached the end.
         */
        prev(t) {
          return this.node = this.findSibling(this.node, "lastChild", "previousSibling", t), this.node;
        }
        prev2(t) {
          return this.node = this.findPreviousNode(this.node, t), this.node;
        }
        findSibling(t, o, r, c) {
          if (t) {
            if (!c && t[o])
              return t[o];
            if (t !== this.rootNode) {
              let u = t[r];
              if (u)
                return u;
              for (let f = t.parentNode; f && f !== this.rootNode; f = f.parentNode)
                if (u = f[r], u)
                  return u;
            }
          }
        }
        findPreviousNode(t, o) {
          if (t) {
            const r = t.previousSibling;
            if (this.rootNode && r === this.rootNode)
              return;
            if (r) {
              if (!o) {
                for (let u = r.lastChild; u; u = u.lastChild)
                  if (!u.lastChild)
                    return u;
              }
              return r;
            }
            const c = t.parentNode;
            if (c && c !== this.rootNode)
              return c;
          }
        }
      }
      const u0 = /^[ \t\r\n]*$/, Th = (e) => u0.test(e), FS = (e) => {
        for (const t of e)
          if (!Xa(t))
            return !1;
        return !0;
      }, l2 = (e) => " \f	\v".indexOf(e) !== -1, LS = (e) => e === `
` || e === "\r", HS = (e, t) => t < e.length && t >= 0 ? LS(e[t]) : !1, d0 = (e, t = 4, o = !0, r = !0) => {
        const c = nl(" ", t), u = e.replace(/\t/g, c);
        return Io(u, (b, v) => l2(v) || v === $s ? b.pcIsSpace || b.str === "" && o || b.str.length === u.length - 1 && r || HS(u, b.str.length + 1) ? { pcIsSpace: !1, str: b.str + $s } : { pcIsSpace: !0, str: b.str + " " } : { pcIsSpace: LS(v), str: b.str + v }, { pcIsSpace: !1, str: "" }).str;
      }, kh = (e) => (t) => !!t && t.nodeType === e, m0 = (e) => !!e && !Object.getPrototypeOf(e), ht = kh(1), zc = (e) => ht(e) && li(te.fromDom(e)), P3 = (e) => ht(e) && e.namespaceURI === "http://www.w3.org/2000/svg", vc = (e) => {
        const t = e.toLowerCase();
        return (o) => X(o) && o.nodeName.toLowerCase() === t;
      }, hi = (e) => {
        const t = e.map((o) => o.toLowerCase());
        return (o) => {
          if (o && o.nodeName) {
            const r = o.nodeName.toLowerCase();
            return Lt(t, r);
          }
          return !1;
        };
      }, f0 = (e, t) => {
        const o = t.toLowerCase().split(" ");
        return (r) => {
          if (ht(r)) {
            const c = r.ownerDocument.defaultView;
            if (c)
              for (let u = 0; u < o.length; u++) {
                const f = c.getComputedStyle(r, null);
                if ((f ? f.getPropertyValue(e) : null) === o[u])
                  return !0;
              }
          }
          return !1;
        };
      }, B3 = (e) => (t) => ht(t) && t.hasAttribute(e), uf = (e) => ht(e) && e.hasAttribute("data-mce-bogus"), $3 = (e) => ht(e) && e.getAttribute("data-mce-bogus") === "all", Vc = (e) => ht(e) && e.tagName === "TABLE", zS = (e) => (t) => !!(zc(t) && (t.contentEditable === e || t.getAttribute("data-mce-contenteditable") === e)), pi = hi(["textarea", "input"]), tt = kh(3), i2 = kh(4), Hr = kh(7), zn = kh(8), lm = kh(9), Ah = kh(11), zs = vc("br"), bi = vc("img"), u1 = vc("a"), dl = zS("true"), Es = zS("false"), im = (e) => zc(e) && e.isContentEditable && X(e.parentElement) && !e.parentElement.isContentEditable, _h = hi(["td", "th"]), u2 = hi(["td", "th", "caption"]), d2 = vc("template"), vi = hi(["video", "audio", "object", "embed"]), d1 = vc("li"), m1 = vc("details"), I3 = vc("summary"), m2 = "uc-video", f1 = (e) => e.nodeName.toLowerCase() === m2, f2 = {
        skipBogus: !0,
        includeZwsp: !1,
        checkRootAsContent: !1
      }, g0 = (e, t, o) => {
        const r = te.fromDom(t), c = te.fromDom(e), u = o.getWhitespaceElements();
        return ft(c, (b) => kn(u, Hn(b)), ue(Qn, r));
      }, F3 = (e) => ht(e) && e.nodeName === "A" && !e.hasAttribute("href") && (e.hasAttribute("name") || e.hasAttribute("id")), L3 = (e, t) => ht(e) && kn(t.getNonEmptyElements(), e.nodeName), g2 = B3("data-mce-bookmark"), H3 = (e) => Fc(te.fromDom(e)).exists((t) => !Ll(t)), g1 = (e, t, o) => Th(e.data) && !g0(e, t, o), e5 = (e, t, o, r) => tt(e) && !g1(e, t, o) && (!r.includeZwsp || !FS(e.data)), ml = (e, t, o, r) => se(r.isContent) && r.isContent(t) || L3(t, e) || g2(t) || F3(t) || e5(t, o, e, r) || Es(t) || dl(t) && H3(t), on = (e, t, o) => {
        const r = { ...f2, ...o };
        if (r.checkRootAsContent && ml(e, t, t, r))
          return !1;
        let c = t.firstChild, u = 0;
        if (!c)
          return !0;
        const f = new Js(c, t);
        do {
          if (r.skipBogus && ht(c)) {
            const b = c.getAttribute("data-mce-bogus");
            if (b) {
              c = f.next(b === "all");
              continue;
            }
          }
          if (zn(c)) {
            c = f.next(!0);
            continue;
          }
          if (zs(c)) {
            u++, c = f.next();
            continue;
          }
          if (ml(e, c, t, r))
            return !1;
          c = f.next();
        } while (c);
        return u <= 1;
      }, er = (e, t, o) => on(e, t.dom, { checkRootAsContent: !0, ...o }), Oh = (e, t, o) => ml(e, t, t, { includeZwsp: f2.includeZwsp, ...o }), VS = (e) => {
        const t = e.toLowerCase();
        return t === "svg" ? "svg" : t === "math" ? "math" : "html";
      }, pg = (e) => VS(e) !== "html", Dh = (e) => pg(e.nodeName), h2 = (e) => VS(e.nodeName), bg = ["svg", "math"], US = () => {
        const e = Mc(), t = () => e.get().map(h2).getOr("html");
        return {
          track: (c) => (Dh(c) ? e.set(c) : e.get().exists((u) => !u.contains(c)) && e.clear(), t()),
          current: t,
          reset: () => {
            e.clear();
          }
        };
      }, Cd = "data-mce-block", jS = (e) => ze(Vt(e), (t) => !/[A-Z]/.test(t)), p2 = (e) => en(jS(e), (t) => {
        const o = CSS.escape(t);
        return `${o}:` + en(bg, (r) => `not(${r} ${o})`).join(":");
      }).join(","), Fs = (e, t) => X(t.querySelector(e)) ? (t.setAttribute(Cd, "true"), t.getAttribute("data-mce-selected") === "inline-boundary" && t.removeAttribute("data-mce-selected"), !0) : (t.removeAttribute(Cd), !1), yi = (e, t) => {
        const o = p2(e.getTransparentElements()), r = p2(e.getBlockElements());
        return ze(t.querySelectorAll(o), (c) => Fs(r, c));
      }, yc = (e, t, o) => {
        const r = o ? "lastChild" : "firstChild";
        for (let c = t[r]; c; c = c[r])
          if (on(e, c, { checkRootAsContent: !0 })) {
            c.parentNode?.removeChild(c);
            return;
          }
      }, Rh = (e, t, o) => {
        const r = document.createRange(), c = t.parentNode;
        if (c) {
          r.setStartBefore(t), r.setEndBefore(o);
          const u = r.extractContents();
          yc(e, u, !0), r.setStartAfter(o), r.setEndAfter(t);
          const f = r.extractContents();
          yc(e, f, !1), on(e, u, { checkRootAsContent: !0 }) || c.insertBefore(u, t), on(e, o, { checkRootAsContent: !0 }) || c.insertBefore(o, t), on(e, f, { checkRootAsContent: !0 }) || c.insertBefore(f, t), c.removeChild(t);
        }
      }, Cc = (e, t, o) => {
        const r = e.getBlockElements(), c = te.fromDom(t), u = (b) => Hn(b) in r, f = (b) => Qn(b, c);
        xe(pd(o), (b) => {
          Wi(b, u, f).each((v) => {
            const S = F(b, (O) => u(O) && !e.isValidChild(Hn(v), Hn(O)));
            if (S.length > 0) {
              const O = Fc(v);
              xe(S, (R) => {
                Wi(R, u, f).each((M) => {
                  Rh(e, M.dom, R.dom);
                });
              }), O.each((R) => yi(e, R.dom));
            }
          });
        });
      }, vg = (e, t, o) => {
        xe([...o, ...qs(e, t) ? [t] : []], (r) => xe(Ne(te.fromDom(r), r.nodeName.toLowerCase()), (c) => {
          Gi(e, c.dom) && hc(c);
        }));
      }, ta = (e, t) => {
        const o = yi(e, t);
        Cc(e, t, o), vg(e, t, o);
      }, xc = (e, t) => {
        if (h1(e, t)) {
          const o = p2(e.getBlockElements());
          Fs(o, t);
        }
      }, h0 = (e, t, o) => {
        const r = (u) => Qn(u, te.fromDom(t)), c = ya(te.fromDom(o), r);
        Gr(c, c.length - 2).filter(Is).fold(() => ta(e, t), (u) => ta(e, u.dom));
      }, Ze = (e) => e.hasAttribute(Cd), Uc = (e, t) => kn(e.getTransparentElements(), t), h1 = (e, t) => ht(t) && Uc(e, t.nodeName), qs = (e, t) => h1(e, t) && Ze(t), Gi = (e, t) => h1(e, t) && !Ze(t), fl = (e, t) => t.type === 1 && Uc(e, t.name) && U(t.attr(Cd)), z3 = Ii().browser, xd = (e) => _o(e, Is), WS = (e) => z3.isFirefox() && Hn(e) === "table" ? xd(Os(e)).filter((t) => Hn(t) === "caption").bind((t) => xd($r(t)).map((o) => {
        const r = o.dom.offsetTop, c = t.dom.offsetTop, u = t.dom.offsetHeight;
        return r <= c ? -u : 0;
      })).getOr(0) : 0, jc = (e, t) => e.children && Lt(e.children, t), Fo = (e, t, o) => {
        let r = 0, c = 0;
        const u = e.ownerDocument;
        if (o = o || e, t) {
          if (o === e && t.getBoundingClientRect && Ls(te.fromDom(e), "position") === "static") {
            const b = t.getBoundingClientRect();
            return r = b.left + (u.documentElement.scrollLeft || e.scrollLeft) - u.documentElement.clientLeft, c = b.top + (u.documentElement.scrollTop || e.scrollTop) - u.documentElement.clientTop, { x: r, y: c };
          }
          let f = t;
          for (; f && f !== o && f.nodeType && !jc(f, o); ) {
            const b = f;
            r += b.offsetLeft || 0, c += b.offsetTop || 0, f = b.offsetParent;
          }
          for (f = t.parentNode; f && f !== o && f.nodeType && !jc(f, o); )
            r -= f.scrollLeft || 0, c -= f.scrollTop || 0, f = f.parentNode;
          c += WS(te.fromDom(t));
        }
        return { x: r, y: c };
      }, Ru = (e, t) => {
        const o = t.crossOrigin;
        return t.contentCssCors ? "anonymous" : se(o) ? o(e) : void 0;
      }, Nh = (e, t = {}) => {
        let o = 0;
        const r = {}, c = te.fromDom(e), u = Pl(c), f = (be) => {
          t.referrerPolicy = be;
        }, b = (be) => {
          t.contentCssCors = be;
        }, v = (be) => {
          t.crossOrigin = be;
        }, S = (be) => {
          bo(Xp(c), be);
        }, O = (be) => {
          const ve = Xp(c);
          Zi(ve, "#" + be).each(qo);
        }, R = (be) => Wo(r, be).getOrThunk(() => ({
          id: "mce-u" + o++,
          passed: [],
          failed: [],
          count: 0
        })), M = (be) => new Promise((ve, Be) => {
          let je;
          const xt = Je._addCacheSuffix(be), Kt = R(xt);
          r[xt] = Kt, Kt.count++;
          const Me = (wn, uo) => {
            xe(wn, Fn), Kt.status = uo, Kt.passed = [], Kt.failed = [], je && (je.onload = null, je.onerror = null, je = null);
          }, Te = () => Me(Kt.passed, 2), $e = () => Me(Kt.failed, 3);
          if (ve && Kt.passed.push(ve), Be && Kt.failed.push(Be), Kt.status === 1)
            return;
          if (Kt.status === 2) {
            Te();
            return;
          }
          if (Kt.status === 3) {
            $e();
            return;
          }
          Kt.status = 1;
          const yt = te.fromTag("link", u.dom);
          ea(yt, {
            rel: "stylesheet",
            type: "text/css",
            id: Kt.id
          });
          const Sn = Ru(be, t);
          Sn !== void 0 && Ss(yt, "crossOrigin", Sn), t.referrerPolicy && Ss(yt, "referrerpolicy", t.referrerPolicy), je = yt.dom, je.onload = Te, je.onerror = $e, S(yt), Ss(yt, "href", xt);
        }), H = (be, ve) => {
          const Be = R(be);
          r[be] = Be, Be.count++;
          const je = te.fromTag("style", u.dom);
          ea(je, {
            rel: "stylesheet",
            type: "text/css",
            id: Be.id,
            "data-mce-key": be
          }), je.dom.innerHTML = ve, S(je);
        }, J = (be) => Promise.allSettled(en(be, (Be) => M(Be).then(ot(Be)))).then((Be) => {
          const je = st(Be, (xt) => xt.status === "fulfilled");
          return je.fail.length > 0 ? Promise.reject(en(je.fail, (xt) => xt.reason)) : en(je.pass, (xt) => xt.value);
        }), W = (be) => {
          const ve = Je._addCacheSuffix(be);
          Wo(r, ve).each((Be) => {
            --Be.count === 0 && (delete r[ve], O(Be.id));
          });
        };
        return {
          load: M,
          loadRawCss: H,
          loadAll: J,
          unload: W,
          unloadRawCss: (be) => {
            Wo(r, be).each((ve) => {
              --ve.count === 0 && (delete r[be], O(ve.id));
            });
          },
          unloadAll: (be) => {
            xe(be, (ve) => {
              W(ve);
            });
          },
          _setReferrerPolicy: f,
          _setContentCssCors: b,
          _setCrossOrigin: v
        };
      }, b2 = (() => {
        const e = /* @__PURE__ */ new WeakMap();
        return {
          forElement: (o, r) => {
            const u = Fr(o).dom;
            return P.from(e.get(u)).getOrThunk(() => {
              const f = Nh(u, r);
              return e.set(u, f), f;
            });
          }
        };
      })(), v2 = (e) => e.nodeName.toLowerCase() === "span", qi = (e, t) => X(e) && (Oh(t, e) || t.isInline(e.nodeName.toLowerCase())), p0 = (e, t, o) => {
        const r = new Js(e, t).prev(!1), c = new Js(e, t).next(!1), u = Gn(r) || qi(r, o), f = Gn(c) || qi(c, o);
        return u && f;
      }, Wc = (e) => v2(e) && e.getAttribute("data-mce-type") === "bookmark", V3 = (e, t, o) => tt(e) && e.data.length > 0 && p0(e, t, o), we = (e) => ht(e) ? e.childNodes.length > 0 : !1, Vl = (e) => Ah(e) || lm(e), p1 = (e, t, o, r) => {
        const c = r || t;
        if (ht(t) && Wc(t))
          return t;
        const u = t.childNodes;
        for (let f = u.length - 1; f >= 0; f--)
          p1(e, u[f], o, c);
        if (ht(t)) {
          const f = t.childNodes;
          f.length === 1 && Wc(f[0]) && t.parentNode?.insertBefore(f[0], t);
        }
        return !Vl(t) && !Oh(o, t) && !we(t) && !V3(t, c, o) && e.remove(t), t;
      }, Vs = Je.makeMap, Sc = /[&<>\"\u0060\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, zr = /[<>&\u007E-\uD7FF\uE000-\uFFEF]|[\uD800-\uDBFF][\uDC00-\uDFFF]/g, cs = /[<>&\"\']/g, ZS = /&#([a-z0-9]+);?|&([a-z0-9]+);/gi, df = {
        128: "€",
        130: "‚",
        131: "ƒ",
        132: "„",
        133: "…",
        134: "†",
        135: "‡",
        136: "ˆ",
        137: "‰",
        138: "Š",
        139: "‹",
        140: "Œ",
        142: "Ž",
        145: "‘",
        146: "’",
        147: "“",
        148: "”",
        149: "•",
        150: "–",
        151: "—",
        152: "˜",
        153: "™",
        154: "š",
        155: "›",
        156: "œ",
        158: "ž",
        159: "Ÿ"
      }, mf = {
        '"': "&quot;",
        // Needs to be escaped since the YUI compressor would otherwise break the code
        "'": "&#39;",
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;",
        "`": "&#96;"
      }, Mh = {
        "&lt;": "<",
        "&gt;": ">",
        "&amp;": "&",
        "&quot;": '"',
        "&apos;": "'"
      }, b1 = (e) => {
        const t = te.fromTag("div").dom;
        return t.innerHTML = e, t.textContent || t.innerText || e;
      }, y2 = (e, t) => {
        const o = {};
        if (e) {
          const r = e.split(",");
          t = t || 10;
          for (let c = 0; c < r.length; c += 2) {
            const u = String.fromCharCode(parseInt(r[c], t));
            if (!mf[u]) {
              const f = "&" + r[c + 1] + ";";
              o[u] = f, o[f] = u;
            }
          }
          return o;
        } else
          return;
      }, C2 = y2("50,nbsp,51,iexcl,52,cent,53,pound,54,curren,55,yen,56,brvbar,57,sect,58,uml,59,copy,5a,ordf,5b,laquo,5c,not,5d,shy,5e,reg,5f,macr,5g,deg,5h,plusmn,5i,sup2,5j,sup3,5k,acute,5l,micro,5m,para,5n,middot,5o,cedil,5p,sup1,5q,ordm,5r,raquo,5s,frac14,5t,frac12,5u,frac34,5v,iquest,60,Agrave,61,Aacute,62,Acirc,63,Atilde,64,Auml,65,Aring,66,AElig,67,Ccedil,68,Egrave,69,Eacute,6a,Ecirc,6b,Euml,6c,Igrave,6d,Iacute,6e,Icirc,6f,Iuml,6g,ETH,6h,Ntilde,6i,Ograve,6j,Oacute,6k,Ocirc,6l,Otilde,6m,Ouml,6n,times,6o,Oslash,6p,Ugrave,6q,Uacute,6r,Ucirc,6s,Uuml,6t,Yacute,6u,THORN,6v,szlig,70,agrave,71,aacute,72,acirc,73,atilde,74,auml,75,aring,76,aelig,77,ccedil,78,egrave,79,eacute,7a,ecirc,7b,euml,7c,igrave,7d,iacute,7e,icirc,7f,iuml,7g,eth,7h,ntilde,7i,ograve,7j,oacute,7k,ocirc,7l,otilde,7m,ouml,7n,divide,7o,oslash,7p,ugrave,7q,uacute,7r,ucirc,7s,uuml,7t,yacute,7u,thorn,7v,yuml,ci,fnof,sh,Alpha,si,Beta,sj,Gamma,sk,Delta,sl,Epsilon,sm,Zeta,sn,Eta,so,Theta,sp,Iota,sq,Kappa,sr,Lambda,ss,Mu,st,Nu,su,Xi,sv,Omicron,t0,Pi,t1,Rho,t3,Sigma,t4,Tau,t5,Upsilon,t6,Phi,t7,Chi,t8,Psi,t9,Omega,th,alpha,ti,beta,tj,gamma,tk,delta,tl,epsilon,tm,zeta,tn,eta,to,theta,tp,iota,tq,kappa,tr,lambda,ts,mu,tt,nu,tu,xi,tv,omicron,u0,pi,u1,rho,u2,sigmaf,u3,sigma,u4,tau,u5,upsilon,u6,phi,u7,chi,u8,psi,u9,omega,uh,thetasym,ui,upsih,um,piv,812,bull,816,hellip,81i,prime,81j,Prime,81u,oline,824,frasl,88o,weierp,88h,image,88s,real,892,trade,89l,alefsym,8cg,larr,8ch,uarr,8ci,rarr,8cj,darr,8ck,harr,8dl,crarr,8eg,lArr,8eh,uArr,8ei,rArr,8ej,dArr,8ek,hArr,8g0,forall,8g2,part,8g3,exist,8g5,empty,8g7,nabla,8g8,isin,8g9,notin,8gb,ni,8gf,prod,8gh,sum,8gi,minus,8gn,lowast,8gq,radic,8gt,prop,8gu,infin,8h0,ang,8h7,and,8h8,or,8h9,cap,8ha,cup,8hb,int,8hk,there4,8hs,sim,8i5,cong,8i8,asymp,8j0,ne,8j1,equiv,8j4,le,8j5,ge,8k2,sub,8k3,sup,8k4,nsub,8k6,sube,8k7,supe,8kl,oplus,8kn,otimes,8l5,perp,8m5,sdot,8o8,lceil,8o9,rceil,8oa,lfloor,8ob,rfloor,8p9,lang,8pa,rang,9ea,loz,9j0,spades,9j3,clubs,9j5,hearts,9j6,diams,ai,OElig,aj,oelig,b0,Scaron,b1,scaron,bo,Yuml,m6,circ,ms,tilde,802,ensp,803,emsp,809,thinsp,80c,zwnj,80d,zwj,80e,lrm,80f,rlm,80j,ndash,80k,mdash,80o,lsquo,80p,rsquo,80q,sbquo,80s,ldquo,80t,rdquo,80u,bdquo,810,dagger,811,Dagger,81g,permil,81p,lsaquo,81q,rsaquo,85c,euro", 32), ff = (e, t) => e.replace(t ? Sc : zr, (o) => mf[o] || o), Ph = (e) => ("" + e).replace(cs, (t) => mf[t] || t), GS = (e, t) => e.replace(t ? Sc : zr, (o) => o.length > 1 ? "&#" + ((o.charCodeAt(0) - 55296) * 1024 + (o.charCodeAt(1) - 56320) + 65536) + ";" : mf[o] || "&#" + o.charCodeAt(0) + ";"), x2 = (e, t, o) => {
        const r = o || C2;
        return e.replace(t ? Sc : zr, (c) => mf[c] || r[c] || c);
      }, gl = {
        encodeRaw: ff,
        encodeAllRaw: Ph,
        encodeNumeric: GS,
        encodeNamed: x2,
        getEncodeFunc: (e, t) => {
          const o = y2(t) || C2, r = (f, b) => f.replace(b ? Sc : zr, (v) => mf[v] !== void 0 ? mf[v] : o[v] !== void 0 ? o[v] : v.length > 1 ? "&#" + ((v.charCodeAt(0) - 55296) * 1024 + (v.charCodeAt(1) - 56320) + 65536) + ";" : "&#" + v.charCodeAt(0) + ";"), c = (f, b) => x2(f, b, o), u = Vs(e.replace(/\+/g, ","));
          return u.named && u.numeric ? r : u.named ? t ? c : x2 : u.numeric ? GS : ff;
        },
        decode: (e) => e.replace(ZS, (t, o) => o ? (o.charAt(0).toLowerCase() === "x" ? o = parseInt(o.substr(1), 16) : o = parseInt(o, 10), o > 65535 ? (o -= 65536, String.fromCharCode(55296 + (o >> 10), 56320 + (o & 1023))) : df[o] || String.fromCharCode(o)) : Mh[t] || C2[t] || b1(t))
      }, ir = (e, t) => (e = Je.trim(e), e ? e.split(t || " ") : []), gf = (e) => new RegExp("^" + e.replace(/([?+*])/g, ".$1") + "$"), v1 = (e) => Ye(e) && e.source && Object.prototype.toString.call(e) === "[object RegExp]", Zc = (e) => {
        const t = (o) => Ot(o) ? en(o, t) : v1(o) ? new RegExp(o.source, o.flags) : Ye(o) ? lc(o, t) : o;
        return t(e);
      }, Bh = (e) => {
        const t = /^(~)?(.+)$/;
        return xo(ir(e, ","), (o) => {
          const r = t.exec(o);
          if (r) {
            const u = r[1] === "~" ? "span" : "div", f = r[2];
            return [{ cloneName: u, name: f }];
          } else
            return [];
        });
      }, Nr = (e) => Object.freeze([
        // Present on all schema types
        "id",
        "accesskey",
        "class",
        "dir",
        "lang",
        "style",
        "tabindex",
        "title",
        "role",
        // html5 and html5-strict extra attributes
        ...e !== "html4" ? ["contenteditable", "contextmenu", "draggable", "dropzone", "hidden", "spellcheck", "translate", "itemprop", "itemscope", "itemtype"] : [],
        // html4 and html5 extra attributes
        ...e !== "html5-strict" ? ["xml:lang"] : []
      ]), b0 = (e) => {
        let t, o;
        t = "address blockquote div dl fieldset form h1 h2 h3 h4 h5 h6 hr menu ol p pre table ul", o = "a abbr b bdo br button cite code del dfn em embed i iframe img input ins kbd label map noscript object q s samp script select small span strong sub sup textarea u var #text #comment", e !== "html4" && (t += " article aside details dialog figure main header footer hgroup section nav " + "a ins del canvas map", o += " audio canvas command data datalist mark meter output picture progress template time wbr video ruby bdi keygen svg"), e !== "html5-strict" && (o = [o, "acronym applet basefont big font strike tt"].join(" "), t = [t, "center dir isindex noframes"].join(" "));
        const r = [t, o].join(" ");
        return { blockContent: t, phrasingContent: o, flowContent: r };
      }, Ul = (e) => {
        const { blockContent: t, phrasingContent: o, flowContent: r } = b0(e), c = (u) => Object.freeze(u.split(" "));
        return Object.freeze({
          blockContent: c(t),
          phrasingContent: c(o),
          flowContent: c(r)
        });
      }, Ki = {
        html4: ha(() => Ul("html4")),
        html5: ha(() => Ul("html5")),
        "html5-strict": ha(() => Ul("html5-strict"))
      }, S2 = (e, t) => {
        const { blockContent: o, phrasingContent: r, flowContent: c } = Ki[e]();
        return t === "blocks" ? P.some(o) : t === "phrasing" ? P.some(r) : t === "flow" ? P.some(c) : P.none();
      }, na = (e) => {
        const t = Nr(e), { phrasingContent: o, flowContent: r } = b0(e), c = {}, u = (v, S, O) => {
          c[v] = {
            attributes: vu(S, ot({})),
            attributesOrder: S,
            children: vu(O, ot({}))
          };
        }, f = (v, S = "", O = "") => {
          const R = ir(O), M = ir(v);
          let H = M.length;
          const J = [...t, ...ir(S)];
          for (; H--; )
            u(M[H], J.slice(), R);
        }, b = (v, S) => {
          const O = ir(v), R = ir(S);
          let M = O.length;
          for (; M--; ) {
            const H = c[O[M]];
            for (let J = 0, W = R.length; J < W; J++)
              H.attributes[R[J]] = {}, H.attributesOrder.push(R[J]);
          }
        };
        return e !== "html5-strict" && (xe(ir("acronym applet basefont big font strike tt"), (O) => {
          f(O, "", o);
        }), xe(ir("center dir isindex noframes"), (O) => {
          f(O, "", r);
        })), f("html", "manifest", "head body"), f("head", "", "base command link meta noscript script style title"), f("title hr noscript br"), f("base", "href target"), f("link", "href rel media hreflang type sizes hreflang"), f("meta", "name http-equiv content charset property"), f("style", "media type scoped"), f("script", "src async defer type charset"), f("body", "onafterprint onbeforeprint onbeforeunload onblur onerror onfocus onhashchange onload onmessage onoffline ononline onpagehide onpageshow onpopstate onresize onscroll onstorage onunload", r), f("dd div", "", r), f("address dt caption", "", e === "html4" ? o : r), f("h1 h2 h3 h4 h5 h6 pre p abbr code var samp kbd sub sup i b u bdo span legend em strong small s cite dfn", "", o), f("blockquote", "cite", r), f("ol", "reversed start type", "li"), f("ul", "", "li"), f("li", "value", r), f("dl", "", "dt dd"), f("a", "href target rel media hreflang type", e === "html4" ? o : r), f("q", "cite", o), f("ins del", "cite datetime", r), f("img", "src sizes srcset alt usemap ismap width height"), f("iframe", "src name width height", r), f("embed", "src type width height"), f("object", "data type typemustmatch name usemap form width height", [r, "param"].join(" ")), f("param", "name value"), f("map", "name", [r, "area"].join(" ")), f("area", "alt coords shape href target rel media hreflang type"), f("table", "border", "caption colgroup thead tfoot tbody tr" + (e === "html4" ? " col" : "")), f("colgroup", "span", "col"), f("col", "span"), f("tbody thead tfoot", "", "tr"), f("tr", "", "td th"), f("td", "colspan rowspan headers", r), f("th", "colspan rowspan headers scope abbr", r), f("form", "accept-charset action autocomplete enctype method name novalidate target", r), f("fieldset", "disabled form name", [r, "legend"].join(" ")), f("label", "form for", o), f("input", "accept alt autocomplete checked dirname disabled form formaction formenctype formmethod formnovalidate formtarget height list max maxlength min multiple name pattern readonly required size src step type value width"), f("button", "disabled form formaction formenctype formmethod formnovalidate formtarget name type value", e === "html4" ? r : o), f("select", "disabled form multiple name required size", "option optgroup"), f("optgroup", "disabled label", "option"), f("option", "disabled label selected value"), f("textarea", "cols dirname disabled form maxlength name readonly required rows wrap"), f("menu", "type label", [r, "li"].join(" ")), f("noscript", "", r), e !== "html4" && (f("wbr"), f("ruby", "", [o, "rt rp"].join(" ")), f("figcaption", "", r), f("mark rt rp bdi", "", o), f("summary", "", [o, "h1 h2 h3 h4 h5 h6"].join(" ")), f("canvas", "width height", r), f("data", "value", o), f("video", "src crossorigin poster preload autoplay mediagroup loop controlslist disablepictureinpicture disableremoteplayback playsinline muted controls width height buffered", [r, "track source"].join(" ")), f("audio", "src crossorigin preload autoplay mediagroup loop muted controls buffered volume", [r, "track source"].join(" ")), f("picture", "", "img source"), f("source", "src srcset type media sizes"), f("track", "kind src srclang label default"), f("datalist", "", [o, "option"].join(" ")), f("article section nav aside main header footer", "", r), f("hgroup", "", "h1 h2 h3 h4 h5 h6"), f("figure", "", [r, "figcaption"].join(" ")), f("time", "datetime", o), f("dialog", "open", r), f("command", "type label icon disabled checked radiogroup command"), f("output", "for form name", o), f("progress", "value max", o), f("meter", "value min max low high optimum", o), f("details", "open", [r, "summary"].join(" ")), f("keygen", "autofocus challenge disabled form keytype name"), u("svg", "id tabindex lang xml:space class style x y width height viewBox preserveAspectRatio zoomAndPan transform".split(" "), [])), e !== "html5-strict" && (b("script", "language xml:space"), b("style", "xml:space"), b("object", "declare classid code codebase codetype archive standby align border hspace vspace"), b("embed", "align name hspace vspace"), b("param", "valuetype type"), b("a", "charset name rev shape coords"), b("br", "clear"), b("applet", "codebase archive code object alt name width height align hspace vspace"), b("img", "name longdesc align border hspace vspace"), b("iframe", "longdesc frameborder marginwidth marginheight scrolling align"), b("font basefont", "size color face"), b("input", "usemap align"), b("select"), b("textarea"), b("h1 h2 h3 h4 h5 h6 div p legend caption", "align"), b("ul", "type compact"), b("li", "type"), b("ol dl menu dir", "compact"), b("pre", "width xml:space"), b("hr", "align noshade size width"), b("isindex", "prompt"), b("table", "summary width frame rules cellspacing cellpadding align bgcolor"), b("col", "width align char charoff valign"), b("colgroup", "width align char charoff valign"), b("thead", "align char charoff valign"), b("tr", "align char charoff valign bgcolor"), b("th", "axis align char charoff valign nowrap bgcolor width height"), b("form", "accept"), b("td", "abbr axis scope align char charoff valign nowrap bgcolor width height"), b("tfoot", "align char charoff valign"), b("tbody", "align char charoff valign"), b("area", "nohref"), b("body", "background bgcolor text link vlink alink")), e !== "html4" && (b("input button select textarea", "autofocus"), b("input textarea", "placeholder"), b("a", "download"), b("link script img", "crossorigin"), b("img", "loading"), b("iframe", "sandbox seamless allow allowfullscreen loading referrerpolicy")), e !== "html4" && xe([c.video, c.audio], (v) => {
          delete v.children.audio, delete v.children.video;
        }), xe(ir("a form meter progress dfn"), (v) => {
          c[v] && delete c[v].children[v];
        }), delete c.caption.children.table, delete c.script, c;
      }, $h = (e) => e === "-" ? "remove" : "add", Nu = (e) => {
        const t = /^(@?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)$/;
        return P.from(t.exec(e)).map((o) => ({
          preset: o[1] === "@",
          name: o[2]
        }));
      }, yg = (e) => {
        const t = /^([+\-]?)([A-Za-z0-9_\-.\u00b7\u00c0-\u00d6\u00d8-\u00f6\u00f8-\u037d\u037f-\u1fff\u200c-\u200d\u203f-\u2040\u2070-\u218f\u2c00-\u2fef\u3001-\ud7ff\uf900-\ufdcf\ufdf0-\ufffd]+)\[([^\]]+)]$/;
        return xo(ir(e, ","), (o) => {
          const r = t.exec(o);
          if (r) {
            const c = r[1], u = c ? $h(c) : "replace", f = r[2], b = xo(ir(r[3], "|"), (v) => Nu(v).toArray());
            return [{ operation: u, name: f, validChildren: b }];
          } else
            return [];
        });
      }, Cg = (e, t) => {
        const o = /^([!\-])?(\w+[\\:]:\w+|[^=~<]+)?(?:([=~<])(.*))?$/, r = /[*?+]/, { attributes: c, attributesOrder: u } = t;
        return xe(ir(e, "|"), (f) => {
          const b = o.exec(f);
          if (b) {
            const v = {}, S = b[1], O = b[2].replace(/[\\:]:/g, ":"), R = b[3], M = b[4];
            if (S === "!" && (t.attributesRequired = t.attributesRequired || [], t.attributesRequired.push(O), v.required = !0), S === "-") {
              delete c[O], u.splice(Je.inArray(u, O), 1);
              return;
            }
            if (R && (R === "=" ? (t.attributesDefault = t.attributesDefault || [], t.attributesDefault.push({ name: O, value: M }), v.defaultValue = M) : R === "~" ? (t.attributesForced = t.attributesForced || [], t.attributesForced.push({ name: O, value: M }), v.forcedValue = M) : R === "<" && (v.validValues = Je.makeMap(M, "?"))), r.test(O)) {
              const H = v;
              t.attributePatterns = t.attributePatterns || [], H.pattern = gf(O), t.attributePatterns.push(H);
            } else
              c[O] || u.push(O), c[O] = v;
          }
        });
      }, j3 = (e, t) => {
        Un(e.attributes, (o, r) => {
          t.attributes[r] = o;
        }), t.attributesOrder.push(...e.attributesOrder);
      }, v0 = (e, t) => {
        const o = /^([#+\-])?([^\[!\/]+)(?:\/([^\[!]+))?(?:(!?)\[([^\]]+)])?$/;
        return xo(ir(t, ","), (r) => {
          const c = o.exec(r);
          if (c) {
            const u = c[1], f = c[2], b = c[3], v = c[4], S = c[5], O = {
              attributes: {},
              attributesOrder: []
            };
            if (e.each((R) => j3(R, O)), u === "#" ? O.paddEmpty = !0 : u === "-" && (O.removeEmpty = !0), v === "!" && (O.removeEmptyAttrs = !0), S && Cg(S, O), b && (O.outputName = f), f === "@")
              if (e.isNone())
                e = P.some(O);
              else
                return [];
            return [b ? { name: f, element: O, aliasName: b } : { name: f, element: O }];
          } else
            return [];
        });
      }, um = {}, y1 = Je.makeMap, ls = Je.each, qS = Je.extend, dm = Je.explode, Ih = (e, t = {}) => {
        const o = y1(e, " ", y1(e.toUpperCase(), " "));
        return qS(o, t);
      }, y0 = (e) => Ih("td th li dt dd figcaption caption details summary", e.getTextBlockElements()), mm = (e, t) => {
        if (e) {
          const o = {};
          return U(e) && (e = {
            "*": e
          }), ls(e, (r, c) => {
            o[c] = o[c.toUpperCase()] = t === "map" ? y1(r, /[, ]/) : dm(r, /[, ]/);
          }), o;
        } else
          return;
      }, wa = (e = {}) => {
        const t = {}, o = {};
        let r = [];
        const c = {}, u = {}, f = {}, b = (bn, ho, _r) => {
          const ks = e[bn];
          if (ks)
            return y1(ks, /[, ]/, y1(ks.toUpperCase(), /[, ]/));
          {
            let ts = um[bn];
            return ts || (ts = Ih(ho, _r), um[bn] = ts), ts;
          }
        }, v = e.schema ?? "html5", S = na(v);
        e.verify_html === !1 && (e.valid_elements = "*[*]");
        const O = mm(e.valid_styles), R = mm(e.invalid_styles, "map"), M = mm(e.valid_classes, "map"), H = b("whitespace_elements", "pre script noscript style textarea video audio iframe object code"), J = b("self_closing_elements", "colgroup dd dt li option p td tfoot th thead tr"), W = b("void_elements", "area base basefont br col frame hr img input isindex link meta param embed source wbr track"), Q = b("boolean_attributes", "checked compact declare defer disabled ismap multiple nohref noresize noshade nowrap readonly selected autoplay loop controls allowfullscreen"), ge = "td th iframe video audio object script code", be = b("non_empty_elements", ge + " pre svg textarea summary", W), ve = b("move_caret_before_on_enter_elements", ge + " table", W), Be = "h1 h2 h3 h4 h5 h6", je = b("text_block_elements", Be + " p div address pre form blockquote center dir fieldset header footer article section hgroup aside main nav figure"), xt = b("block_elements", "hr table tbody thead tfoot th tr td li ol ul caption dl dt dd noscript menu isindex option datalist select optgroup figcaption details summary html body multicol listing colgroup col", je), Kt = b("text_inline_elements", "span strong b em i font s strike u var cite dfn code mark q sup sub samp"), Me = b("transparent_elements", "a ins del canvas map"), Te = b("wrap_block_elements", "pre " + Be);
        ls("script noscript iframe noframes noembed title style textarea xmp plaintext".split(" "), (bn) => {
          u[bn] = new RegExp("</" + bn + "[^>]*>", "gi");
        });
        const $e = (bn) => {
          const ho = P.from(t["@"]), _r = /[*?+]/;
          xe(v0(ho, bn ?? ""), ({ name: ks, element: ts, aliasName: Cr }) => {
            if (Cr && (t[Cr] = ts), _r.test(ks)) {
              const Oi = ts;
              Oi.pattern = gf(ks), r.push(Oi);
            } else
              t[ks] = ts;
          });
        }, yt = (bn) => {
          r = [], xe(Vt(t), (ho) => {
            delete t[ho];
          }), $e(bn);
        }, Sn = (bn, ho) => {
          delete um.text_block_elements, delete um.block_elements;
          const _r = ho.extends ? !Qc(ho.extends) : !1, ks = ho.extends;
          if (o[bn] = ks ? o[ks] : {}, c[bn] = ks ?? bn, be[bn.toUpperCase()] = {}, be[bn] = {}, _r || (xt[bn.toUpperCase()] = {}, xt[bn] = {}), ks && !t[bn] && t[ks]) {
            const ts = Zc(t[ks]);
            delete ts.removeEmptyAttrs, delete ts.removeEmpty, t[bn] = ts;
          } else
            t[bn] = { attributesOrder: [], attributes: {} };
          if (Ot(ho.attributes)) {
            const ts = (Oi) => {
              Cr.attributesOrder.push(Oi), Cr.attributes[Oi] = {};
            }, Cr = t[bn] ?? {};
            delete Cr.attributesDefault, delete Cr.attributesForced, delete Cr.attributePatterns, delete Cr.attributesRequired, Cr.attributesOrder = [], Cr.attributes = {}, xe(ho.attributes, (Oi) => {
              const wl = Nr(v);
              Nu(Oi).each(({ preset: sd, name: uh }) => {
                sd ? uh === "global" && xe(wl, ts) : ts(uh);
              });
            }), t[bn] = Cr;
          }
          if (Yt(ho.padEmpty)) {
            const ts = t[bn] ?? {};
            ts.paddEmpty = ho.padEmpty, t[bn] = ts;
          }
          if (Ot(ho.children)) {
            const ts = {}, Cr = (wl) => {
              ts[wl] = {};
            }, Oi = (wl) => {
              S2(v, wl).each((sd) => {
                xe(sd, Cr);
              });
            };
            xe(ho.children, (wl) => {
              Nu(wl).each(({ preset: sd, name: uh }) => {
                sd ? Oi(uh) : Cr(uh);
              });
            }), o[bn] = ts;
          }
          ks && Un(o, (ts, Cr) => {
            ts[ks] && (o[Cr] = ts = qS({}, o[Cr]), ts[bn] = ts[ks]);
          });
        }, wn = (bn) => {
          xe(Bh(bn ?? ""), ({ name: ho, cloneName: _r }) => {
            Sn(ho, { extends: _r });
          });
        }, uo = (bn, ho) => {
          f[bn] = ho;
        }, Go = (bn) => {
          Ye(bn) ? Un(bn, (ho, _r) => {
            const ks = ho.componentUrl;
            U(ks) && uo(_r, ks), Sn(_r, ho);
          }) : U(bn) && wn(bn);
        }, ys = (bn) => {
          xe(yg(bn ?? ""), ({ operation: ho, name: _r, validChildren: ks }) => {
            const ts = ho === "replace" ? { "#comment": {} } : o[_r], Cr = (wl) => {
              ho === "remove" ? delete ts[wl] : ts[wl] = {};
            }, Oi = (wl) => {
              S2(v, wl).each((sd) => {
                xe(sd, Cr);
              });
            };
            xe(ks, ({ preset: wl, name: sd }) => {
              wl ? Oi(sd) : Cr(sd);
            }), o[_r] = ts;
          });
        }, Ps = (bn) => {
          const ho = t[bn];
          if (ho)
            return ho;
          let _r = r.length;
          for (; _r--; ) {
            const ks = r[_r];
            if (ks.pattern.test(bn))
              return ks;
          }
        }, Ra = () => {
          e.valid_elements ? (yt(e.valid_elements), ls(S, (bn, ho) => {
            o[ho] = bn.children;
          })) : (ls(S, (bn, ho) => {
            t[ho] = {
              attributes: bn.attributes,
              attributesOrder: bn.attributesOrder
            }, o[ho] = bn.children;
          }), ls(ir("strong/b em/i"), (bn) => {
            const ho = ir(bn, "/");
            t[ho[1]].outputName = ho[0];
          }), ls(Kt, (bn, ho) => {
            t[ho] && (e.padd_empty_block_inline_children && (t[ho].paddInEmptyBlock = !0), t[ho].removeEmpty = !0);
          }), ls(ir("ol ul blockquote a table tbody"), (bn) => {
            t[bn] && (t[bn].removeEmpty = !0);
          }), ls(ir("p h1 h2 h3 h4 h5 h6 th td pre div address caption li summary"), (bn) => {
            t[bn] && (t[bn].paddEmpty = !0);
          }), ls(ir("span"), (bn) => {
            t[bn].removeEmptyAttrs = !0;
          })), delete t.svg, Go(e.custom_elements), ys(e.valid_children), $e(e.extended_valid_elements), ys("+ol[ul|ol],+ul[ul|ol]"), ls({
            dd: "dl",
            dt: "dl",
            li: "ul ol",
            td: "tr",
            th: "tr",
            tr: "tbody thead tfoot",
            tbody: "table",
            thead: "table",
            tfoot: "table",
            legend: "fieldset",
            area: "map",
            param: "video audio object"
          }, (bn, ho) => {
            t[ho] && (t[ho].parentsRequired = ir(bn));
          }), e.invalid_elements && ls(dm(e.invalid_elements), (bn) => {
            t[bn] && delete t[bn];
          }), Ps("span") || $e("span[!data-mce-type|*]");
        }, Ai = ot(O), At = ot(R), sn = ot(M), Lo = ot(Q), Ao = ot(xt), Ga = ot(je), Le = ot(Kt), ut = ot(Object.seal(W)), $t = ot(J), to = ot(be), Zn = ot(ve), Qo = ot(H), _i = ot(Me), Kd = ot(Te), od = ot(Object.seal(u)), fu = (bn, ho) => {
          const _r = o[bn.toLowerCase()];
          return !!(_r && _r[ho.toLowerCase()]);
        }, $p = (bn, ho) => {
          const _r = Ps(bn);
          if (_r)
            if (ho) {
              if (_r.attributes[ho])
                return !0;
              const ks = _r.attributePatterns;
              if (ks) {
                let ts = ks.length;
                for (; ts--; )
                  if (ks[ts].pattern.test(ho))
                    return !0;
              }
            } else
              return !0;
          return !1;
        }, Qc = (bn) => kn(Ao(), bn), Xl = (bn) => !hn(bn, "#") && $p(bn) && !Qc(bn), ih = (bn) => kn(Kd(), bn) || Xl(bn), zy = ot(c), E3 = ot(f);
        return Ra(), {
          type: v,
          children: o,
          elements: t,
          getValidStyles: Ai,
          getValidClasses: sn,
          getBlockElements: Ao,
          getInvalidStyles: At,
          getVoidElements: ut,
          getTextBlockElements: Ga,
          getTextInlineElements: Le,
          getBoolAttrs: Lo,
          getElementRule: Ps,
          getSelfClosingElements: $t,
          getNonEmptyElements: to,
          getMoveCaretBeforeOnEnterElements: Zn,
          getWhitespaceElements: Qo,
          getTransparentElements: _i,
          getSpecialElements: od,
          getComponentUrls: E3,
          isValidChild: fu,
          isValid: $p,
          isBlock: Qc,
          isInline: Xl,
          isWrapper: ih,
          getCustomElements: zy,
          addValidElements: $e,
          setValidElements: yt,
          addCustomElements: Go,
          addValidChildren: ys
        };
      }, xg = (e) => ({
        value: Fh(e)
      }), Fh = (e) => Zm(e, "#").toUpperCase(), C0 = (e) => {
        const t = e.toString(16);
        return (t.length === 1 ? "0" + t : t).toUpperCase();
      }, x0 = (e) => {
        const t = C0(e.red) + C0(e.green) + C0(e.blue);
        return xg(t);
      }, S0 = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, C1 = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, KS = (e, t, o, r) => ({
        red: e,
        green: t,
        blue: o,
        alpha: r
      }), w2 = (e, t, o, r) => {
        const c = parseInt(e, 10), u = parseInt(t, 10), f = parseInt(o, 10), b = parseFloat(r);
        return KS(c, u, f, b);
      }, E2 = (e) => S0.test(e) ? "rgb" : C1.test(e) ? "rgba" : "other", Lh = (e) => {
        const t = S0.exec(e);
        if (t !== null)
          return P.some(w2(t[1], t[2], t[3], "1"));
        const o = C1.exec(e);
        return o !== null ? P.some(w2(o[1], o[2], o[3], o[4])) : P.none();
      }, Mu = (e) => `rgba(${e.red},${e.green},${e.blue},${e.alpha})`, Ci = (e) => Lh(e).map(x0).map((t) => "#" + t.value).getOr(e), fm = (e = {}, t) => {
        const o = /(?:url(?:(?:\(\s*\"([^\"]+)\"\s*\))|(?:\(\s*\'([^\']+)\'\s*\))|(?:\(\s*([^)\s]+)\s*\))))|(?:\'([^\']+)\')|(?:\"([^\"]+)\")/gi, r = /\s*([^:]+):\s*([^;]+);?/g, c = /\s+$/, u = {};
        let f, b;
        const v = Pc;
        t && (f = t.getValidStyles(), b = t.getInvalidStyles());
        const S = (`\\" \\' \\; \\: ; : ` + v).split(" ");
        for (let R = 0; R < S.length; R++)
          u[S[R]] = v + R, u[v + R] = S[R];
        const O = {
          /**
           * Parses the specified style value into an object collection. This parser will also
           * merge and remove any redundant items that browsers might have added. URLs inside
           * the styles will also be converted to absolute/relative based on the settings.
           *
           * @method parse
           * @param {String} css Style value to parse. For example: `border:1px solid red;`
           * @return {Object} Object representation of that style. For example: `{ border: '1px solid red' }`
           */
          parse: (R) => {
            const M = {};
            let H = !1;
            const J = e.url_converter, W = e.url_converter_scope || O, Q = (Me, Te, $e) => {
              const yt = M[Me + "-top" + Te];
              if (!yt)
                return;
              const Sn = M[Me + "-right" + Te];
              if (!Sn)
                return;
              const wn = M[Me + "-bottom" + Te];
              if (!wn)
                return;
              const uo = M[Me + "-left" + Te];
              if (!uo)
                return;
              const Go = [yt, Sn, wn, uo];
              let ys = Go.length - 1;
              for (; ys-- && Go[ys] === Go[ys + 1]; )
                ;
              ys > -1 && $e || (M[Me + Te] = ys === -1 ? Go[0] : Go.join(" "), delete M[Me + "-top" + Te], delete M[Me + "-right" + Te], delete M[Me + "-bottom" + Te], delete M[Me + "-left" + Te]);
            }, ge = (Me) => {
              const Te = M[Me];
              if (!Te)
                return;
              const $e = Te.indexOf(",") > -1 ? [Te] : Te.split(" ");
              let yt = $e.length;
              for (; yt--; )
                if ($e[yt] !== $e[0])
                  return !1;
              return M[Me] = $e[0], !0;
            }, be = (Me, Te, $e, yt) => {
              ge(Te) && ge($e) && ge(yt) && (M[Me] = M[Te] + " " + M[$e] + " " + M[yt], delete M[Te], delete M[$e], delete M[yt]);
            }, ve = (Me) => (H = !0, u[Me]), Be = (Me, Te) => (H && (Me = Me.replace(/\uFEFF[0-9]/g, ($e) => u[$e])), Te || (Me = Me.replace(/\\([\'\";:])/g, "$1")), Me), je = (Me) => String.fromCharCode(parseInt(Me.slice(1), 16)), xt = (Me) => Me.replace(/\\[0-9a-f]+/gi, je), Kt = (Me, Te, $e, yt, Sn, wn) => {
              if (Sn = Sn || wn, Sn)
                return Sn = Be(Sn), "'" + Sn.replace(/\'/g, "\\'") + "'";
              if (Te = Be(Te || $e || yt || ""), !e.allow_script_urls) {
                const uo = Te.replace(/[\s\r\n]+/g, "");
                if (/(java|vb)script:/i.test(uo) || !e.allow_svg_data_urls && /^data:image\/svg/i.test(uo))
                  return "";
              }
              return J && (Te = J.call(W, Te, "style")), "url('" + Te.replace(/\'/g, "\\'") + "')";
            };
            if (R) {
              R = R.replace(/[\u0000-\u001F]/g, ""), R = R.replace(/\\[\"\';:\uFEFF]/g, ve).replace(/\"[^\"]+\"|\'[^\']+\'/g, (Te) => Te.replace(/[;:]/g, ve));
              let Me;
              for (; Me = r.exec(R); ) {
                r.lastIndex = Me.index + Me[0].length;
                let Te = Me[1].replace(c, "").toLowerCase(), $e = Me[2].replace(c, "");
                if (Te && $e) {
                  if (Te = xt(Te), $e = xt($e), Te.indexOf(v) !== -1 || Te.indexOf('"') !== -1 || !e.allow_script_urls && (Te === "behavior" || /expression\s*\(|\/\*|\*\//.test($e)))
                    continue;
                  Te === "font-weight" && $e === "700" ? $e = "bold" : (Te === "color" || Te === "background-color") && ($e = $e.toLowerCase()), E2($e) === "rgb" && Lh($e).each((yt) => {
                    $e = Ci(Mu(yt)).toLowerCase();
                  }), $e = $e.replace(o, Kt), M[Te] = H ? Be($e, !0) : $e;
                }
              }
              Q("border", "", !0), Q("border", "-width"), Q("border", "-color"), Q("border", "-style"), Q("padding", ""), Q("margin", ""), be("border", "border-width", "border-style", "border-color"), M.border === "medium none" && delete M.border, M["border-image"] === "none" && delete M["border-image"];
            }
            return M;
          },
          /**
           * Serializes the specified style object into a string.
           *
           * @method serialize
           * @param {Object} styles Object to serialize as string. For example: `{ border: '1px solid red' }`
           * @param {String} elementName Optional element name, if specified only the styles that matches the schema will be serialized.
           * @return {String} String representation of the style object. For example: `border: 1px solid red`
           */
          serialize: (R, M) => {
            let H = "";
            const J = (Q, ge) => {
              const be = ge[Q];
              if (be)
                for (let ve = 0, Be = be.length; ve < Be; ve++) {
                  const je = be[ve], xt = R[je];
                  xt && (H += (H.length > 0 ? " " : "") + je + ": " + xt + ";");
                }
            }, W = (Q, ge) => {
              if (!b || !ge)
                return !0;
              let be = b["*"];
              return be && be[Q] ? !1 : (be = b[ge], !(be && be[Q]));
            };
            return M && f ? (J("*", f), J(M, f)) : Un(R, (Q, ge) => {
              Q && W(ge, M) && (H += (H.length > 0 ? " " : "") + ge + ": " + Q + ";");
            }), H;
          }
        };
        return O;
      }, YS = {
        keyLocation: !0,
        layerX: !0,
        layerY: !0,
        returnValue: !0,
        webkitMovementX: !0,
        webkitMovementY: !0,
        keyIdentifier: !0,
        mozPressure: !0
      }, w0 = (e) => e instanceof Event || se(e.initEvent), T2 = (e) => e.isDefaultPrevented === He || e.isDefaultPrevented === ye, XS = (e) => jt(e.preventDefault) || w0(e), k2 = (e, t) => {
        const o = t ?? {};
        for (const r in e)
          kn(YS, r) || (o[r] = e[r]);
        return X(e.composedPath) && (o.composedPath = () => e.composedPath()), X(e.getModifierState) && (o.getModifierState = (r) => e.getModifierState(r)), X(e.getTargetRanges) && (o.getTargetRanges = () => e.getTargetRanges()), o;
      }, E0 = (e, t, o, r) => {
        const c = k2(t, r);
        return c.type = e, jt(c.target) && (c.target = c.srcElement ?? o), XS(t) && (c.preventDefault = () => {
          c.defaultPrevented = !0, c.isDefaultPrevented = He, se(t.preventDefault) && t.preventDefault();
        }, c.stopPropagation = () => {
          c.cancelBubble = !0, c.isPropagationStopped = He, se(t.stopPropagation) && t.stopPropagation();
        }, c.stopImmediatePropagation = () => {
          c.isImmediatePropagationStopped = He, c.stopPropagation();
        }, T2(c) || (c.isDefaultPrevented = c.defaultPrevented === !0 ? He : ye, c.isPropagationStopped = c.cancelBubble === !0 ? He : ye, c.isImmediatePropagationStopped = ye)), c;
      }, T0 = "mce-data-", k0 = /^(?:mouse|contextmenu)|click/, Pu = (e, t, o, r) => {
        e.addEventListener(t, o, r || !1);
      }, x1 = (e, t, o, r) => {
        e.removeEventListener(t, o, r || !1);
      }, Hh = (e) => X(e) && k0.test(e.type), Sg = (e, t) => {
        const o = E0(e.type, e, document, t);
        if (Hh(e) && Gn(e.pageX) && !Gn(e.clientX)) {
          const r = o.target.ownerDocument || document, c = r.documentElement, u = r.body, f = o;
          f.pageX = e.clientX + (c && c.scrollLeft || u && u.scrollLeft || 0) - (c && c.clientLeft || u && u.clientLeft || 0), f.pageY = e.clientY + (c && c.scrollTop || u && u.scrollTop || 0) - (c && c.clientTop || u && u.clientTop || 0);
        }
        return o;
      }, QS = (e, t, o) => {
        const r = e.document, c = { type: "ready" };
        if (o.domLoaded) {
          t(c);
          return;
        }
        const u = () => r.readyState === "complete" || r.readyState === "interactive" && r.body, f = () => {
          x1(e, "DOMContentLoaded", f), x1(e, "load", f), o.domLoaded || (o.domLoaded = !0, t(c)), e = null;
        };
        u() ? f() : Pu(e, "DOMContentLoaded", f), o.domLoaded || Pu(e, "load", f);
      };
      class zh {
        static Event = new zh();
        // State if the DOMContentLoaded was executed or not
        domLoaded = !1;
        events = {};
        expando;
        hasFocusIn;
        count = 1;
        constructor() {
          this.expando = T0 + (+/* @__PURE__ */ new Date()).toString(32), this.hasFocusIn = "onfocusin" in document.documentElement, this.count = 1;
        }
        bind(t, o, r, c) {
          const u = this;
          let f;
          const b = window, v = (M) => {
            u.executeHandlers(Sg(M || b.event), S);
          };
          if (!t || tt(t) || zn(t))
            return r;
          let S;
          t[u.expando] ? S = t[u.expando] : (S = u.count++, t[u.expando] = S, u.events[S] = {}), c = c || t;
          const O = o.split(" ");
          let R = O.length;
          for (; R--; ) {
            let M = O[R], H = v, J = !1, W = !1;
            if (M === "DOMContentLoaded" && (M = "ready"), u.domLoaded && M === "ready" && t.readyState === "complete") {
              r.call(c, Sg({ type: M }));
              continue;
            }
            !u.hasFocusIn && (M === "focusin" || M === "focusout") && (J = !0, W = M === "focusin" ? "focus" : "blur", H = (Q) => {
              const ge = Sg(Q || b.event);
              ge.type = ge.type === "focus" ? "focusin" : "focusout", u.executeHandlers(ge, S);
            }), f = u.events[S][M], f ? M === "ready" && u.domLoaded ? r(Sg({ type: M })) : f.push({ func: r, scope: c }) : (u.events[S][M] = f = [{ func: r, scope: c }], f.fakeName = W, f.capture = J, f.nativeHandler = H, M === "ready" ? QS(t, H, u) : Pu(t, W || M, H, J));
          }
          return t = f = null, r;
        }
        unbind(t, o, r) {
          if (!t || tt(t) || zn(t))
            return this;
          const c = t[this.expando];
          if (c) {
            let u = this.events[c];
            if (o) {
              const f = o.split(" ");
              let b = f.length;
              for (; b--; ) {
                const v = f[b], S = u[v];
                if (S) {
                  if (r) {
                    let O = S.length;
                    for (; O--; )
                      if (S[O].func === r) {
                        const R = S.nativeHandler, M = S.fakeName, H = S.capture, J = S.slice(0, O).concat(S.slice(O + 1));
                        J.nativeHandler = R, J.fakeName = M, J.capture = H, u[v] = J;
                      }
                  }
                  (!r || S.length === 0) && (delete u[v], x1(t, S.fakeName || v, S.nativeHandler, S.capture));
                }
              }
            } else
              Un(u, (f, b) => {
                x1(t, f.fakeName || b, f.nativeHandler, f.capture);
              }), u = {};
            for (const f in u)
              if (kn(u, f))
                return this;
            delete this.events[c];
            try {
              delete t[this.expando];
            } catch {
              t[this.expando] = null;
            }
          }
          return this;
        }
        /**
         * Fires the specified event on the specified target.
         * <br>
         * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 7.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {Object} target Target node/window or custom object.
         * @param {String} name Event name to fire.
         * @param {Object} args Optional arguments to send to the observers.
         * @return {EventUtils} Event utils instance.
         * @deprecated Use dispatch() instead
         */
        fire(t, o, r) {
          return this.dispatch(t, o, r);
        }
        /**
         * Dispatches the specified event on the specified target.
         *
         * @method dispatch
         * @param {Node/window} target Target node/window or custom object.
         * @param {String} name Event name to dispatch.
         * @param {Object} args Optional arguments to send to the observers.
         * @return {EventUtils} Event utils instance.
         */
        dispatch(t, o, r) {
          if (!t || tt(t) || zn(t))
            return this;
          const c = Sg({ type: o, target: t }, r);
          do {
            const u = t[this.expando];
            u && this.executeHandlers(c, u), t = t.parentNode || t.ownerDocument || t.defaultView || t.parentWindow;
          } while (t && !c.isPropagationStopped());
          return this;
        }
        /**
         * Removes all bound event listeners for the specified target. This will also remove any bound
         * listeners to child nodes within that target.
         *
         * @method clean
         * @param {Object} target Target node/window object.
         * @return {EventUtils} Event utils instance.
         */
        clean(t) {
          if (!t || tt(t) || zn(t))
            return this;
          if (t[this.expando] && this.unbind(t), t.getElementsByTagName || (t = t.document), t && t.getElementsByTagName) {
            this.unbind(t);
            const o = t.getElementsByTagName("*");
            let r = o.length;
            for (; r--; )
              t = o[r], t[this.expando] && this.unbind(t);
          }
          return this;
        }
        /**
         * Destroys the event object. Call this to remove memory leaks.
         */
        destroy() {
          this.events = {};
        }
        // Legacy function for canceling events
        cancel(t) {
          return t && (t.preventDefault(), t.stopImmediatePropagation()), !1;
        }
        /**
         * Executes all event handler callbacks for a specific event.
         *
         * @private
         * @param {Event} evt Event object.
         * @param {String} id Expando id value to look for.
         */
        executeHandlers(t, o) {
          const r = this.events[o], c = r && r[t.type];
          if (c)
            for (let u = 0, f = c.length; u < f; u++) {
              const b = c[u];
              if (b && b.func.call(b.scope, t) === !1 && t.preventDefault(), t.isImmediatePropagationStopped())
                return;
            }
        }
      }
      const wc = Je.each, W3 = Je.grep, A2 = "data-mce-style", _2 = Je.makeMap("fill-opacity font-weight line-height opacity orphans widows z-index zoom", " "), A0 = (e, t, o) => {
        jt(o) || o === "" ? sr(e, t) : Ss(e, t, o);
      }, JS = (e) => e.replace(/[A-Z]/g, (t) => "-" + t.toLowerCase()), wg = (e, t) => {
        let o = 0;
        if (e)
          for (let r = e.nodeType, c = e.previousSibling; c; c = c.previousSibling) {
            const u = c.nodeType;
            t && tt(c) && (u === r || !c.data.length) || (o++, r = u);
          }
        return o;
      }, ew = (e, t) => {
        const o = gs(t, "style"), r = e.serialize(e.parse(o), Hn(t));
        A0(t, A2, r);
      }, S1 = (e, t) => ns(e) ? kn(_2, t) ? e + "" : e + "px" : e, O2 = (e, t, o) => {
        const r = JS(t);
        jt(o) || o === "" ? bh(e, r) : Ca(e, r, S1(o, r));
      }, tw = (e, t, o) => {
        const r = t.keep_values, c = {
          set: (f, b, v) => {
            const S = te.fromDom(f);
            se(t.url_converter) && X(b) && (b = t.url_converter.call(t.url_converter_scope || o(), String(b), v, f));
            const O = "data-mce-" + v;
            A0(S, O, b), A0(S, v, b);
          },
          get: (f, b) => {
            const v = te.fromDom(f);
            return gs(v, "data-mce-" + b) || gs(v, b);
          }
        }, u = {
          style: {
            set: (f, b) => {
              const v = te.fromDom(f);
              r && A0(v, A2, b), sr(v, "style"), U(b) && pc(v, e.parse(b));
            },
            get: (f) => {
              const b = te.fromDom(f), v = gs(b, A2) || gs(b, "style");
              return e.serialize(e.parse(v), Hn(b));
            }
          }
        };
        return r && (u.href = u.src = c), u;
      }, lo = (e, t = {}) => {
        const o = {}, r = window, c = {};
        let u = 0;
        const f = !0, b = !0, v = b2.forElement(te.fromDom(e), {
          contentCssCors: t.contentCssCors,
          referrerPolicy: t.referrerPolicy,
          crossOrigin: (Se) => {
            const ke = t.crossOrigin;
            if (se(ke))
              return ke(Se, "stylesheet");
          }
        }), S = [], O = t.schema ? t.schema : wa({}), R = fm({
          url_converter: t.url_converter,
          url_converter_scope: t.url_converter_scope
        }, t.schema), M = t.ownEvents ? new zh() : zh.Event, H = O.getBlockElements(), J = (Se) => U(Se) ? kn(H, Se) : ht(Se) && (kn(H, Se.nodeName) || qs(O, Se)), W = (Se) => Se && e && U(Se) ? e.getElementById(Se) : Se, Q = (Se) => {
          const ke = W(Se);
          return X(ke) ? te.fromDom(ke) : null;
        }, ge = (Se, ke, Dt = "") => {
          let dt;
          const Tn = Q(Se);
          if (X(Tn) && Is(Tn)) {
            const Ro = u7[ke];
            Ro && Ro.get ? dt = Ro.get(Tn.dom, ke) : dt = gs(Tn, ke);
          }
          return X(dt) ? dt : Dt;
        }, be = (Se) => {
          const ke = W(Se);
          return jt(ke) ? [] : ke.attributes;
        }, ve = (Se, ke, Dt) => {
          sn(Se, (dt) => {
            if (ht(dt)) {
              const Tn = te.fromDom(dt), Ro = Dt === "" ? null : Dt, Zr = gs(Tn, ke), dh = u7[ke];
              dh && dh.set ? dh.set(Tn.dom, Ro, ke) : A0(Tn, ke, Ro), Zr !== Ro && t.onSetAttrib && t.onSetAttrib({
                attrElm: Tn.dom,
                // We lie here to not break backwards compatibility
                attrName: ke,
                attrValue: Ro
              });
            }
          });
        }, Be = (Se, ke) => Se.cloneNode(ke), je = () => t.root_element || e.body, xt = (Se) => {
          const ke = ul(Se);
          return {
            x: ke.x,
            y: ke.y,
            w: ke.width,
            h: ke.height
          };
        }, Kt = (Se, ke) => Fo(e.body, W(Se), ke), Me = (Se, ke, Dt) => {
          sn(Se, (dt) => {
            const Tn = te.fromDom(dt);
            O2(Tn, ke, Dt), t.update_styles && ew(R, Tn);
          });
        }, Te = (Se, ke) => {
          sn(Se, (Dt) => {
            const dt = te.fromDom(Dt);
            Un(ke, (Tn, Ro) => {
              O2(dt, Ro, Tn);
            }), t.update_styles && ew(R, dt);
          });
        }, $e = (Se, ke, Dt) => {
          const dt = W(Se);
          if (!(jt(dt) || !zc(dt) && !P3(dt)))
            return Dt ? Ls(te.fromDom(dt), JS(ke)) : (ke = ke.replace(/-(\D)/g, (Tn, Ro) => Ro.toUpperCase()), ke === "float" && (ke = "cssFloat"), dt.style ? dt.style[ke] : void 0);
        }, yt = (Se) => {
          const ke = W(Se);
          if (!ke)
            return { w: 0, h: 0 };
          let Dt = $e(ke, "width"), dt = $e(ke, "height");
          return (!Dt || Dt.indexOf("px") === -1) && (Dt = "0"), (!dt || dt.indexOf("px") === -1) && (dt = "0"), {
            w: parseInt(Dt, 10) || ke.offsetWidth || ke.clientWidth,
            h: parseInt(dt, 10) || ke.offsetHeight || ke.clientHeight
          };
        }, Sn = (Se) => {
          const ke = W(Se), Dt = Kt(ke), dt = yt(ke);
          return {
            x: Dt.x,
            y: Dt.y,
            w: dt.w,
            h: dt.h
          };
        }, wn = (Se, ke) => {
          if (!Se)
            return !1;
          const Dt = Ot(Se) ? Se : [Se];
          return po(Dt, (dt) => Ic(te.fromDom(dt), ke));
        }, uo = (Se, ke, Dt, dt) => {
          const Tn = [];
          let Ro = W(Se);
          dt = dt === void 0;
          const Zr = Dt || (je().nodeName !== "BODY" ? je().parentNode : null);
          if (U(ke))
            if (ke === "*")
              ke = ht;
            else {
              const dh = ke;
              ke = (Qf) => wn(Qf, dh);
            }
          for (; Ro && !(Ro === Zr || jt(Ro.nodeType) || lm(Ro) || Ah(Ro)); ) {
            if (!ke || ke(Ro))
              if (dt)
                Tn.push(Ro);
              else
                return [Ro];
            Ro = Ro.parentNode;
          }
          return dt ? Tn : null;
        }, Go = (Se, ke, Dt) => {
          const dt = uo(Se, ke, Dt, !1);
          return dt && dt.length > 0 ? dt[0] : null;
        }, ys = (Se, ke, Dt) => {
          let dt = ke;
          if (Se) {
            U(ke) && (dt = (Tn) => wn(Tn, ke));
            for (let Tn = Se[Dt]; Tn; Tn = Tn[Dt])
              if (se(dt) && dt(Tn))
                return Tn;
          }
          return null;
        }, Ps = (Se, ke) => ys(Se, ke, "nextSibling"), Ra = (Se, ke) => ys(Se, ke, "previousSibling"), Ai = (Se) => se(Se.querySelectorAll), At = (Se, ke) => {
          const Dt = W(ke) ?? t.root_element ?? e;
          return Ai(Dt) ? rs(Dt.querySelectorAll(Se)) : [];
        }, sn = function(Se, ke, Dt) {
          const dt = Dt ?? this;
          if (Ot(Se)) {
            const Tn = [];
            return wc(Se, (Ro, Zr) => {
              const dh = W(Ro);
              dh && Tn.push(ke.call(dt, dh, Zr));
            }), Tn;
          } else {
            const Tn = W(Se);
            return Tn ? ke.call(dt, Tn) : !1;
          }
        }, Lo = (Se, ke) => {
          sn(Se, (Dt) => {
            Un(ke, (dt, Tn) => {
              ve(Dt, Tn, dt);
            });
          });
        }, Ao = (Se, ke) => {
          sn(Se, (Dt) => {
            const dt = te.fromDom(Dt);
            Au(dt, ke);
          });
        }, Ga = (Se, ke, Dt, dt, Tn) => sn(Se, (Ro) => {
          const Zr = U(ke) ? e.createElement(ke) : ke;
          return X(Dt) && Lo(Zr, Dt), dt && (!U(dt) && dt.nodeType ? Zr.appendChild(dt) : U(dt) && Ao(Zr, dt)), Tn ? Zr : Ro.appendChild(Zr);
        }), Le = (Se, ke, Dt) => Ga(e.createElement(Se), Se, ke, Dt, !0), ut = gl.decode, $t = gl.encodeAllRaw, to = (Se, ke, Dt = "") => {
          let dt = "<" + Se;
          for (const Tn in ke)
            Zo(ke, Tn) && (dt += " " + Tn + '="' + $t(ke[Tn]) + '"');
          return ti(Dt) && kn(O.getVoidElements(), Se) ? dt + " />" : dt + ">" + Dt + "</" + Se + ">";
        }, Zn = (Se) => {
          const ke = e.createElement("div"), Dt = e.createDocumentFragment();
          Dt.appendChild(ke), Se && (ke.innerHTML = Se);
          let dt;
          for (; dt = ke.firstChild; )
            Dt.appendChild(dt);
          return Dt.removeChild(ke), Dt;
        }, Qo = (Se, ke) => sn(Se, (Dt) => {
          const dt = te.fromDom(Dt);
          return ke && xe(Os(dt), (Tn) => {
            Eo(Tn) && Tn.dom.length === 0 ? qo(Tn) : ca(dt, Tn);
          }), qo(dt), dt.dom;
        }), _i = (Se) => sn(Se, (ke) => {
          const Dt = ke.attributes;
          for (let dt = Dt.length - 1; dt >= 0; dt--)
            ke.removeAttributeNode(Dt.item(dt));
        }), Kd = (Se) => R.parse(Se), od = (Se, ke) => R.serialize(Se, ke), fu = (Se) => {
          if (Uy !== lo.DOM && e === document) {
            if (o[Se])
              return;
            o[Se] = !0;
          }
          let ke = e.getElementById("mceDefaultStyles");
          if (!ke) {
            ke = e.createElement("style"), ke.id = "mceDefaultStyles", ke.type = "text/css";
            const Dt = e.head;
            Dt.firstChild ? Dt.insertBefore(ke, Dt.firstChild) : Dt.appendChild(ke);
          }
          ke.styleSheet ? ke.styleSheet.cssText += Se : ke.appendChild(e.createTextNode(Se));
        }, $p = (Se) => {
          Se || (Se = ""), xe(Se.split(","), (ke) => {
            c[ke] = !0, v.load(ke).catch(St);
          });
        }, Qc = (Se, ke, Dt) => {
          sn(Se, (dt) => {
            if (ht(dt)) {
              const Tn = te.fromDom(dt), Ro = ke.split(" ");
              xe(Ro, (Zr) => {
                X(Dt) ? (Dt ? bc : cr)(Tn, Zr) : Lr(Tn, Zr);
              });
            }
          });
        }, Xl = (Se, ke) => {
          Qc(Se, ke, !0);
        }, ih = (Se, ke) => {
          Qc(Se, ke, !1);
        }, zy = (Se, ke) => {
          const Dt = Q(Se), dt = ke.split(" ");
          return X(Dt) && qa(dt, (Tn) => yh(Dt, Tn));
        }, E3 = (Se) => {
          sn(Se, (ke) => bh(te.fromDom(ke), "display"));
        }, bn = (Se) => {
          sn(Se, (ke) => Ca(te.fromDom(ke), "display", "none"));
        }, ho = (Se) => {
          const ke = Q(Se);
          return X(ke) && Ho(rr(ke, "display"), "none");
        }, _r = (Se) => (Se || "mce_") + u++, ks = (Se) => {
          const ke = Q(Se);
          return X(ke) ? ht(ke.dom) ? ke.dom.outerHTML : Jy(ke) : "";
        }, ts = (Se, ke) => {
          sn(Se, (Dt) => {
            ht(Dt) && (Dt.outerHTML = ke);
          });
        }, Cr = (Se, ke) => {
          const Dt = W(ke);
          return sn(Se, (dt) => {
            const Tn = Dt?.parentNode, Ro = Dt?.nextSibling;
            return Tn && (Ro ? Tn.insertBefore(dt, Ro) : Tn.appendChild(dt)), dt;
          });
        }, Oi = (Se, ke, Dt) => sn(ke, (dt) => {
          const Tn = Ot(ke) ? Se.cloneNode(!0) : Se;
          return Dt && wc(W3(dt.childNodes), (Ro) => {
            Tn.appendChild(Ro);
          }), dt.parentNode?.replaceChild(Tn, dt), dt;
        }), wl = (Se, ke) => {
          if (Se.nodeName !== ke.toUpperCase()) {
            const Dt = Le(ke);
            return wc(be(Se), (dt) => {
              ve(Dt, dt.nodeName, ge(Se, dt.nodeName));
            }), Oi(Dt, Se, !0), Dt;
          } else
            return Se;
        }, sd = (Se, ke) => {
          let Dt = Se;
          for (; Dt; ) {
            let dt = ke;
            for (; dt && Dt !== dt; )
              dt = dt.parentNode;
            if (Dt === dt)
              break;
            Dt = Dt.parentNode;
          }
          return !Dt && Se.ownerDocument ? Se.ownerDocument.documentElement : Dt;
        }, uh = (Se, ke, Dt) => On(ke) ? on(O, Se, { ...Dt, isContent: (Tn) => {
          const Ro = Tn.nodeName.toLowerCase();
          return !!ke[Ro];
        } }) : on(O, Se, Dt), T3 = () => e.createRange(), k3 = (Se, ke, Dt) => {
          let dt = T3(), Tn, Ro;
          if (Se && ke && Se.parentNode && ke.parentNode) {
            const Zr = Se.parentNode;
            return dt.setStart(Zr, wg(Se)), dt.setEnd(ke.parentNode, wg(ke)), Tn = dt.extractContents(), dt = T3(), dt.setStart(ke.parentNode, wg(ke) + 1), dt.setEnd(Zr, wg(Se) + 1), Ro = dt.extractContents(), Zr.insertBefore(p1(Uy, Tn, O), Se), Dt ? Zr.insertBefore(Dt, Se) : Zr.insertBefore(ke, Se), Zr.insertBefore(p1(Uy, Ro, O), Se), Qo(Se), Dt || ke;
          } else
            return;
        }, RS = (Se, ke, Dt, dt) => {
          if (Ot(Se)) {
            let Tn = Se.length;
            const Ro = [];
            for (; Tn--; )
              Ro[Tn] = RS(Se[Tn], ke, Dt, dt);
            return Ro;
          } else
            return t.collect && (Se === e || Se === r) && S.push([Se, ke, Dt, dt]), M.bind(Se, ke, Dt, dt || Uy);
        }, Xf = (Se, ke, Dt) => {
          if (Ot(Se)) {
            let dt = Se.length;
            const Tn = [];
            for (; dt--; )
              Tn[dt] = Xf(Se[dt], ke, Dt);
            return Tn;
          } else {
            if (S.length > 0 && (Se === e || Se === r)) {
              let dt = S.length;
              for (; dt--; ) {
                const [Tn, Ro, Zr] = S[dt];
                Se === Tn && (!ke || ke === Ro) && (!Dt || Dt === Zr) && M.unbind(Tn, Ro, Zr);
              }
            }
            return M.unbind(Se, ke, Dt);
          }
        }, Vy = (Se, ke, Dt) => M.dispatch(Se, ke, Dt), VN = (Se, ke, Dt) => M.dispatch(Se, ke, Dt), A3 = (Se) => {
          if (Se && zc(Se)) {
            const ke = Se.getAttribute("data-mce-contenteditable");
            return ke && ke !== "inherit" ? ke : Se.contentEditable !== "inherit" ? Se.contentEditable : null;
          } else
            return null;
        }, Uy = {
          doc: e,
          settings: t,
          win: r,
          files: c,
          stdMode: f,
          boxModel: b,
          styleSheetLoader: v,
          boundEvents: S,
          styles: R,
          schema: O,
          events: M,
          isBlock: J,
          root: null,
          clone: Be,
          /**
           * Returns the root node of the document. This is normally the body but might be a DIV. Parents like getParent will not
           * go above the point of this root node.
           *
           * @method getRoot
           * @return {Element} Root element for the utility class.
           */
          getRoot: je,
          /**
           * Returns the viewport of the window.
           *
           * @method getViewPort
           * @param {Window} win Optional window to get viewport of.
           * @return {Object} Viewport object with fields x, y, w and h.
           */
          getViewPort: xt,
          /**
           * Returns the rectangle for a specific element.
           *
           * @method getRect
           * @param {Element/String} elm Element object or element ID to get rectangle from.
           * @return {Object} Rectangle for specified element object with x, y, w, h fields.
           */
          getRect: Sn,
          /**
           * Returns the size dimensions of the specified element.
           *
           * @method getSize
           * @param {Element/String} elm Element object or element ID to get rectangle from.
           * @return {Object} Rectangle for specified element object with w, h fields.
           */
          getSize: yt,
          /**
           * Returns a node by the specified selector function. This function will
           * loop through all parent nodes and call the specified function for each node.
           * If the function then returns true indicating that it has found what it was looking for, the loop execution will then end
           * and the node it found will be returned.
           *
           * @method getParent
           * @param {Node/String} node DOM node to search parents on or ID string.
           * @param {Function} selector Selection function or CSS selector to execute on each node.
           * @param {Node} root Optional root element, never go beyond this point.
           * @return {Node} DOM Node or null if it wasn't found.
           */
          getParent: Go,
          /**
           * Returns a node list of all parents matching the specified selector function or pattern.
           * If the function then returns true indicating that it has found what it was looking for and that node will be collected.
           *
           * @method getParents
           * @param {Node/String} node DOM node to search parents on or ID string.
           * @param {Function} selector Selection function to execute on each node or CSS pattern.
           * @param {Node} root Optional root element, never go beyond this point.
           * @return {Array} Array of nodes or null if it wasn't found.
           */
          getParents: uo,
          /**
           * Returns the specified element by ID or the input element if it isn't a string.
           *
           * @method get
           * @param {String/Element} n Element id to look for or element to just pass though.
           * @return {Element} Element matching the specified id or null if it wasn't found.
           */
          get: W,
          /**
           * Returns the next node that matches selector or function
           *
           * @method getNext
           * @param {Node} node Node to find siblings from.
           * @param {String/function} selector Selector CSS expression or function.
           * @return {Node} Next node item matching the selector or null if it wasn't found.
           */
          getNext: Ps,
          /**
           * Returns the previous node that matches selector or function
           *
           * @method getPrev
           * @param {Node} node Node to find siblings from.
           * @param {String/function} selector Selector CSS expression or function.
           * @return {Node} Previous node item matching the selector or null if it wasn't found.
           */
          getPrev: Ra,
          // #ifndef jquery
          /**
           * Returns a list of the elements specified by the given CSS selector. For example: `div#a1 p.test`
           *
           * @method select
           * @param {String} selector Target CSS selector.
           * @param {Object} scope Optional root element/scope element to search in.
           * @return {Array} Array with all matched elements.
           * @example
           * // Adds a class to all paragraphs in the currently active editor
           * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'someclass');
           *
           * // Adds a class to all spans that have the test class in the currently active editor
           * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('span.test'), 'someclass')
           */
          select: At,
          /**
           * Returns true/false if the specified element matches the specified css pattern.
           *
           * @method is
           * @param {Node/NodeList} elm DOM node to match or an array of nodes to match.
           * @param {String} selector CSS pattern to match the element against.
           */
          is: wn,
          // #endif
          /**
           * Adds the specified element to another element or elements.
           *
           * @method add
           * @param {String/Element/Array} parentElm Element id string, DOM node element or array of ids or elements to add to.
           * @param {String/Element} name Name of new element to add or existing element to add.
           * @param {Object} attrs Optional object collection with arguments to add to the new element(s).
           * @param {String} html Optional inner HTML contents to add for each element.
           * @param {Boolean} create Optional flag if the element should be created or added.
           * @return {Element/Array} Element that got created, or an array of created elements if multiple input elements
           * were passed in.
           * @example
           * // Adds a new paragraph to the end of the active editor
           * tinymce.activeEditor.dom.add(tinymce.activeEditor.getBody(), 'p', { title: 'my title' }, 'Some content');
           */
          add: Ga,
          /**
           * Creates a new element.
           *
           * @method create
           * @param {String} name Name of new element.
           * @param {Object} attrs Optional object name/value collection with element attributes.
           * @param {String} html Optional HTML string to set as inner HTML of the element.
           * @return {Element} HTML DOM node element that got created.
           * @example
           * // Adds an element where the caret/selection is in the active editor
           * var el = tinymce.activeEditor.dom.create('div', { id: 'test', 'class': 'myclass' }, 'some content');
           * tinymce.activeEditor.selection.setNode(el);
           */
          create: Le,
          /**
           * Creates HTML string for element. The element will be closed unless an empty inner HTML string is passed in.
           *
           * @method createHTML
           * @param {String} name Name of new element.
           * @param {Object} attrs Optional object name/value collection with element attributes.
           * @param {String} html Optional HTML string to set as inner HTML of the element.
           * @return {String} String with new HTML element, for example: <a href="#">test</a>.
           * @example
           * // Creates a html chunk and inserts it at the current selection/caret location
           * tinymce.activeEditor.insertContent(tinymce.activeEditor.dom.createHTML('a', { href: 'test.html' }, 'some line'));
           */
          createHTML: to,
          /**
           * Creates a document fragment out of the specified HTML string.
           *
           * @method createFragment
           * @param {String} html Html string to create fragment from.
           * @return {DocumentFragment} Document fragment node.
           */
          createFragment: Zn,
          /**
           * Removes/deletes the specified element(s) from the DOM.
           *
           * @method remove
           * @param {String/Element/Array} node ID of element or DOM element object or array containing multiple elements/ids.
           * @param {Boolean} keepChildren Optional state to keep children or not. If set to true all children will be
           * placed at the location of the removed element.
           * @return {Element/Array} HTML DOM element that got removed, or an array of removed elements if multiple input elements
           * were passed in.
           * @example
           * // Removes all paragraphs in the active editor
           * tinymce.activeEditor.dom.remove(tinymce.activeEditor.dom.select('p'));
           *
           * // Removes an element by id in the document
           * tinymce.DOM.remove('mydiv');
           */
          remove: Qo,
          /**
           * Sets the CSS style value on a HTML element. The name can be a camelcase string
           * or the CSS style name like background-color.
           *
           * @method setStyle
           * @param {String/Element/Array} elm HTML element/Array of elements to set CSS style value on.
           * @param {String} name Name of the style value to set.
           * @param {String} value Value to set on the style.
           * @example
           * // Sets a style value on all paragraphs in the currently active editor
           * tinymce.activeEditor.dom.setStyle(tinymce.activeEditor.dom.select('p'), 'background-color', 'red');
           *
           * // Sets a style value to an element by id in the current document
           * tinymce.DOM.setStyle('mydiv', 'background-color', 'red');
           */
          setStyle: Me,
          /**
           * Returns the current style or runtime/computed value of an element.
           *
           * @method getStyle
           * @param {String/Element} elm HTML element or element id string to get style from.
           * @param {String} name Style name to return.
           * @param {Boolean} computed Computed style.
           * @return {String} Current style or computed style value of an element.
           */
          getStyle: $e,
          /**
           * Sets multiple styles on the specified element(s).
           *
           * @method setStyles
           * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set styles on.
           * @param {Object} styles Name/Value collection of style items to add to the element(s).
           * @example
           * // Sets styles on all paragraphs in the currently active editor
           * tinymce.activeEditor.dom.setStyles(tinymce.activeEditor.dom.select('p'), { 'background-color': 'red', 'color': 'green' });
           *
           * // Sets styles to an element by id in the current document
           * tinymce.DOM.setStyles('mydiv', { 'background-color': 'red', 'color': 'green' });
           */
          setStyles: Te,
          /**
           * Removes all attributes from an element or elements.
           *
           * @method removeAllAttribs
           * @param {Element/String/Array} e DOM element, element id string or array of elements/ids to remove attributes from.
           */
          removeAllAttribs: _i,
          /**
           * Sets the specified attribute of an element or elements.
           *
           * @method setAttrib
           * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attribute on.
           * @param {String} name Name of attribute to set.
           * @param {String} value Value to set on the attribute - if this value is falsy like null, 0 or '' it will remove
           * the attribute instead.
           * @example
           * // Sets class attribute on all paragraphs in the active editor
           * tinymce.activeEditor.dom.setAttrib(tinymce.activeEditor.dom.select('p'), 'class', 'myclass');
           *
           * // Sets class attribute on a specific element in the current page
           * tinymce.dom.setAttrib('mydiv', 'class', 'myclass');
           */
          setAttrib: ve,
          /**
           * Sets two or more specified attributes of an element or elements.
           *
           * @method setAttribs
           * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set attributes on.
           * @param {Object} attrs Name/Value collection of attribute items to add to the element(s).
           * @example
           * // Sets class and title attributes on all paragraphs in the active editor
           * tinymce.activeEditor.dom.setAttribs(tinymce.activeEditor.dom.select('p'), { 'class': 'myclass', title: 'some title' });
           *
           * // Sets class and title attributes on a specific element in the current page
           * tinymce.DOM.setAttribs('mydiv', { 'class': 'myclass', title: 'some title' });
           */
          setAttribs: Lo,
          /**
           * Returns the specified attribute by name.
           *
           * @method getAttrib
           * @param {String/Element} elm Element string id or DOM element to get attribute from.
           * @param {String} name Name of attribute to get.
           * @param {String} defaultVal Optional default value to return if the attribute didn't exist.
           * @return {String} Attribute value string, default value or null if the attribute wasn't found.
           */
          getAttrib: ge,
          /**
           * Returns the absolute x, y position of a node. The position will be returned in an object with x, y fields.
           *
           * @method getPos
           * @param {Element/String} elm HTML element or element id to get x, y position from.
           * @param {Element} rootElm Optional root element to stop calculations at.
           * @return {Object} Absolute position of the specified element object with x, y fields.
           */
          getPos: Kt,
          /**
           * Parses the specified style value into an object collection. This parser will also
           * merge and remove any redundant items that browsers might have added. It will also convert non-hex
           * colors to hex values. Urls inside the styles will also be converted to absolute/relative based on settings.
           *
           * @method parseStyle
           * @param {String} cssText Style value to parse, for example: border:1px solid red;.
           * @return {Object} Object representation of that style, for example: {border: '1px solid red'}
           */
          parseStyle: Kd,
          /**
           * Serializes the specified style object into a string.
           *
           * @method serializeStyle
           * @param {Object} styles Object to serialize as string, for example: {border: '1px solid red'}
           * @param {String} name Optional element name.
           * @return {String} String representation of the style object, for example: border: 1px solid red.
           */
          serializeStyle: od,
          /**
           * Adds a style element at the top of the document with the specified cssText content.
           *
           * @method addStyle
           * @param {String} cssText CSS Text style to add to top of head of document.
           */
          addStyle: fu,
          /**
           * Imports/loads the specified CSS file into the document bound to the class.
           *
           * @method loadCSS
           * @param {String} url URL to CSS file to load.
           * @example
           * // Loads a CSS file dynamically into the current document
           * tinymce.DOM.loadCSS('somepath/some.css');
           *
           * // Loads a CSS file into the currently active editor instance
           * tinymce.activeEditor.dom.loadCSS('somepath/some.css');
           *
           * // Loads a CSS file into an editor instance by id
           * tinymce.get('someid').dom.loadCSS('somepath/some.css');
           *
           * // Loads multiple CSS files into the current document
           * tinymce.DOM.loadCSS('somepath/some.css,somepath/someother.css');
           */
          loadCSS: $p,
          /**
           * Adds a class to the specified element or elements.
           *
           * @method addClass
           * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
           * @param {String} cls Class name to add to each element.
           * @return {String/Array} String with new class value or array with new class values for all elements.
           * @example
           * // Adds a class to all paragraphs in the active editor
           * tinymce.activeEditor.dom.addClass(tinymce.activeEditor.dom.select('p'), 'myclass');
           *
           * // Adds a class to a specific element in the current page
           * tinymce.DOM.addClass('mydiv', 'myclass');
           */
          addClass: Xl,
          /**
           * Removes a class from the specified element or elements.
           *
           * @method removeClass
           * @param {String/Element/Array} elm Element ID string or DOM element or array with elements or IDs.
           * @param {String} cls Class name to remove from each element.
           * @return {String/Array} String of remaining class name(s), or an array of strings if multiple input elements
           * were passed in.
           * @example
           * // Removes a class from all paragraphs in the active editor
           * tinymce.activeEditor.dom.removeClass(tinymce.activeEditor.dom.select('p'), 'myclass');
           *
           * // Removes a class from a specific element in the current page
           * tinymce.DOM.removeClass('mydiv', 'myclass');
           */
          removeClass: ih,
          /**
           * Returns true if the specified element has the specified class.
           *
           * @method hasClass
           * @param {String/Element} elm HTML element or element id string to check CSS class on.
           * @param {String} cls CSS class to check for.
           * @return {Boolean} true/false if the specified element has the specified class.
           */
          hasClass: zy,
          /**
           * Toggles the specified class on/off.
           *
           * @method toggleClass
           * @param {Element} elm Element to toggle class on.
           * @param {String} cls Class to toggle on/off.
           * @param {Boolean} state Optional state to set.
           */
          toggleClass: Qc,
          /**
           * Shows the specified element(s) by ID by setting the "display" style.
           *
           * @method show
           * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to show.
           */
          show: E3,
          /**
           * Hides the specified element(s) by ID by setting the "display" style.
           *
           * @method hide
           * @param {String/Element/Array} elm ID of DOM element or DOM element or array with elements or IDs to hide.
           * @example
           * // Hides an element by id in the document
           * tinymce.DOM.hide('myid');
           */
          hide: bn,
          /**
           * Returns true/false if the element is hidden or not by checking the "display" style.
           *
           * @method isHidden
           * @param {String/Element} elm Id or element to check display state on.
           * @return {Boolean} true/false if the element is hidden or not.
           */
          isHidden: ho,
          /**
           * Returns a unique id. This can be useful when generating elements on the fly.
           * This method will not check if the element already exists.
           *
           * @method uniqueId
           * @param {String} prefix Optional prefix to add in front of all ids - defaults to "mce_".
           * @return {String} Unique id.
           */
          uniqueId: _r,
          /**
           * Sets the specified HTML content inside the element or elements. The HTML will first be processed. This means
           * URLs will get converted, hex color values fixed etc. Check processHTML for details.
           *
           * @method setHTML
           * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set HTML inside of.
           * @param {String} html HTML content to set as inner HTML of the element.
           * @example
           * // Sets the inner HTML of all paragraphs in the active editor
           * tinymce.activeEditor.dom.setHTML(tinymce.activeEditor.dom.select('p'), 'some inner html');
           *
           * // Sets the inner HTML of an element by id in the document
           * tinymce.DOM.setHTML('mydiv', 'some inner html');
           */
          setHTML: Ao,
          /**
           * Returns the outer HTML of an element.
           *
           * @method getOuterHTML
           * @param {String/Element} elm Element ID or element object to get outer HTML from.
           * @return {String} Outer HTML string.
           * @example
           * tinymce.DOM.getOuterHTML(editorElement);
           * tinymce.activeEditor.getOuterHTML(tinymce.activeEditor.getBody());
           */
          getOuterHTML: ks,
          /**
           * Sets the specified outer HTML on an element or elements.
           *
           * @method setOuterHTML
           * @param {Element/String/Array} elm DOM element, element id string or array of elements/ids to set outer HTML on.
           * @param {Object} html HTML code to set as outer value for the element.
           * @example
           * // Sets the outer HTML of all paragraphs in the active editor
           * tinymce.activeEditor.dom.setOuterHTML(tinymce.activeEditor.dom.select('p'), '<div>some html</div>');
           *
           * // Sets the outer HTML of an element by id in the document
           * tinymce.DOM.setOuterHTML('mydiv', '<div>some html</div>');
           */
          setOuterHTML: ts,
          /**
           * Entity decodes a string. This method decodes any HTML entities, such as `&amp;aring;`.
           *
           * @method decode
           * @param {String} s String to decode entities on.
           * @return {String} Entity decoded string.
           */
          decode: ut,
          /**
           * Entity encodes a string. This method encodes the most common entities, such as `<`, `>`, `"` and `&`.
           *
           * @method encode
           * @param {String} text String to encode with entities.
           * @return {String} Entity encoded string.
           */
          encode: $t,
          /**
           * Inserts an element after the reference element.
           *
           * @method insertAfter
           * @param {Element} node Element to insert after the reference.
           * @param {Element/String/Array} referenceNode Reference element, element id or array of elements to insert after.
           * @return {Element/Array} Element that got added or an array with elements.
           */
          insertAfter: Cr,
          /**
           * Replaces the specified element or elements with the new element specified. The new element will
           * be cloned if multiple input elements are passed in.
           *
           * @method replace
           * @param {Element} newElm New element to replace old ones with.
           * @param {Element/String/Array} oldElm Element DOM node, element id or array of elements or ids to replace.
           * @param {Boolean} keepChildren Optional keep children state, if set to true child nodes from the old object will be added
           * to new ones.
           */
          replace: Oi,
          /**
           * Renames the specified element and keeps its attributes and children.
           *
           * @method rename
           * @param {Element} elm Element to rename.
           * @param {String} name Name of the new element.
           * @return {Element} New element or the old element if it needed renaming.
           */
          rename: wl,
          /**
           * Find the common ancestor of two elements. This is a shorter method than using the DOM Range logic.
           *
           * @method findCommonAncestor
           * @param {Element} a Element to find common ancestor of.
           * @param {Element} b Element to find common ancestor of.
           * @return {Element} Common ancestor element of the two input elements.
           */
          findCommonAncestor: sd,
          /**
           * Executes the specified function on the element by id or dom element node or array of elements/id.
           *
           * @method run
           * @param {String/Element/Array} elm ID or DOM element object or array with ids or elements.
           * @param {Function} func Function to execute for each item.
           * @param {Object} scope Optional scope to execute the function in.
           * @return {Object/Array} Single object, or an array of objects if multiple input elements were passed in.
           */
          run: sn,
          /**
           * Returns a NodeList with attributes for the element.
           *
           * @method getAttribs
           * @param {HTMLElement/string} elm Element node or string id to get attributes from.
           * @return {NodeList} NodeList with attributes.
           */
          getAttribs: be,
          /**
           * Returns true/false if the specified node is to be considered empty or not.
           *
           * @method isEmpty
           * @param {Node} node The target node to check if it's empty.
           * @param {Object} elements Optional name/value object with elements that are automatically treated as non-empty elements.
           * @return {Boolean} true/false if the node is empty or not.
           * @example
           * tinymce.DOM.isEmpty(node, { img: true });
           */
          isEmpty: uh,
          /**
           * Creates a new DOM Range object. This will use the native DOM Range API if it's
           * available. If it's not, it will fall back to the custom TinyMCE implementation.
           *
           * @method createRng
           * @return {DOMRange} DOM Range object.
           * @example
           * const rng = tinymce.DOM.createRng();
           * alert(rng.startContainer + "," + rng.startOffset);
           */
          createRng: T3,
          /**
           * Returns the index of the specified node within its parent.
           *
           * @method nodeIndex
           * @param {Node} node Node to look for.
           * @param {Boolean} normalized Optional true/false state if the index is what it would be after a normalization.
           * @return {Number} Index of the specified node.
           */
          nodeIndex: wg,
          /**
           * Splits an element into two new elements and places the specified split
           * element or elements between the new ones. For example splitting the paragraph at the bold element in
           * this example `<p>abc<b>abc</b>123</p>` would produce `<p>abc</p><b>abc</b><p>123</p>`.
           *
           * @method split
           * @param {Element} parentElm Parent element to split.
           * @param {Element} splitElm Element to split at.
           * @param {Element} replacementElm Optional replacement element to replace the split element with.
           * @return {Element} Returns the split element or the replacement element if that is specified.
           */
          split: k3,
          /**
           * Adds an event handler to the specified object.
           *
           * @method bind
           * @param {Element/Document/Window/Array} target Target element to bind events to.
           * handler to or an array of elements/ids/documents.
           * @param {String} name Name of event handler to add, for example: click.
           * @param {Function} func Function to execute when the event occurs.
           * @param {Object} scope Optional scope to execute the function in.
           * @return {Function} Function callback handler the same as the one passed in.
           */
          bind: RS,
          /**
           * Removes the specified event handler by name and function from an element or collection of elements.
           *
           * @method unbind
           * @param {Element/Document/Window/Array} target Target element to unbind events on.
           * @param {String} name Event handler name, for example: "click"
           * @param {Function} func Function to remove.
           * @return {Boolean/Array} Bool state of true if the handler was removed, or an array of states if multiple input elements
           * were passed in.
           */
          unbind: Xf,
          /**
           * Fires the specified event name and optional object on the specified target.
           * <br>
           * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 7.0. Use <code>dispatch</code> instead.</em>
           *
           * @method fire
           * @param {Node/Document/Window} target Target element or object to fire event on.
           * @param {String} name Event name to fire.
           * @param {Object} evt Event object to send.
           * @return {Event} Event object.
           * @deprecated Use dispatch() instead
           */
          fire: VN,
          /**
           * Dispatches the specified event name and optional object on the specified target.
           *
           * @method dispatch
           * @param {Node/Document/Window} target Target element or object to dispatch event on.
           * @param {String} name Name of the event to fire.
           * @param {Object} evt Event object to send.
           * @return {Event} Event object.
           */
          dispatch: Vy,
          // Returns the content editable state of a node
          getContentEditable: A3,
          getContentEditableParent: (Se) => {
            const ke = je();
            let Dt = null;
            for (let dt = Se; dt && dt !== ke && (Dt = A3(dt), Dt === null); dt = dt.parentNode)
              ;
            return Dt;
          },
          /**
           * Checks if the specified node is editable within the given context of its parents.
           *
           * @method isEditable
           * @param {Node} node Node to check if it's editable.
           * @return {Boolean} Will be true if the node is editable and false if it's not editable.
           */
          isEditable: (Se) => {
            if (X(Se)) {
              const ke = ht(Se) ? Se : Se.parentElement;
              return X(ke) && zc(ke) && Ll(te.fromDom(ke));
            } else
              return !1;
          },
          /**
           * Destroys all internal references to the DOM to solve memory leak issues.
           *
           * @method destroy
           */
          destroy: () => {
            if (S.length > 0) {
              let Se = S.length;
              for (; Se--; ) {
                const [ke, Dt, dt] = S[Se];
                M.unbind(ke, Dt, dt);
              }
            }
            Un(c, (Se, ke) => {
              v.unload(ke), delete c[ke];
            });
          },
          isChildOf: (Se, ke) => Se === ke || ke.contains(Se),
          dumpRng: (Se) => "startContainer: " + Se.startContainer.nodeName + ", startOffset: " + Se.startOffset + ", endContainer: " + Se.endContainer.nodeName + ", endOffset: " + Se.endOffset
        }, u7 = tw(R, t, ot(Uy));
        return Uy;
      };
      lo.DOM = lo(document), lo.nodeIndex = wg;
      const _0 = lo.DOM, yo = 0, hl = 1, hf = 2, w1 = 3;
      class Do {
        static ScriptLoader = new Do();
        settings;
        states = {};
        queue = [];
        scriptLoadedCallbacks = {};
        queueLoadedCallbacks = [];
        loading = !1;
        constructor(t = {}) {
          this.settings = t;
        }
        _setReferrerPolicy(t) {
          this.settings.referrerPolicy = t;
        }
        _setCrossOrigin(t) {
          this.settings.crossOrigin = t;
        }
        /**
         * Loads a specific script directly without adding it to the load queue.
         *
         * @method loadScript
         * @param {String} url Absolute URL to script to add.
         * @return {Promise} A promise that will resolve when the script loaded successfully or reject if it failed to load.
         */
        loadScript(t) {
          return new Promise((o, r) => {
            const c = _0, u = document;
            let f;
            const b = () => {
              c.remove(O), f && (f.onerror = f.onload = f = null);
            }, v = () => {
              b(), o();
            }, S = () => {
              b(), r("Failed to load script: " + t);
            }, O = c.uniqueId();
            f = u.createElement("script"), f.id = O, f.type = "text/javascript", f.src = Je._addCacheSuffix(t), this.settings.referrerPolicy && c.setAttrib(f, "referrerpolicy", this.settings.referrerPolicy);
            const R = this.settings.crossOrigin;
            if (se(R)) {
              const M = R(t);
              M !== void 0 && c.setAttrib(f, "crossorigin", M);
            }
            f.onload = v, f.onerror = S, (u.head || u.body).appendChild(f);
          });
        }
        /**
         * Returns true/false if a script has been loaded or not.
         *
         * @method isDone
         * @param {String} url URL to check for.
         * @return {Boolean} true/false if the URL is loaded.
         */
        isDone(t) {
          return this.states[t] === hf;
        }
        /**
         * Marks a specific script to be loaded. This can be useful if a script got loaded outside
         * the script loader or to skip it from loading some script.
         *
         * @method markDone
         * @param {String} url Absolute URL to the script to mark as loaded.
         */
        markDone(t) {
          this.states[t] = hf;
        }
        /**
         * Adds a specific script to the load queue of the script loader.
         *
         * @method add
         * @param {String} url Absolute URL to script to add.
         * @return {Promise} A promise that will resolve when the script loaded successfully or reject if it failed to load.
         */
        add(t) {
          const o = this;
          return o.queue.push(t), o.states[t] === void 0 && (o.states[t] = yo), new Promise((c, u) => {
            o.scriptLoadedCallbacks[t] || (o.scriptLoadedCallbacks[t] = []), o.scriptLoadedCallbacks[t].push({
              resolve: c,
              reject: u
            });
          });
        }
        load(t) {
          return this.add(t);
        }
        remove(t) {
          delete this.states[t], delete this.scriptLoadedCallbacks[t];
        }
        /**
         * Starts the loading of the queue.
         *
         * @method loadQueue
         * @return {Promise} A promise that is resolved when all queued items are loaded or rejected with the script urls that failed to load.
         */
        loadQueue() {
          const t = this.queue;
          return this.queue = [], this.loadScripts(t);
        }
        /**
         * Loads the specified queue of files and executes the callback ones they are loaded.
         * This method is generally not used outside this class but it might be useful in some scenarios.
         *
         * @method loadScripts
         * @param {Array} scripts Array of queue items to load.
         * @return {Promise} A promise that is resolved when all scripts are loaded or rejected with the script urls that failed to load.
         */
        loadScripts(t) {
          const o = this, r = (v, S) => {
            Wo(o.scriptLoadedCallbacks, S).each((O) => {
              xe(O, (R) => R[v](S));
            }), delete o.scriptLoadedCallbacks[S];
          }, c = (v) => {
            const S = ze(v, (O) => O.status === "rejected");
            return S.length > 0 ? Promise.reject(xo(S, ({ reason: O }) => Ot(O) ? O : [O])) : Promise.resolve();
          }, u = (v) => Promise.allSettled(en(v, (S) => o.states[S] === hf ? (r("resolve", S), Promise.resolve()) : o.states[S] === w1 ? (r("reject", S), Promise.reject(S)) : (o.states[S] = hl, o.loadScript(S).then(() => {
            o.states[S] = hf, r("resolve", S);
            const O = o.queue;
            return O.length > 0 ? (o.queue = [], u(O).then(c)) : Promise.resolve();
          }, () => (o.states[S] = w1, r("reject", S), Promise.reject(S)))))), f = (v) => (o.loading = !0, u(v).then((S) => {
            o.loading = !1;
            const O = o.queueLoadedCallbacks.shift();
            return P.from(O).each(Fn), c(S);
          })), b = Gm(t);
          return o.loading ? new Promise((v, S) => {
            o.queueLoadedCallbacks.push(() => {
              f(b).then(v, S);
            });
          }) : f(b);
        }
        /**
         * Returns the attributes that should be added to a script tag when loading the specified URL.
         *
         * @method getScriptAttributes
         * @param {String} url Url to get attributes for.
         * @return {Object} Object with attributes to add to the script tag.
         */
        getScriptAttributes(t) {
          const o = {};
          this.settings.referrerPolicy && (o.referrerpolicy = this.settings.referrerPolicy);
          const r = this.settings.crossOrigin;
          if (se(r)) {
            const c = r(t);
            U(c) && (o.crossorigin = c);
          }
          return o;
        }
      }
      const nw = (e, t) => {
        const o = e.indexOf(t);
        return o !== -1 && e.indexOf(t, o + 1) > o;
      }, ow = (e) => Ye(e) && kn(e, "raw"), Z3 = (e) => Ot(e) && e.length > 1, Eg = {}, E1 = Wt("en"), sw = () => Wo(Eg, E1.get()), pl = {
        getData: () => lc(Eg, (e) => ({ ...e })),
        setCode: (e) => {
          e && E1.set(e);
        },
        getCode: () => E1.get(),
        add: (e, t) => {
          let o = Eg[e];
          o || (Eg[e] = o = {});
          const r = en(Vt(t), (c) => c.toLowerCase());
          Un(t, (c, u) => {
            const f = u.toLowerCase();
            f !== u && nw(r, f) ? (kn(t, f) || (o[f] = c), o[u] = c) : o[f] = c;
          });
        },
        translate: (e) => {
          const t = sw().getOr({}), o = (b) => se(b) ? Object.prototype.toString.call(b) : r(b) ? "" : "" + b, r = (b) => b === "" || b === null || b === void 0, c = (b) => {
            const v = o(b);
            return kn(t, v) ? o(t[v]) : Wo(t, v.toLowerCase()).map(o).getOr(v);
          }, u = (b) => b.replace(/{context:\w+}$/, ""), f = (b) => b.replaceAll("...", eg);
          if (r(e))
            return "";
          if (ow(e))
            return f(o(e.raw));
          if (Z3(e)) {
            const b = e.slice(1), v = c(e[0]).replace(/\{([0-9]+)\}/g, (S, O) => kn(b, O) ? o(b[O]) : S);
            return f(u(v));
          }
          return f(u(c(e)));
        },
        isRtl: () => sw().bind((e) => Wo(e, "_dir")).exists((e) => e === "rtl"),
        hasCode: (e) => kn(Eg, e)
      }, Vr = () => {
        const e = [], t = {}, o = {}, r = [], c = (W, Q) => {
          const ge = ze(r, (be) => be.name === W && be.state === Q);
          xe(ge, (be) => be.resolve());
        }, u = (W) => kn(t, W), f = (W) => kn(o, W), b = (W) => {
          if (o[W])
            return o[W].instance;
        }, v = (W, Q) => {
          const ge = pl.getCode(), be = "," + (Q || "") + ",";
          !ge || Q && be.indexOf("," + ge + ",") === -1 || Do.ScriptLoader.add(t[W] + "/langs/" + ge + ".js");
        }, S = (W, Q) => {
          Vr.languageLoad !== !1 && (u(W) ? v(W, Q) : J(W, "loaded").then(() => v(W, Q)));
        }, O = (W, Q) => (e.push(Q), o[W] = { instance: Q }, c(W, "added"), Q), R = (W) => {
          delete t[W], delete o[W];
        }, M = (W, Q) => U(Q) ? U(W) ? { prefix: "", resource: Q, suffix: "" } : { prefix: W.prefix, resource: Q, suffix: W.suffix } : Q, H = (W, Q) => {
          if (t[W])
            return Promise.resolve();
          let ge = U(Q) ? Q : Q.prefix + Q.resource + Q.suffix;
          ge.indexOf("/") !== 0 && ge.indexOf("://") === -1 && (ge = Vr.baseURL + "/" + ge), t[W] = ge.substring(0, ge.lastIndexOf("/"));
          const be = () => (c(W, "loaded"), Promise.resolve());
          return o[W] ? be() : Do.ScriptLoader.add(ge).then(be);
        }, J = (W, Q = "added") => Q === "added" && f(W) || Q === "loaded" && u(W) ? Promise.resolve() : new Promise((ge) => {
          r.push({ name: W, state: Q, resolve: ge });
        });
        return {
          items: e,
          urls: t,
          lookup: o,
          /**
           * Returns the specified add on by the short name.
           *
           * @method get
           * @param {String} name Add-on to look for.
           * @return {tinymce.Theme/tinymce.Plugin} Theme or plugin add-on instance or undefined.
           */
          get: b,
          /**
           * Loads a language pack for the specified add-on.
           *
           * @method requireLangPack
           * @param {String} name Short name of the add-on.
           * @param {String} languages Optional comma or space separated list of languages to check if it matches the name.
           */
          requireLangPack: S,
          /**
           * Adds a instance of the add-on by it's short name.
           *
           * @method add
           * @param {String} id Short name/id for the add-on.
           * @param {tinymce.Theme/tinymce.Plugin} addOn Theme or plugin to add.
           * @return {tinymce.Theme/tinymce.Plugin} The same theme or plugin instance that got passed in.
           * @example
           * // Create a simple plugin
           * const TestPlugin = (ed, url) => {
           *   ed.on('click', (e) => {
           *     ed.windowManager.alert('Hello World!');
           *   });
           * };
           *
           * // Register plugin using the add method
           * tinymce.PluginManager.add('test', TestPlugin);
           *
           * // Initialize TinyMCE
           * tinymce.init({
           *   ...
           *   plugins: '-test' // Init the plugin but don't try to load it
           * });
           */
          add: O,
          remove: R,
          createUrl: M,
          /**
           * Loads an add-on from a specific url.
           *
           * @method load
           * @param {String} name Short name of the add-on that gets loaded.
           * @param {String} addOnUrl URL to the add-on that will get loaded.
           * @return {Promise} A promise that will resolve when the add-on is loaded successfully or reject if it failed to load.
           * @example
           * // Loads a plugin from an external URL
           * tinymce.PluginManager.load('myplugin', '/some/dir/someplugin/plugin.js');
           *
           * // Initialize TinyMCE
           * tinymce.init({
           *   ...
           *   plugins: '-myplugin' // Don't try to load it again
           * });
           */
          load: H,
          waitFor: J
        };
      };
      Vr.languageLoad = !0, Vr.baseURL = "", Vr.PluginManager = Vr(), Vr.ThemeManager = Vr(), Vr.ModelManager = Vr();
      const pf = ot("mce-annotation"), Yi = ot("data-mce-annotation"), Sd = ot("data-mce-annotation-uid"), Vh = ot("data-mce-annotation-active"), Uh = ot("data-mce-annotation-classes"), O0 = ot("data-mce-annotation-attrs"), X3 = (e) => (t) => Qn(t, e), D0 = (e, t) => {
        const o = e.selection.getRng(), r = te.fromDom(o.startContainer), c = te.fromDom(e.getBody()), u = t.fold(() => "." + pf(), (v) => `[${Yi()}="${v}"]`), f = Bl(r, o.startOffset).getOr(r);
        return ia(f, u, X3(c)).bind((v) => il(v, `${Sd()}`).bind((S) => il(v, `${Yi()}`).map((O) => {
          const R = T1(e, S);
          return {
            uid: S,
            name: O,
            elements: R
          };
        })));
      }, D2 = (e) => Is(e) && yh(e, pf()), R2 = (e, t) => Cs(e, "data-mce-bogus") || ss(e, '[data-mce-bogus="all"]', X3(t)), T1 = (e, t) => {
        const o = te.fromDom(e.getBody()), r = Ne(o, `[${Sd()}="${t}"]`);
        return ze(r, (c) => !R2(c, o));
      }, gm = (e, t) => {
        const o = te.fromDom(e.getBody()), r = Ne(o, `[${Yi()}="${t}"]`), c = {};
        return xe(r, (u) => {
          if (!R2(u, o)) {
            const f = gs(u, Sd()), b = Wo(c, f).getOr([]);
            c[f] = b.concat([u]);
          }
        }), c;
      }, R0 = (e, t) => {
        const o = Wt({}), r = () => ({
          listeners: [],
          previous: Mc()
        }), c = (R, M) => {
          u(R, (H) => (M(H), H));
        }, u = (R, M) => {
          const H = o.get(), J = Wo(H, R).getOrThunk(r), W = M(J);
          H[R] = W, o.set(H);
        }, f = (R, M, H) => {
          c(R, (J) => {
            xe(J.listeners, (W) => W(!0, R, {
              uid: M,
              nodes: en(H, (Q) => Q.dom)
            }));
          });
        }, b = (R) => {
          c(R, (M) => {
            xe(M.listeners, (H) => H(!1, R));
          });
        }, v = (R, M) => {
          xe(T1(e, R), (H) => {
            M ? Ss(H, Vh(), "true") : sr(H, Vh());
          });
        }, S = ni(() => {
          const R = Tl(t.getNames());
          xe(R, (M) => {
            u(M, (H) => {
              const J = H.previous.get();
              return D0(e, P.some(M)).fold(() => {
                J.each((W) => {
                  b(M), H.previous.clear(), v(W, !1);
                });
              }, ({ uid: W, name: Q, elements: ge }) => {
                Ho(J, W) || (J.each((be) => v(be, !1)), f(Q, W, ge), H.previous.set(W), v(W, !0));
              }), {
                previous: H.previous,
                listeners: H.listeners
              };
            });
          });
        }, 30);
        return e.on("remove", () => {
          S.cancel();
        }), e.on("NodeChange", () => {
          S.throttle();
        }), {
          addListener: (R, M) => {
            u(R, (H) => ({
              previous: H.previous,
              listeners: H.listeners.concat([M])
            }));
          }
        };
      }, k1 = (e, t) => {
        const o = Yi(), r = (u) => P.from(u.attr(o)).bind(t.lookup), c = (u) => {
          u.attr(Sd(), null), u.attr(Yi(), null), u.attr(Vh(), null);
          const f = P.from(u.attr(O0())).map((O) => O.split(",")).getOr([]), b = P.from(u.attr(Uh())).map((O) => O.split(",")).getOr([]);
          xe(f, (O) => u.attr(O, null));
          const v = u.attr("class")?.split(" ") ?? [], S = Bs(v, [pf()].concat(b));
          u.attr("class", S.length > 0 ? S.join(" ") : null), u.attr(Uh(), null), u.attr(O0(), null);
        };
        e.serializer.addTempAttr(Vh()), e.serializer.addAttributeFilter(o, (u) => {
          for (const f of u)
            r(f).each((b) => {
              b.persistent === !1 && (f.name === "span" ? f.unwrap() : c(f));
            });
        });
      }, N0 = () => {
        const e = {};
        return {
          register: (c, u) => {
            e[c] = {
              name: c,
              settings: u
            };
          },
          lookup: (c) => Wo(e, c).map((u) => u.settings),
          getNames: () => Vt(e)
        };
      }, cw = (e, t, o = ye) => {
        const r = new Js(e, t), c = (u) => {
          let f;
          do
            f = r[u]();
          while (f && !tt(f) && !o(f));
          return P.from(f).filter(tt);
        };
        return {
          current: () => P.from(r.current()).filter(tt),
          next: () => c("next"),
          prev: () => c("prev"),
          prev2: () => c("prev2")
        };
      }, wd = (e, t) => {
        const o = t || ((f) => e.isBlock(f) || zs(f) || Es(f)), r = (f, b, v, S) => {
          if (tt(f)) {
            const O = S(f, b, f.data);
            if (O !== -1)
              return P.some({ container: f, offset: O });
          }
          return v().bind((O) => r(O.container, O.offset, v, S));
        };
        return {
          backwards: (f, b, v, S) => {
            const O = cw(f, S ?? e.getRoot(), o);
            return r(f, b, () => O.prev().map((R) => ({ container: R, offset: R.length })), v).getOrNull();
          },
          forwards: (f, b, v, S) => {
            const O = cw(f, S ?? e.getRoot(), o);
            return r(f, b, () => O.next().map((R) => ({ container: R, offset: 0 })), v).getOrNull();
          }
        };
      }, M0 = ["td", "th"], lw = ["thead", "tbody", "tfoot"], Q3 = [
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "p",
        "div",
        "address",
        "pre",
        "form",
        "blockquote",
        "center",
        "dir",
        "fieldset",
        "header",
        "footer",
        "article",
        "section",
        "hgroup",
        "aside",
        "nav",
        "figure"
      ], J3 = ["li", "dd", "dt"], iw = ["ul", "ol", "dl"], N2 = ["pre", "script", "textarea", "style"], Ed = (e) => {
        let t;
        return (o) => (t = t || vu(e, He), kn(t, Hn(o)));
      }, uw = (e) => Hn(e) === "table", Xi = (e) => Is(e) && Hn(e) === "br", nc = Ed(Q3), xi = Ed(iw), Ec = Ed(J3), P0 = Ed(lw), kg = Ed(M0), B0 = Ed(N2), M2 = (e) => {
        const t = [];
        let o = e.dom;
        for (; o; )
          t.push(te.fromDom(o)), o = o.lastChild;
        return t;
      }, ek = (e) => {
        const t = Ne(e, "br"), o = ze(M2(e).slice(-1), Xi);
        t.length === o.length && xe(o, qo);
      }, bf = () => {
        const e = te.fromTag("br");
        return Ss(e, "data-mce-bogus", "1"), e;
      }, vf = (e) => {
        Il(e), bo(e, bf());
      }, P2 = (e, t) => {
        or(e).each((o) => {
          rl(o).each((r) => {
            t.isBlock(Hn(e)) && Xi(o) && t.isBlock(Hn(r)) && qo(o);
          });
        });
      }, Ur = Pc, A1 = Xa, Gc = Bc, $0 = (e) => e.insertContent(Ur, { preserve_zwsp: !0 }), Jo = ht, Bu = tt, hm = (e) => (Bu(e) && (e = e.parentNode), Jo(e) && e.hasAttribute("data-mce-caret")), $u = (e) => Bu(e) && A1(e.data), jl = (e) => hm(e) || $u(e), I0 = (e) => e.firstChild !== e.lastChild || !zs(e.firstChild), dw = (e, t) => {
        const r = (e.ownerDocument ?? document).createTextNode(Ur), c = e.parentNode;
        if (t) {
          const u = e.previousSibling;
          if (Bu(u)) {
            if (jl(u))
              return u;
            if (yf(u))
              return u.splitText(u.data.length - 1);
          }
          c?.insertBefore(r, e);
        } else {
          const u = e.nextSibling;
          if (Bu(u)) {
            if (jl(u))
              return u;
            if (bl(u))
              return u.splitText(1), u;
          }
          e.nextSibling ? c?.insertBefore(r, e.nextSibling) : c?.appendChild(r);
        }
        return r;
      }, pm = (e) => {
        const t = e.container();
        return tt(t) ? t.data.charAt(e.offset()) === Ur || e.isAtStart() && $u(t.previousSibling) : !1;
      }, Ag = (e) => {
        const t = e.container();
        return tt(t) ? t.data.charAt(e.offset() - 1) === Ur || e.isAtEnd() && $u(t.nextSibling) : !1;
      }, B2 = (e, t, o) => {
        const c = (t.ownerDocument ?? document).createElement(e);
        c.setAttribute("data-mce-caret", o ? "before" : "after"), c.setAttribute("data-mce-bogus", "all"), c.appendChild(bf().dom);
        const u = t.parentNode;
        return o ? u?.insertBefore(c, t) : t.nextSibling ? u?.insertBefore(c, t.nextSibling) : u?.appendChild(c), c;
      }, bl = (e) => Bu(e) && e.data[0] === Ur, yf = (e) => Bu(e) && e.data[e.data.length - 1] === Ur, Ea = (e) => {
        const t = e.getElementsByTagName("br"), o = t[t.length - 1];
        uf(o) && o.parentNode?.removeChild(o);
      }, Qi = (e) => e && e.hasAttribute("data-mce-caret") ? (Ea(e), e.removeAttribute("data-mce-caret"), e.removeAttribute("data-mce-bogus"), e.removeAttribute("style"), e.removeAttribute("data-mce-style"), e.removeAttribute("_moz_abspos"), e) : null, F0 = (e) => hm(e.startContainer), _g = Math.round, Cf = (e) => e ? {
        left: _g(e.left),
        top: _g(e.top),
        bottom: _g(e.bottom),
        right: _g(e.right),
        width: _g(e.width),
        height: _g(e.height)
      } : { left: 0, top: 0, bottom: 0, right: 0, width: 0, height: 0 }, _1 = (e, t) => (e = Cf(e), t || (e.left = e.left + e.width), e.right = e.left, e.width = 0, e), $2 = (e, t) => e.left === t.left && e.top === t.top && e.bottom === t.bottom && e.right === t.right, L0 = (e, t, o) => e >= 0 && e <= Math.min(t.height, o.height) / 2, Og = (e, t) => {
        const o = Math.min(t.height / 2, e.height / 2);
        return e.bottom - o < t.top ? !0 : e.top > t.bottom ? !1 : L0(t.top - e.bottom, e, t);
      }, xf = (e, t) => e.top > t.bottom ? !0 : e.bottom < t.top ? !1 : L0(t.bottom - e.top, e, t), I2 = (e, t, o) => t >= e.left && t <= e.right && o >= e.top && o <= e.bottom, O1 = (e) => Io(e, (t, o) => t.fold(() => P.some(o), (r) => {
        const c = Math.min(o.left, r.left), u = Math.min(o.top, r.top), f = Math.max(o.right, r.right), b = Math.max(o.bottom, r.bottom);
        return P.some({
          top: u,
          right: f,
          bottom: b,
          left: c,
          width: f - c,
          height: b - u
        });
      }), P.none()), F2 = (e, t, o) => {
        const r = Math.max(Math.min(t, e.left + e.width), e.left), c = Math.max(Math.min(o, e.top + e.height), e.top);
        return Math.sqrt((t - r) * (t - r) + (o - c) * (o - c));
      }, mw = (e, t) => Math.max(0, Math.min(e.bottom, t.bottom) - Math.max(e.top, t.top)), jr = (e) => {
        const t = e.startContainer, o = e.startOffset;
        return t === e.endContainer && t.hasChildNodes() && e.endOffset === o + 1 ? t.childNodes[o] : null;
      }, Sf = (e, t) => {
        if (ht(e) && e.hasChildNodes()) {
          const o = e.childNodes, r = ad(t, 0, o.length - 1);
          return o[r];
        } else
          return e;
      }, wf = (e, t) => {
        if (!(t < 0 && ht(e) && e.hasChildNodes()))
          return Sf(e, t);
      }, fw = new RegExp("[̀-ͯ҃-҇҈-҉֑-ֽֿׁ-ׂׄ-ׇׅؐ-ًؚ-ٰٟۖ-ۜ۟-ۤۧ-۪ۨ-ܑۭܰ-݊ަ-ް߫-߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛ࣣ-ंऺ़ु-ै्॑-ॗॢ-ॣঁ়াু-ৄ্ৗৢ-ৣਁ-ਂ਼ੁ-ੂੇ-ੈੋ-੍ੑੰ-ੱੵઁ-ં઼ુ-ૅે-ૈ્ૢ-ૣଁ଼ାିୁ-ୄ୍ୖୗୢ-ୣஂாீ்ௗఀా-ీె-ైొ-్ౕ-ౖౢ-ౣಁ಼ಿೂೆೌ-್ೕ-ೖೢ-ೣഁാു-ൄ്ൗൢ-ൣ්ාි-ුූෟัิ-ฺ็-๎ັິ-ູົ-ຼ່-ໍ༘-ཱ༹༙༵༷-ཾྀ-྄྆-྇ྍ-ྗྙ-ྼ࿆ိ-ူဲ-့္-်ွ-ှၘ-ၙၞ-ၠၱ-ၴႂႅ-ႆႍႝ፝-፟ᜒ-᜔ᜲ-᜴ᝒ-ᝓᝲ-ᝳ឴-឵ិ-ួំ៉-៓៝᠋-᠍ᢩᤠ-ᤢᤧ-ᤨᤲ᤹-᤻ᨗ-ᨘᨛᩖᩘ-ᩞ᩠ᩢᩥ-ᩬᩳ-᩿᩼᪰-᪽᪾ᬀ-ᬃ᬴ᬶ-ᬺᬼᭂ᭫-᭳ᮀ-ᮁᮢ-ᮥᮨ-ᮩ᮫-ᮭ᯦ᯨ-ᯩᯭᯯ-ᯱᰬ-ᰳᰶ-᰷᳐-᳔᳒-᳢᳠-᳨᳭᳴᳸-᳹᷀-᷵᷼-᷿‌-‍⃐-⃜⃝-⃠⃡⃢-⃤⃥-⃰⳯-⵿⳱ⷠ-〪ⷿ-〭〮-゙〯-゚꙯꙰-꙲ꙴ-꙽ꚞ-ꚟ꛰-꛱ꠂ꠆ꠋꠥ-ꠦ꣄꣠-꣱ꤦ-꤭ꥇ-ꥑꦀ-ꦂ꦳ꦶ-ꦹꦼꧥꨩ-ꨮꨱ-ꨲꨵ-ꨶꩃꩌꩼꪰꪲ-ꪴꪷ-ꪸꪾ-꪿꫁ꫬ-ꫭ꫶ꯥꯨ꯭ﬞ︀-️︠-︯ﾞ-ﾟ]"), H0 = (e) => U(e) && e.charCodeAt(0) >= 768 && fw.test(e), L2 = (...e) => (t) => {
        for (let o = 0; o < e.length; o++)
          if (e[o](t))
            return !0;
        return !1;
      }, D1 = (...e) => (t) => {
        for (let o = 0; o < e.length; o++)
          if (!e[o](t))
            return !1;
        return !0;
      }, z0 = dl, gw = Es, tk = zs, R1 = tt, Mr = hi(["script", "style", "textarea"]), Er = hi(["img", "input", "textarea", "hr", "iframe", "video", "audio", "object", "embed"]), Ta = hi(["table"]), ua = jl, Rs = (e) => ua(e) ? !1 : R1(e) ? !Mr(e.parentNode) : Er(e) || tk(e) || Ta(e) || jh(e), Tr = (e) => ht(e) && e.getAttribute("unselectable") === "true", jh = (e) => !Tr(e) && gw(e), H2 = (e, t) => {
        for (let o = e.parentNode; o && o !== t; o = o.parentNode) {
          if (jh(o))
            return !1;
          if (z0(o))
            return !0;
        }
        return !0;
      }, z2 = (e) => jh(e) ? !Io(rs(e.getElementsByTagName("*")), (t, o) => t || z0(o), !1) : !1, hw = (e) => Er(e) || z2(e), V0 = (e, t) => Rs(e) && H2(e, t), V2 = ht, U2 = Rs, U0 = f0("display", "block table"), j2 = f0("float", "left right"), Wh = D1(V2, U2, bt(j2)), pw = bt(f0("white-space", "pre pre-line pre-wrap")), N1 = tt, Iu = zs, j0 = lo.nodeIndex, M1 = wf, Zh = (e) => e ? e.createRange() : lo.DOM.createRng(), Dg = (e) => U(e) && /[\r\n\t ]/.test(e), P1 = (e) => !!e.setStart && !!e.setEnd, W0 = (e) => {
        const t = e.startContainer, o = e.startOffset;
        if (Dg(e.toString()) && pw(t.parentNode) && tt(t)) {
          const r = t.data;
          if (Dg(r[o - 1]) || Dg(r[o + 1]))
            return !0;
        }
        return !1;
      }, B1 = (e) => {
        const t = e.ownerDocument, o = Zh(t), r = t.createTextNode($s), c = e.parentNode;
        c.insertBefore(r, e), o.setStart(r, 0), o.setEnd(r, 1);
        const u = Cf(o.getBoundingClientRect());
        return c.removeChild(r), u;
      }, Z0 = (e) => {
        const t = e.startContainer, o = e.endContainer, r = e.startOffset, c = e.endOffset;
        if (t === o && tt(o) && r === 0 && c === 1) {
          const u = e.cloneRange();
          return u.setEndAfter(o), Tc(u);
        } else
          return null;
      }, Rg = (e) => e.left === 0 && e.right === 0 && e.top === 0 && e.bottom === 0, Tc = (e) => {
        let t;
        const o = e.getClientRects();
        return o.length > 0 ? t = Cf(o[0]) : t = Cf(e.getBoundingClientRect()), !P1(e) && Iu(e) && Rg(t) ? B1(e) : Rg(t) && P1(e) ? Z0(e) ?? t : t;
      }, La = (e, t) => {
        const o = _1(e, t);
        return o.width = 1, o.right = o.left + 1, o;
      }, Gh = (e) => {
        const t = [], o = (f) => {
          f.height !== 0 && (t.length > 0 && $2(f, t[t.length - 1]) || t.push(f));
        }, r = (f, b) => {
          const v = Zh(f.ownerDocument);
          if (b < f.data.length) {
            if (H0(f.data[b]))
              return;
            if (H0(f.data[b - 1]) && (v.setStart(f, b), v.setEnd(f, b + 1), !W0(v))) {
              o(La(Tc(v), !1));
              return;
            }
          }
          b > 0 && (v.setStart(f, b - 1), v.setEnd(f, b), W0(v) || o(La(Tc(v), !1))), b < f.data.length && (v.setStart(f, b), v.setEnd(f, b + 1), W0(v) || o(La(Tc(v), !0)));
        }, c = e.container(), u = e.offset();
        if (N1(c))
          return r(c, u), t;
        if (V2(c))
          if (e.isAtEnd()) {
            const f = M1(c, u);
            N1(f) && r(f, f.data.length), Wh(f) && !Iu(f) && o(La(Tc(f), !1));
          } else {
            const f = M1(c, u);
            if (N1(f) && r(f, 0), Wh(f) && e.isAtEnd())
              return o(La(Tc(f), !1)), t;
            const b = M1(e.container(), e.offset() - 1);
            Wh(b) && !Iu(b) && (U0(b) || U0(f) || !Wh(f)) && o(La(Tc(b), !1)), Wh(f) && o(La(Tc(f), !0));
          }
        return t;
      }, Re = (e, t, o) => {
        const r = () => (N1(e), t === 0), c = () => N1(e) ? t >= e.data.length : t >= e.childNodes.length, u = () => {
          const O = Zh(e.ownerDocument);
          return O.setStart(e, t), O.setEnd(e, t), O;
        }, f = () => (o || (o = Gh(Re(e, t))), o), b = () => f().length > 0, v = (O) => O && e === O.container() && t === O.offset(), S = (O) => M1(e, O ? t - 1 : t);
        return {
          /**
           * Returns the container node.
           *
           * @method container
           * @return {Node} Container node.
           */
          container: ot(e),
          /**
           * Returns the offset within the container node.
           *
           * @method offset
           * @return {Number} Offset within the container node.
           */
          offset: ot(t),
          /**
           * Returns a range out of a the caret position.
           *
           * @method toRange
           * @return {DOMRange} range for the caret position.
           */
          toRange: u,
          /**
           * Returns the client rects for the caret position. Might be multiple rects between
           * block elements.
           *
           * @method getClientRects
           * @return {Array} Array of client rects.
           */
          getClientRects: f,
          /**
           * Returns true if the caret location is visible/displayed on screen.
           *
           * @method isVisible
           * @return {Boolean} true/false if the position is visible or not.
           */
          isVisible: b,
          /**
           * Returns true if the caret location is at the beginning of text node or container.
           *
           * @method isVisible
           * @return {Boolean} true/false if the position is at the beginning.
           */
          isAtStart: r,
          /**
           * Returns true if the caret location is at the end of text node or container.
           *
           * @method isVisible
           * @return {Boolean} true/false if the position is at the end.
           */
          isAtEnd: c,
          /**
           * Compares the caret position to another caret position. This will only compare the
           * container and offset not it's visual position.
           *
           * @method isEqual
           * @param {tinymce.caret.CaretPosition} caretPosition Caret position to compare with.
           * @return {Boolean} true if the caret positions are equal.
           */
          isEqual: v,
          /**
           * Returns the closest resolved node from a node index. That means if you have an offset after the
           * last node in a container it will return that last node.
           *
           * @method getNode
           * @return {Node} Node that is closest to the index.
           */
          getNode: S
        };
      };
      Re.fromRangeStart = (e) => Re(e.startContainer, e.startOffset), Re.fromRangeEnd = (e) => Re(e.endContainer, e.endOffset), Re.after = (e) => Re(e.parentNode, j0(e) + 1), Re.before = (e) => Re(e.parentNode, j0(e)), Re.isAbove = (e, t) => Xs(js(t.getClientRects()), dr(e.getClientRects()), Og).getOr(!1), Re.isBelow = (e, t) => Xs(dr(t.getClientRects()), js(e.getClientRects()), xf).getOr(!1), Re.isAtStart = (e) => e ? e.isAtStart() : !1, Re.isAtEnd = (e) => e ? e.isAtEnd() : !1, Re.isTextPosition = (e) => e ? tt(e.container()) : !1, Re.isElementPosition = (e) => !Re.isTextPosition(e);
      const $1 = (e, t) => {
        tt(t) && t.data.length === 0 && e.remove(t);
      }, nk = (e, t, o) => {
        t.insertNode(o), $1(e, o.previousSibling), $1(e, o.nextSibling);
      }, kc = (e, t, o) => {
        const r = P.from(o.firstChild), c = P.from(o.lastChild);
        t.insertNode(o), r.each((u) => $1(e, u.previousSibling)), c.each((u) => $1(e, u.nextSibling));
      }, qh = (e, t, o) => {
        Ah(o) ? kc(e, t, o) : nk(e, t, o);
      }, Fu = tt, W2 = uf, Z2 = lo.nodeIndex, Ng = (e) => {
        const t = e.parentNode;
        return W2(t) ? Ng(t) : t;
      }, I1 = (e) => e ? Bi(e.childNodes, (t, o) => (W2(o) && o.nodeName !== "BR" ? t = t.concat(I1(o)) : t.push(o), t), []) : [], bm = (e, t) => {
        let o = e;
        for (; (o = o.previousSibling) && Fu(o); )
          t += o.data.length;
        return t;
      }, G0 = (e) => (t) => e === t, ok = (e) => {
        let t, o;
        t = I1(Ng(e)), o = tm(t, G0(e), e), t = t.slice(0, o + 1);
        const r = Bi(t, (c, u, f) => (Fu(u) && Fu(t[f - 1]) && c++, c), 0);
        return t = wu(t, hi([e.nodeName])), o = tm(t, G0(e), e), o - r;
      }, Ha = (e) => (Fu(e) ? "text()" : e.nodeName.toLowerCase()) + "[" + ok(e) + "]", Lu = (e, t, o) => {
        const r = [];
        for (let c = t.parentNode; c && c !== e; c = c.parentNode)
          r.push(c);
        return r;
      }, vl = (e, t) => {
        let o = [], r = t.container(), c = t.offset(), u;
        if (Fu(r))
          u = bm(r, c);
        else {
          const b = r.childNodes;
          c >= b.length ? (u = "after", c = b.length - 1) : u = "before", r = b[c];
        }
        o.push(Ha(r));
        let f = Lu(e, r);
        return f = wu(f, bt(uf)), o = o.concat(si(f, (b) => Ha(b))), o.reverse().join("/") + "," + u;
      }, sk = (e, t, o) => {
        let r = I1(e);
        return r = wu(r, (c, u) => !Fu(c) || !Fu(r[u - 1])), r = wu(r, hi([t])), r[o];
      }, Kh = (e, t) => {
        let o = e, r = 0;
        for (; Fu(o); ) {
          const c = o.data.length;
          if (t >= r && t <= r + c) {
            e = o, t = t - r;
            break;
          }
          if (!Fu(o.nextSibling)) {
            e = o, t = c;
            break;
          }
          r += c, o = o.nextSibling;
        }
        return Fu(e) && t > e.data.length && (t = e.data.length), Re(e, t);
      }, bw = (e, t) => {
        if (!t)
          return null;
        const o = t.split(","), r = o[0].split("/"), c = o.length > 1 ? o[1] : "before", u = Bi(r, (f, b) => {
          const v = /([\w\-\(\)]+)\[([0-9]+)\]/.exec(b);
          return v ? (v[1] === "text()" && (v[1] = "#text"), sk(f, v[1], parseInt(v[2], 10))) : null;
        }, e);
        if (!u)
          return null;
        if (!Fu(u) && u.parentNode) {
          let f;
          return c === "after" ? f = Z2(u) + 1 : f = Z2(u), Re(u.parentNode, f);
        }
        return Kh(u, parseInt(c, 10));
      }, q0 = Es, rk = (e, t, o) => {
        let r = e(t.data.slice(0, o)).length;
        for (let c = t.previousSibling; c && tt(c); c = c.previousSibling)
          r += e(c.data).length;
        return r;
      }, vw = (e, t, o, r, c) => {
        const u = c ? r.startContainer : r.endContainer;
        let f = c ? r.startOffset : r.endOffset;
        const b = [], v = e.getRoot();
        if (tt(u))
          b.push(o ? rk(t, u, f) : f);
        else {
          let S = 0;
          const O = u.childNodes;
          f >= O.length && O.length && (S = 1, f = Math.max(0, O.length - 1)), b.push(e.nodeIndex(O[f], o) + S);
        }
        for (let S = u; S && S !== v; S = S.parentNode)
          b.push(e.nodeIndex(S, o));
        return b;
      }, Wn = (e, t, o, r) => {
        const c = t.dom, u = vw(c, e, o, r, !0), f = t.isForward(), b = F0(r) ? { isFakeCaret: !0 } : {};
        if (t.isCollapsed())
          return { start: u, forward: f, ...b };
        {
          const v = vw(c, e, o, r, !1);
          return { start: u, end: v, forward: f, ...b };
        }
      }, tn = (e, t, o) => {
        let r = 0;
        return Je.each(e.select(t), (c) => {
          if (c.getAttribute("data-mce-bogus") !== "all") {
            if (c === o)
              return !1;
            r++;
            return;
          }
        }), r;
      }, Yh = (e, t) => {
        let o = t ? e.startContainer : e.endContainer, r = t ? e.startOffset : e.endOffset;
        if (ht(o) && o.nodeName === "TR") {
          const c = o.childNodes;
          o = c[Math.min(t ? r : r - 1, c.length - 1)], o && (r = t ? 0 : o.childNodes.length, t ? e.setStart(o, r) : e.setEnd(o, r));
        }
      }, K0 = (e) => (Yh(e, !0), Yh(e, !1), e), Y0 = (e, t) => {
        if (ht(e) && (e = Sf(e, t), q0(e)))
          return e;
        if (jl(e)) {
          tt(e) && hm(e) && (e = e.parentNode);
          let o = e.previousSibling;
          if (q0(o) || (o = e.nextSibling, q0(o)))
            return o;
        }
      }, ak = (e) => Y0(e.startContainer, e.startOffset) || Y0(e.endContainer, e.endOffset), G2 = (e, t, o) => {
        const r = o.getNode(), c = o.getRng();
        if (r.nodeName === "IMG" || q0(r)) {
          const f = r.nodeName;
          return { name: f, index: tn(o.dom, f, r) };
        }
        const u = ak(c);
        if (u) {
          const f = u.tagName;
          return { name: f, index: tn(o.dom, f, u) };
        }
        return Wn(e, o, t, c);
      }, Ts = (e) => {
        const t = e.getRng();
        return {
          start: vl(e.dom.getRoot(), Re.fromRangeStart(t)),
          end: vl(e.dom.getRoot(), Re.fromRangeEnd(t)),
          forward: e.isForward()
        };
      }, X0 = (e) => ({ rng: e.getRng(), forward: e.isForward() }), Q0 = (e, t, o) => {
        const r = { "data-mce-type": "bookmark", id: t, style: "overflow:hidden;line-height:0px" };
        return o ? e.create("span", r, "&#xFEFF;") : e.create("span", r);
      }, q2 = (e, t) => {
        const o = e.dom;
        let r = e.getRng();
        const c = o.uniqueId(), u = e.isCollapsed(), f = e.getNode(), b = f.nodeName, v = e.isForward();
        if (b === "IMG")
          return { name: b, index: tn(o, b, f) };
        const S = K0(r.cloneRange());
        if (!u) {
          S.collapse(!1);
          const R = Q0(o, c + "_end", t);
          qh(o, S, R);
        }
        r = K0(r), r.collapse(!0);
        const O = Q0(o, c + "_start", t);
        return qh(o, r, O), e.moveToBookmark({ id: c, keep: !0, forward: v }), { id: c, forward: v };
      }, Ie = (e, t, o = !1) => t === 2 ? G2(Gc, o, e) : t === 3 ? Ts(e) : t ? X0(e) : q2(e, !1), Xh = ue(G2, jo, !0), Mg = (e) => e === 1, Td = (e) => e === -1;
      var Ji;
      (function(e) {
        e[e.Error = 0] = "Error", e[e.Value = 1] = "Value";
      })(Ji || (Ji = {}));
      const kd = (e, t, o) => e.stype === Ji.Error ? t(e.serror) : o(e.svalue), Qh = (e) => {
        const t = [], o = [];
        return xe(e, (r) => {
          kd(r, (c) => o.push(c), (c) => t.push(c));
        }), { values: t, errors: o };
      }, Pg = (e, t) => e.stype === Ji.Error ? { stype: Ji.Error, serror: t(e.serror) } : e, ck = (e, t) => e.stype === Ji.Value ? { stype: Ji.Value, svalue: t(e.svalue) } : e, Jh = (e, t) => e.stype === Ji.Value ? t(e.svalue) : e, hs = (e, t) => e.stype === Ji.Error ? t(e.serror) : e, eu = (e) => ({ stype: Ji.Value, svalue: e }), K2 = (e) => ({ stype: Ji.Error, serror: e }), za = {
        fromResult: (e) => e.fold(K2, eu),
        toResult: (e) => kd(e, xr.error, xr.value),
        svalue: eu,
        partition: Qh,
        serror: K2,
        bind: Jh,
        bindError: hs,
        map: ck,
        mapError: Pg,
        fold: kd
      }, yw = (e) => Ye(e) && Vt(e).length > 100 ? " removed due to size" : JSON.stringify(e, null, 2), Y2 = (e) => {
        const t = e.length > 10 ? e.slice(0, 10).concat([
          {
            path: [],
            getErrorInfo: ot("... (only showing first ten failures)")
          }
        ]) : e;
        return en(t, (o) => "Failed path: (" + o.path.join(" > ") + `)
` + o.getErrorInfo());
      }, Cw = (e, t) => za.serror([{
        path: e,
        // This is lazy so that it isn't calculated unnecessarily
        getErrorInfo: t
      }]), lk = (e, t, o) => Cw(e, () => 'Could not find valid *required* value for "' + t + '" in ' + yw(o)), ik = (e, t) => Cw(e, ot(t)), X2 = (e) => {
        const t = (r, c) => za.bindError(e(c), (u) => ik(r, u)), o = ot("val");
        return {
          extract: t,
          toString: o
        };
      }, xw = X2(za.svalue), nt = ot(xw), Q2 = (e, t) => X2((o) => {
        const r = typeof o;
        return e(o) ? za.svalue(o) : za.serror(`Expected type: ${t} but got: ${r}`);
      }), da = Q2(ns, "number"), J2 = Q2(U, "string"), eC = Q2(se, "function"), tC = () => ({ tag: "required", process: {} }), uk = (e) => ({ tag: "defaultedThunk", process: e }), xn = (e) => uk(ot(e)), Sw = () => ({ tag: "option", process: {} }), ww = (e, t, o, r) => ({ tag: "field", key: e, newKey: t, presence: o, prop: r }), dk = (e, t, o) => {
        switch (e.tag) {
          case "field":
            return t(e.key, e.newKey, e.presence, e.prop);
          case "custom":
            return o(e.newKey, e.instantiator);
        }
      }, mk = (e, t) => za.svalue(xu(t, kl.apply(void 0, e))), Ew = (e) => A(za.serror, ga)(e), Tw = {
        consolidateObj: (e, t) => {
          const o = za.partition(e);
          return o.errors.length > 0 ? Ew(o.errors) : mk(o.values, t);
        },
        consolidateArr: (e) => {
          const t = za.partition(e);
          return t.errors.length > 0 ? Ew(t.errors) : za.svalue(t.values);
        }
      }, fk = (e, t, o, r) => (
        // In required mode, if it is undefined, it is an error.
        Wo(t, o).fold(() => lk(e, o, t), r)
      ), En = (e, t, o, r) => {
        const c = Wo(e, t).getOrThunk(() => o(e));
        return r(c);
      }, nC = (e, t, o) => o(Wo(e, t)), vm = (e, t, o, r) => {
        const c = Wo(e, t).map((u) => u === !0 ? o(e) : u);
        return r(c);
      }, Si = (e, t, o, r, c) => {
        const u = (b) => c.extract(t.concat([r]), b), f = (b) => b.fold(() => za.svalue(P.none()), (v) => {
          const S = c.extract(t.concat([r]), v);
          return za.map(S, P.some);
        });
        switch (e.tag) {
          case "required":
            return fk(t, o, r, u);
          case "defaultedThunk":
            return En(o, r, e.process, u);
          case "option":
            return nC(o, r, f);
          case "defaultedOptionThunk":
            return vm(o, r, e.process, f);
          case "mergeWithThunk":
            return En(o, r, ot({}), (b) => {
              const v = xu(e.process(o), b);
              return u(v);
            });
        }
      }, J0 = (e, t, o) => {
        const r = {}, c = [];
        for (const u of o)
          dk(u, (f, b, v, S) => {
            const O = Si(v, e, t, f, S);
            za.fold(O, (R) => {
              c.push(...R);
            }, (R) => {
              r[b] = R;
            });
          }, (f, b) => {
            r[f] = b(t);
          });
        return c.length > 0 ? za.serror(c) : za.svalue(r);
      }, Ac = (e) => ({
        extract: (r, c) => J0(r, c, e),
        toString: () => `obj{
` + en(e, (c) => dk(c, (u, f, b, v) => u + " -> " + v.toString(), (u, f) => "state(" + u + ")")).join(`
`) + "}"
      }), ep = (e) => ({
        extract: (r, c) => {
          const u = en(c, (f, b) => e.extract(r.concat(["[" + b + "]"]), f));
          return Tw.consolidateArr(u);
        },
        toString: () => "array(" + e.toString() + ")"
      }), F1 = A(ep, Ac), ev = (e) => X2((t) => e(t).fold(za.serror, za.svalue)), tp = (e, t, o) => {
        const r = t.extract([e], o);
        return za.mapError(r, (c) => ({ input: o, errors: c }));
      }, np = (e, t, o) => za.toResult(tp(e, t, o)), Ad = (e) => `Errors: 
` + Y2(e.errors).join(`
`) + `

Input object: ` + yw(e.input), kr = ww, ym = (e) => kr(e, e, tC(), nt()), kw = (e, t) => kr(e, e, tC(), t), oC = (e) => kw(e, J2), Aw = (e) => kw(e, eC), gk = (e, t) => kr(e, e, tC(), ep(t)), io = (e) => kr(e, e, Sw(), nt()), tu = (e, t) => kr(e, e, Sw(), t), Tf = (e) => tu(e, J2), n5 = (e) => tu(e, eC), op = (e, t) => kr(e, e, xn(t), nt()), go = (e, t, o) => kr(e, e, xn(t), o), hk = (e, t) => go(e, t, da), pk = (e, t, o) => go(e, t, ep(o)), o5 = (e) => e.type === "inline-command" || e.type === "inline-format", s5 = (e) => e.type === "block-command" || e.type === "block-format", L1 = (e, t) => (e.type === "block-command" || e.type === "block-format") && e.trigger === t, bk = (e) => {
        const t = (r) => xr.error({ message: r, pattern: e }), o = (r, c, u) => {
          if (e.format !== void 0) {
            let f;
            if (Ot(e.format)) {
              if (!qa(e.format, U))
                return t(r + " pattern has non-string items in the `format` array");
              f = e.format;
            } else if (U(e.format))
              f = [e.format];
            else
              return t(r + " pattern has non-string `format` parameter");
            return xr.value(c(f));
          } else return e.cmd !== void 0 ? U(e.cmd) ? xr.value(u(e.cmd, e.value)) : t(r + " pattern has non-string `cmd` parameter") : t(r + " pattern is missing both `format` and `cmd` parameters");
        };
        if (!Ye(e))
          return t("Raw pattern is not an object");
        if (!U(e.start))
          return t("Raw pattern is missing `start` parameter");
        if (e.end !== void 0) {
          if (!U(e.end))
            return t("Inline pattern has non-string `end` parameter");
          if (e.start.length === 0 && e.end.length === 0)
            return t("Inline pattern has empty `start` and `end` parameters");
          let r = e.start, c = e.end;
          return c.length === 0 && (c = r, r = ""), o("Inline", (u) => ({ type: "inline-format", start: r, end: c, format: u }), (u, f) => ({ type: "inline-command", start: r, end: c, cmd: u, value: f }));
        } else {
          if (e.replacement !== void 0)
            return U(e.replacement) ? e.start.length === 0 ? t("Replacement pattern has empty `start` parameter") : xr.value({
              type: "inline-command",
              start: "",
              end: e.start,
              cmd: "mceInsertContent",
              value: e.replacement
            }) : t("Replacement pattern has non-string `replacement` parameter");
          {
            const r = e.trigger ?? "space";
            return e.start.length === 0 ? t("Block pattern has empty `start` parameter") : o("Block", (c) => ({
              type: "block-format",
              start: e.start,
              format: c[0],
              trigger: r
            }), (c, u) => ({
              type: "block-command",
              start: e.start,
              cmd: c,
              value: u,
              trigger: r
            }));
          }
        }
      }, vk = (e) => ze(e, s5), H1 = (e) => ze(e, o5), yk = (e, t) => ({
        inlinePatterns: H1(e),
        blockPatterns: vk(e),
        dynamicPatternsLookup: t
      }), z1 = (e, t) => ({
        ...e,
        blockPatterns: ze(e.blockPatterns, (o) => L1(o, t))
      }), _w = (e) => {
        const t = Br(en(e, bk));
        return xe(t.errors, (o) => console.error(o.message, o.pattern)), t.values;
      }, Ck = (e) => (t) => {
        const o = e(t);
        return _w(o);
      }, tv = (e, t) => e.dispatch("PreProcess", t), sC = (e, t) => e.dispatch("PostProcess", t), rC = (e) => {
        e.dispatch("remove");
      }, Ow = (e) => {
        e.dispatch("detach");
      }, xk = (e, t) => {
        e.dispatch("SwitchMode", { mode: t });
      }, Dw = (e, t, o, r, c) => {
        e.dispatch("ObjectResizeStart", { target: t, width: o, height: r, origin: c });
      }, aC = (e, t, o, r, c) => {
        e.dispatch("ObjectResized", { target: t, width: o, height: r, origin: c });
      }, Rw = (e) => {
        e.dispatch("PreInit");
      }, So = (e) => {
        e.dispatch("PostRender");
      }, Nw = (e) => {
        e.dispatch("Init");
      }, cC = (e, t) => {
        e.dispatch("PlaceholderToggle", { state: t });
      }, nv = (e, t, o) => {
        e.dispatch(t, o);
      }, Cm = (e, t, o, r) => {
        e.dispatch("FormatApply", { format: t, node: o, vars: r });
      }, lC = (e, t, o, r) => {
        e.dispatch("FormatRemove", { format: t, node: o, vars: r });
      }, Sk = (e, t) => e.dispatch("BeforeSetContent", t), Mw = (e, t) => e.dispatch("SetContent", t), sp = (e, t) => e.dispatch("BeforeGetContent", t), Pw = (e, t) => e.dispatch("GetContent", t), V1 = (e, t) => {
        e.dispatch("AutocompleterStart", t);
      }, U1 = (e, t) => {
        e.dispatch("AutocompleterUpdate", t);
      }, iC = (e, t) => {
        e.dispatch("AutocompleterUpdateActiveRange", t);
      }, kf = (e) => {
        e.dispatch("AutocompleterEnd");
      }, Bw = (e, t, o) => e.dispatch("PastePreProcess", { content: t, internal: o }), $w = (e, t, o) => e.dispatch("PastePostProcess", { node: t, internal: o }), Iw = (e, t) => e.dispatch("PastePlainTextToggle", { state: t }), Fw = (e, t) => e.dispatch("EditableRootStateChange", { state: t }), r5 = (e, t) => e.dispatch("DisabledStateChange", { state: t }), Lw = (e) => e.dispatch("CloseActiveTooltips"), ov = Ii().deviceType, sv = ov.isTouch(), j1 = lo.DOM, rv = (e) => {
        const t = e.indexOf("=") > 0 ? e.split(/[;,](?![^=;,]*(?:[;,]|$))/) : e.split(",");
        return Io(t, (o, r) => {
          const c = r.split("="), u = c[0], f = c.length > 1 ? c[1] : u;
          return o[_s(u)] = _s(f), o;
        }, {});
      }, av = (e) => lt(e, RegExp), Rt = (e) => (t) => t.options.get(e), Af = (e) => U(e) || Ye(e), _d = (e, t = "") => (o) => {
        const r = U(o);
        if (r)
          if (o.indexOf("=") !== -1) {
            const c = rv(o);
            return { value: Wo(c, e.id).getOr(t), valid: r };
          } else
            return { value: o, valid: r };
        else
          return { valid: !1, message: "Must be a string." };
      }, W1 = (e) => {
        const t = e.options.register;
        t("id", {
          processor: "string",
          default: e.id
        }), t("selector", {
          processor: "string"
        }), t("target", {
          processor: "object"
        }), t("suffix", {
          processor: "string"
        }), t("cache_suffix", {
          processor: "string"
        }), t("base_url", {
          processor: "string"
        }), t("referrer_policy", {
          processor: "string",
          default: ""
        }), t("crossorigin", {
          processor: "function",
          default: ot(void 0)
        }), t("language_load", {
          processor: "boolean",
          default: !0
        }), t("inline", {
          processor: "boolean",
          default: !1
        }), t("iframe_attrs", {
          processor: "object",
          default: {}
        }), t("doctype", {
          processor: "string",
          default: "<!DOCTYPE html>"
        }), t("document_base_url", {
          processor: "string",
          default: e.editorManager.documentBaseURL
        }), t("body_id", {
          processor: _d(e, "tinymce"),
          default: "tinymce"
        }), t("body_class", {
          processor: _d(e),
          default: ""
        }), t("content_security_policy", {
          processor: "string",
          default: ""
        }), t("br_in_pre", {
          processor: "boolean",
          default: !0
        }), t("forced_root_block", {
          processor: (r) => {
            const c = U(r) && ms(r);
            return c ? { value: r, valid: c } : { valid: !1, message: "Must be a non-empty string." };
          },
          default: "p"
        }), t("forced_root_block_attrs", {
          processor: "object",
          default: {}
        }), t("newline_behavior", {
          processor: (r) => {
            const c = Lt(["block", "linebreak", "invert", "default"], r);
            return c ? { value: r, valid: c } : { valid: !1, message: "Must be one of: block, linebreak, invert or default." };
          },
          default: "default"
        }), t("br_newline_selector", {
          processor: "string",
          default: ".mce-toc h2,figcaption,caption"
        }), t("no_newline_selector", {
          processor: "string",
          default: ""
        }), t("keep_styles", {
          processor: "boolean",
          default: !0
        }), t("end_container_on_empty_block", {
          processor: (r) => Yt(r) ? { valid: !0, value: r } : U(r) ? { valid: !0, value: r } : { valid: !1, message: "Must be boolean or a string" },
          default: "blockquote"
        }), t("font_size_style_values", {
          processor: "string",
          default: "xx-small,x-small,small,medium,large,x-large,xx-large"
        }), t("font_size_legacy_values", {
          processor: "string",
          // See: http://www.w3.org/TR/CSS2/fonts.html#propdef-font-size
          default: "xx-small,small,medium,large,x-large,xx-large,300%"
        }), t("font_size_classes", {
          processor: "string",
          default: ""
        }), t("automatic_uploads", {
          processor: "boolean",
          default: !0
        }), t("images_reuse_filename", {
          processor: "boolean",
          default: !1
        }), t("images_replace_blob_uris", {
          processor: "boolean",
          default: !0
        }), t("icons", {
          processor: "string",
          default: ""
        }), t("icons_url", {
          processor: "string",
          default: ""
        }), t("images_upload_url", {
          processor: "string",
          default: ""
        }), t("images_upload_base_path", {
          processor: "string",
          default: ""
        }), t("images_upload_credentials", {
          processor: "boolean",
          default: !1
        }), t("images_upload_handler", {
          processor: "function"
        }), t("language", {
          processor: "string",
          default: "en"
        }), t("language_url", {
          processor: "string",
          default: ""
        }), t("entity_encoding", {
          processor: "string",
          default: "named"
        }), t("indent", {
          processor: "boolean",
          default: !0
        }), t("indent_before", {
          processor: "string",
          default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
        }), t("indent_after", {
          processor: "string",
          default: "p,h1,h2,h3,h4,h5,h6,blockquote,div,title,style,pre,script,td,th,ul,ol,li,dl,dt,dd,area,table,thead,tfoot,tbody,tr,section,details,summary,article,hgroup,aside,figure,figcaption,option,optgroup,datalist"
        }), t("indent_use_margin", {
          processor: "boolean",
          default: !1
        }), t("indentation", {
          processor: "string",
          default: "40px"
        }), t("content_css", {
          processor: (r) => {
            const c = r === !1 || U(r) || an(r, U);
            return c ? U(r) ? { value: en(r.split(","), _s), valid: c } : Ot(r) ? { value: r, valid: c } : r === !1 ? { value: [], valid: c } : { value: r, valid: c } : { valid: !1, message: "Must be false, a string or an array of strings." };
          },
          default: G1(e) ? [] : ["default"]
        }), t("content_style", {
          processor: "string"
        }), t("content_css_cors", {
          processor: "boolean",
          default: !1
        }), t("font_css", {
          processor: (r) => {
            const c = U(r) || an(r, U);
            return c ? { value: Ot(r) ? r : en(r.split(","), _s), valid: c } : { valid: !1, message: "Must be a string or an array of strings." };
          },
          default: []
        }), t("extended_mathml_attributes", {
          processor: "string[]"
        }), t("extended_mathml_elements", {
          processor: "string[]"
        }), t("inline_boundaries", {
          processor: "boolean",
          default: !0
        }), t("inline_boundaries_selector", {
          processor: "string",
          default: "a[href],code,span.mce-annotation"
        }), t("object_resizing", {
          processor: (r) => {
            const c = Yt(r) || U(r);
            return c ? r === !1 || ov.isiPhone() || ov.isiPad() ? { value: "", valid: c } : { value: r === !0 ? "table,img,figure.image,div,video,iframe" : r, valid: c } : { valid: !1, message: "Must be boolean or a string" };
          },
          // No nice way to do object resizing on touch devices at this stage
          default: !sv
        }), t("resize_img_proportional", {
          processor: "boolean",
          default: !0
        }), t("event_root", {
          processor: "string"
        }), t("service_message", {
          processor: "string"
        }), t("onboarding", {
          processor: "boolean",
          default: !0
        }), t("tiny_cloud_entry_url", {
          processor: "string"
        }), t("theme", {
          processor: (r) => r === !1 || U(r) || se(r),
          default: "silver"
        }), t("theme_url", {
          processor: "string"
        }), t("formats", {
          processor: "object"
        }), t("format_empty_lines", {
          processor: "boolean",
          default: !1
        }), t("format_noneditable_selector", {
          processor: "string",
          default: ""
        }), t("preview_styles", {
          processor: (r) => {
            const c = r === !1 || U(r);
            return c ? { value: r === !1 ? "" : r, valid: c } : { valid: !1, message: "Must be false or a string" };
          },
          default: "font-family font-size font-weight font-style text-decoration text-transform color background-color border border-radius outline text-shadow"
        }), t("custom_ui_selector", {
          processor: "string",
          default: ""
        }), t("hidden_input", {
          processor: "boolean",
          default: !0
        }), t("submit_patch", {
          processor: "boolean",
          default: !0
        }), t("encoding", {
          processor: "string"
        }), t("add_form_submit_trigger", {
          processor: "boolean",
          default: !0
        }), t("add_unload_trigger", {
          processor: "boolean",
          default: !0
        }), t("custom_undo_redo_levels", {
          processor: "number",
          default: 0
        }), t("disable_nodechange", {
          processor: "boolean",
          default: !1
        }), t("disabled", {
          processor: (r) => Yt(r) ? (e.initialized && ou(e) !== r && Promise.resolve().then(() => {
            r5(e, r);
          }), { valid: !0, value: r }) : { valid: !1, message: "The value must be a boolean." },
          default: !1
        }), t("readonly", {
          processor: "boolean",
          default: !1
        }), t("editable_root", {
          processor: "boolean",
          default: !0
        }), t("plugins", {
          processor: "string[]",
          default: []
        }), t("external_plugins", {
          processor: "object"
        }), t("forced_plugins", {
          processor: "string[]"
        }), t("model", {
          processor: "string",
          default: e.hasPlugin("rtc") ? "plugin" : "dom"
        }), t("model_url", {
          processor: "string"
        }), t("block_unsupported_drop", {
          processor: "boolean",
          default: !0
        }), t("visual", {
          processor: "boolean",
          default: !0
        }), t("visual_table_class", {
          processor: "string",
          default: "mce-item-table"
        }), t("visual_anchor_class", {
          processor: "string",
          default: "mce-item-anchor"
        }), t("iframe_aria_text", {
          processor: "string",
          default: "Rich Text Area".concat(e.hasPlugin("help") ? ". Press ALT-0 for help." : "")
        }), t("setup", {
          processor: "function"
        }), t("init_instance_callback", {
          processor: "function"
        }), t("url_converter", {
          processor: "function",
          // Note: Don't bind here, as the binding is handled via the `url_converter_scope`
          // eslint-disable-next-line @typescript-eslint/unbound-method
          default: e.convertURL
        }), t("url_converter_scope", {
          processor: "object",
          default: e
        }), t("urlconverter_callback", {
          processor: "function"
        }), t("allow_conditional_comments", {
          processor: "boolean",
          default: !1
        }), t("allow_html_data_urls", {
          processor: "boolean",
          default: !1
        }), t("allow_svg_data_urls", {
          processor: "boolean"
        }), t("allow_html_in_named_anchor", {
          processor: "boolean",
          default: !1
        }), t("allow_html_in_comments", {
          processor: "boolean",
          default: !1
        }), t("allow_script_urls", {
          processor: "boolean",
          default: !1
        }), t("allow_unsafe_link_target", {
          processor: "boolean",
          default: !1
        }), t("allow_mathml_annotation_encodings", {
          processor: (r) => {
            const c = an(r, U);
            return c ? { value: r, valid: c } : { valid: !1, message: "Must be an array of strings." };
          },
          default: []
        }), t("convert_fonts_to_spans", {
          processor: "boolean",
          default: !0,
          deprecated: !0
        }), t("fix_list_elements", {
          processor: "boolean",
          default: !1
        }), t("preserve_cdata", {
          processor: "boolean",
          default: !1
        }), t("remove_trailing_brs", {
          processor: "boolean",
          default: !0
        }), t("pad_empty_with_br", {
          processor: "boolean",
          default: !1
        }), t("inline_styles", {
          processor: "boolean",
          default: !0,
          deprecated: !0
        }), t("element_format", {
          processor: "string",
          default: "html"
        }), t("entities", {
          processor: "string"
        }), t("schema", {
          processor: "string",
          default: "html5"
        }), t("convert_urls", {
          processor: "boolean",
          default: !0
        }), t("relative_urls", {
          processor: "boolean",
          default: !0
        }), t("remove_script_host", {
          processor: "boolean",
          default: !0
        }), t("custom_elements", {
          processor: Af
        }), t("extended_valid_elements", {
          processor: "string"
        }), t("invalid_elements", {
          processor: "string"
        }), t("invalid_styles", {
          processor: Af
        }), t("valid_children", {
          processor: "string"
        }), t("valid_classes", {
          processor: Af
        }), t("valid_elements", {
          processor: "string"
        }), t("valid_styles", {
          processor: Af
        }), t("verify_html", {
          processor: "boolean",
          default: !0
        }), t("auto_focus", {
          processor: (r) => U(r) || r === !0
        }), t("browser_spellcheck", {
          processor: "boolean",
          default: !1
        }), t("protect", {
          processor: "array"
        }), t("images_file_types", {
          processor: "string",
          default: "jpeg,jpg,jpe,jfi,jif,jfif,png,gif,bmp,webp"
        }), t("deprecation_warnings", {
          processor: "boolean",
          default: !0
        }), t("a11y_advanced_options", {
          processor: "boolean",
          default: !1
        }), t("api_key", {
          processor: "string"
        }), t("license_key", {
          processor: "string"
        }), t("paste_block_drop", {
          processor: "boolean",
          default: !1
        }), t("paste_data_images", {
          processor: "boolean",
          default: !0
        }), t("paste_preprocess", {
          processor: "function"
        }), t("paste_postprocess", {
          processor: "function"
        }), t("paste_webkit_styles", {
          processor: "string",
          default: "none"
        }), t("paste_remove_styles_if_webkit", {
          processor: "boolean",
          default: !0
        }), t("paste_merge_formats", {
          processor: "boolean",
          default: !0
        }), t("smart_paste", {
          processor: "boolean",
          default: !0
        }), t("paste_as_text", {
          processor: "boolean",
          default: !1
        }), t("paste_tab_spaces", {
          processor: "number",
          default: 4
        }), t("text_patterns", {
          processor: (r) => an(r, Ye) || r === !1 ? { value: _w(r === !1 ? [] : r), valid: !0 } : { valid: !1, message: "Must be an array of objects or false." },
          default: [
            { start: "*", end: "*", format: "italic" },
            { start: "**", end: "**", format: "bold" },
            { start: "#", format: "h1", trigger: "space" },
            { start: "##", format: "h2", trigger: "space" },
            { start: "###", format: "h3", trigger: "space" },
            { start: "####", format: "h4", trigger: "space" },
            { start: "#####", format: "h5", trigger: "space" },
            { start: "######", format: "h6", trigger: "space" },
            { start: "1.", cmd: "InsertOrderedList", trigger: "space" },
            { start: "*", cmd: "InsertUnorderedList", trigger: "space" },
            { start: "-", cmd: "InsertUnorderedList", trigger: "space" },
            { start: ">", cmd: "mceBlockQuote", trigger: "space" },
            { start: "---", cmd: "InsertHorizontalRule", trigger: "space" }
          ]
        }), t("text_patterns_lookup", {
          processor: (r) => se(r) ? {
            value: Ck(r),
            valid: !0
          } : { valid: !1, message: "Must be a single function" },
          default: (r) => []
        }), t("noneditable_class", {
          processor: "string",
          default: "mceNonEditable"
        }), t("editable_class", {
          processor: "string",
          default: "mceEditable"
        }), t("noneditable_regexp", {
          processor: (r) => an(r, av) ? { value: r, valid: !0 } : av(r) ? { value: [r], valid: !0 } : { valid: !1, message: "Must be a RegExp or an array of RegExp." },
          default: []
        }), t("table_tab_navigation", {
          processor: "boolean",
          default: !0
        }), t("highlight_on_focus", {
          processor: "boolean",
          default: !0
        }), t("xss_sanitization", {
          processor: "boolean",
          default: !0
        }), t("details_initial_state", {
          processor: (r) => {
            const c = Lt(["inherited", "collapsed", "expanded"], r);
            return c ? { value: r, valid: c } : { valid: !1, message: "Must be one of: inherited, collapsed, or expanded." };
          },
          default: "inherited"
        }), t("details_serialized_state", {
          processor: (r) => {
            const c = Lt(["inherited", "collapsed", "expanded"], r);
            return c ? { value: r, valid: c } : { valid: !1, message: "Must be one of: inherited, collapsed, or expanded." };
          },
          default: "inherited"
        }), t("init_content_sync", {
          processor: "boolean",
          default: !1
        }), t("newdocument_content", {
          processor: "string",
          default: ""
        }), t("sandbox_iframes", {
          processor: "boolean",
          default: !0
        }), t("sandbox_iframes_exclusions", {
          processor: "string[]",
          default: [
            "youtube.com",
            "youtu.be",
            "vimeo.com",
            "player.vimeo.com",
            "dailymotion.com",
            "embed.music.apple.com",
            "open.spotify.com",
            "giphy.com",
            "dai.ly",
            "codepen.io"
          ]
        }), t("convert_unsafe_embeds", {
          processor: "boolean",
          default: !0
        }), t("user_id", {
          processor: "string",
          default: "Anonymous"
        }), t("fetch_users", {
          processor: (r) => r === void 0 ? { valid: !0, value: void 0 } : se(r) ? { valid: !0, value: r } : {
            valid: !1,
            message: "fetch_users must be a function that returns a Promise<ExpectedUser[]>"
          }
        });
        const o = F1([
          oC("mimeType"),
          gk("extensions", ev((r) => U(r) ? xr.value(r) : xr.error("Extensions must be an array of strings")))
        ]);
        t("documents_file_types", {
          processor: (r) => np("documents_file_types", o, r).fold((c) => ({
            valid: !1,
            message: "Must be a non-empty array of objects matching the configuration schema: https://www.tiny.cloud/docs/tinymce/latest/uploadcare-documents/#documents-file-types"
          }), (c) => ({ valid: !0, value: c }))
        }), e.on("ScriptsLoaded", () => {
          t("directionality", {
            processor: "string",
            default: pl.isRtl() ? "rtl" : void 0
          }), t("placeholder", {
            processor: "string",
            // Fallback to the original elements placeholder if not set in the settings
            default: j1.getAttrib(e.getElement(), "placeholder")
          });
        }), t("lists_indent_on_tab", {
          processor: "boolean",
          default: !0
        }), t("list_max_depth", {
          processor: (r) => {
            const c = ns(r);
            if (c) {
              if (r < 0)
                throw new Error("list_max_depth cannot be set to lower than 0");
              return { value: r, valid: c };
            } else
              return { valid: !1, message: "Must be a number" };
          }
        });
      }, Hw = Rt("iframe_attrs"), uC = Rt("doctype"), dC = Rt("document_base_url"), zw = Rt("body_id"), Vw = Rt("body_class"), Uw = Rt("content_security_policy"), cv = Rt("br_in_pre"), Ar = Rt("forced_root_block"), nu = Rt("forced_root_block_attrs"), lv = Rt("newline_behavior"), jw = Rt("br_newline_selector"), Ww = Rt("no_newline_selector"), Zw = Rt("keep_styles"), iv = Rt("end_container_on_empty_block"), mC = Rt("automatic_uploads"), Gw = Rt("images_reuse_filename"), qw = Rt("images_replace_blob_uris"), Z1 = Rt("icons"), fC = Rt("icons_url"), uv = Rt("images_upload_url"), gC = Rt("images_upload_base_path"), wk = Rt("images_upload_credentials"), Kw = Rt("images_upload_handler"), Yw = Rt("content_css_cors"), dv = Rt("referrer_policy"), Bg = Rt("crossorigin"), Xw = Rt("language"), Qw = Rt("language_url"), mv = Rt("indent_use_margin"), Ek = Rt("indentation"), Tk = Rt("content_css"), $g = Rt("content_style"), hC = Rt("font_css"), kk = Rt("directionality"), Ak = Rt("inline_boundaries_selector"), Jw = Rt("object_resizing"), _k = Rt("resize_img_proportional"), pC = Rt("placeholder"), fv = Rt("event_root"), bC = Rt("service_message"), Od = Rt("theme"), eE = Rt("theme_url"), gv = Rt("model"), Ok = Rt("model_url"), _f = Rt("inline_boundaries"), Dk = Rt("formats"), Rk = Rt("preview_styles"), a5 = Rt("format_empty_lines"), c5 = Rt("format_noneditable_selector"), rp = Rt("custom_ui_selector"), G1 = Rt("inline"), vC = Rt("hidden_input"), Nk = Rt("submit_patch"), Mk = Rt("add_form_submit_trigger"), hv = Rt("add_unload_trigger"), tE = Rt("custom_undo_redo_levels"), nE = Rt("disable_nodechange"), q1 = Rt("readonly"), pv = Rt("editable_root"), yC = Rt("content_css_cors"), K1 = Rt("plugins"), CC = Rt("external_plugins"), Pk = Rt("block_unsupported_drop"), Y1 = Rt("visual"), oE = Rt("visual_table_class"), bv = Rt("visual_anchor_class"), vv = Rt("iframe_aria_text"), Ig = Rt("setup"), Bk = Rt("init_instance_callback"), Dd = Rt("urlconverter_callback"), $k = Rt("auto_focus"), sE = Rt("browser_spellcheck"), Ik = Rt("protect"), l5 = Rt("paste_block_drop"), yv = Rt("paste_data_images"), Fk = Rt("paste_preprocess"), Lk = Rt("paste_postprocess"), Hk = Rt("newdocument_content"), xC = Rt("paste_webkit_styles"), zk = Rt("paste_remove_styles_if_webkit"), rE = Rt("paste_merge_formats"), SC = Rt("smart_paste"), Vk = Rt("paste_as_text"), Uk = Rt("paste_tab_spaces"), wC = Rt("allow_html_data_urls"), aE = Rt("text_patterns"), Xt = Rt("text_patterns_lookup"), X1 = Rt("noneditable_class"), cE = Rt("editable_class"), jk = Rt("noneditable_regexp"), EC = Rt("preserve_cdata"), Q1 = Rt("highlight_on_focus"), Cv = Rt("xss_sanitization"), J1 = Rt("init_content_sync"), ap = (e) => e.options.isSet("text_patterns_lookup"), TC = (e) => Je.explode(e.options.get("font_size_style_values")), kC = (e) => Je.explode(e.options.get("font_size_classes")), lE = (e) => e.options.get("encoding") === "xml", AC = (e) => Je.explode(e.options.get("images_file_types")), iE = Rt("table_tab_navigation"), cp = Rt("details_initial_state"), xm = Rt("details_serialized_state"), lp = Rt("sandbox_iframes"), Sm = (e) => e.options.get("sandbox_iframes_exclusions"), wm = Rt("convert_unsafe_embeds"), uE = Rt("license_key"), eb = Rt("api_key"), ou = Rt("disabled"), dE = Rt("user_id"), mE = Rt("fetch_users"), _C = Rt("lists_indent_on_tab"), OC = (e) => P.from(e.options.get("list_max_depth")), fE = ht, gE = tt, Wk = (e) => {
        const t = e.parentNode;
        t && t.removeChild(e);
      }, hE = (e) => {
        const t = Gc(e);
        return {
          count: e.length - t.length,
          text: t
        };
      }, Fg = (e) => {
        let t;
        for (; (t = e.data.lastIndexOf(Ur)) !== -1; )
          e.deleteData(t, 1);
      }, DC = (e, t) => (Lg(e), t), pE = (e, t) => {
        const o = hE(e.data.substr(0, t.offset())), r = hE(e.data.substr(t.offset()));
        return (o.text + r.text).length > 0 ? (Fg(e), Re(e, t.offset() - o.count)) : t;
      }, RC = (e, t) => {
        const o = t.container(), r = ur(rs(o.childNodes), e).map((c) => c < t.offset() ? Re(o, t.offset() - 1) : t).getOr(t);
        return Lg(e), r;
      }, NC = (e, t) => gE(e) && t.container() === e ? pE(e, t) : DC(e, t), MC = (e, t) => t.container() === e.parentNode ? RC(e, t) : DC(e, t), Zk = (e, t) => Re.isTextPosition(t) ? NC(e, t) : MC(e, t), Lg = (e) => {
        fE(e) && jl(e) && (I0(e) ? e.removeAttribute("data-mce-caret") : Wk(e)), gE(e) && (Fg(e), e.data.length === 0 && Wk(e));
      }, Hg = Es, xv = vi, Sv = _h, bE = "*[contentEditable=false],video,audio,embed,object", Gk = (e, t, o) => {
        const r = _1(t.getBoundingClientRect(), o);
        let c, u;
        if (e.tagName === "BODY") {
          const b = e.ownerDocument.documentElement;
          c = e.scrollLeft || b.scrollLeft, u = e.scrollTop || b.scrollTop;
        } else {
          const b = e.getBoundingClientRect();
          c = e.scrollLeft - b.left, u = e.scrollTop - b.top;
        }
        r.left += c, r.right += c, r.top += u, r.bottom += u, r.width = 1;
        let f = t.offsetWidth - t.clientWidth;
        return f > 0 && (o && (f *= -1), r.left += f, r.right += f), r;
      }, vE = (e) => {
        const t = Ne(te.fromDom(e), bE);
        for (let o = 0; o < t.length; o++) {
          const r = t[o].dom;
          let c = r.previousSibling;
          if (yf(c)) {
            const u = c.data;
            u.length === 1 ? c.parentNode?.removeChild(c) : c.deleteData(u.length - 1, 1);
          }
          c = r.nextSibling, bl(c) && (c.data.length === 1 ? c.parentNode?.removeChild(c) : c.deleteData(0, 1));
        }
      }, An = (e, t, o, r) => {
        const c = Mc();
        let u, f;
        const b = Ar(e), v = e.dom, S = (W, Q) => {
          let ge;
          if (O(), Sv(Q))
            return null;
          if (o(Q)) {
            const be = B2(b, Q, W), ve = Gk(t, Q, W);
            v.setStyle(be, "top", ve.top), v.setStyle(be, "caret-color", "transparent"), f = be;
            const Be = v.create("div", { class: "mce-visual-caret", "data-mce-bogus": "all" });
            v.setStyles(Be, { ...ve }), v.add(t, Be), c.set({ caret: Be, element: Q, before: W }), W && v.addClass(Be, "mce-visual-caret-before"), R(), ge = Q.ownerDocument.createRange(), ge.setStart(be, 0), ge.setEnd(be, 0);
          } else
            return f = dw(Q, W), ge = Q.ownerDocument.createRange(), Wl(f.nextSibling) ? (ge.setStart(f, 0), ge.setEnd(f, 0)) : (ge.setStart(f, 1), ge.setEnd(f, 1)), ge;
          return ge;
        }, O = () => {
          vE(t), f && (Lg(f), f = null), c.on((W) => {
            v.remove(W.caret), c.clear();
          }), u && (clearInterval(u), u = void 0);
        }, R = () => {
          u = window.setInterval(() => {
            c.on((W) => {
              r() ? v.toggleClass(W.caret, "mce-visual-caret-hidden") : v.addClass(W.caret, "mce-visual-caret-hidden");
            });
          }, 500);
        }, M = () => {
          c.on((W) => {
            const Q = Gk(t, W.element, W.before);
            v.setStyles(W.caret, { ...Q });
          });
        }, H = () => clearInterval(u), J = () => ".mce-visual-caret {position: absolute;background-color: black;background-color: currentcolor;}.mce-visual-caret-hidden {display: none;}*[data-mce-caret] {position: absolute;left: -1000px;right: auto;top: 0;margin: 0;padding: 0;}";
        return {
          isShowing: c.isSet,
          show: S,
          hide: O,
          getCss: J,
          reposition: M,
          destroy: H
        };
      }, wv = () => fo.browser.isFirefox(), Wl = (e) => Hg(e) || xv(e), tb = (e) => (Wl(e) || Vc(e) && wv()) && Fc(te.fromDom(e)).exists(Ll), qk = dl, Ev = Es, Kk = vi, PC = f0("display", "block table table-cell table-row table-caption list-item"), BC = jl, nb = hm, zu = ht, ip = tt, Yk = Rs, zg = (e, t) => {
        let o;
        for (; o = e(t); )
          if (!nb(o))
            return o;
        return null;
      }, ob = (e, t, o, r, c) => {
        const u = new Js(e, r), f = Ev(e) || nb(e);
        let b;
        if (Td(t)) {
          if (f && (b = zg(u.prev.bind(u), !0), o(b)))
            return b;
          for (; b = zg(u.prev.bind(u), c); )
            if (o(b))
              return b;
        }
        if (Mg(t)) {
          if (f && (b = zg(u.next.bind(u), !0), o(b)))
            return b;
          for (; b = zg(u.next.bind(u), c); )
            if (o(b))
              return b;
        }
        return null;
      }, Tv = (e, t) => {
        const o = (c) => qk(c.dom), r = (c) => c.dom === t;
        return Wi(te.fromDom(e), o, r).map((c) => c.dom).getOr(t);
      }, Wr = (e) => ht(e) && Ls(te.fromDom(e), "position") === "absolute", Xk = (e, t) => e.parentNode !== t, $C = (e, t) => Ev(e) && Wr(e) && Xk(e, t), Of = (e, t) => {
        for (; e && e !== t; ) {
          if (PC(e) && !$C(e, t))
            return e;
          e = e.parentNode;
        }
        return null;
      }, Rd = (e, t, o) => Of(e.container(), o) === Of(t.container(), o), IC = (e, t) => {
        if (!t)
          return P.none();
        const o = t.container(), r = t.offset();
        return zu(o) ? P.from(o.childNodes[r + e]) : P.none();
      }, yE = (e, t) => {
        const r = (t.ownerDocument ?? document).createRange();
        return e ? (r.setStartBefore(t), r.setEndBefore(t)) : (r.setStartAfter(t), r.setEndAfter(t)), r;
      }, Qk = (e, t, o) => Of(t, e) === Of(o, e), kv = (e, t, o) => {
        const r = e ? "previousSibling" : "nextSibling";
        let c = o;
        for (; c && c !== t; ) {
          let u = c[r];
          if (u && BC(u) && (u = u[r]), Ev(u) || Kk(u)) {
            if (Qk(t, u, c))
              return u;
            break;
          }
          if (Yk(u))
            break;
          c = c.parentNode;
        }
        return null;
      }, sb = ue(yE, !0), Df = ue(yE, !1), Av = (e, t, o) => {
        let r;
        const c = ue(kv, !0, t), u = ue(kv, !1, t), f = o.startContainer, b = o.startOffset;
        if (hm(f)) {
          const v = ip(f) ? f.parentNode : f, S = v.getAttribute("data-mce-caret");
          if (S === "before" && (r = v.nextSibling, tb(r)))
            return sb(r);
          if (S === "after" && (r = v.previousSibling, tb(r)))
            return Df(r);
        }
        if (!o.collapsed)
          return o;
        if (tt(f)) {
          if (BC(f)) {
            if (e === 1) {
              if (r = u(f), r)
                return sb(r);
              if (r = c(f), r)
                return Df(r);
            }
            if (e === -1) {
              if (r = c(f), r)
                return Df(r);
              if (r = u(f), r)
                return sb(r);
            }
            return o;
          }
          if (yf(f) && b >= f.data.length - 1)
            return e === 1 && (r = u(f), r) ? sb(r) : o;
          if (bl(f) && b <= 1)
            return e === -1 && (r = c(f), r) ? Df(r) : o;
          if (b === f.data.length)
            return r = u(f), r ? sb(r) : o;
          if (b === 0)
            return r = c(f), r ? Df(r) : o;
        }
        return o;
      }, _v = (e, t) => IC(e ? 0 : -1, t).filter(Ev), Rf = (e, t, o) => {
        const r = Av(e, t, o);
        return e === -1 ? Re.fromRangeStart(r) : Re.fromRangeEnd(r);
      }, rb = (e) => P.from(e.getNode()).map(te.fromDom), FC = (e) => P.from(e.getNode(!0)).map(te.fromDom), Ov = (e, t) => {
        let o = t;
        for (; o = e(o); )
          if (o.isVisible())
            return o;
        return o;
      }, Vu = (e, t) => {
        const o = Rd(e, t);
        return !o && zs(e.getNode()) ? !0 : o;
      }, CE = Es, Nd = tt, LC = ht, Dv = zs, up = Rs, ab = hw, Rv = V0, Jk = (e, t) => {
        const o = [];
        let r = e;
        for (; r && r !== t; )
          o.push(r), r = r.parentNode;
        return o;
      }, xE = (e, t) => e.hasChildNodes() && t < e.childNodes.length ? e.childNodes[t] : null, Nv = (e, t) => {
        if (Mg(e)) {
          if (up(t.previousSibling) && !Nd(t.previousSibling))
            return Re.before(t);
          if (Nd(t))
            return Re(t, 0);
        }
        if (Td(e)) {
          if (up(t.nextSibling) && !Nd(t.nextSibling))
            return Re.after(t);
          if (Nd(t))
            return Re(t, t.data.length);
        }
        return Td(e) ? Dv(t) ? Re.before(t) : Re.after(t) : Re.before(t);
      }, eA = (e, t) => {
        const o = t.nextSibling;
        return o && up(o) ? Nd(o) ? Re(o, 0) : Re.before(o) : HC(1, Re.after(t), e);
      }, HC = (e, t, o) => {
        let r, c, u, f;
        if (!LC(o) || !t)
          return null;
        if (t.isEqual(Re.after(o)) && o.lastChild) {
          if (f = Re.after(o.lastChild), Td(e) && up(o.lastChild) && LC(o.lastChild))
            return Dv(o.lastChild) ? Re.before(o.lastChild) : f;
        } else
          f = t;
        const b = f.container();
        let v = f.offset();
        if (Nd(b)) {
          if (Td(e) && v > 0)
            return Re(b, --v);
          if (Mg(e) && v < b.length)
            return Re(b, ++v);
          r = b;
        } else {
          if (Td(e) && v > 0 && (c = xE(b, v - 1), up(c)))
            return !ab(c) && (u = ob(c, e, Rv, c), u) ? Nd(u) ? Re(u, u.data.length) : Re.after(u) : Nd(c) ? Re(c, c.data.length) : Re.before(c);
          if (Mg(e) && v < b.childNodes.length && (c = xE(b, v), up(c)))
            return Dv(c) ? eA(o, c) : !ab(c) && (u = ob(c, e, Rv, c), u) ? Nd(u) ? Re(u, 0) : Re.before(u) : Nd(c) ? Re(c, 0) : Re.after(c);
          r = c || f.getNode();
        }
        if (r && (Mg(e) && f.isAtEnd() || Td(e) && f.isAtStart()) && (r = ob(r, e, He, o, !0), Rv(r, o)))
          return Nv(e, r);
        c = r && ob(r, e, Rv, o);
        const S = ol(ze(Jk(b, o), CE));
        return S && (!c || !S.contains(c)) ? (Mg(e) ? f = Re.after(S) : f = Re.before(S), f) : c ? Nv(e, c) : null;
      }, Uu = (e) => ({
        /**
           * Returns the next logical caret position from the specified input
           * caretPosition or null if there isn't any more positions left for example
           * at the end specified root element.
           *
           * @method next
           * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
           * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
           */
        next: (t) => HC(1, t, e),
        /**
           * Returns the previous logical caret position from the specified input
           * caretPosition or null if there isn't any more positions left for example
           * at the end specified root element.
           *
           * @method prev
           * @param {tinymce.caret.CaretPosition} caretPosition Caret position to start from.
           * @return {tinymce.caret.CaretPosition} CaretPosition or null if no position was found.
           */
        prev: (t) => HC(-1, t, e)
      }), zC = (e, t, o) => {
        const r = e ? Re.before(o) : Re.after(o);
        return Zl(e, t, r);
      }, tA = (e) => zs(e) ? Re.before(e) : Re.after(e), SE = (e) => Re.isTextPosition(e) ? e.offset() === 0 : Rs(e.getNode()), wE = (e) => {
        if (Re.isTextPosition(e)) {
          const t = e.container();
          return e.offset() === t.data.length;
        } else
          return Rs(e.getNode(!0));
      }, EE = (e, t) => !Re.isTextPosition(e) && !Re.isTextPosition(t) && e.getNode() === t.getNode(!0), nA = (e) => !Re.isTextPosition(e) && zs(e.getNode()), xs = (e, t, o) => e ? !EE(t, o) && !nA(t) && wE(t) && SE(o) : !EE(o, t) && SE(t) && wE(o), Zl = (e, t, o) => {
        const r = Uu(t);
        return P.from(e ? r.next(o) : r.prev(o));
      }, dp = (e, t, o) => Zl(e, t, o).bind((r) => Rd(o, r, t) && xs(e, o, r) ? Zl(e, t, r) : P.some(r)), i = (e, t, o, r) => dp(e, t, o).bind((c) => r(c) ? i(e, t, c, r) : P.some(c)), m = (e, t) => {
        const o = e ? t.firstChild : t.lastChild;
        return tt(o) ? P.some(Re(o, e ? 0 : o.data.length)) : o ? Rs(o) ? P.some(e ? Re.before(o) : tA(o)) : zC(e, t, o) : P.none();
      }, p = ue(Zl, !0), y = ue(Zl, !1), E = ue(m, !0), D = ue(m, !1), $ = "_mce_caret", z = (e) => ht(e) && e.id === $, K = (e, t) => {
        let o = t;
        for (; o && o !== e; ) {
          if (z(o))
            return o;
          o = o.parentNode;
        }
        return null;
      }, ce = (e) => U(e.start), Ce = (e) => kn(e, "rng"), Ge = (e) => kn(e, "id"), kt = (e) => kn(e, "name"), wt = (e) => Je.isArray(e.start), Gt = (e) => !kt(e) && Yt(e.forward) ? e.forward : !0, Fe = (e, t) => (ht(t) && e.isBlock(t) && !t.innerHTML && (t.innerHTML = '<br data-mce-bogus="1" />'), t), qe = (e, t) => {
        const o = P.from(bw(e.getRoot(), t.start)), r = P.from(bw(e.getRoot(), t.end));
        return Xs(o, r, (c, u) => {
          const f = e.createRng();
          return f.setStart(c.container(), c.offset()), f.setEnd(u.container(), u.offset()), { range: f, forward: Gt(t) };
        });
      }, dn = (e, t) => {
        const r = (e.ownerDocument ?? document).createTextNode(Ur);
        e.appendChild(r), t.setStart(r, 0), t.setEnd(r, 0);
      }, Bn = (e) => !e.hasChildNodes(), Bt = (e, t) => D(e).fold(ye, (o) => (t.setStart(o.container(), o.offset()), t.setEnd(o.container(), o.offset()), !0)), Bo = (e, t, o) => Bn(t) && K(e, t) ? (dn(t, o), !0) : !1, $o = (e, t, o, r) => {
        const c = o[t ? "start" : "end"], u = e.getRoot();
        if (c) {
          let f = u, b = c[0];
          for (let v = c.length - 1; f && v >= 1; v--) {
            const S = f.childNodes;
            if (Bo(u, f, r))
              return !0;
            if (c[v] > S.length - 1)
              return Bo(u, f, r) ? !0 : Bt(f, r);
            f = S[c[v]];
          }
          tt(f) && (b = Math.min(c[0], f.data.length)), ht(f) && (b = Math.min(c[0], f.childNodes.length)), t ? r.setStart(f, b) : r.setEnd(f, b);
        }
        return !0;
      }, Rn = (e) => tt(e) && e.data.length > 0, br = (e, t, o) => {
        const r = e.get(o.id + "_" + t), c = r?.parentNode, u = o.keep;
        if (r && c) {
          let f, b;
          if (t === "start" ? u ? r.hasChildNodes() ? (f = r.firstChild, b = 1) : Rn(r.nextSibling) ? (f = r.nextSibling, b = 0) : Rn(r.previousSibling) ? (f = r.previousSibling, b = r.previousSibling.data.length) : (f = c, b = e.nodeIndex(r) + 1) : (f = c, b = e.nodeIndex(r)) : u ? r.hasChildNodes() ? (f = r.firstChild, b = 1) : Rn(r.previousSibling) ? (f = r.previousSibling, b = r.previousSibling.data.length) : (f = c, b = e.nodeIndex(r)) : (f = c, b = e.nodeIndex(r)), !u) {
            const v = r.previousSibling, S = r.nextSibling;
            Je.each(Je.grep(r.childNodes), (R) => {
              tt(R) && (R.data = R.data.replace(/\uFEFF/g, ""));
            });
            let O;
            for (; O = e.get(o.id + "_" + t); )
              e.remove(O, !0);
            if (tt(S) && tt(v) && !fo.browser.isOpera()) {
              const R = v.data.length;
              v.appendData(S.data), e.remove(S), f = v, b = R;
            }
          }
          return P.some(Re(f, b));
        } else
          return P.none();
      }, wi = (e, t) => {
        const o = e.createRng();
        return $o(e, !0, t, o) && $o(e, !1, t, o) ? P.some({ range: o, forward: Gt(t) }) : P.none();
      }, Em = (e, t) => {
        const o = br(e, "start", t), r = br(e, "end", t);
        return Xs(o, r.or(o), (c, u) => {
          const f = e.createRng();
          return f.setStart(Fe(e, c.container()), c.offset()), f.setEnd(Fe(e, u.container()), u.offset()), { range: f, forward: Gt(t) };
        });
      }, Nf = (e, t) => P.from(e.select(t.name)[t.index]).map((o) => {
        const r = e.createRng();
        return r.selectNode(o), { range: r, forward: !0 };
      }), Vg = (e, t) => {
        const o = e.dom;
        if (t) {
          if (wt(t))
            return wi(o, t);
          if (ce(t))
            return qe(o, t);
          if (Ge(t))
            return Em(o, t);
          if (kt(t))
            return Nf(o, t);
          if (Ce(t))
            return P.some({ range: t.rng, forward: Gt(t) });
        }
        return P.none();
      }, Ko = (e, t, o) => Ie(e, t, o), _c = (e, t) => {
        Vg(e, t).each(({ range: o, forward: r }) => {
          e.setRng(o, r);
        });
      }, Ys = (e) => ht(e) && e.tagName === "SPAN" && e.getAttribute("data-mce-type") === "bookmark", oc = ((e) => (t) => e === t)($s), Gl = (e) => e !== "" && ` \f
\r	\v`.indexOf(e) !== -1, ka = (e) => !Gl(e) && !oc(e) && !Xa(e), Mv = (e) => {
        const t = [];
        if (e)
          for (let o = 0; o < e.rangeCount; o++)
            t.push(e.getRangeAt(o));
        return t;
      }, cb = (e) => xo(e, (t) => {
        const o = jr(t);
        return o ? [te.fromDom(o)] : [];
      }), Tm = (e) => Mv(e).length > 1, sc = (e) => ze(cb(e), kg), oA = (e) => Ne(e, "td[data-mce-selected],th[data-mce-selected]"), TE = (e, t) => {
        const o = oA(t);
        return o.length > 0 ? o : sc(e);
      }, Ft = (e) => TE(Mv(e.selection.getSel()), te.fromDom(e.getBody())), qc = (e, t) => ar(e, "table", t), sA = (e) => {
        const t = e.startContainer, o = e.startOffset;
        return tt(t) ? o === 0 ? P.some(te.fromDom(t)) : P.none() : P.from(t.childNodes[o]).map(te.fromDom);
      }, Pv = (e) => {
        const t = e.endContainer, o = e.endOffset;
        return tt(t) ? o === t.data.length ? P.some(te.fromDom(t)) : P.none() : P.from(t.childNodes[o - 1]).map(te.fromDom);
      }, kE = (e) => Ir(e).fold(ot([e]), (t) => [e].concat(kE(t))), Ug = (e) => or(e).fold(ot([e]), (t) => Hn(t) === "br" ? rl(t).map((o) => [e].concat(Ug(o))).getOr([]) : [e].concat(Ug(t))), rA = (e, t) => Xs(sA(t), Pv(t), (o, r) => {
        const c = _o(kE(e), ue(Qn, o)), u = _o(Ug(e), ue(Qn, r));
        return c.isSome() && u.isSome();
      }).getOr(!1), AE = (e, t, o, r) => {
        const c = o, u = new Js(o, c), f = Ri(e.schema.getMoveCaretBeforeOnEnterElements(), (v, S) => !Lt(["td", "th", "table"], S.toLowerCase()));
        let b = o;
        do {
          if (tt(b) && Je.trim(b.data).length !== 0) {
            r ? t.setStart(b, 0) : t.setEnd(b, b.data.length);
            return;
          }
          if (f[b.nodeName]) {
            r ? t.setStartBefore(b) : b.nodeName === "BR" ? t.setEndBefore(b) : t.setEndAfter(b);
            return;
          }
        } while (b = r ? u.next() : u.prev());
        c.nodeName === "BODY" && (r ? t.setStart(c, 0) : t.setEnd(c, c.childNodes.length));
      }, VC = (e) => {
        const t = e.selection.getSel();
        return X(t) && t.rangeCount > 0;
      }, UC = (e, t) => {
        const o = Ft(e);
        o.length > 0 ? xe(o, (r) => {
          const c = r.dom, u = e.dom.createRng();
          u.setStartBefore(c), u.setEndAfter(c), t(u, !0);
        }) : t(e.selection.getRng(), !1);
      }, _E = (e, t, o) => {
        const r = q2(e, t);
        o(r), e.moveToBookmark(r);
      }, jC = (e, t) => e.startContainer === e.endContainer && e.endOffset - e.startOffset === 1 && t(e.startContainer.childNodes[e.startOffset]), b7 = (e) => jC(e, zc), v7 = (e) => jC(e, tt), y7 = (e) => jC(e, u1), WC = (e) => ns(e?.nodeType), ZC = (e) => ht(e) && !Ys(e) && !z(e) && !uf(e), i5 = (e, t) => {
        if (ZC(t) && !/^(TD|TH)$/.test(t.nodeName)) {
          const o = e.getAttrib(t, "data-mce-selected"), r = parseInt(o, 10);
          return !isNaN(r) && r > 0;
        } else
          return !1;
      }, u5 = (e, t, o) => {
        const { selection: r, dom: c } = e, u = r.getNode(), f = Es(u);
        _E(r, !0, () => {
          t();
        }), f && Es(u) && c.isChildOf(u, e.getBody()) ? e.selection.select(u) : o(r.getStart()) && d5(c, r);
      }, d5 = (e, t) => {
        const o = t.getRng(), { startContainer: r, startOffset: c } = o, u = t.getNode();
        if (!i5(e, u) && ht(r)) {
          const f = r.childNodes, b = e.getRoot();
          let v;
          if (c < f.length) {
            const S = f[c];
            v = new Js(S, e.getParent(S, e.isBlock) ?? b);
          } else {
            const S = f[f.length - 1];
            v = new Js(S, e.getParent(S, e.isBlock) ?? b), v.next(!0);
          }
          for (let S = v.current(); S; S = v.next()) {
            if (e.getContentEditable(S) === "false")
              return;
            if (tt(S) && !aA(S)) {
              o.setStart(S, 0), t.setRng(o);
              return;
            }
          }
        }
      }, m5 = (e, t, o) => {
        if (e) {
          const r = t ? "nextSibling" : "previousSibling";
          for (e = e[r]; e; e = e[r])
            if (ht(e) || !aA(e))
              return e;
        }
      }, GC = (e, t) => !!e.getTextBlockElements()[t.nodeName.toLowerCase()] || qs(e, t), Bv = (e, t, o) => e.schema.isValidChild(t, o), aA = (e, t = !1) => {
        if (X(e) && tt(e)) {
          const o = t ? e.data.replace(/ /g, " ") : e.data;
          return Th(o);
        } else
          return !1;
      }, C7 = (e) => X(e) && tt(e) && e.length === 0, x7 = (e, t) => {
        const o = "[data-mce-cef-wrappable]", r = c5(e), c = ti(r) ? o : `${o},${r}`;
        return Ic(te.fromDom(t), c);
      }, f5 = (e, t) => {
        const o = e.dom;
        return ZC(t) && o.getContentEditable(t) === "false" && x7(e, t) && o.select('[contenteditable="true"]', t).length === 0;
      }, jg = (e, t) => se(e) ? e(t) : (X(t) && (e = e.replace(/%(\w+)/g, (o, r) => t[r] || o)), e), qC = (e, t) => (e = e || "", t = t || "", e = "" + (e.nodeName || e), t = "" + (t.nodeName || t), e.toLowerCase() === t.toLowerCase()), OE = (e, t) => {
        if (jt(e))
          return null;
        {
          let o = String(e);
          return (t === "color" || t === "backgroundColor") && (o = Ci(o)), t === "fontWeight" && e === 700 && (o = "bold"), t === "fontFamily" && (o = o.replace(/[\'\"]/g, "").replace(/,\s+/g, ",")), o;
        }
      }, KC = (e, t, o) => {
        const r = e.getStyle(t, o);
        return OE(r, o);
      }, g5 = (e, t) => {
        let o;
        return e.getParent(t, (r) => ht(r) ? (o = e.getStyle(r, "text-decoration"), !!o && o !== "none") : !1), o;
      }, DE = (e, t, o) => e.getParents(t, o, e.getRoot()), cA = (e, t, o) => {
        const r = e.formatter.get(t);
        return X(r) && po(r, o);
      }, RE = (e, t) => cA(e, t, (r) => {
        const c = (u) => se(u) || u.length > 1 && u.charAt(0) === "%";
        return po(["styles", "attributes"], (u) => Wo(r, u).exists((f) => {
          const b = Ot(f) ? f : Pa(f);
          return po(b, c);
        }));
      }), h5 = (e, t, o) => {
        const r = ["inline", "block", "selector", "attributes", "styles", "classes"], c = (u) => Ri(u, (f, b) => po(r, (v) => v === b));
        return cA(e, t, (u) => {
          const f = c(u);
          return cA(e, o, (b) => {
            const v = c(b);
            return rd(f, v);
          });
        });
      }, km = (e) => Zo(e, "block"), S7 = (e) => km(e) && e.wrapper === !0, w7 = (e) => km(e) && e.wrapper !== !0, Md = (e) => Zo(e, "selector"), Va = (e) => Zo(e, "inline"), BY = (e) => Md(e) && Va(e) && Ho(Wo(e, "mixed"), !0), lA = (e) => Md(e) && e.expand !== !1 && !Va(e), $Y = (e) => {
        const t = [];
        let o = e;
        for (; o; ) {
          if (tt(o) && o.data !== Ur || o.childNodes.length > 1)
            return [];
          ht(o) && t.push(o), o = o.firstChild;
        }
        return t;
      }, p5 = (e) => $Y(e).length > 0, iA = (e) => z(e.dom) && p5(e.dom), YC = Ys, b5 = DE, Ns = aA, uA = GC, NE = (e) => zs(e) && e.getAttribute("data-mce-bogus") && !e.nextSibling, XC = (e, t) => {
        let o = t;
        for (; o; ) {
          if (ht(o) && e.getContentEditable(o))
            return e.getContentEditable(o) === "false" ? o : t;
          o = o.parentNode;
        }
        return t;
      }, Mf = (e, t, o, r) => {
        const c = t.data;
        if (e) {
          for (let u = o; u > 0; u--)
            if (r(c.charAt(u - 1)))
              return u;
        } else
          for (let u = o; u < c.length; u++)
            if (r(c.charAt(u)))
              return u;
        return -1;
      }, ME = (e, t, o) => Mf(e, t, o, (r) => oc(r) || Gl(r)), $v = (e, t, o) => Mf(e, t, o, ka), dA = (e, t, o, r, c, u) => {
        let f;
        const b = e.getParent(o, (R) => im(R) || e.isBlock(R)), v = X(b) ? b : t, S = (R, M, H) => {
          const J = wd(e), W = c ? J.backwards : J.forwards;
          return P.from(W(R, M, (Q, ge) => YC(Q.parentNode) ? -1 : (f = Q, H(c, Q, ge)), v));
        };
        return S(o, r, ME).bind((R) => u ? S(R.container, R.offset + (c ? -1 : 0), $v) : P.some(R)).orThunk(() => f ? P.some({ container: f, offset: c ? 0 : f.length }) : P.none());
      }, v5 = (e, t, o, r, c) => {
        const u = r[c];
        tt(r) && ti(r.data) && u && (r = u);
        const f = b5(e, r);
        for (let b = 0; b < f.length; b++)
          for (let v = 0; v < t.length; v++) {
            const S = t[v];
            if (!(X(S.collapsed) && S.collapsed !== o.collapsed) && Md(S) && e.is(f[b], S.selector))
              return f[b];
          }
        return r;
      }, y5 = (e, t, o, r) => {
        let c = o;
        const u = e.getRoot(), f = t[0];
        if (km(f) && (c = f.wrapper ? null : e.getParent(o, f.block, u)), !c) {
          const b = e.getParent(o, "LI,TD,TH,SUMMARY") ?? u;
          c = e.getParent(
            tt(o) ? o.parentNode : o,
            // Fixes #6183 where it would expand to editable parent element in inline mode
            (v) => v !== u && uA(e.schema, v),
            b
          );
        }
        if (c && km(f) && f.wrapper && (c = b5(e, c, "ul,ol").reverse()[0] || c), !c)
          for (c = o; c && c[r] && !e.isBlock(c[r]) && (c = c[r], !qC(c, "br")); )
            ;
        return c || o;
      }, mA = (e, t, o, r) => {
        const c = o.parentNode;
        return X(o[r]) ? !1 : c === t || jt(c) || e.isBlock(c) ? !0 : mA(e, t, c, r);
      }, PE = (e, t, o, r, c, u) => {
        let f = o;
        const b = c ? "previousSibling" : "nextSibling", v = e.getRoot();
        if (tt(o) && !Ns(o) && (c ? r > 0 : r < o.data.length))
          return o;
        for (; f; ) {
          if (im(f))
            return o;
          if (!t[0].block_expand && e.isBlock(f))
            return u ? f : o;
          for (let S = f[b]; S; S = S[b]) {
            const O = tt(S) && !mA(e, v, S, b);
            if (!YC(S) && !NE(S) && !Ns(S, O))
              return f;
          }
          if (f === v || f.parentNode === v) {
            o = f;
            break;
          }
          f = f.parentNode;
        }
        return o;
      }, BE = (e) => YC(e.parentNode) || YC(e), Pf = (e, t, o, r = {}) => {
        const { includeTrailingSpace: c = !1, expandToBlock: u = !0 } = r, f = e.getParent(t.commonAncestorContainer, (H) => im(H)), b = X(f) ? f : e.getRoot();
        let { startContainer: v, startOffset: S, endContainer: O, endOffset: R } = t;
        const M = o[0];
        return ht(v) && v.hasChildNodes() && (v = Sf(v, S), tt(v) && (S = 0)), ht(O) && O.hasChildNodes() && (O = Sf(O, t.collapsed ? R : R - 1), tt(O) && (R = O.data.length)), v = XC(e, v), O = XC(e, O), BE(v) && (v = YC(v) ? v : v.parentNode, t.collapsed ? v = v.previousSibling || v : v = v.nextSibling || v, tt(v) && (S = t.collapsed ? v.length : 0)), BE(O) && (O = YC(O) ? O : O.parentNode, t.collapsed ? O = O.nextSibling || O : O = O.previousSibling || O, tt(O) && (R = t.collapsed ? 0 : O.length)), t.collapsed && (dA(e, b, v, S, !0, c).each(({ container: W, offset: Q }) => {
          v = W, S = Q;
        }), dA(e, b, O, R, !1, c).each(({ container: W, offset: Q }) => {
          O = W, R = Q;
        })), (Va(M) || M.block_expand) && ((!Va(M) || !tt(v) || S === 0) && (v = PE(e, o, v, S, !0, u)), (!Va(M) || !tt(O) || R === O.data.length) && (O = PE(e, o, O, R, !1, u))), lA(M) && (v = v5(e, o, t, v, "previousSibling"), O = v5(e, o, t, O, "nextSibling")), (km(M) || Md(M)) && (v = y5(e, o, v, "previousSibling"), O = y5(e, o, O, "nextSibling"), km(M) && (e.isBlock(v) || (v = PE(e, o, v, S, !0, u), tt(v) && (S = 0)), e.isBlock(O) || (O = PE(e, o, O, R, !1, u), tt(O) && (R = O.data.length)))), ht(v) && v.parentNode && (S = e.nodeIndex(v), v = v.parentNode), ht(O) && O.parentNode && (R = e.nodeIndex(O) + 1, O = O.parentNode), {
          startContainer: v,
          startOffset: S,
          endContainer: O,
          endOffset: R
        };
      }, Pd = (e, t, o) => {
        const r = t.startOffset, c = Sf(t.startContainer, r), u = t.endOffset, f = Sf(t.endContainer, u - 1), b = (W) => {
          const Q = W[0];
          tt(Q) && Q === c && r >= Q.data.length && W.splice(0, 1);
          const ge = W[W.length - 1];
          return u === 0 && W.length > 0 && ge === f && tt(ge) && W.splice(W.length - 1, 1), W;
        }, v = (W, Q, ge) => {
          const be = [];
          for (; W && W !== ge; W = W[Q])
            be.push(W);
          return be;
        }, S = (W, Q) => e.getParent(W, (ge) => ge.parentNode === Q, Q), O = (W, Q, ge) => {
          const be = ge ? "nextSibling" : "previousSibling";
          for (let ve = W, Be = ve.parentNode; ve && ve !== Q; ve = Be) {
            Be = ve.parentNode;
            const je = v(ve === W ? ve : ve[be], be);
            je.length && (ge || je.reverse(), o(b(je)));
          }
        };
        if (c === f)
          return o(b([c]));
        const R = e.findCommonAncestor(c, f) ?? e.getRoot();
        if (e.isChildOf(c, f))
          return O(c, R, !0);
        if (e.isChildOf(f, c))
          return O(f, R);
        const M = S(c, R) || c, H = S(f, R) || f;
        O(c, M, !0);
        const J = v(M === c ? M : M.nextSibling, "nextSibling", H === f ? H.nextSibling : H);
        J.length && o(b(J)), O(f, H);
      }, lb = [
        // Codesample plugin
        'pre[class*=language-][contenteditable="false"]',
        // Image plugin - captioned image
        "figure.image",
        // Mediaembed plugin
        "div[data-ephox-embed-iri]",
        // Pageembed plugin
        "div.tiny-pageembed",
        // Tableofcontents plugin
        "div.mce-toc",
        "div[data-mce-toc]",
        // Footnootes plugin
        "div.mce-footnotes"
      ], C5 = (e) => Eo(e) && xa(e) === Ur, E7 = (e, t, o, r) => Fc(t).fold(() => "skipping", (c) => r === "br" || C5(t) ? "valid" : D2(t) ? "existing" : z(t.dom) ? "caret" : po(lb, (u) => Ic(t, u)) ? "valid-block" : !Bv(e, o, r) || !Bv(e, Hn(c), o) ? "invalid-child" : "valid"), T7 = (e, t) => {
        const o = Pf(e.dom, t, [{ inline: "span" }]);
        t.setStart(o.startContainer, o.startOffset), t.setEnd(o.endContainer, o.endOffset), e.selection.setRng(t);
      }, x5 = (e, t, o, r, c, u) => {
        const { uid: f = t, ...b } = o;
        bc(e, pf()), Ss(e, `${Sd()}`, f), Ss(e, `${Yi()}`, r);
        const { attributes: v = {}, classes: S = [] } = c(f, b);
        if (ea(e, v), dg(e, S), u) {
          S.length > 0 && Ss(e, `${Uh()}`, S.join(","));
          const O = Vt(v);
          O.length > 0 && Ss(e, `${O0()}`, O.join(","));
        }
      }, k7 = (e) => {
        cr(e, pf()), sr(e, `${Sd()}`), sr(e, `${Yi()}`), sr(e, `${Vh()}`);
        const t = il(e, `${O0()}`).map((r) => r.split(",")).getOr([]), o = il(e, `${Uh()}`).map((r) => r.split(",")).getOr([]);
        xe(t, (r) => sr(e, r)), Ch(e, o), sr(e, `${Uh()}`), sr(e, `${O0()}`);
      }, S5 = (e, t, o, r, c) => {
        const u = te.fromTag("span", e);
        return x5(u, t, o, r, c, !1), u;
      }, A7 = (e, t, o, r, c, u) => {
        const f = [], b = S5(e.getDoc(), o, u, r, c), v = Mc(), S = () => {
          v.clear();
        }, O = () => v.get().getOrThunk(() => {
          const J = pr(b);
          return f.push(J), v.set(J), J;
        }), R = (J) => {
          xe(J, M);
        }, M = (J) => {
          switch (E7(e, J, "span", Hn(J))) {
            case "invalid-child": {
              S();
              const Q = Os(J);
              R(Q), S();
              break;
            }
            case "valid-block": {
              S(), x5(J, o, u, r, c, !0);
              break;
            }
            case "valid": {
              const Q = O();
              Lc(J, Q);
              break;
            }
          }
        }, H = (J) => {
          const W = en(J, te.fromDom);
          R(W);
        };
        return Pd(e.dom, t, (J) => {
          S(), H(J);
        }), f;
      }, w5 = (e, t, o, r) => {
        e.undoManager.transact(() => {
          const c = e.selection, u = c.getRng(), f = Ft(e).length > 0, b = nr("mce-annotation");
          if (u.collapsed && !f && T7(e, u), c.getRng().collapsed && !f) {
            const v = S5(e.getDoc(), b, r, t, o.decorate);
            Au(v, $s), c.getRng().insertNode(v.dom), c.select(v.dom);
          } else
            _E(c, !1, () => {
              UC(e, (v) => {
                A7(e, v, b, t, o.decorate, r);
              });
            });
        });
      }, E5 = (e) => {
        const t = N0();
        k1(e, t);
        const o = R0(e, t), r = fr("span"), c = (u) => {
          xe(u, (f) => {
            r(f) ? hc(f) : k7(f);
          });
        };
        return {
          /**
           * Registers a specific annotator by name
           *
           * @method register
           * @param {String} name the name of the annotation
           * @param {Object} settings settings for the annotation (e.g. decorate)
           */
          register: (u, f) => {
            t.register(u, f);
          },
          /**
           * Applies the annotation at the current selection using data
           *
           * @method annotate
           * @param {String} name the name of the annotation to apply
           * @param {Object} data information to pass through to this particular
           * annotation
           */
          annotate: (u, f) => {
            t.lookup(u).each((b) => {
              w5(e, u, b, f);
            });
          },
          /**
           * Executes the specified callback when the current selection matches the annotation or not.
           *
           * @method annotationChanged
           * @param {String} name Name of annotation to listen for
           * @param {Function} callback Callback with (state, name, and data) fired when the annotation
           * at the cursor changes. If state if false, data will not be provided.
           */
          annotationChanged: (u, f) => {
            o.addListener(u, f);
          },
          /**
           * Removes any annotations from the current selection that match
           * the name
           *
           * @method remove
           * @param {String} name the name of the annotation to remove
           */
          remove: (u) => {
            D0(e, P.some(u)).each(({ elements: f }) => {
              const b = e.selection.getBookmark();
              c(f), e.selection.moveToBookmark(b);
            });
          },
          /**
           * Removes all annotations that match the specified name from the entire document.
           *
           * @method removeAll
           * @param {String} name the name of the annotation to remove
           */
          removeAll: (u) => {
            const f = e.selection.getBookmark();
            Un(gm(e, u), (b, v) => {
              c(b);
            }), e.selection.moveToBookmark(f);
          },
          /**
           * Retrieve all the annotations for a given name
           *
           * @method getAll
           * @param {String} name the name of the annotations to retrieve
           * @return {Object} an index of annotations from uid => DOM nodes
           */
          getAll: (u) => {
            const f = gm(e, u);
            return lc(f, (b) => en(b, (v) => v.dom));
          }
        };
      }, Iv = (e) => ({
        /**
         * Returns a bookmark location for the current selection. This bookmark object
         * can then be used to restore the selection after some content modification to the document.
         *
         * @method getBookmark
         * @param {Number} type Optional state if the bookmark should be simple or not. Default is complex.
         * @param {Boolean} normalized Optional state that enables you to get a position that it would be after normalization.
         * @return {Object} Bookmark object, use moveToBookmark with this object to restore the selection.
         * @example
         * // Stores a bookmark of the current selection
         * const bm = tinymce.activeEditor.selection.getBookmark();
         *
         * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
         *
         * // Restore the selection bookmark
         * tinymce.activeEditor.selection.moveToBookmark(bm);
         */
        getBookmark: ue(Ko, e),
        /**
         * Restores the selection to the specified bookmark.
         *
         * @method moveToBookmark
         * @param {Object} bookmark Bookmark to restore selection from.
         * @example
         * // Stores a bookmark of the current selection
         * const bm = tinymce.activeEditor.selection.getBookmark();
         *
         * tinymce.activeEditor.setContent(tinymce.activeEditor.getContent() + 'Some new content');
         *
         * // Restore the selection bookmark
         * tinymce.activeEditor.selection.moveToBookmark(bm);
         */
        moveToBookmark: ue(_c, e)
      });
      Iv.isBookmarkNode = Ys;
      const T5 = (e, t, o) => o.collapsed ? !1 : po(o.getClientRects(), (r) => I2(r, e, t)), _7 = (e, t) => {
        const o = Eo(t) ? xa(t).length : Os(t).length + 1;
        return e > o ? o : e < 0 ? 0 : e;
      }, O7 = (e) => af.range(e.start, _7(e.soffset, e.start), e.finish, _7(e.foffset, e.finish)), Aa = (e, t) => !m0(t.dom) && (Ja(e, t) || Qn(e, t)), QC = (e) => (t) => Aa(e, t.start) && Aa(e, t.finish), rc = (e) => e.inline || fo.browser.isFirefox(), Bd = (e) => af.range(te.fromDom(e.startContainer), e.startOffset, te.fromDom(e.endContainer), e.endOffset), D7 = (e) => {
        const t = e.getSelection();
        return (!t || t.rangeCount === 0 ? P.none() : P.from(t.getRangeAt(0))).map(Bd);
      }, k5 = (e) => {
        const t = ii(e);
        return D7(t.dom).filter(QC(e));
      }, R7 = (e, t) => P.from(t).filter(QC(e)).map(O7), fA = (e) => {
        const t = document.createRange();
        try {
          return t.setStart(e.start.dom, e.soffset), t.setEnd(e.finish.dom, e.foffset), P.some(t);
        } catch {
          return P.none();
        }
      }, $E = (e) => {
        const t = rc(e) ? k5(te.fromDom(e.getBody())) : P.none();
        e.bookmark = t.isSome() ? t : e.bookmark;
      }, IE = (e) => (e.bookmark ? e.bookmark : P.none()).bind((o) => R7(te.fromDom(e.getBody()), o)).bind(fA), N7 = (e) => {
        IE(e).each((t) => e.selection.setRng(t));
      }, A5 = {
        isEditorUIElement: (e) => {
          const t = e.className.toString();
          return t.indexOf("tox-") !== -1 || t.indexOf("mce-") !== -1;
        }
      }, su = (e, t) => (ns(t) || (t = 0), window.setTimeout(e, t)), yl = (e, t) => (ns(t) || (t = 0), window.setInterval(e, t)), $d = {
        /**
         * Sets a timeout that's similar to the native browser <a href="https://developer.mozilla.org/en-US/docs/Web/API/setTimeout">setTimeout</a>
         * API, except that it checks if the editor instance is still alive when the callback gets executed.
         *
         * @method setEditorTimeout
         * @param {tinymce.Editor} editor Editor instance to check the removed state on.
         * @param {Function} callback Callback to execute when timer runs out.
         * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
         * @return {Number} Timeout id number.
         */
        setEditorTimeout: (e, t, o) => su(() => {
          e.removed || t();
        }, o),
        /**
         * Sets an interval timer that's similar to native browser <a href="https://developer.mozilla.org/en-US/docs/Web/API/setInterval">setInterval</a>
         * API, except that it checks if the editor instance is still alive when the callback gets executed.
         *
         * @method setEditorInterval
         * @param {Function} callback Callback to execute when interval time runs out.
         * @param {Number} time Optional time to wait before the callback is executed, defaults to 0.
         * @return {Number} Timeout id number.
         */
        setEditorInterval: (e, t, o) => {
          const r = yl(() => {
            e.removed ? window.clearInterval(r) : t();
          }, o);
          return r;
        }
      }, Am = (e) => e.type === "nodechange" && e.selectionChange, gA = (e, t) => {
        const o = () => {
          t.throttle();
        };
        lo.DOM.bind(document, "mouseup", o), e.on("remove", () => {
          lo.DOM.unbind(document, "mouseup", o);
        });
      }, M7 = (e, t) => {
        e.on("mouseup touchend", (o) => {
          t.throttle();
        });
      }, P7 = (e, t) => {
        M7(e, t), e.on("keyup NodeChange AfterSetSelectionRange", (o) => {
          Am(o) || $E(e);
        });
      }, _5 = (e) => {
        const t = vt(() => {
          $E(e);
        }, 0);
        e.on("init", () => {
          e.inline && gA(e, t), P7(e, t);
        }), e.on("remove", () => {
          t.cancel();
        });
      };
      let Fv;
      const FE = lo.DOM, B7 = (e) => ht(e) && A5.isEditorUIElement(e), JC = (e) => {
        const t = e.classList;
        return t !== void 0 ? t.contains("tox-edit-area") || t.contains("tox-edit-area__iframe") || t.contains("mce-content-body") : !1;
      }, LE = (e, t) => {
        const o = rp(e);
        return FE.getParent(t, (c) => B7(c) || (o ? e.dom.is(c, o) : !1)) !== null;
      }, hA = (e) => {
        try {
          const t = Fr(te.fromDom(e.getElement()));
          return $l(t).fold(() => document.body, (o) => o.dom);
        } catch {
          return document.body;
        }
      }, $7 = (e, t) => {
        const o = t.editor;
        _5(o);
        const r = (c, u) => {
          if (Q1(c) && c.inline !== !0) {
            const f = te.fromDom(c.getContainer());
            u(f, "tox-edit-focus");
          }
        };
        o.on("focusin", () => {
          const c = e.focusedEditor;
          JC(hA(o)) && r(o, bc), c !== o && (c && c.dispatch("blur", { focusedEditor: o }), e.setActive(o), e.focusedEditor = o, o.dispatch("focus", { blurredEditor: c }), o.focus(!0));
        }), o.on("focusout", () => {
          $d.setEditorTimeout(o, () => {
            const c = e.focusedEditor;
            (!JC(hA(o)) || c !== o) && r(o, cr), !LE(o, hA(o)) && c === o && (o.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
          });
        }), Fv || (Fv = (c) => {
          const u = e.activeEditor;
          u && Qp(c).each((f) => {
            const b = f;
            b.ownerDocument === document && b !== document.body && !LE(u, b) && e.focusedEditor === u && (u.dispatch("blur", { focusedEditor: null }), e.focusedEditor = null);
          });
        }, FE.bind(document, "focusin", Fv));
      }, I7 = (e, t) => {
        e.focusedEditor === t.editor && (e.focusedEditor = null), !e.activeEditor && Fv && (FE.unbind(document, "focusin", Fv), Fv = null);
      }, O5 = (e) => {
        e.on("AddEditor", ue($7, e)), e.on("RemoveEditor", ue(I7, e));
      }, pA = (e, t) => e.dom.getParent(t, (o) => e.dom.getContentEditable(o) === "true"), D5 = (e, t) => e.dom.getParent(t, (o) => e.dom.getContentEditable(o) === "false") !== null, bA = (e) => e.collapsed ? P.from(Sf(e.startContainer, e.startOffset)).map(te.fromDom) : P.none(), F7 = (e, t) => bA(t).bind((o) => P0(o) ? P.some(o) : Ja(e, o) ? P.none() : P.some(e)), L7 = (e, t) => {
        F7(te.fromDom(e.getBody()), t).bind((o) => E(o.dom)).fold(() => {
          e.selection.normalize();
        }, (o) => e.selection.setRng(o.toRange()));
      }, vA = (e) => {
        if (e.setActive)
          try {
            e.setActive();
          } catch {
            e.focus();
          }
        else
          e.focus();
      }, H7 = (e) => Hi(e) || Jp(e).isSome(), R5 = (e) => X(e.iframeElement) && Hi(te.fromDom(e.iframeElement)), z7 = (e) => {
        const t = e.getBody();
        return t && H7(te.fromDom(t));
      }, V7 = (e) => {
        const t = Fr(te.fromDom(e.getElement()));
        return $l(t).filter((o) => !JC(o.dom) && LE(e, o.dom)).isSome();
      }, Lv = (e) => e.inline ? z7(e) : R5(e), N5 = (e) => Lv(e) || V7(e), FY = (e) => {
        const t = e.selection, o = e.getBody();
        let r = t.getRng();
        e.quirks.refreshContentEditable();
        const c = (f) => {
          IE(f).each((b) => {
            f.selection.setRng(b), r = b;
          });
        };
        !Lv(e) && e.hasEditableRoot() && c(e);
        const u = pA(e, t.getNode());
        if (u && e.dom.isChildOf(u, o)) {
          D5(e, u) || vA(o), vA(u), e.hasEditableRoot() || c(e), L7(e, r), HE(e);
          return;
        }
        e.inline || (fo.browser.isOpera() || vA(o), e.getWin().focus()), (fo.browser.isFirefox() || e.inline) && (vA(o), L7(e, r)), HE(e);
      }, HE = (e) => e.editorManager.setActive(e), M5 = (e, t) => {
        e.removed || (t ? HE(e) : FY(e));
      }, Et = {
        BACKSPACE: 8,
        DELETE: 46,
        DOWN: 40,
        ENTER: 13,
        ESC: 27,
        LEFT: 37,
        RIGHT: 39,
        SPACEBAR: 32,
        TAB: 9,
        UP: 38,
        PAGE_UP: 33,
        PAGE_DOWN: 34,
        END: 35,
        HOME: 36,
        modifierPressed: (e) => e.shiftKey || e.ctrlKey || e.altKey || Et.metaKeyPressed(e),
        metaKeyPressed: (e) => fo.os.isMacOS() || fo.os.isiOS() ? e.metaKey : e.ctrlKey && !e.altKey
      }, ib = "data-mce-selected", U7 = `table,img,figure.image,hr,video,span.mce-preview-object,details,${m2}`, j7 = Math.abs, yA = Math.round, P5 = {
        // Name: x multiplier, y multiplier, delta size x, delta size y
        nw: [0, 0, -1, -1],
        ne: [1, 0, 1, -1],
        se: [1, 1, 1, 1],
        sw: [0, 1, -1, 1]
      }, W7 = (e) => e.type === "longpress" || e.type.indexOf("touch") === 0, Z7 = (e, t) => {
        const o = t.dom, r = t.getDoc(), c = document, u = t.getBody();
        let f, b, v, S, O, R, M, H, J, W, Q, ge, be, ve, Be;
        const je = (Le) => X(Le) && (bi(Le) || o.is(Le, "figure.image")), xt = (Le) => vi(Le) || o.hasClass(Le, "mce-preview-object"), Kt = (Le, ut) => {
          if (W7(Le)) {
            const $t = Le.touches[0];
            return je(Le.target) && !T5($t.clientX, $t.clientY, ut);
          } else
            return je(Le.target) && !T5(Le.clientX, Le.clientY, ut);
        }, Me = (Le) => {
          const ut = Le.target;
          Kt(Le, t.selection.getRng()) && !Le.isDefaultPrevented() && t.selection.select(ut);
        }, Te = (Le) => o.hasClass(Le, "mce-preview-object") && X(Le.firstElementChild) ? [Le, Le.firstElementChild] : o.is(Le, "figure.image") ? [Le.querySelector("img")] : [Le], $e = (Le) => {
          const ut = Jw(t);
          return !ut || t.mode.isReadOnly() || Le.getAttribute("data-mce-resize") === "false" || Le === t.getBody() ? !1 : o.hasClass(Le, "mce-preview-object") && X(Le.firstElementChild) ? Ic(te.fromDom(Le.firstElementChild), ut) : Ic(te.fromDom(Le), ut);
        }, yt = (Le, ut) => {
          if (xt(ut))
            return Le.create("img", { src: fo.transparentSrc });
          if (Vc(ut)) {
            const to = hn(S.name, "n") ? js : dr, Zn = ut.cloneNode(!0);
            return to(Le.select("tr", Zn)).each((Qo) => {
              const _i = Le.select("td,th", Qo);
              Le.setStyle(Qo, "height", null), xe(_i, (Kd) => Le.setStyle(Kd, "height", null));
            }), Zn;
          } else
            return ut.cloneNode(!0);
        }, Sn = (Le, ut, $t) => {
          Le[ut] = $t;
          const to = 400;
          if (Le.width > to && !(ut === "width" && $t < to))
            Le[ut] = $t, o.setStyle(Le, ut, $t);
          else {
            const Zn = ut === "height" ? to * (W ?? 1) : to;
            Le[ut] = Zn, o.setStyle(Le, ut, Zn);
          }
        }, wn = (Le, ut, $t) => {
          if (X($t)) {
            const to = Te(Le);
            xe(to, (Zn) => {
              f1(Zn) ? Sn(Zn, ut, $t) : Zn.style[ut] || !t.schema.isValid(Zn.nodeName.toLowerCase(), ut) ? o.setStyle(Zn, ut, $t) : o.setAttrib(Zn, ut, "" + $t);
            });
          }
        }, uo = (Le, ut, $t) => {
          wn(Le, "width", ut), wn(Le, "height", $t);
        }, Go = (Le) => {
          let ut, $t, to, Zn, Qo;
          ut = Le.screenX - R, $t = Le.screenY - M, ge = ut * S[2] + H, be = $t * S[3] + J, ge = ge < 5 ? 5 : ge, be = be < 5 ? 5 : be, (je(f) || xt(f) || f1(f)) && _k(t) !== !1 ? to = !Et.modifierPressed(Le) : to = Et.modifierPressed(Le), to && (j7(ut) > j7($t) ? (be = yA(ge * W), ge = yA(be / W)) : (ge = yA(be / W), be = yA(ge * W))), uo(b, ge, be), Zn = S.startPos.x + ut, Qo = S.startPos.y + $t, Zn = Zn > 0 ? Zn : 0, Qo = Qo > 0 ? Qo : 0, o.setStyles(v, {
            left: Zn,
            top: Qo,
            display: "block"
          }), v.innerHTML = ge + " &times; " + be, ut = u.scrollWidth - ve, $t = u.scrollHeight - Be, ut + $t !== 0 && o.setStyles(v, {
            left: Zn - ut,
            top: Qo - $t
          }), Q || (Dw(t, f, H, J, "corner-" + S.name), Q = !0);
        }, ys = () => {
          const Le = Q;
          Q = !1, Le && (wn(f, "width", ge), wn(f, "height", be)), o.unbind(r, "mousemove", Go), o.unbind(r, "mouseup", ys), c !== r && (o.unbind(c, "mousemove", Go), o.unbind(c, "mouseup", ys)), o.remove(b), o.remove(v), o.remove(O), Ps(f), Le && (aC(t, f, ge, be, "corner-" + S.name), o.setAttrib(f, "style", o.getAttrib(f, "style"))), t.nodeChanged();
        }, Ps = (Le) => {
          Lo();
          const ut = o.getPos(Le, u), $t = ut.x, to = ut.y, Zn = Le.getBoundingClientRect(), Qo = Zn.width || Zn.right - Zn.left, _i = Zn.height || Zn.bottom - Zn.top;
          f !== Le && (Ai(), f = Le, ge = be = 0);
          const Kd = t.dispatch("ObjectSelected", { target: Le });
          $e(Le) && !Kd.isDefaultPrevented() ? Un(P5, (od, fu) => {
            const $p = (Xl) => {
              const ih = Te(f)[0];
              R = Xl.screenX, M = Xl.screenY, H = ih.clientWidth, J = ih.clientHeight, W = J / H, S = od, S.name = fu, S.startPos = {
                x: Qo * od[0] + $t,
                y: _i * od[1] + to
              }, ve = u.scrollWidth, Be = u.scrollHeight, O = o.add(u, "div", {
                class: "mce-resize-backdrop",
                "data-mce-bogus": "all"
              }), o.setStyles(O, {
                position: "fixed",
                left: "0",
                top: "0",
                width: "100%",
                height: "100%"
              }), b = yt(o, f), o.addClass(b, "mce-clonedresizable"), o.setAttrib(b, "data-mce-bogus", "all"), b.contentEditable = "false", o.setStyles(b, {
                left: $t,
                top: to,
                margin: 0
              }), uo(b, Qo, _i), b.removeAttribute(ib), u.appendChild(b), o.bind(r, "mousemove", Go), o.bind(r, "mouseup", ys), c !== r && (o.bind(c, "mousemove", Go), o.bind(c, "mouseup", ys)), v = o.add(u, "div", {
                class: "mce-resize-helper",
                "data-mce-bogus": "all"
              }, H + " &times; " + J);
            };
            let Qc = o.get("mceResizeHandle" + fu);
            Qc && o.remove(Qc), Qc = o.add(u, "div", {
              id: "mceResizeHandle" + fu,
              "data-mce-bogus": "all",
              class: "mce-resizehandle",
              unselectable: !0,
              style: "cursor:" + fu + "-resize; margin:0; padding:0"
            }), o.bind(Qc, "mousedown", (Xl) => {
              Xl.stopImmediatePropagation(), Xl.preventDefault(), $p(Xl);
            }), od.elm = Qc, o.setStyles(Qc, {
              left: Qo * od[0] + $t - Qc.offsetWidth / 2,
              top: _i * od[1] + to - Qc.offsetHeight / 2
            });
          }) : Ai(!1);
        }, Ra = vt(Ps, 0), Ai = (Le = !0) => {
          Ra.cancel(), Lo(), f && Le && f.removeAttribute(ib), Un(P5, (ut, $t) => {
            const to = o.get("mceResizeHandle" + $t);
            to && (o.unbind(to), o.remove(to));
          });
        }, At = (Le, ut) => o.isChildOf(Le, ut), sn = (Le) => {
          if (Q || t.removed || t.composing)
            return;
          const ut = Le.type === "mousedown" ? Le.target : e.getNode(), $t = ia(te.fromDom(ut), U7).map((Zn) => Zn.dom).filter((Zn) => o.isEditable(Zn.parentElement) || Zn.nodeName === "IMG" && o.isEditable(Zn)).getOrUndefined(), to = X($t) ? o.getAttrib($t, ib, "1") : "1";
          if (xe(o.select(`img[${ib}],hr[${ib}]`), (Zn) => {
            Zn.removeAttribute(ib);
          }), X($t) && At($t, u) && N5(t)) {
            Ao();
            const Zn = e.getStart(!0);
            if (At(Zn, $t) && At(e.getEnd(!0), $t)) {
              o.setAttrib($t, ib, to), Ra.throttle($t);
              return;
            }
          }
          Ai();
        }, Lo = () => {
          Un(P5, (Le) => {
            Le.elm && (o.unbind(Le.elm), delete Le.elm);
          });
        }, Ao = () => {
          try {
            t.getDoc().execCommand("enableObjectResizing", !1, "false");
          } catch {
          }
        };
        return t.on("init", () => {
          Ao(), t.on("NodeChange ResizeEditor ResizeWindow ResizeContent drop", sn), t.on("keyup compositionend", (Le) => {
            f && f.nodeName === "TABLE" && sn(Le);
          }), t.on("hide blur", Ai), t.on("contextmenu longpress", Me, !0);
        }), t.on("remove", Lo), {
          isResizable: $e,
          showResizeRect: Ps,
          hideResizeRect: Ai,
          updateResizeRect: sn,
          destroy: () => {
            Ra.cancel(), f = b = O = null;
          }
        };
      }, B5 = (e, t, o) => {
        const r = ii(te.fromDom(o));
        return i0(r.dom, e, t).map((c) => {
          const u = o.createRange();
          return u.setStart(c.start.dom, c.soffset), u.setEnd(c.finish.dom, c.foffset), u;
        }).getOrUndefined();
      }, Wg = (e, t) => X(e) && X(t) && e.startContainer === t.startContainer && e.startOffset === t.startOffset && e.endContainer === t.endContainer && e.endOffset === t.endOffset, G7 = (e, t, o) => {
        let r = e;
        for (; r && r !== t; ) {
          if (o(r))
            return r;
          r = r.parentNode;
        }
        return null;
      }, CA = (e, t, o) => G7(e, t, o) !== null, $5 = (e, t, o) => CA(e, t, (r) => r.nodeName === o), I5 = (e, t) => jl(e) && !CA(e, t, z), xA = (e, t, o) => {
        const r = t.parentNode;
        if (r) {
          const c = new Js(t, e.getParent(r, e.isBlock) || e.getRoot());
          let u;
          for (; u = c[o ? "prev" : "next"](); )
            if (zs(u))
              return !0;
        }
        return !1;
      }, SA = (e, t) => e.previousSibling?.nodeName === t, LY = (e, t) => {
        let o = t;
        for (; o && o !== e; ) {
          if (Es(o))
            return !0;
          o = o.parentNode;
        }
        return !1;
      }, wA = (e, t, o, r, c) => {
        const u = e.getRoot(), f = e.schema.getNonEmptyElements(), b = c.parentNode;
        let v, S;
        if (!b)
          return P.none();
        const O = e.getParent(b, e.isBlock) || u;
        if (r && zs(c) && t && e.isEmpty(O))
          return P.some(Re(b, e.nodeIndex(c)));
        const R = new Js(c, O);
        for (; S = R[r ? "prev" : "next"](); ) {
          if (e.getContentEditableParent(S) === "false" || I5(S, u))
            return P.none();
          if (tt(S) && S.data.length > 0)
            return $5(S, u, "A") ? P.none() : P.some(Re(S, r ? S.data.length : 0));
          if (e.isBlock(S) || f[S.nodeName.toLowerCase()])
            return P.none();
          v = S;
        }
        return zn(v) ? P.none() : o && v ? P.some(Re(v, 0)) : P.none();
      }, q7 = (e, t, o, r) => {
        const c = e.getRoot();
        let u, f = !1, b = o ? r.startContainer : r.endContainer, v = o ? r.startOffset : r.endOffset;
        const S = ht(b) && v === b.childNodes.length, O = e.schema.getNonEmptyElements();
        let R = o;
        if (jl(b))
          return P.none();
        if (ht(b) && v > b.childNodes.length - 1 && (R = !1), lm(b) && (b = c, v = 0), b === c) {
          if (R && (u = b.childNodes[v > 0 ? v - 1 : 0], u && (jl(u) || O[u.nodeName] || Vc(u))))
            return P.none();
          if (b.hasChildNodes()) {
            if (v = Math.min(!R && v > 0 ? v - 1 : v, b.childNodes.length - 1), b = b.childNodes[v], v = tt(b) && S ? b.data.length : 0, !t && b === c.lastChild && Vc(b) || LY(c, b) || jl(b) || m1(b))
              return P.none();
            if (b.hasChildNodes() && !Vc(b)) {
              u = b;
              const M = new Js(b, c);
              do {
                if (Es(u) || jl(u)) {
                  f = !1;
                  break;
                }
                if (tt(u) && u.data.length > 0) {
                  v = R ? 0 : u.data.length, b = u, f = !0;
                  break;
                }
                if (O[u.nodeName.toLowerCase()] && !u2(u)) {
                  v = e.nodeIndex(u), b = u.parentNode, R || v++, f = !0;
                  break;
                }
              } while (u = R ? M.next() : M.prev());
            }
          }
        }
        return t && (tt(b) && v === 0 && wA(e, S, t, !0, b).each((M) => {
          b = M.container(), v = M.offset(), f = !0;
        }), ht(b) && (u = b.childNodes[v], u || (u = b.childNodes[v - 1]), u && zs(u) && !SA(u, "A") && !xA(e, u, !1) && !xA(e, u, !0) && wA(e, S, t, !0, u).each((M) => {
          b = M.container(), v = M.offset(), f = !0;
        }))), R && !t && tt(b) && v === b.data.length && wA(e, S, t, !1, b).each((M) => {
          b = M.container(), v = M.offset(), f = !0;
        }), f && b ? P.some(Re(b, v)) : P.none();
      }, zE = (e, t) => {
        const o = t.collapsed, r = t.cloneRange(), c = Re.fromRangeStart(t);
        return q7(e, o, !0, r).each((u) => {
          (!o || !Re.isAbove(c, u)) && r.setStart(u.container(), u.offset());
        }), o || q7(e, o, !1, r).each((u) => {
          r.setEnd(u.container(), u.offset());
        }), o && r.collapse(!0), Wg(t, r) ? P.none() : P.some(r);
      }, VE = (e, t) => e.splitText(t), Hv = (e) => {
        let t = e.startContainer, o = e.startOffset, r = e.endContainer, c = e.endOffset;
        if (t === r && tt(t)) {
          if (o > 0 && o < t.data.length)
            if (r = VE(t, o), t = r.previousSibling, c > o) {
              c = c - o;
              const u = VE(r, c).previousSibling;
              t = r = u, c = u.data.length, o = 0;
            } else
              c = 0;
        } else if (tt(t) && o > 0 && o < t.data.length && (t = VE(t, o), o = 0), tt(r) && c > 0 && c < r.data.length) {
          const u = VE(r, c).previousSibling;
          r = u, c = u.data.length;
        }
        return {
          startContainer: t,
          startOffset: o,
          endContainer: r,
          endOffset: c
        };
      }, _m = (e) => ({
        walk: (u, f) => Pd(e, u, f),
        split: Hv,
        expand: (u, f = { type: "word" }) => {
          if (f.type === "word") {
            const b = Pf(e, u, [{ inline: "span" }], { includeTrailingSpace: !1, expandToBlock: !1 }), v = e.createRng();
            return v.setStart(b.startContainer, b.startOffset), v.setEnd(b.endContainer, b.endOffset), v;
          }
          return u;
        },
        normalize: (u) => zE(e, u).fold(ye, (f) => (u.setStart(f.startContainer, f.startOffset), u.setEnd(f.endContainer, f.endOffset), !0))
      });
      _m.compareRanges = Wg, _m.getCaretRangeFromPoint = B5, _m.getSelectedNode = jr, _m.getNode = Sf;
      const K7 = (e, t) => e.view(t).fold(ot([]), (r) => {
        const c = e.owner(r), u = K7(e, c);
        return [r].concat(u);
      }), HY = (e, t) => {
        const o = t.owner(e);
        return K7(t, o);
      };
      var VY = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        view: (e) => (e.dom === document ? P.none() : P.from(e.dom.defaultView?.frameElement)).map(te.fromDom),
        owner: (e) => Pl(e)
      });
      const Y7 = (e) => {
        const t = ph(), o = o1(t), r = HY(e, VY), c = ug(e), u = qn(r, (f, b) => {
          const v = ug(b);
          return {
            left: f.left + v.left,
            top: f.top + v.top
          };
        }, { left: 0, top: 0 });
        return mi(u.left + c.left + o.left, u.top + c.top + o.top);
      }, UE = (e) => Hn(e) === "textarea", X7 = (e, t) => e.dispatch("ScrollIntoView", t).isDefaultPrevented(), F5 = (e, t) => {
        e.dispatch("AfterScrollIntoView", t);
      }, UY = (e, t) => {
        const o = Os(e);
        if (o.length === 0 || UE(e))
          return { element: e, offset: t };
        if (t < o.length && !UE(o[t]))
          return { element: o[t], offset: 0 };
        {
          const r = o[o.length - 1];
          return UE(r) ? { element: e, offset: t } : Hn(r) === "img" ? { element: r, offset: 1 } : Eo(r) ? { element: r, offset: xa(r).length } : { element: r, offset: Os(r).length };
        }
      }, L5 = (e, t) => {
        const o = ig(e), r = e2(e);
        return {
          element: e,
          bottom: o.top + r,
          height: r,
          pos: o,
          cleanup: t
        };
      }, H5 = (e, t) => {
        const o = UY(e, t), r = te.fromHtml('<span data-mce-bogus="all" style="display: inline-block;">' + Ur + "</span>");
        return ca(o.element, r), L5(r, () => qo(r));
      }, Q7 = (e) => L5(te.fromDom(e), St), z5 = (e, t, o, r) => {
        eH(e, (c, u) => J7(e, t, o, r), o);
      }, V5 = (e, t, o, r, c) => {
        const u = { elm: r.element.dom, alignToTop: c };
        if (X7(e, u))
          return;
        const f = o1(t).top;
        o(e, t, f, r, c), F5(e, u);
      }, J7 = (e, t, o, r) => {
        const c = te.fromDom(e.getBody()), u = te.fromDom(e.getDoc());
        t1(c);
        const f = H5(te.fromDom(o.startContainer), o.startOffset);
        V5(e, u, t, f, r), f.cleanup();
      }, U5 = (e, t, o, r) => {
        const c = te.fromDom(e.getDoc());
        V5(e, c, o, Q7(t), r);
      }, eH = (e, t, o) => {
        const r = o.startContainer, c = o.startOffset, u = o.endContainer, f = o.endOffset;
        t(te.fromDom(r), te.fromDom(u));
        const b = e.dom.createRng();
        b.setStart(r, c), b.setEnd(u, f), e.selection.setRng(o);
      }, EA = (e, t, o, r, c) => {
        const u = t.pos, f = 30;
        if (r)
          r0(u.left, Math.max(0, u.top - f), c);
        else {
          const b = u.top - o + t.height + f;
          r0(-e.getBody().getBoundingClientRect().left, b, c);
        }
      }, j5 = (e, t, o, r, c, u) => {
        const f = r + o, b = c.pos.top, v = c.bottom, S = v - b >= r;
        b < o ? EA(e, c, r, u !== !1, t) : b > f ? EA(e, c, r, S ? u !== !1 : u === !0, t) : v > f && !S && EA(e, c, r, u === !0, t);
      }, W5 = (e, t, o, r, c) => {
        const u = ii(t).dom.innerHeight;
        j5(e, t, o, u, r, c);
      }, Z5 = (e, t, o, r, c) => {
        const u = ii(t).dom.innerHeight;
        j5(e, t, o, u, r, c);
        const f = Y7(r.element), b = ul(window);
        f.top < b.y ? Fl(r.element, c !== !1) : f.top > b.bottom && Fl(r.element, c === !0);
      }, tH = (e, t, o) => z5(e, W5, t, o), nH = (e, t, o) => U5(e, t, W5, o), oH = (e, t, o) => z5(e, Z5, t, o), sH = (e, t, o) => U5(e, t, Z5, o), _t = (e, t, o) => {
        (e.inline ? nH : sH)(e, t, o);
      }, ru = (e, t, o) => {
        (e.inline ? tH : oH)(e, t, o);
      }, rH = (e, t) => t.collapsed ? e.isEditable(t.startContainer) : e.isEditable(t.startContainer) && e.isEditable(t.endContainer), G5 = (e, t, o, r, c) => {
        const u = o ? t.startContainer : t.endContainer, f = o ? t.startOffset : t.endOffset;
        return P.from(u).map(te.fromDom).map((b) => !r || !t.collapsed ? Bl(b, c(b, f)).getOr(b) : b).bind((b) => Is(b) ? P.some(b) : ec(b).filter(Is)).map((b) => b.dom).getOr(e);
      }, jE = (e, t, o = !1) => G5(e, t, !0, o, (r, c) => Math.min(fd(r), c)), TA = (e, t, o = !1) => G5(e, t, !1, o, (r, c) => c > 0 ? c - 1 : c), kA = (e, t) => {
        const o = e;
        for (; e && tt(e) && e.length === 0; )
          e = t ? e.nextSibling : e.previousSibling;
        return e || o;
      }, AA = (e, t) => {
        if (!t)
          return e;
        let o = t.startContainer, r = t.endContainer;
        const c = t.startOffset, u = t.endOffset;
        let f = t.commonAncestorContainer;
        t.collapsed || (o === r && u - c < 2 && o.hasChildNodes() && (f = o.childNodes[c]), tt(o) && tt(r) && (o.length === c ? o = kA(o.nextSibling, !0) : o = o.parentNode, u === 0 ? r = kA(r.previousSibling, !1) : r = r.parentNode, o && o === r && (f = o)));
        const b = tt(f) ? f.parentNode : f;
        return zc(b) ? b : e;
      }, aH = (e, t, o, r) => {
        const c = [], u = e.getRoot(), f = e.getParent(o || jE(u, t, t.collapsed), e.isBlock), b = e.getParent(r || TA(u, t, t.collapsed), e.isBlock);
        if (f && f !== u && c.push(f), f && b && f !== b) {
          let v;
          const S = new Js(f, u);
          for (; (v = S.next()) && v !== b; )
            e.isBlock(v) && c.push(v);
        }
        return b && f !== b && b !== u && c.push(b), c;
      }, q5 = (e, t, o) => P.from(t).bind((r) => P.from(r.parentNode).map((c) => {
        const u = e.nodeIndex(r), f = e.createRng();
        return f.setStart(c, u), f.setEnd(c, u + 1), o && (AE(e, f, r, !0), AE(e, f, r, !1)), f;
      })), _A = (e, t) => en(t, (o) => {
        const r = e.dispatch("GetSelectionRange", { range: o });
        return r.range !== o ? r.range : o;
      }), cH = {
        "#text": 3,
        "#comment": 8,
        "#cdata": 4,
        "#pi": 7,
        "#doctype": 10,
        "#document-fragment": 11
      }, WE = (e, t, o) => {
        const r = o ? "lastChild" : "firstChild", c = o ? "prev" : "next";
        if (e[r])
          return e[r];
        if (e !== t) {
          let u = e[c];
          if (u)
            return u;
          for (let f = e.parent; f && f !== t; f = f.parent)
            if (u = f[c], u)
              return u;
        }
      }, lH = (e) => {
        const t = e.value ?? "";
        if (!Th(t))
          return !1;
        const o = e.parent;
        return !(o && (o.name !== "span" || o.attr("style")) && /^[ ]+$/.test(t));
      }, K5 = (e) => {
        const t = e.name === "a" && !e.attr("href") && e.attr("id");
        return e.attr("name") || e.attr("id") && !e.firstChild || e.attr("data-mce-bookmark") || t;
      };
      class _a {
        /**
         * Creates a node of a specific type.
         *
         * @static
         * @method create
         * @param {String} name Name of the node type to create for example "b" or "#text".
         * @param {Object} attrs Name/value collection of attributes that will be applied to elements.
         */
        static create(t, o) {
          const r = new _a(t, cH[t] || 1);
          return o && Un(o, (c, u) => {
            r.attr(u, c);
          }), r;
        }
        name;
        type;
        attributes;
        value;
        parent;
        firstChild;
        lastChild;
        next;
        prev;
        raw;
        /**
         * Constructs a new Node instance.
         *
         * @constructor
         * @method Node
         * @param {String} name Name of the node type.
         * @param {Number} type Numeric type representing the node.
         */
        constructor(t, o) {
          this.name = t, this.type = o, o === 1 && (this.attributes = [], this.attributes.map = {});
        }
        /**
         * Replaces the current node with the specified one.
         *
         * @method replace
         * @param {tinymce.html.Node} node Node to replace the current node with.
         * @return {tinymce.html.Node} The old node that got replaced.
         * @example
         * someNode.replace(someNewNode);
         */
        replace(t) {
          const o = this;
          return t.parent && t.remove(), o.insert(t, o), o.remove(), o;
        }
        attr(t, o) {
          const r = this;
          if (!U(t))
            return X(t) && Un(t, (u, f) => {
              r.attr(f, u);
            }), r;
          const c = r.attributes;
          if (c) {
            if (o !== void 0) {
              if (o === null) {
                if (t in c.map) {
                  delete c.map[t];
                  let u = c.length;
                  for (; u--; )
                    if (c[u].name === t)
                      return c.splice(u, 1), r;
                }
                return r;
              }
              if (t in c.map) {
                let u = c.length;
                for (; u--; )
                  if (c[u].name === t) {
                    c[u].value = o;
                    break;
                  }
              } else
                c.push({ name: t, value: o });
              return c.map[t] = o, r;
            }
            return c.map[t];
          }
        }
        /**
         * Does a shallow clones the node into a new node. It will also exclude id attributes since
         * there should only be one id per document.
         *
         * @method clone
         * @return {tinymce.html.Node} New copy of the original node.
         * @example
         * const clonedNode = node.clone();
         */
        clone() {
          const t = this, o = new _a(t.name, t.type), r = t.attributes;
          if (r) {
            const c = [];
            c.map = {};
            for (let u = 0, f = r.length; u < f; u++) {
              const b = r[u];
              b.name !== "id" && (c[c.length] = { name: b.name, value: b.value }, c.map[b.name] = b.value);
            }
            o.attributes = c;
          }
          return o.value = t.value, o;
        }
        /**
         * Wraps the node in in another node.
         *
         * @method wrap
         * @example
         * node.wrap(wrapperNode);
         */
        wrap(t) {
          const o = this;
          return o.parent && (o.parent.insert(t, o), t.append(o)), o;
        }
        /**
         * Unwraps the node in other words it removes the node but keeps the children.
         *
         * @method unwrap
         * @example
         * node.unwrap();
         */
        unwrap() {
          const t = this;
          for (let o = t.firstChild; o; ) {
            const r = o.next;
            t.insert(o, t, !0), o = r;
          }
          t.remove();
        }
        /**
         * Removes the node from it's parent.
         *
         * @method remove
         * @return {tinymce.html.Node} Current node that got removed.
         * @example
         * node.remove();
         */
        remove() {
          const t = this, o = t.parent, r = t.next, c = t.prev;
          return o && (o.firstChild === t ? (o.firstChild = r, r && (r.prev = null)) : c && (c.next = r), o.lastChild === t ? (o.lastChild = c, c && (c.next = null)) : r && (r.prev = c), t.parent = t.next = t.prev = null), t;
        }
        /**
         * Appends a new node as a child of the current node.
         *
         * @method append
         * @param {tinymce.html.Node} node Node to append as a child of the current one.
         * @return {tinymce.html.Node} The node that got appended.
         * @example
         * node.append(someNode);
         */
        append(t) {
          const o = this;
          t.parent && t.remove();
          const r = o.lastChild;
          return r ? (r.next = t, t.prev = r, o.lastChild = t) : o.lastChild = o.firstChild = t, t.parent = o, t;
        }
        /**
         * Inserts a node at a specific position as a child of this node.
         *
         * @method insert
         * @param {tinymce.html.Node} node Node to insert as a child of this node.
         * @param {tinymce.html.Node} refNode Reference node to set node before/after.
         * @param {Boolean} before Optional state to insert the node before the reference node.
         * @return {tinymce.html.Node} The node that got inserted.
         * @example
         * parentNode.insert(newChildNode, oldChildNode);
         */
        insert(t, o, r) {
          t.parent && t.remove();
          const c = o.parent || this;
          return r ? (o === c.firstChild ? c.firstChild = t : o.prev && (o.prev.next = t), t.prev = o.prev, t.next = o, o.prev = t) : (o === c.lastChild ? c.lastChild = t : o.next && (o.next.prev = t), t.next = o.next, t.prev = o, o.next = t), t.parent = c, t;
        }
        /**
         * Get all descendants by name.
         *
         * @method getAll
         * @param {String} name Name of the descendant nodes to collect.
         * @return {Array} Array with descendant nodes matching the specified name.
         */
        getAll(t) {
          const o = this, r = [];
          for (let c = o.firstChild; c; c = WE(c, o))
            c.name === t && r.push(c);
          return r;
        }
        /**
         * Get all children of this node.
         *
         * @method children
         * @return {Array} Array containing child nodes.
         */
        children() {
          const t = this, o = [];
          for (let r = t.firstChild; r; r = r.next)
            o.push(r);
          return o;
        }
        /**
         * Removes all children of the current node.
         *
         * @method empty
         * @return {tinymce.html.Node} The current node that got cleared.
         */
        empty() {
          const t = this;
          if (t.firstChild) {
            const o = [];
            for (let c = t.firstChild; c; c = WE(c, t))
              o.push(c);
            let r = o.length;
            for (; r--; ) {
              const c = o[r];
              c.parent = c.firstChild = c.lastChild = c.next = c.prev = null;
            }
          }
          return t.firstChild = t.lastChild = null, t;
        }
        /**
         * Returns true/false if the node is to be considered empty or not.
         *
         * @method isEmpty
         * @param {Object} elements Name/value object with elements that are automatically treated as non empty elements.
         * @param {Object} whitespace Name/value object with elements that are automatically treated whitespace preservables.
         * @param {Function} predicate Optional predicate that gets called after the other rules determine that the node is empty. Should return true if the node is a content node.
         * @return {Boolean} true/false if the node is empty or not.
         * @example
         * node.isEmpty({ img: true });
         */
        isEmpty(t, o = {}, r) {
          const c = this;
          let u = c.firstChild;
          if (K5(c))
            return !1;
          if (u)
            do {
              if (u.type === 1) {
                if (u.attr("data-mce-bogus"))
                  continue;
                if (t[u.name] || K5(u))
                  return !1;
              }
              if (u.type === 8 || u.type === 3 && !lH(u) || u.type === 3 && u.parent && o[u.parent.name] && Th(u.value ?? "") || r && r(u))
                return !1;
            } while (u = WE(u, c));
          return !0;
        }
        /**
         * Walks to the next or previous node and returns that node or null if it wasn't found.
         *
         * @method walk
         * @param {Boolean} prev Optional previous node state defaults to false.
         * @return {tinymce.html.Node} Node that is next to or previous of the current node.
         */
        walk(t) {
          return WE(this, null, t);
        }
      }
      const iH = Je.makeMap("NOSCRIPT STYLE SCRIPT XMP IFRAME NOEMBED NOFRAMES PLAINTEXT", " "), Y5 = (e) => U(e.nodeValue) && e.nodeValue.includes(Ur), X5 = (e) => `${e.length === 0 ? "" : `${en(e, (t) => `[${t}]`).join(",")},`}[data-mce-bogus="all"]`, uH = (e, t) => t.querySelectorAll(X5(e)), Q5 = (e) => document.createTreeWalker(e, NodeFilter.SHOW_COMMENT, (t) => Y5(t) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP), OA = (e) => document.createTreeWalker(e, NodeFilter.SHOW_TEXT, (t) => {
        if (Y5(t)) {
          const o = t.parentNode;
          return o && kn(iH, o.nodeName) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
        } else
          return NodeFilter.FILTER_SKIP;
      }), ZE = (e) => Q5(e).nextNode() !== null, dH = (e) => OA(e).nextNode() !== null, mH = (e, t) => t.querySelector(X5(e)) !== null, fH = (e, t) => {
        xe(uH(e, t), (o) => {
          const r = te.fromDom(o);
          gs(r, "data-mce-bogus") === "all" ? qo(r) : xe(e, (c) => {
            Cs(r, c) && sr(r, c);
          });
        });
      }, J5 = (e) => {
        let t = e.nextNode();
        for (; t !== null; )
          t.nodeValue = null, t = e.nextNode();
      }, gH = A(J5, Q5), hH = A(J5, OA), eM = (e, t) => {
        const o = [
          {
            condition: ue(mH, t),
            action: ue(fH, t)
          },
          {
            condition: ZE,
            action: gH
          },
          {
            condition: dH,
            action: hH
          }
        ];
        let r = e, c = !1;
        return xe(o, ({ condition: u, action: f }) => {
          u(r) && (c || (r = e.cloneNode(!0), c = !0), f(r));
        }), r;
      }, tM = (e) => {
        const t = Ne(e, "[data-mce-bogus]");
        xe(t, (o) => {
          gs(o, "data-mce-bogus") === "all" ? qo(o) : Xi(o) ? (ca(o, te.fromText(Pc)), qo(o)) : hc(o);
        });
      }, nM = (e) => {
        const t = Ne(e, "input");
        xe(t, (o) => {
          sr(o, "name");
        });
      }, pH = (e, t) => {
        const o = Ar(e), r = new RegExp(`^(<${o}[^>]*>(&nbsp;|&#160;|\\s| |<br \\/>|)<\\/${o}>[\r
]*|<br \\/>[\r
]*)$`);
        return t.replace(r, "");
      }, bH = (e, t) => {
        const o = e.getDoc(), r = Fr(te.fromDom(e.getBody())), c = te.fromTag("div", o);
        Ss(c, "data-mce-bogus", "all"), pc(c, {
          position: "fixed",
          left: "-9999999px",
          top: "0"
        }), Au(c, t.innerHTML), tM(c), nM(c);
        const u = n0(r);
        bo(u, c);
        const f = Gc(c.dom.innerText);
        return qo(c), f;
      }, vH = (e, t, o) => {
        let r;
        return t.format === "raw" ? r = Je.trim(Gc(eM(o, e.serializer.getTempAttrs()).innerHTML)) : t.format === "text" ? r = bH(e, o) : t.format === "tree" ? r = e.serializer.serialize(o, t) : r = pH(e, e.serializer.serialize(o, t)), t.format !== "text" && !B0(te.fromDom(o)) && U(r) ? Je.trim(r) : r;
      }, yH = (e, t) => P.from(e.getBody()).fold(ot(t.format === "tree" ? new _a("body", 11) : ""), (o) => vH(e, t, o)), oM = Je.makeMap, DA = (e) => {
        const t = [];
        e = e || {};
        const o = e.indent, r = oM(e.indent_before || ""), c = oM(e.indent_after || ""), u = gl.getEncodeFunc(e.entity_encoding || "raw", e.entities), f = e.element_format !== "xhtml";
        return {
          /**
           * Writes a start element, such as `<p id="a">`.
           *
           * @method start
           * @param {String} name Name of the element.
           * @param {Array} attrs Optional array of objects containing an attribute name and value, or undefined if the element has no attributes.
           * @param {Boolean} empty Optional empty state if the tag should serialize as a void element. For example: `<img />`
           */
          start: (b, v, S) => {
            if (o && r[b] && t.length > 0) {
              const O = t[t.length - 1];
              O.length > 0 && O !== `
` && t.push(`
`);
            }
            if (t.push("<", b), v)
              for (let O = 0, R = v.length; O < R; O++) {
                const M = v[O];
                t.push(" ", M.name, '="', u(M.value, !0), '"');
              }
            if (!S || f ? t[t.length] = ">" : t[t.length] = " />", S && o && c[b] && t.length > 0) {
              const O = t[t.length - 1];
              O.length > 0 && O !== `
` && t.push(`
`);
            }
          },
          /**
           * Writes an end element, such as `</p>`.
           *
           * @method end
           * @param {String} name Name of the element.
           */
          end: (b) => {
            let v;
            t.push("</", b, ">"), o && c[b] && t.length > 0 && (v = t[t.length - 1], v.length > 0 && v !== `
` && t.push(`
`));
          },
          /**
           * Writes a text node.
           *
           * @method text
           * @param {String} text String to write out.
           * @param {Boolean} raw Optional raw state. If true, the contents won't get encoded.
           */
          text: (b, v) => {
            b.length > 0 && (t[t.length] = v ? b : u(b));
          },
          /**
           * Writes a cdata node, such as `<![CDATA[data]]>`.
           *
           * @method cdata
           * @param {String} text String to write out inside the cdata.
           */
          cdata: (b) => {
            t.push("<![CDATA[", b, "]]>");
          },
          /**
           * Writes a comment node, such as `<!-- Comment -->`.
           *
           * @method comment
           * @param {String} text String to write out inside the comment.
           */
          comment: (b) => {
            t.push("<!--", b, "-->");
          },
          /**
           * Writes a processing instruction (PI) node, such as `<?xml attr="value" ?>`.
           *
           * @method pi
           * @param {String} name Name of the pi.
           * @param {String} text String to write out inside the pi.
           */
          pi: (b, v) => {
            v ? t.push("<?", b, " ", u(v), "?>") : t.push("<?", b, "?>"), o && t.push(`
`);
          },
          /**
           * Writes a doctype node, such as `<!DOCTYPE data>`.
           *
           * @method doctype
           * @param {String} text String to write out inside the doctype.
           */
          doctype: (b) => {
            t.push("<!DOCTYPE", b, ">", o ? `
` : "");
          },
          /**
           * Resets the internal buffer. For example, if one wants to reuse the writer.
           *
           * @method reset
           */
          reset: () => {
            t.length = 0;
          },
          /**
           * Returns the contents that was serialized.
           *
           * @method getContent
           * @return {String} HTML contents that got written down.
           */
          getContent: () => t.join("").replace(/\n$/, "")
        };
      }, mp = (e = {}, t = wa()) => {
        const o = DA(e);
        return e.validate = "validate" in e ? e.validate : !0, {
          serialize: (c) => {
            const u = e.validate, f = {
              // #text
              3: (v) => {
                o.text(v.value ?? "", v.raw);
              },
              // #comment
              8: (v) => {
                o.comment(v.value ?? "");
              },
              // Processing instruction
              7: (v) => {
                o.pi(v.name, v.value);
              },
              // Doctype
              10: (v) => {
                o.doctype(v.value ?? "");
              },
              // CDATA
              4: (v) => {
                o.cdata(v.value ?? "");
              },
              // Document fragment
              11: (v) => {
                let S = v;
                if (S = S.firstChild)
                  do
                    b(S);
                  while (S = S.next);
              }
            };
            o.reset();
            const b = (v) => {
              const S = f[v.type];
              if (S)
                S(v);
              else {
                const O = v.name, R = O in t.getVoidElements();
                let M = v.attributes;
                if (u && M && M.length > 1) {
                  const H = [];
                  H.map = {};
                  const J = t.getElementRule(v.name);
                  if (J) {
                    for (let W = 0, Q = J.attributesOrder.length; W < Q; W++) {
                      const ge = J.attributesOrder[W];
                      if (ge in M.map) {
                        const be = M.map[ge];
                        H.map[ge] = be, H.push({ name: ge, value: be });
                      }
                    }
                    for (let W = 0, Q = M.length; W < Q; W++) {
                      const ge = M[W].name;
                      if (!(ge in H.map)) {
                        const be = M.map[ge];
                        H.map[ge] = be, H.push({ name: ge, value: be });
                      }
                    }
                    M = H;
                  }
                }
                if (o.start(O, M, R), pg(O))
                  U(v.value) && o.text(v.value, !0), o.end(O);
                else if (!R) {
                  let H = v.firstChild;
                  if (H) {
                    (O === "pre" || O === "textarea") && H.type === 3 && H.value?.[0] === `
` && o.text(`
`, !0);
                    do
                      b(H);
                    while (H = H.next);
                  }
                  o.end(O);
                }
              }
            };
            return c.type === 1 && !e.inner ? b(c) : c.type === 3 ? f[3](c) : f[11](c), o.getContent();
          }
        };
      }, sM = /* @__PURE__ */ new Set();
      xe([
        "margin",
        "margin-left",
        "margin-right",
        "margin-top",
        "margin-bottom",
        "padding",
        "padding-left",
        "padding-right",
        "padding-top",
        "padding-bottom",
        "border",
        "border-width",
        "border-style",
        "border-color",
        "background",
        "background-attachment",
        "background-clip",
        "background-image",
        "background-origin",
        "background-position",
        "background-repeat",
        "background-size",
        "float",
        "position",
        "left",
        "right",
        "top",
        "bottom",
        "z-index",
        "display",
        "transform",
        "width",
        "max-width",
        "min-width",
        "height",
        "max-height",
        "min-height",
        "overflow",
        "overflow-x",
        "overflow-y",
        "text-overflow",
        "vertical-align",
        "transition",
        "transition-delay",
        "transition-duration",
        "transition-property",
        "transition-timing-function"
      ], (t) => {
        sM.add(t);
      });
      const ex = /* @__PURE__ */ new Set();
      xe([
        "background-color"
      ], (t) => {
        ex.add(t);
      });
      const fp = ["font", "text-decoration", "text-emphasis"], GE = (e, t) => e.parseStyle(e.getAttrib(t, "style")), zv = (e, t) => Vt(GE(e, t)), CH = (e) => sM.has(e), xH = (e) => ex.has(e), rM = (e, t) => po(zv(e, t), (o) => CH(o)), aM = (e, t) => rM(e, t) && po(zv(e, t), (o) => xH(o)), SH = (e) => ze(e, (t) => po(fp, (o) => hn(t, o))), wH = (e, t, o) => {
        const r = zv(e, t), c = zv(e, o), u = (f) => {
          const b = e.getStyle(t, f) ?? "", v = e.getStyle(o, f) ?? "";
          return ms(b) && ms(v) && b !== v;
        };
        return po(r, (f) => {
          const b = (v) => po(v, (S) => S === f);
          if (!b(c) && b(fp)) {
            const v = SH(c);
            return po(v, u);
          } else
            return u(f);
        });
      }, RA = (e, t, o) => P.from(o.container()).filter(tt).exists((r) => {
        const c = e ? 0 : -1;
        return t(r.data.charAt(o.offset() + c));
      }), NA = ue(RA, !0, Gl), qE = ue(RA, !1, Gl), EH = (e) => {
        const t = e.container();
        return tt(t) && (t.data.length === 0 || A1(t.data) && Iv.isBookmarkNode(t.parentNode));
      }, gp = (e, t) => (o) => IC(e ? 0 : -1, o).filter(t).isSome(), cM = (e) => bi(e) && Ls(te.fromDom(e), "display") === "block", MA = (e) => Es(e) && !$3(e), PA = gp(!0, cM), lM = gp(!1, cM), tx = gp(!0, vi), nx = gp(!1, vi), ox = gp(!0, Vc), BA = gp(!1, Vc), Zg = gp(!0, MA), Bf = gp(!1, MA), iM = (e) => e.slice(0, -1), TH = (e, t, o) => Ja(t, e) ? iM(ya(e, (r) => o(r) || Qn(r, t))) : [], uM = (e, t) => TH(e, t, ye), Id = (e, t) => [e].concat(uM(e, t)), KE = (e, t, o) => i(e, t, o, EH), dM = (e) => (t) => e.isBlock(Hn(t)), $A = (e, t, o) => _o(Id(te.fromDom(t.container()), e), dM(o)), IA = (e, t, o, r) => KE(e, t.dom, o).forall((c) => $A(t, o, r).fold(() => !Rd(c, o, t.dom), (u) => !Rd(c, o, t.dom) && Ja(u, te.fromDom(c.container())))), FA = (e, t, o, r) => $A(t, o, r).fold(() => KE(e, t.dom, o).forall((c) => !Rd(c, o, t.dom)), (c) => KE(e, c.dom, o).isNone()), YE = ue(FA, !1), LA = ue(FA, !0), mM = ue(IA, !1), fM = ue(IA, !0), gM = (e) => rb(e).exists(Xi), XE = (e, t, o, r) => {
        const c = ze(Id(te.fromDom(o.container()), t), (f) => r.isBlock(Hn(f))), u = js(c).getOr(t);
        return Zl(e, u.dom, o).filter(gM);
      }, HA = (e, t, o) => rb(t).exists(Xi) || XE(!0, e, t, o).isSome(), QE = (e, t, o) => FC(t).exists(Xi) || XE(!1, e, t, o).isSome(), hM = ue(XE, !1), kH = ue(XE, !0), pM = (e) => Re.isTextPosition(e) && !e.isAtStart() && !e.isAtEnd(), bM = (e, t, o) => {
        const r = ze(Id(te.fromDom(t.container()), e), (c) => o.isBlock(Hn(c)));
        return js(r).getOr(e);
      }, vM = (e, t, o) => pM(t) ? qE(t) : qE(t) || y(bM(e, t, o).dom, t).exists(qE), yM = (e, t, o) => pM(t) ? NA(t) : NA(t) || p(bM(e, t, o).dom, t).exists(NA), AH = (e) => Lt(["pre", "pre-wrap"], e), JE = (e) => rb(e).bind((t) => Uo(t, Is)).exists((t) => AH(Ls(t, "white-space"))), jY = (e, t) => y(e.dom, t).isNone(), WY = (e, t) => p(e.dom, t).isNone(), _H = (e, t, o) => jY(e, t) || WY(e, t) || YE(e, t, o) || LA(e, t, o) || QE(e, t, o) || HA(e, t, o), ZY = (e) => X(e) && Es(e) && PC(e), CM = (e, t) => (o) => ZY(new Js(o, e)[t]()), Oc = (e, t) => {
        const o = p(e.dom, t).getOr(t), r = CM(e.dom, "next");
        return t.isAtEnd() && (r(t.container()) || r(o.container()));
      }, OH = (e, t) => {
        const o = y(e.dom, t).getOr(t), r = CM(e.dom, "prev");
        return t.isAtStart() && (r(t.container()) || r(o.container()));
      }, DH = (e, t, o) => JE(t) ? !1 : _H(e, t, o) || vM(e, t, o) || yM(e, t, o), sx = (e, t, o) => JE(t) ? !1 : YE(e, t, o) || mM(e, t, o) || QE(e, t, o) || vM(e, t, o) || OH(e, t), RH = (e) => {
        const t = e.container(), o = e.offset();
        return tt(t) && o < t.data.length ? Re(t, o + 1) : e;
      }, Dc = (e, t, o) => JE(t) ? !1 : LA(e, t, o) || fM(e, t, o) || HA(e, t, o) || yM(e, t, o) || Oc(e, t), xM = (e, t, o) => sx(e, t, o) || Dc(e, RH(t), o), SM = (e, t) => oc(e.charAt(t)), NH = (e, t) => Gl(e.charAt(t)), MH = (e) => {
        const t = e.container();
        return tt(t) && As(t.data, $s);
      }, PH = (e) => {
        const t = e.split("");
        return en(t, (o, r) => oc(o) && r > 0 && r < t.length - 1 && ka(t[r - 1]) && ka(t[r + 1]) ? " " : o).join("");
      }, BH = (e, t, o, r) => {
        const c = t.data, u = Re(t, 0);
        return !o && SM(c, 0) && !xM(e, u, r) ? (t.data = " " + c.slice(1), !0) : o && NH(c, 0) && sx(e, u, r) ? (t.data = $s + c.slice(1), !0) : !1;
      }, $H = (e) => {
        const t = e.data, o = PH(t);
        return o !== t ? (e.data = o, !0) : !1;
      }, ql = (e, t, o, r) => {
        const c = t.data, u = Re(t, c.length - 1);
        return !o && SM(c, c.length - 1) && !xM(e, u, r) ? (t.data = c.slice(0, -1) + " ", !0) : o && NH(c, c.length - 1) && Dc(e, u, r) ? (t.data = c.slice(0, -1) + $s, !0) : !1;
      }, wM = (e, t, o) => {
        const r = t.container();
        if (!tt(r))
          return P.none();
        if (MH(t)) {
          const c = BH(e, r, !1, o) || $H(r) || ql(e, r, !1, o);
          return $a(c, t);
        } else if (xM(e, t, o)) {
          const c = BH(e, r, !0, o) || ql(e, r, !0, o);
          return $a(c, t);
        } else
          return P.none();
      }, EM = (e) => {
        const t = te.fromDom(e.getBody());
        e.selection.isCollapsed() && wM(t, Re.fromRangeStart(e.selection.getRng()), e.schema).each((o) => {
          e.selection.setRng(o.toRange());
        });
      }, TM = (e, t, o, r) => {
        if (o === 0)
          return;
        const c = te.fromDom(e), u = Wi(c, (S) => r.isBlock(Hn(S))).getOr(c), f = e.data.slice(t, t + o), b = t + o >= e.data.length && Dc(u, Re(e, e.data.length), r), v = t === 0 && sx(u, Re(e, 0), r);
        e.replaceData(t, o, d0(f, 4, v, b));
      }, eT = (e, t, o) => {
        const r = e.data.slice(t), c = r.length - em(r).length;
        TM(e, t, c, o);
      }, tT = (e, t, o) => {
        const r = e.data.slice(0, t), c = r.length - Pi(r).length;
        TM(e, t - c, c, o);
      }, nT = (e, t, o, r, c = !0) => {
        const u = Pi(e.data).length, f = c ? e : t, b = c ? t : e;
        return c ? f.appendData(b.data) : f.insertData(0, b.data), qo(te.fromDom(b)), r && eT(f, u, o), f;
      }, IH = (e, t) => {
        const o = e.container(), r = e.offset();
        return !Re.isTextPosition(e) && o === t.parentNode && r > Re.before(t).offset();
      }, FH = (e, t) => IH(t, e) ? Re(t.container(), t.offset() - 1) : t, LH = (e) => tt(e) ? Re(e, 0) : Re.before(e), HH = (e) => tt(e) ? Re(e, e.data.length) : Re.after(e), zA = (e) => Rs(e.previousSibling) ? P.some(HH(e.previousSibling)) : e.previousSibling ? D(e.previousSibling) : P.none(), kM = (e) => Rs(e.nextSibling) ? P.some(LH(e.nextSibling)) : e.nextSibling ? E(e.nextSibling) : P.none(), AM = (e, t) => P.from(t.previousSibling ? t.previousSibling : t.parentNode).bind((o) => y(e, Re.before(o))).orThunk(() => p(e, Re.after(t))), zH = (e, t) => p(e, Re.after(t)).orThunk(() => y(e, Re.before(t))), GY = (e, t) => zA(t).orThunk(() => kM(t)).orThunk(() => AM(e, t)), VH = (e, t) => kM(t).orThunk(() => zA(t)).orThunk(() => zH(e, t)), UH = (e, t, o) => e ? VH(t, o) : GY(t, o), qY = (e, t, o) => UH(e, t, o).map(ue(FH, o)), _M = (e, t, o) => {
        o.fold(() => {
          e.focus();
        }, (r) => {
          e.selection.setRng(r.toRange(), t);
        });
      }, Co = (e) => (t) => t.dom === e, rx = (e, t) => t && kn(e.schema.getBlockElements(), Hn(t)), Gg = (e, t, o) => {
        if (er(e, t)) {
          const r = te.fromHtml('<br data-mce-bogus="1">');
          return o ? xe(Os(t), (c) => {
            iA(c) || qo(c);
          }) : Il(t), bo(t, r), P.some(Re.before(r.dom));
        } else
          return P.none();
      }, ub = (e, t, o, r) => {
        const c = rl(e).filter(Eo), u = tc(e).filter(Eo);
        return qo(e), Al(c, u, t, (f, b, v) => {
          const S = f.dom, O = b.dom, R = S.data.length;
          return nT(S, O, o, r), v.container() === O ? Re(S, R) : v;
        }).orThunk(() => (r && (c.each((f) => tT(f.dom, f.dom.length, o)), u.each((f) => eT(f.dom, 0, o))), t));
      }, oT = (e, t) => kn(e.schema.getTextInlineElements(), Hn(t)), $f = (e, t, o, r = !0, c = !1) => {
        const u = qY(t, e.getBody(), o.dom), f = Wi(o, ue(rx, e), Co(e.getBody())), b = ub(o, u, e.schema, oT(e, o));
        e.dom.isEmpty(e.getBody()) ? (e.setContent(""), e.selection.setCursorLocation()) : f.bind((v) => Gg(e.schema, v, c)).fold(() => {
          r && _M(e, t, b);
        }, (v) => {
          r && _M(e, t, P.some(v));
        });
      }, VA = /[\u0591-\u07FF\uFB1D-\uFDFF\uFE70-\uFEFC]/, OM = (e) => VA.test(e), db = (e, t) => Ic(te.fromDom(t), Ak(e)) && !qs(e.schema, t) && e.dom.isEditable(t), UA = (e) => lo.DOM.getStyle(e, "direction", !0) === "rtl" || OM(e.textContent ?? ""), DM = (e, t, o) => ze(lo.DOM.getParents(o.container(), "*", t), e), hp = (e, t, o) => {
        const r = DM(e, t, o);
        return P.from(r[r.length - 1]);
      }, jH = (e, t, o) => {
        const r = Of(t, e), c = Of(o, e);
        return X(r) && r === c;
      }, WH = (e) => pm(e) || Ag(e), Wu = (e, t) => {
        const o = t.container(), r = t.offset();
        return e ? $u(o) ? tt(o.nextSibling) ? Re(o.nextSibling, 0) : Re.after(o) : pm(t) ? Re(o, r + 1) : t : $u(o) ? tt(o.previousSibling) ? Re(o.previousSibling, o.previousSibling.data.length) : Re.before(o) : Ag(t) ? Re(o, r - 1) : t;
      }, RM = ue(Wu, !0), NM = ue(Wu, !1), jA = (e, t) => {
        const o = (r) => r.stopImmediatePropagation();
        e.on("beforeinput input", o, !0), e.getDoc().execCommand(t), e.off("beforeinput input", o);
      }, MM = (e) => {
        e.execCommand("delete");
      }, WA = (e) => jA(e, "Delete"), ZH = (e) => jA(e, "ForwardDelete"), KY = (e) => (t) => Ho(ec(t), e, Qn), GH = (e) => nc(e) || Ec(e), ZA = (e, t) => Ja(e, t) ? Uo(t, GH, KY(e)) : P.none(), PM = (e, t = !0) => {
        e.dom.isEmpty(e.getBody()) && e.setContent("", { no_selection: !t });
      }, BM = (e, t, o) => Xs(E(o), D(o), (r, c) => {
        const u = Wu(!0, r), f = Wu(!1, c), b = Wu(!1, t);
        return e ? p(o, b).exists((v) => v.isEqual(f) && t.isEqual(u)) : y(o, b).exists((v) => v.isEqual(u) && t.isEqual(f));
      }).getOr(!0), $M = (e) => (ci(e) ? rl(e) : or(e)).bind($M).orThunk(() => P.some(e)), qH = (e, t, o, r = !0) => {
        t.deleteContents();
        const c = $M(o).getOr(o), u = te.fromDom(e.dom.getParent(c.dom, e.dom.isBlock) ?? o.dom);
        if (u.dom === e.getBody() ? PM(e, r) : er(e.schema, u, { checkRootAsContent: !1 }) && (vf(u), r && e.selection.setCursorLocation(u.dom, 0)), !Qn(o, u)) {
          const f = Ho(ec(u), o) ? [] : Oo(u);
          xe(f.concat(Os(o)), (b) => {
            !Qn(b, u) && !Ja(b, u) && er(e.schema, b) && qo(b);
          });
        }
      }, KH = (e) => (t) => Qn(e, t), Kc = (e) => Ne(e, "td,th"), YH = (e, t) => qc(te.fromDom(e), t), XH = (e) => Xs(e.startTable, e.endTable, (t, o) => {
        const r = Dn(t, (u) => Qn(u, o)), c = Dn(o, (u) => Qn(u, t));
        return !r && !c ? e : {
          ...e,
          startTable: r ? P.none() : e.startTable,
          endTable: c ? P.none() : e.endTable,
          isSameTable: !1,
          isMultiTable: !1
        };
      }).getOr(e), IM = (e) => XH(e), YY = (e, t) => {
        const o = YH(e.startContainer, t), r = YH(e.endContainer, t), c = o.isSome(), u = r.isSome(), f = Xs(o, r, Qn).getOr(!1);
        return IM({
          startTable: o,
          endTable: r,
          isStartInTable: c,
          isEndInTable: u,
          isSameTable: f,
          isMultiTable: !f && c && u
        });
      }, GA = (e, t) => ({
        start: e,
        end: t
      }), QH = (e, t, o) => ({
        rng: e,
        table: t,
        cells: o
      }), ax = el.generate([
        { singleCellTable: ["rng", "cell"] },
        { fullTable: ["table"] },
        { partialTable: ["cells", "outsideDetails"] },
        { multiTable: ["startTableCells", "endTableCells", "betweenRng"] }
      ]), Vv = (e, t) => ia(te.fromDom(e), "td,th", t), JH = (e) => !Qn(e.start, e.end), FM = (e, t) => qc(e.start, t).bind((o) => qc(e.end, t).bind((r) => $a(Qn(o, r), o))), ez = (e, t) => !JH(e) && FM(e, t).exists((o) => {
        const r = o.dom.rows;
        return r.length === 1 && r[0].cells.length === 1;
      }), is = (e, t) => {
        const o = Vv(e.startContainer, t), r = Vv(e.endContainer, t);
        return Xs(o, r, GA);
      }, tz = (e) => (t) => qc(t, e).bind((o) => dr(Kc(o)).map((r) => GA(t, r))), nz = (e) => (t) => qc(t, e).bind((o) => js(Kc(o)).map((r) => GA(r, t))), mb = (e) => (t) => FM(t, e).map((o) => QH(t, o, Kc(o))), qA = (e, t, o, r) => {
        if (o.collapsed || !e.forall(JH))
          return P.none();
        if (t.isSameTable) {
          const c = e.bind(mb(r));
          return P.some({
            start: c,
            end: c
          });
        } else {
          const c = Vv(o.startContainer, r), u = Vv(o.endContainer, r), f = c.bind(tz(r)).bind(mb(r)), b = u.bind(nz(r)).bind(mb(r));
          return P.some({
            start: f,
            end: b
          });
        }
      }, LM = (e, t) => Ql(e, (o) => Qn(o, t)), KA = (e) => Xs(LM(e.cells, e.rng.start), LM(e.cells, e.rng.end), (t, o) => e.cells.slice(t, o + 1)), oz = (e, t, o) => e.exists((r) => ez(r, o) && rA(r.start, t)), YA = (e, t) => {
        const { startTable: o, endTable: r } = t, c = e.cloneRange();
        return o.each((u) => c.setStartAfter(u.dom)), r.each((u) => c.setEndBefore(u.dom)), c;
      }, sz = (e, t, o, r) => qA(e, t, o, r).bind(({ start: c, end: u }) => c.or(u)).bind((c) => {
        const { isSameTable: u } = t, f = KA(c).getOr([]);
        if (u && c.cells.length === f.length)
          return P.some(ax.fullTable(c.table));
        if (f.length > 0) {
          if (u)
            return P.some(ax.partialTable(f, P.none()));
          {
            const b = YA(o, t);
            return P.some(ax.partialTable(f, P.some({
              ...t,
              rng: b
            })));
          }
        } else
          return P.none();
      }), XY = (e, t, o, r) => qA(e, t, o, r).bind(({ start: c, end: u }) => {
        const f = c.bind(KA).getOr([]), b = u.bind(KA).getOr([]);
        if (f.length > 0 && b.length > 0) {
          const v = YA(o, t);
          return P.some(ax.multiTable(f, b, v));
        } else
          return P.none();
      }), QY = (e, t) => {
        const o = KH(e), r = is(t, o), c = YY(t, o);
        return oz(r, t, o) ? r.map((u) => ax.singleCellTable(t, u.start)) : c.isMultiTable ? XY(r, c, t, o) : sz(r, c, t, o);
      }, HM = (e) => xe(e, (t) => {
        sr(t, "contenteditable"), vf(t);
      }), rz = (e, t) => P.from(e.dom.getParent(t, e.dom.isBlock)).map(te.fromDom), az = (e, t, o) => {
        o.each((r) => {
          t ? qo(r) : (vf(r), e.selection.setCursorLocation(r.dom, 0));
        });
      }, XA = (e, t, o, r) => {
        const c = o.cloneRange();
        r ? (c.setStart(o.startContainer, o.startOffset), c.setEndAfter(t.dom.lastChild)) : (c.setStartBefore(t.dom.firstChild), c.setEnd(o.endContainer, o.endOffset)), sT(e, c, t, !1).each((u) => u());
      }, QA = (e) => {
        const t = Ft(e), o = te.fromDom(e.selection.getNode());
        _h(o.dom) && er(e.schema, o) ? e.selection.setCursorLocation(o.dom, 0) : e.selection.collapse(!0), t.length > 1 && po(t, (r) => Qn(r, o)) && Ss(o, "data-mce-selected", "1");
      }, zM = (e, t, o) => P.some(() => {
        const r = e.selection.getRng(), c = o.bind(({ rng: u, isStartInTable: f }) => {
          const b = rz(e, f ? u.endContainer : u.startContainer);
          u.deleteContents(), az(e, f, b.filter(ue(er, e.schema)));
          const v = f ? t[0] : t[t.length - 1];
          return XA(e, v, r, f), er(e.schema, v) ? P.none() : P.some(f ? t.slice(1) : t.slice(0, -1));
        }).getOr(t);
        HM(c), QA(e);
      }), eo = (e, t, o, r) => P.some(() => {
        const c = e.selection.getRng(), u = t[0], f = o[o.length - 1];
        XA(e, u, c, !0), XA(e, f, c, !1);
        const b = er(e.schema, u) ? t : t.slice(1), v = er(e.schema, f) ? o : o.slice(0, -1);
        HM(b.concat(v)), r.deleteContents(), QA(e);
      }), sT = (e, t, o, r = !0) => P.some(() => {
        qH(e, t, o, r);
      }), cx = (e, t) => P.some(() => $f(e, !1, t)), lx = (e, t, o) => QY(t, o).bind((r) => r.fold(ue(sT, e), ue(cx, e), ue(zM, e), ue(eo, e))), ix = (e, t) => JA(e, t), ux = (e, t, o, r) => UM(t, r).fold(() => lx(e, t, o), (c) => ix(e, c)), VM = (e, t, o) => {
        const r = te.fromDom(e.getBody()), c = e.selection.getRng();
        return o.length !== 0 ? zM(e, o, P.none()) : ux(e, r, c, t);
      }, cz = (e, t) => _o(Id(t, e), kg), UM = (e, t) => _o(Id(t, e), fr("caption")), JY = (e, t, o, r, c) => (
        // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
        dp(o, e.getBody(), c).bind((u) => cz(t, te.fromDom(u.getNode())).bind((f) => Qn(f, r) ? P.none() : P.some(St)))
      ), JA = (e, t) => P.some(() => {
        vf(t), e.selection.setCursorLocation(t.dom, 0);
      }), lz = (e, t, o, r) => E(e.dom).bind((c) => D(e.dom).map((u) => t ? o.isEqual(c) && r.isEqual(u) : o.isEqual(u) && r.isEqual(c))).getOr(!0), eX = (e, t) => JA(e, t), iz = (e, t, o) => (
        // TODO: TINY-8865 - This may not be safe to cast as Node below and alternative solutions need to be looked into
        UM(e, te.fromDom(o.getNode())).fold(() => P.some(St), (r) => $a(!Qn(r, t), St))
      ), uz = (e, t, o, r, c) => dp(o, e.getBody(), c).fold(() => P.some(St), (u) => lz(r, o, c, u) ? eX(e, r) : iz(t, r, u)), tX = (e, t, o, r) => {
        const c = Re.fromRangeStart(e.selection.getRng());
        return cz(o, r).bind((u) => er(e.schema, u, { checkRootAsContent: !1 }) ? JA(e, u) : JY(e, o, t, u, c));
      }, dz = (e, t, o, r) => {
        const c = Re.fromRangeStart(e.selection.getRng());
        return er(e.schema, r) ? JA(e, r) : uz(e, o, t, r, c);
      }, ps = (e, t) => e ? ox(t) : BA(t), nX = (e, t) => {
        const o = Re.fromRangeStart(e.selection.getRng());
        return ps(t, o) || Zl(t, e.getBody(), o).exists((r) => ps(t, r));
      }, oX = (e, t, o) => {
        const r = te.fromDom(e.getBody());
        return UM(r, o).fold(() => tX(e, t, r, o).orThunk(() => $a(nX(e, t), St)), (c) => dz(e, t, r, c));
      }, e_ = (e, t) => {
        const o = te.fromDom(e.selection.getStart(!0)), r = Ft(e);
        return e.selection.isCollapsed() && r.length === 0 ? oX(e, t, o) : VM(e, o, r);
      }, Om = (e, t) => {
        let o = t;
        for (; o && o !== e; ) {
          if (dl(o) || Es(o))
            return o;
          o = o.parentNode;
        }
        return null;
      }, mz = [
        "data-ephox-",
        "data-mce-",
        "data-alloy-",
        "data-snooker-",
        "_"
      ], fz = Je.each, Dm = (e) => {
        const t = e.dom, o = new Set(e.serializer.getTempAttrs()), r = (u, f) => {
          if (u.nodeName !== f.nodeName || u.nodeType !== f.nodeType)
            return !1;
          const b = (S) => {
            const O = {};
            return fz(t.getAttribs(S), (R) => {
              const M = R.nodeName.toLowerCase();
              M !== "style" && !c(M) && (O[M] = t.getAttrib(S, M));
            }), O;
          }, v = (S, O) => {
            for (const R in S)
              if (kn(S, R)) {
                const M = O[R];
                if (Gn(M) || S[R] !== M)
                  return !1;
                delete O[R];
              }
            for (const R in O)
              if (kn(O, R))
                return !1;
            return !0;
          };
          return ht(u) && ht(f) && (!v(b(u), b(f)) || !v(t.parseStyle(t.getAttrib(u, "style")), t.parseStyle(t.getAttrib(f, "style")))) ? !1 : !Ys(u) && !Ys(f);
        }, c = (u) => po(mz, (f) => hn(u, f)) || o.has(u);
        return {
          compare: r,
          isAttributeInternal: c
        };
      }, To = (e, t) => {
        if (tt(e))
          return { container: e, offset: t };
        const o = _m.getNode(e, t);
        return tt(o) ? {
          container: o,
          offset: t >= e.childNodes.length ? o.data.length : 0
        } : o.previousSibling && tt(o.previousSibling) ? {
          container: o.previousSibling,
          offset: o.previousSibling.data.length
        } : o.nextSibling && tt(o.nextSibling) ? {
          container: o.nextSibling,
          offset: 0
        } : { container: e, offset: t };
      }, ma = (e) => {
        const t = e.cloneRange(), o = To(e.startContainer, e.startOffset);
        t.setStart(o.container, o.offset);
        const r = To(e.endContainer, e.endOffset);
        return t.setEnd(r.container, r.offset), t;
      }, au = lo.DOM, gz = () => au.create("span", { "data-mce-type": "bookmark" }), jM = (e, t, o) => {
        if (ht(e)) {
          const r = o();
          return e.hasChildNodes() ? t === e.childNodes.length ? e.appendChild(r) : e.insertBefore(r, e.childNodes[t]) : e.appendChild(r), { container: r, offset: 0 };
        } else
          return { container: e, offset: t };
      }, WM = (e, t) => {
        const o = (r) => {
          let c = r.parentNode?.firstChild, u = 0;
          for (; c; ) {
            if (c === r)
              return u;
            (!ht(c) || c.getAttribute("data-mce-type") !== "bookmark") && u++, c = c.nextSibling;
          }
          return -1;
        };
        if (ht(e) && X(e.parentNode)) {
          const r = e;
          t = o(e), e = e.parentNode, au.remove(r), !e.hasChildNodes() && au.isBlock(e) && e.appendChild(au.create("br"));
        }
        return { container: e, offset: t };
      }, ZM = (e, t, o, r) => {
        const c = au.createRng();
        return c.setStart(e, t), c.setEnd(o, r), ma(c);
      }, If = (e, t = gz) => {
        const { container: o, offset: r } = jM(e.startContainer, e.startOffset, t);
        if (e.collapsed)
          return { startContainer: o, startOffset: r };
        {
          const { container: c, offset: u } = jM(e.endContainer, e.endOffset, t);
          return { startContainer: o, startOffset: r, endContainer: c, endOffset: u };
        }
      }, Zu = (e) => {
        const { container: t, offset: o } = WM(e.startContainer, e.startOffset);
        if (!Gn(e.endContainer) && !Gn(e.endOffset)) {
          const { container: r, offset: c } = WM(e.endContainer, e.endOffset);
          return ZM(t, o, r, c);
        } else
          return ZM(t, o, t, o);
      }, t_ = (e, t, o, r) => {
        if (Je.each(o.styles, (c, u) => {
          e.setStyle(t, u, jg(c, r));
        }), o.styles) {
          const c = e.getAttrib(t, "style");
          c && e.setAttrib(t, "data-mce-style", c);
        }
      }, fb = (e, t, o, r, c) => {
        const u = e.dom;
        se(o.onformat) && o.onformat(t, o, r, c), t_(u, t, o, r), Je.each(o.attributes, (f, b) => {
          u.setAttrib(t, b, jg(f, r));
        }), Je.each(o.classes, (f) => {
          const b = jg(f, r);
          u.hasClass(t, b) || u.addClass(t, b);
        });
      }, hz = (e) => !Ot(e.attributes) && !Ot(e.styles), n_ = qC, GM = (e, t, o) => {
        const r = e.formatter.get(o);
        if (r)
          for (let c = 0; c < r.length; c++) {
            const u = r[c];
            if (Md(u) && u.inherit === !1 && e.dom.is(t, u.selector))
              return !0;
          }
        return !1;
      }, rT = (e, t, o, r, c) => {
        const u = e.dom.getRoot();
        if (t === u)
          return !1;
        const f = e.dom.getParent(t, (b) => GM(e, b, o) ? !0 : b.parentNode === u || !!Gu(e, b, o, r, !0));
        return !!Gu(e, f, o, r, c);
      }, aT = (e, t, o) => Va(o) && n_(t, o.inline) || km(o) && n_(t, o.block) ? !0 : Md(o) ? ht(t) && e.is(t, o.selector) : !1, qM = (e, t, o, r, c, u) => {
        const f = o[r], b = r === "attributes";
        if (se(o.onmatch))
          return o.onmatch(t, o, r);
        if (f) {
          if (tg(f)) {
            for (let v = 0; v < f.length; v++)
              if (b ? e.getAttrib(t, f[v]) : KC(e, t, f[v]))
                return !0;
          } else
            for (const v in f)
              if (kn(f, v)) {
                const S = b ? e.getAttrib(t, v) : KC(e, t, v), O = jg(f[v], u), R = jt(S) || ti(S);
                if (R && jt(O))
                  continue;
                if (c && R && !o.exact || (!c || o.exact) && !n_(S, OE(O, v)))
                  return !1;
              }
        }
        return !0;
      }, Gu = (e, t, o, r, c) => {
        const u = e.formatter.get(o), f = e.dom;
        if (u && ht(t))
          for (let b = 0; b < u.length; b++) {
            const v = u[b];
            if (aT(e.dom, t, v) && qM(f, t, v, "attributes", c, r) && qM(f, t, v, "styles", c, r)) {
              const S = v.classes;
              if (S) {
                for (let O = 0; O < S.length; O++)
                  if (!e.dom.hasClass(t, jg(S[O], r)))
                    return;
              }
              return v;
            }
          }
      }, o_ = (e, t, o, r, c) => {
        if (r)
          return rT(e, r, t, o, c);
        if (r = e.selection.getNode(), rT(e, r, t, o, c))
          return !0;
        const u = e.selection.getStart();
        return !!(u !== r && rT(e, u, t, o, c));
      }, s_ = (e, t, o) => {
        const r = [], c = {}, u = e.selection.getStart();
        return e.dom.getParent(u, (f) => {
          for (let b = 0; b < t.length; b++) {
            const v = t[b];
            !c[v] && Gu(e, f, v, o) && (c[v] = !0, r.push(v));
          }
        }, e.dom.getRoot()), r;
      }, KM = (e, t) => {
        const o = (c) => Qn(c, te.fromDom(e.getBody())), r = (c, u) => Gu(e, c.dom, u) ? P.some(u) : P.none();
        return P.from(e.selection.getStart(!0)).bind((c) => gi(te.fromDom(c), (u) => cc(t, (f) => r(u, f)), o)).getOrNull();
      }, r_ = (e, t) => {
        const o = e.formatter.get(t), r = e.dom;
        if (o && e.selection.isEditable()) {
          const c = e.selection.getStart(), u = DE(r, c);
          for (let f = o.length - 1; f >= 0; f--) {
            const b = o[f];
            if (!Md(b))
              return !0;
            for (let v = u.length - 1; v >= 0; v--)
              if (r.is(u[v], b.selector))
                return !0;
          }
        }
        return !1;
      }, sX = (e, t, o) => Io(o, (r, c) => {
        const u = RE(e, c);
        return e.formatter.matchNode(t, c, {}, u) ? r.concat([c]) : r;
      }, []), oa = Ur, pz = (e, t) => e.importNode(t, !0), bz = (e) => {
        if (e) {
          const t = new Js(e, e);
          for (let o = t.current(); o; o = t.next())
            if (tt(o))
              return o;
        }
        return null;
      }, a_ = (e) => {
        const t = te.fromTag("span");
        return ea(t, {
          // style: 'color:red',
          id: $,
          "data-mce-bogus": "1",
          "data-mce-type": "format-caret"
        }), e && bo(t, te.fromText(oa)), t;
      }, vz = (e) => {
        const t = bz(e);
        return t && t.data.charAt(0) === oa && t.deleteData(0, 1), t;
      }, c_ = (e, t, o) => {
        const r = e.dom, c = e.selection;
        if (p5(t))
          $f(e, !1, te.fromDom(t), o, !0);
        else {
          const u = c.getRng(), f = r.getParent(t, r.isBlock), b = u.startContainer, v = u.startOffset, S = u.endContainer, O = u.endOffset, R = vz(t);
          r.remove(t, !0), b === R && v > 0 && u.setStart(R, v - 1), S === R && O > 0 && u.setEnd(R, O - 1), f && r.isEmpty(f) && vf(te.fromDom(f)), c.setRng(u);
        }
      }, l_ = (e, t, o) => {
        const r = e.dom, c = e.selection;
        if (t)
          c_(e, t, o);
        else if (t = K(e.getBody(), c.getStart()), !t)
          for (; t = r.get($); )
            c_(e, t, o);
      }, YM = (e, t, o) => {
        const r = e.dom, c = r.getParent(o, ue(GC, e.schema));
        c && r.isEmpty(c) ? o.parentNode?.replaceChild(t, o) : (ek(te.fromDom(o)), r.isEmpty(o) ? o.parentNode?.replaceChild(t, o) : r.insertAfter(t, o));
      }, Uv = (e, t) => (e.appendChild(t), t), XM = (e, t) => {
        const o = qn(e, (c, u) => Uv(c, u.cloneNode(!1)), t), r = o.ownerDocument ?? document;
        return Uv(o, r.createTextNode(oa));
      }, QM = (e, t, o, r, c, u) => {
        const f = e.formatter, b = e.dom, v = ze(Vt(f.get()), (R) => R !== r && !As(R, "removeformat")), S = sX(e, o, v);
        if (ze(S, (R) => !h5(e, R, r)).length > 0) {
          const R = o.cloneNode(!1);
          return b.add(t, R), f.remove(r, c, R, u), b.remove(R), P.some(R);
        } else
          return P.none();
      }, JM = (e) => s1(e, xa(e).replace(new RegExp(`${$s}$`), " ")), pp = (e, t) => {
        const o = () => {
          t !== null && !e.dom.isEmpty(t) && rl(te.fromDom(t)).each((r) => {
            Eo(r) ? JM(r) : of(r, (c) => Eo(c)).each((c) => {
              Eo(c) && JM(c);
            });
          });
        };
        e.once("input", (r) => {
          r.data && !Gl(r.data) && (r.isComposing ? e.once("compositionend", () => {
            o();
          }) : o());
        });
      }, eP = (e, t, o) => {
        let r;
        const c = e.selection, u = e.formatter.get(t);
        if (!u)
          return;
        const f = c.getRng();
        let b = f.startOffset;
        const S = f.startContainer.nodeValue;
        r = K(e.getBody(), c.getStart());
        const O = /[^\s\u00a0\u00ad\u200b\ufeff]/;
        if (S && b > 0 && b < S.length && O.test(S.charAt(b)) && O.test(S.charAt(b - 1))) {
          const R = c.getBookmark();
          f.collapse(!0);
          let M = Pf(e.dom, f, u);
          M = Hv(M), e.formatter.apply(t, o, M), c.moveToBookmark(R);
        } else {
          let R = r ? bz(r) : null;
          (!r || R?.data !== oa) && (r = pz(e.getDoc(), a_(!0).dom), R = r.firstChild, f.insertNode(r), b = 1, pp(e, r)), e.formatter.apply(t, o, r), c.setCursorLocation(R, b);
        }
      }, tP = (e, t, o, r) => {
        const c = e.dom, u = e.selection;
        let f = !1;
        const b = e.formatter.get(t);
        if (!b)
          return;
        const v = u.getRng(), S = v.startContainer, O = v.startOffset;
        let R = S;
        tt(S) && (O !== S.data.length && (f = !0), R = R.parentNode);
        const M = [];
        let H;
        for (; R; ) {
          if (Gu(e, R, t, o, r)) {
            H = R;
            break;
          }
          R.nextSibling && (f = !0), M.push(R), R = R.parentNode;
        }
        if (H)
          if (f) {
            const J = u.getBookmark();
            v.collapse(!0);
            let W = Pf(c, v, b, { includeTrailingSpace: !0 });
            W = Hv(W), e.formatter.remove(t, o, W, r), u.moveToBookmark(J);
          } else {
            const J = K(e.getBody(), H), W = X(J) ? c.getParents(H.parentNode, He, J) : [], Q = a_(!1).dom;
            YM(e, Q, J ?? H);
            const ge = QM(e, Q, H, t, o, r), be = XM([
              ...M,
              ...ge.toArray(),
              ...W
            ], Q);
            J && c_(e, J, X(J)), u.setCursorLocation(be, 1), pp(e, Q), c.isEmpty(H) && c.remove(H);
          }
      }, nP = (e, t, o) => {
        const r = e.selection, c = e.getBody();
        l_(e, null, o), (t === 8 || t === 46) && r.isCollapsed() && r.getStart().innerHTML === oa && l_(e, K(c, r.getStart()), !0), (t === 37 || t === 39) && l_(e, K(c, r.getStart()), !0);
      }, oP = (e) => tt(e) && qr(e.data, $s), sP = (e) => {
        e.on("mouseup keydown", (t) => {
          nP(e, t.keyCode, oP(e.selection.getRng().endContainer));
        });
      }, rP = (e) => {
        const t = a_(!1), o = XM(e, t.dom);
        return { caretContainer: t, caretPosition: Re(o, 0) };
      }, i_ = (e, t) => {
        const { caretContainer: o, caretPosition: r } = rP(t);
        return ca(te.fromDom(e), o), qo(te.fromDom(e)), r;
      }, yz = (e, t) => {
        const { caretContainer: o, caretPosition: r } = rP(t);
        return e.insertNode(o.dom), r;
      }, aP = (e, t) => {
        if (z(t.dom))
          return !1;
        const o = e.schema.getTextInlineElements();
        return kn(o, Hn(t)) && !z(t.dom) && !uf(t.dom);
      }, cP = ["fontWeight", "fontStyle", "color", "fontSize", "fontFamily"], Cz = (e) => Ye(e.styles) && po(Vt(e.styles), (t) => Lt(cP, t)), xz = (e) => _o(e, (t) => Va(t) && t.inline === "span" && Cz(t)), Sz = (e, t) => {
        const o = e.get(t);
        return Ot(o) ? xz(o) : P.none();
      }, u_ = (e, t) => y(t, Re.fromRangeStart(e)).isNone(), lP = (e, t) => p(t, Re.fromRangeEnd(e)).exists((o) => !zs(o.getNode()) || p(t, o).isSome()) === !1, wz = (e) => (t) => d1(t) && e.isEditable(t), iP = (e, t) => en(e.getSelectedBlocks(), (o, r) => r === 0 && t(o) ? e.dom.getParent(o, d1) ?? o : o), d_ = (e) => {
        if (e.isCollapsed())
          return [];
        const t = e.getRng(), o = iP(e, (r) => u_(t, r) && !d1(r));
        if (o.length === 1)
          return u_(t, o[0]) && lP(t, o[0]) ? o : [];
        {
          const r = js(o).filter((f) => u_(t, f)).toArray(), c = dr(o).filter((f) => lP(t, f)).toArray(), u = o.slice(1, -1);
          return r.concat(u).concat(c);
        }
      }, m_ = (e) => ze(d_(e), wz(e.dom)), uP = (e) => ze(iP(e, (t) => !d1(t)), wz(e.dom)), dP = Je.each, f_ = (e) => ht(e) && !Ys(e) && !z(e) && !uf(e), mP = (e, t) => {
        for (let o = e; o; o = o[t]) {
          if (tt(o) && ms(o.data))
            return e;
          if (ht(o) && !Ys(o))
            return o;
        }
        return e;
      }, fP = (e, t, o) => {
        const r = Dm(e), c = zc(t) && e.dom.isEditable(t), u = zc(o) && e.dom.isEditable(o);
        if (c && u) {
          const f = mP(t, "previousSibling"), b = mP(o, "nextSibling");
          if (r.compare(f, b)) {
            for (let v = f.nextSibling; v && v !== b; ) {
              const S = v;
              v = v.nextSibling, f.appendChild(S);
            }
            return e.dom.remove(b), Je.each(Je.grep(b.childNodes), (v) => {
              f.appendChild(v);
            }), f;
          }
        }
        return o;
      }, gP = (e, t, o, r) => {
        if (r && t.merge_siblings !== !1) {
          const c = fP(e, m5(r), r) ?? r;
          fP(e, c, m5(c, !0));
        }
      }, Ez = (e, t, o) => {
        if (t.clear_child_styles) {
          const r = t.links ? "*:not(a)" : "*";
          dP(e.select(r, o), (c) => {
            f_(c) && e.isEditable(c) && dP(t.styles, (u, f) => {
              e.setStyle(c, f, "");
            });
          });
        }
      }, g_ = (e, t, o) => {
        dP(e.childNodes, (r) => {
          f_(r) && (t(r) && o(r), r.hasChildNodes() && g_(r, t, o));
        });
      }, Tz = (e, t) => {
        t.nodeName === "SPAN" && e.getAttribs(t).length === 0 && e.remove(t, !0);
      }, h_ = (e, t) => (o) => !!(o && KC(e, o, t)), hP = (e, t, o) => (r) => {
        e.setStyle(r, t, o), r.getAttribute("style") === "" && r.removeAttribute("style"), Tz(e, r);
      }, gb = el.generate([
        { keep: [] },
        { rename: ["name"] },
        { removed: [] }
      ]), qg = /^(src|href|style)$/, p_ = Je.each, dx = qC, kz = (e) => /^(TR|TH|TD)$/.test(e.nodeName), pP = (e, t, o) => e.isChildOf(t, o) && t !== o && !e.isBlock(o), b_ = (e, t, o) => {
        let r = t[o ? "startContainer" : "endContainer"], c = t[o ? "startOffset" : "endOffset"];
        if (ht(r)) {
          const u = r.childNodes.length - 1;
          !o && c && c--, r = r.childNodes[c > u ? u : c];
        }
        return tt(r) && o && c >= r.data.length && (r = new Js(r, e.getBody()).next() || r), tt(r) && !o && c === 0 && (r = new Js(r, e.getBody()).prev() || r), r;
      }, v_ = (e, t) => {
        const o = t ? "firstChild" : "lastChild", r = e[o];
        return kz(e) && r ? e.nodeName === "TR" && r[o] || r : e;
      }, cT = (e, t, o, r) => {
        const c = e.create(o, r);
        return t.parentNode?.insertBefore(c, t), c.appendChild(t), c;
      }, y_ = (e, t, o, r, c) => {
        const u = te.fromDom(t), f = te.fromDom(e.create(r, c)), b = o ? $r(u) : Xr(u);
        return ll(f, b), o ? (ca(u, f), zi(f, u)) : (cl(u, f), bo(f, u)), f.dom;
      }, Az = (e, t) => t.links && e.nodeName === "A", bP = (e, t, o) => {
        const r = t.parentNode;
        let c;
        const u = e.dom, f = Ar(e);
        km(o) && r === u.getRoot() && (!o.list_block || !dx(t, o.list_block)) && xe(rs(t.childNodes), (b) => {
          Bv(e, f, b.nodeName.toLowerCase()) ? c ? c.appendChild(b) : (c = cT(u, b, f), u.setAttribs(c, nu(e))) : c = null;
        }), !(BY(o) && !dx(o.inline, t)) && u.remove(t, !0);
      }, vP = (e, t, o) => ns(e) ? {
        name: t,
        value: null
      } : {
        name: e,
        value: jg(t, o)
      }, yP = (e, t) => {
        e.getAttrib(t, "style") === "" && (t.removeAttribute("style"), t.removeAttribute("data-mce-style"));
      }, CP = (e, t, o, r, c) => {
        let u = !1;
        p_(o.styles, (f, b) => {
          const { name: v, value: S } = vP(b, f, r), O = OE(S, v);
          (o.remove_similar || oe(S) || !ht(c) || dx(KC(e, c, v), O)) && e.setStyle(t, v, ""), u = !0;
        }), u && yP(e, t);
      }, hb = (e, t, o) => {
        t === "removeformat" ? xe(uP(e.selection), (r) => {
          xe(cP, (c) => e.dom.setStyle(r, c, "")), yP(e.dom, r);
        }) : Sz(e.formatter, t).each((r) => {
          xe(uP(e.selection), (c) => CP(e.dom, c, r, o, null));
        });
      }, lT = (e, t, o, r, c) => {
        const u = e.dom, f = Dm(e), b = e.schema;
        if (Va(t) && Uc(b, t.inline) && qs(b, r) && r.parentElement === e.getBody())
          return bP(e, r, t), gb.removed();
        if (!t.ceFalseOverride && r && u.getContentEditableParent(r) === "false" || r && !aT(u, r, t) && !Az(r, t))
          return gb.keep();
        const v = r, S = t.preserve_attributes;
        if (Va(t) && t.remove === "all" && Ot(S)) {
          const O = ze(u.getAttribs(v), (R) => Lt(S, R.name.toLowerCase()));
          if (u.removeAllAttribs(v), xe(O, (R) => u.setAttrib(v, R.name, R.value)), O.length > 0)
            return gb.rename("span");
        }
        if (t.remove !== "all") {
          CP(u, v, t, o, c), p_(t.attributes, (R, M) => {
            const { name: H, value: J } = vP(M, R, o);
            if (t.remove_similar || oe(J) || !ht(c) || dx(u.getAttrib(c, H), J)) {
              if (H === "class") {
                const W = u.getAttrib(v, H);
                if (W) {
                  let Q = "";
                  if (xe(W.split(/\s+/), (ge) => {
                    /mce\-\w+/.test(ge) && (Q += (Q ? " " : "") + ge);
                  }), Q) {
                    u.setAttrib(v, H, Q);
                    return;
                  }
                }
              }
              if (qg.test(H) && v.removeAttribute("data-mce-" + H), H === "style" && hi(["li"])(v) && u.getStyle(v, "list-style-type") === "none") {
                v.removeAttribute(H), u.setStyle(v, "list-style-type", "none");
                return;
              }
              H === "class" && v.removeAttribute("className"), v.removeAttribute(H);
            }
          }), p_(t.classes, (R) => {
            R = jg(R, o), (!ht(c) || u.hasClass(c, R)) && u.removeClass(v, R);
          });
          const O = u.getAttribs(v);
          for (let R = 0; R < O.length; R++) {
            const M = O[R].nodeName;
            if (!f.isAttributeInternal(M))
              return gb.keep();
          }
        }
        return t.remove !== "none" ? (bP(e, v, t), gb.removed()) : gb.keep();
      }, _z = (e, t, o, r, c) => {
        let u;
        return t.parentNode && xe(DE(e.dom, t.parentNode).reverse(), (f) => {
          if (!u && ht(f) && f.id !== "_start" && f.id !== "_end") {
            const b = Gu(e, f, o, r, c);
            b && b.split !== !1 && (u = f);
          }
        }), u;
      }, Oz = (e, t, o, r) => lT(e, t, o, r, r).fold(ot(r), (c) => (e.dom.createFragment().appendChild(r), e.dom.rename(r, c)), ot(null)), C_ = (e, t, o, r, c, u, f, b) => {
        let v, S;
        const O = e.dom;
        if (o) {
          const R = o.parentNode;
          for (let M = r.parentNode; M && M !== R; M = M.parentNode) {
            let H = O.clone(M, !1);
            for (let J = 0; J < t.length && (H = Oz(e, t[J], b, H), H !== null); J++)
              ;
            H && (v && H.appendChild(v), S || (S = H), v = H);
          }
          (!f.mixed || !O.isBlock(o)) && (r = O.split(o, r) ?? r), v && S && (c.parentNode?.insertBefore(v, c), S.appendChild(c), Va(f) && gP(e, f, b, v));
        }
        return r;
      }, Dz = (e, t, o, r, c) => {
        const u = e.formatter.get(t), f = u[0], b = e.dom, v = e.selection, S = (W) => {
          const Q = _z(e, W, t, o, c);
          return C_(e, u, Q, W, W, !0, f, o);
        }, O = (W) => Ys(W) && ht(W) && (W.id === "_start" || W.id === "_end"), R = (W) => po(u, (Q) => mx(e, Q, o, W, W)), M = (W) => {
          const Q = rs(W.childNodes), be = R(W) || po(u, (je) => aT(b, W, je)), ve = W.parentNode;
          if (!be && X(ve) && lA(f) && R(ve), f.deep && Q.length)
            for (let je = 0; je < Q.length; je++)
              M(Q[je]);
          xe(["underline", "line-through", "overline"], (je) => {
            ht(W) && e.dom.getStyle(W, "text-decoration") === je && W.parentNode && g5(b, W.parentNode) === je && mx(e, {
              deep: !1,
              exact: !0,
              inline: "span",
              styles: {
                textDecoration: je
              }
            }, void 0, W);
          });
        }, H = (W) => {
          const Q = b.get(W ? "_start" : "_end");
          if (Q) {
            let ge = Q[W ? "firstChild" : "lastChild"];
            return O(ge) && (ge = ge[W ? "firstChild" : "lastChild"]), tt(ge) && ge.data.length === 0 && (ge = W ? Q.previousSibling || Q.nextSibling : Q.nextSibling || Q.previousSibling), b.remove(Q, !0), ge;
          } else
            return null;
        }, J = (W) => {
          let Q, ge, be = Pf(b, W, u, { includeTrailingSpace: W.collapsed });
          if (f.split) {
            if (be = Hv(be), Q = b_(e, be, !0), ge = b_(e, be), Q !== ge) {
              if (Q = v_(Q, !0), ge = v_(ge, !1), pP(b, Q, ge)) {
                const Be = P.from(Q.firstChild).getOr(Q);
                S(y_(b, Be, !0, "span", { id: "_start", "data-mce-type": "bookmark" })), H(!0);
                return;
              }
              if (pP(b, ge, Q)) {
                const Be = P.from(ge.lastChild).getOr(ge);
                S(y_(b, Be, !1, "span", { id: "_end", "data-mce-type": "bookmark" })), H(!1);
                return;
              }
              Q = cT(b, Q, "span", { id: "_start", "data-mce-type": "bookmark" }), ge = cT(b, ge, "span", { id: "_end", "data-mce-type": "bookmark" });
              const ve = b.createRng();
              ve.setStartAfter(Q), ve.setEndBefore(ge), Pd(b, ve, (Be) => {
                xe(Be, (je) => {
                  !Ys(je) && !Ys(je.parentNode) && S(je);
                });
              }), S(Q), S(ge), Q = H(!0), ge = H();
            } else
              Q = ge = S(Q);
            be.startContainer = Q.parentNode ? Q.parentNode : Q, be.startOffset = b.nodeIndex(Q), be.endContainer = ge.parentNode ? ge.parentNode : ge, be.endOffset = b.nodeIndex(ge) + 1;
          }
          Pd(b, be, (ve) => {
            xe(ve, M);
          });
        };
        if (r) {
          if (WC(r)) {
            const W = b.createRng();
            W.setStartBefore(r), W.setEndAfter(r), J(W);
          } else
            J(r);
          lC(e, t, r, o);
          return;
        }
        !v.isCollapsed() || !Va(f) || Ft(e).length ? (u5(
          e,
          () => UC(e, J),
          // Before trying to move the start of the selection, check if start element still has formatting then we are at: "<b>text|</b>text"
          // and need to move the start into the next text node
          (W) => Va(f) && o_(e, t, o, W)
        ), e.nodeChanged()) : tP(e, t, o, c), hb(e, t, o), lC(e, t, r, o);
      }, iT = (e, t, o, r, c) => {
        (r || e.selection.isEditable()) && Dz(e, t, o, r, c);
      }, xP = (e, t, o, r) => lT(e, t, o, r).fold(() => P.some(r), (c) => P.some(e.dom.rename(r, c)), P.none), mx = (e, t, o, r, c) => lT(e, t, o, r, c).fold(ye, (u) => (e.dom.rename(r, u), !0), He), SP = ["fontsize", "subscript", "superscript"], uT = ["strikethrough", ...SP], Rz = (e, t, o) => X(e.matchNode(t.dom, o, {}, o === "fontsize")), dT = (e, t) => po(SP, (o) => Rz(e, t, o)), Nz = (e) => Lt(uT, e), wP = (e, t, o, r, c) => {
        const u = ya(t, e).filter(Is);
        return jm(u, o).map((f) => {
          const b = u[f], v = r(b), S = [
            ...c(pr(b)).toArray(),
            ...xo(u.slice(0, f), (O) => o(O) ? c(O).toArray() : [pr(O)])
          ];
          return { container: b, innerWrapper: v, outerWrappers: S };
        });
      }, EP = (e, t, o, r) => {
        xe(Os(e), (c) => {
          Is(c) && o(c) && r(c).isNone() && hc(c);
        }), xe(Os(e), (c) => bo(t, c)), zi(e, t);
      }, TP = (e, t) => {
        if (t.length > 0) {
          const o = t[t.length - 1];
          ca(e, o);
          const r = Io(t.slice(0, t.length - 1), (c, u) => (bo(c, u), u), o);
          bo(r, e);
        }
      }, Mz = (e, t, o, r, c) => {
        const u = (f) => Qn(te.fromDom(e.getRoot()), f) || e.isBlock(f.dom);
        xe(t, (f) => {
          wP(u, f, o, r, c).each(({ container: b, innerWrapper: v, outerWrappers: S }) => {
            e.split(b.dom, f.dom), EP(f, v, o, c), TP(f, S);
          });
        });
      }, x_ = (e, t, o) => {
        const r = (b) => X(Gu(e, b.dom, t)), c = (b) => {
          const v = te.fromTag(Hn(b)), S = Gu(e, b.dom, t, {});
          return X(S) && hz(S) && fb(e, v.dom, S), v;
        }, u = (b) => {
          const v = Gu(e, b.dom, t, {});
          return X(v) ? xP(e, v, {}, b.dom).map(te.fromDom) : P.some(b);
        }, f = If(e.selection.getRng());
        Mz(e.dom, o, r, c, u), e.selection.setRng(Zu(f));
      }, Pz = (e, t) => xo(t, (o) => {
        const r = q(o, (c) => dT(e, c));
        return dT(e, o) ? [o, ...r] : r;
      }), Bz = (e, t, o) => {
        if (Nz(t)) {
          const r = Pz(e.formatter, o);
          x_(e, "strikethrough", r);
        }
      }, $z = (e, t) => {
        const o = ze(t, (r) => dT(e.formatter, r));
        x_(e, "strikethrough", o);
      }, Kl = (e) => ["h1", "h2", "h3", "h4", "h5", "h6"].includes(e.name), kP = (e) => e.name === "summary", Iz = (e, t) => {
        let o = e;
        for (; o = o.walk(); )
          t(o);
      }, S_ = (e, t, o, r) => {
        const c = o.name;
        for (let u = 0, f = e.length; u < f; u++) {
          const b = e[u];
          if (b.name === c) {
            const v = r.nodes[c];
            v ? v.nodes.push(o) : r.nodes[c] = { filter: b, nodes: [o] };
          }
        }
        if (o.attributes)
          for (let u = 0, f = t.length; u < f; u++) {
            const b = t[u], v = b.name;
            if (v in o.attributes.map) {
              const S = r.attributes[v];
              S ? S.nodes.push(o) : r.attributes[v] = { filter: b, nodes: [o] };
            }
          }
      }, Fz = (e, t, o) => {
        const r = { nodes: {}, attributes: {} };
        return o.firstChild && Iz(o, (c) => {
          S_(e, t, c, r);
        }), r;
      }, AP = (e, t) => {
        const o = (r, c) => {
          Un(r, (u) => {
            const f = rs(u.nodes);
            xe(u.filter.callbacks, (b) => {
              for (let v = f.length - 1; v >= 0; v--) {
                const S = f[v];
                (!(c ? S.attr(u.filter.name) !== void 0 : S.name === u.filter.name) || jt(S.parent)) && f.splice(v, 1);
              }
              f.length > 0 && b(f, u.filter.name, t);
            });
          });
        };
        o(e.nodes, !1), o(e.attributes, !0);
      }, _P = (e, t, o, r = {}) => {
        const c = Fz(e, t, o);
        AP(c, r);
      }, bp = (e, t, o, r) => {
        if ((e.pad_empty_with_br || t.insert) && o(r)) {
          const u = new _a("br", 1);
          t.insert && u.attr("data-mce-bogus", "1"), r.empty().append(u);
        } else
          r.empty().append(new _a("#text", 3)).value = $s;
      }, jv = (e) => Lz(e, "#text") && e?.firstChild?.value === $s, Lz = (e, t) => {
        const o = e?.firstChild;
        return X(o) && o === e.lastChild && o.name === t;
      }, Hz = (e, t) => e.getElementRule(t.name)?.paddEmpty === !0, fx = (e, t, o, r) => r.isEmpty(t, o, (c) => Hz(e, c)), Rm = (e, t) => X(e) && (t(e) || e.name === "br"), zz = (e) => {
        let t;
        for (let o = e; o; o = o.parent) {
          const r = o.attr("contenteditable");
          if (r === "false")
            break;
          r === "true" && (t = o);
        }
        return P.from(t);
      }, Vz = (e) => {
        const t = [];
        for (let o = e.firstChild; X(o); o = o.walk())
          t.push(o);
        return t;
      }, Wv = (e, t, o = e.parent) => {
        if (t.getSpecialElements()[e.name])
          e.empty().remove();
        else {
          const r = e.children();
          for (const c of r)
            o && !t.isValidChild(o.name, c.name) && Wv(c, t, o);
          e.unwrap();
        }
      }, OP = (e, t, o, r = St) => {
        const c = t.getTextBlockElements(), u = t.getNonEmptyElements(), f = t.getWhitespaceElements(), b = Je.makeMap("tr,td,th,tbody,thead,tfoot,table,summary"), v = /* @__PURE__ */ new Set(), S = (O) => O !== o && !b[O.name];
        for (let O = 0; O < e.length; O++) {
          const R = e[O];
          let M, H, J;
          if (!R.parent || v.has(R))
            continue;
          if (c[R.name] && R.parent.name === "li") {
            let Q = R.next;
            for (; Q && c[Q.name]; ) {
              Q.name = "li", v.add(Q), R.parent.insert(Q, R.parent);
              Q = Q.next;
            }
            R.unwrap();
            continue;
          }
          const W = [R];
          for (M = R.parent; M && !t.isValidChild(M.name, R.name) && S(M); M = M.parent)
            W.push(M);
          if (M && W.length > 1)
            if (gx(t, R, M))
              Wv(R, t);
            else {
              W.reverse(), H = W[0].clone(), r(H);
              let Q = H;
              for (let ge = 0; ge < W.length - 1; ge++) {
                t.isValidChild(Q.name, W[ge].name) && ge > 0 ? (J = W[ge].clone(), r(J), Q.append(J)) : J = Q;
                for (let be = W[ge].firstChild; be && be !== W[ge + 1]; ) {
                  const ve = be.next;
                  J.append(be), be = ve;
                }
                Q = J;
              }
              fx(t, u, f, H) ? M.insert(R, W[0], !0) : (M.insert(H, W[0], !0), M.insert(R, H)), M = W[0], (fx(t, u, f, M) || Lz(M, "br")) && M.empty().remove();
            }
          else if (R.parent) {
            if (R.name === "li") {
              let Q = R.prev;
              if (Q && (Q.name === "ul" || Q.name === "ol")) {
                Q.append(R);
                continue;
              }
              if (Q = R.next, Q && (Q.name === "ul" || Q.name === "ol") && Q.firstChild) {
                Q.insert(R, Q.firstChild, !0);
                continue;
              }
              const ge = new _a("ul", 1);
              r(ge), R.wrap(ge);
              continue;
            }
            if (t.isValidChild(R.parent.name, "div") && t.isValidChild("div", R.name)) {
              const Q = new _a("div", 1);
              r(Q), R.wrap(Q);
            } else
              Wv(R, t);
          }
        }
      }, w_ = (e, t) => {
        let o = e;
        for (; o; ) {
          if (o.name === t)
            return !0;
          o = o.parent;
        }
        return !1;
      }, gx = (e, t, o = t.parent) => o ? e.children[t.name] && !e.isValidChild(o.name, t.name) || t.name === "a" && w_(o, "a") ? !0 : kP(o) && Kl(t) ? !(o?.firstChild === t && o?.lastChild === t) : !1 : !1, DP = (e, t, o, r) => {
        const c = document.createRange();
        return c.setStart(e, t), c.setEnd(o, r), c;
      }, Uz = (e) => {
        const t = Re.fromRangeStart(e), o = Re.fromRangeEnd(e), r = e.commonAncestorContainer;
        return Zl(!1, r, o).map((c) => !Rd(t, o, r) && Rd(t, c, r) ? DP(t.container(), t.offset(), c.container(), c.offset()) : e).getOr(e);
      }, E_ = (e) => e.collapsed ? e : Uz(e), Kg = Je.explode, RP = () => {
        const e = {};
        return {
          addFilter: (c, u) => {
            xe(Kg(c), (f) => {
              kn(e, f) || (e[f] = { name: f, callbacks: [] }), e[f].callbacks.push(u);
            });
          },
          getFilters: () => Pa(e),
          removeFilter: (c, u) => {
            xe(Kg(c), (f) => {
              if (kn(e, f))
                if (X(u)) {
                  const b = e[f], v = ze(b.callbacks, (S) => S !== u);
                  v.length > 0 ? b.callbacks = v : delete e[f];
                } else
                  delete e[f];
            });
          }
        };
      }, jz = (e) => e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), Wz = (e) => e.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&amp;/g, "&"), Yn = (e, t) => {
        xe(t, (o) => {
          e.attr(o, null);
        });
      }, Zz = (e, t, o) => {
        e.addNodeFilter("font", (r) => {
          xe(r, (c) => {
            const u = t.parse(c.attr("style")), f = c.attr("color"), b = c.attr("face"), v = c.attr("size");
            f && (u.color = f), b && (u["font-family"] = b), v && Jf(v).each((S) => {
              u["font-size"] = o[S - 1];
            }), c.name = "span", c.attr("style", t.serialize(u)), Yn(c, ["color", "face", "size"]);
          });
        });
      }, Gz = (e, t, o) => {
        e.addNodeFilter("strike", (r) => {
          const c = t.type !== "html4";
          xe(r, (u) => {
            if (c)
              u.name = "s";
            else {
              const f = o.parse(u.attr("style"));
              f["text-decoration"] = "line-through", u.name = "span", u.attr("style", o.serialize(f));
            }
          });
        });
      }, NP = (e, t, o) => {
        const r = fm();
        t.convert_fonts_to_spans && Zz(e, r, Je.explode(t.font_size_legacy_values ?? "")), Gz(e, o, r);
      }, qz = (e, t, o) => {
        t.inline_styles && NP(e, t, o);
      }, Kz = (e) => fetch(e).then((t) => t.ok ? t.blob() : Promise.reject()).catch(() => Promise.reject({
        message: `Cannot convert ${e} to Blob. Resource might not exist or is inaccessible.`,
        uriType: "blob"
      })), vr = (e) => {
        const t = /([a-z0-9+\/=\s]+)/i.exec(e);
        return t ? t[1] : "";
      }, Yz = (e) => {
        try {
          return decodeURIComponent(e);
        } catch {
          return e;
        }
      }, T_ = (e) => {
        const [t, ...o] = e.split(","), r = o.join(","), c = /data:([^/]+\/[^;]+)(;.+)?/.exec(t);
        if (c) {
          const u = c[2] === ";base64", f = Yz(r), b = u ? vr(f) : f;
          return P.some({
            type: c[1],
            data: b,
            base64Encoded: u
          });
        } else
          return P.none();
      }, MP = (e, t, o = !0) => {
        let r = t;
        if (o)
          try {
            r = atob(t);
          } catch {
            return P.none();
          }
        const c = new Uint8Array(r.length);
        for (let u = 0; u < c.length; u++)
          c[u] = r.charCodeAt(u);
        return P.some(new Blob([c], { type: e }));
      }, Xz = (e) => new Promise((t, o) => {
        T_(e).bind(({ type: r, data: c, base64Encoded: u }) => MP(r, c, u)).fold(() => o("Invalid data URI"), t);
      }), Us = (e) => hn(e, "blob:") ? Kz(e) : hn(e, "data:") ? Xz(e) : Promise.reject("Unknown URI format"), k_ = (e) => new Promise((t, o) => {
        const r = new FileReader();
        r.onloadend = () => {
          t(r.result);
        }, r.onerror = () => {
          o(r.error?.message);
        }, r.readAsDataURL(e);
      });
      let PP = 0;
      const Qz = (e) => "blobid" + PP++, A_ = (e, t, o) => T_(e).bind(({ data: r, type: c, base64Encoded: u }) => {
        if (t && !u)
          return P.none();
        {
          const f = u ? r : btoa(r);
          return o(f, c);
        }
      }), BP = (e, t, o) => {
        const r = e.create(Qz(), t, o);
        return e.add(r), r;
      }, Ff = (e, t, o = !1) => A_(t, o, (r, c) => P.from(e.getByData(r, c)).orThunk(() => MP(c, r).map((u) => BP(e, u, r)))), __ = (e, t) => {
        const o = () => Promise.reject("Invalid data URI");
        if (hn(t, "blob:")) {
          const r = e.getByUri(t);
          return X(r) ? Promise.resolve(r) : Us(t).then((c) => k_(c).then((u) => A_(u, !1, (f) => P.some(BP(e, c, f))).getOrThunk(o)));
        } else return hn(t, "data:") ? Ff(e, t).fold(o, (r) => Promise.resolve(r)) : Promise.reject("Unknown image data format");
      }, Jz = /^(?:(?:(?:[A-Za-z][A-Za-z\d.+-]{0,14}:\/\/(?:[-.~*+=!&;:'%@?^${}(),\w]+@)?|www\.|[-;:&=+$,.\w]+@)([A-Za-z\d-]+(?:\.[A-Za-z\d-]+)*))(?::\d+)?(?:\/(?:[-.~*+=!;:'%@$(),\/\w]*[-~*+=%@$()\/\w])?)?(?:\?(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?(?:#(?:[-.~*+=!&;:'%@?^${}(),\/\w]+)?)?)$/, e9 = (e) => P.from(e.match(Jz)).bind((t) => Gr(t, 1)).map((t) => hn(t, "www.") ? t.substring(4) : t), mT = (e, t) => {
        P.from(e.attr("src")).bind(e9).forall((o) => !Lt(t, o)) && e.attr("sandbox", "");
      }, O_ = (e, t) => hn(e, `${t}/`), t9 = (e) => Gn(e) ? "iframe" : O_(e, "image") ? "img" : O_(e, "video") ? "video" : O_(e, "audio") ? "audio" : "iframe", sa = ({ type: e, src: t, width: o, height: r } = {}, c, u) => {
        const f = t9(e), b = new _a(f, 1);
        return b.attr(f === "audio" ? { src: t } : { src: t, width: o, height: r }), (f === "audio" || f === "video") && b.attr("controls", ""), f === "iframe" && c && mT(b, u), b;
      }, n9 = (e) => X(e.attr("data-mce-bogus")), vp = (e) => e.attr("src") === fo.transparentSrc || X(e.attr("data-mce-placeholder")), o9 = (e, t) => {
        const { blob_cache: o } = t;
        if (o) {
          const r = (c) => {
            const u = c.attr("src");
            vp(c) || n9(c) || jt(u) || Ff(o, u, !0).each((f) => {
              c.attr("src", f.blobUri());
            });
          };
          e.addAttributeFilter("src", (c) => xe(c, r));
        }
      }, s9 = (e, t) => {
        const o = e.schema;
        e.addAttributeFilter("href", (f) => {
          let b = f.length;
          const v = (O) => O.split(" ").filter((M) => M.length > 0).concat(["noopener"]).sort().join(" "), S = (O) => {
            const R = O ? Je.trim(O) : "";
            return /\b(noopener)\b/g.test(R) ? R : v(R);
          };
          if (!t.allow_unsafe_link_target)
            for (; b--; ) {
              const O = f[b];
              O.name === "a" && O.attr("target") === "_blank" && O.attr("rel", S(O.attr("rel")));
            }
        }), t.allow_html_in_named_anchor || e.addAttributeFilter("id,name", (f) => {
          let b = f.length, v, S, O, R;
          for (; b--; )
            if (R = f[b], R.name === "a" && R.firstChild && !R.attr("href"))
              for (O = R.parent, v = R.lastChild; v && O; )
                S = v.prev, O.insert(v, R), v = S;
        }), t.fix_list_elements && e.addNodeFilter("ul,ol", (f) => {
          let b = f.length, v, S;
          for (; b--; )
            if (v = f[b], S = v.parent, S && (S.name === "ul" || S.name === "ol"))
              if (v.prev && v.prev.name === "li")
                v.prev.append(v);
              else {
                const O = new _a("li", 1);
                O.attr("style", "list-style-type: none"), v.wrap(O);
              }
        });
        const r = o.getValidClasses();
        t.validate && r && e.addAttributeFilter("class", (f) => {
          let b = f.length;
          for (; b--; ) {
            const v = f[b], S = v.attr("class") ?? "", O = Je.explode(S, " ");
            let R = "";
            for (let M = 0; M < O.length; M++) {
              const H = O[M];
              let J = !1, W = r["*"];
              W && W[H] && (J = !0), W = r[v.name], !J && W && W[H] && (J = !0), J && (R && (R += " "), R += H);
            }
            R.length || (R = null), v.attr("class", R);
          }
        }), o9(e, t);
        const c = t.sandbox_iframes ?? !1, u = Ka(t.sandbox_iframes_exclusions ?? []);
        t.convert_unsafe_embeds && e.addNodeFilter("object,embed", (f) => xe(f, (b) => {
          b.replace(sa({
            type: b.attr("type"),
            src: b.name === "object" ? b.attr("data") : b.attr("src"),
            width: b.attr("width"),
            height: b.attr("height")
          }, c, u));
        })), c && e.addNodeFilter("iframe", (f) => xe(f, (b) => mT(b, u)));
      };
      /*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
      const {
        entries: $P,
        setPrototypeOf: IP,
        isFrozen: r9,
        getPrototypeOf: a9,
        getOwnPropertyDescriptor: c9
      } = Object;
      let {
        freeze: Ei,
        seal: Fd,
        create: hx
      } = Object, {
        apply: D_,
        construct: R_
      } = typeof Reflect < "u" && Reflect;
      Ei || (Ei = function(t) {
        return t;
      }), Fd || (Fd = function(t) {
        return t;
      }), D_ || (D_ = function(t, o, r) {
        return t.apply(o, r);
      }), R_ || (R_ = function(t, o) {
        return new t(...o);
      });
      const N_ = Yc(Array.prototype.forEach), px = Yc(Array.prototype.lastIndexOf), FP = Yc(Array.prototype.pop), pb = Yc(Array.prototype.push), l9 = Yc(Array.prototype.splice), fT = Yc(String.prototype.toLowerCase), M_ = Yc(String.prototype.toString), LP = Yc(String.prototype.match), Nm = Yc(String.prototype.replace), bb = Yc(String.prototype.indexOf), gT = Yc(String.prototype.trim), cu = Yc(Object.prototype.hasOwnProperty), Ua = Yc(RegExp.prototype.test), Mm = hT(TypeError);
      function Yc(e) {
        return function(t) {
          t instanceof RegExp && (t.lastIndex = 0);
          for (var o = arguments.length, r = new Array(o > 1 ? o - 1 : 0), c = 1; c < o; c++)
            r[c - 1] = arguments[c];
          return D_(e, t, r);
        };
      }
      function hT(e) {
        return function() {
          for (var t = arguments.length, o = new Array(t), r = 0; r < t; r++)
            o[r] = arguments[r];
          return R_(e, o);
        };
      }
      function us(e, t) {
        let o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : fT;
        IP && IP(e, null);
        let r = t.length;
        for (; r--; ) {
          let c = t[r];
          if (typeof c == "string") {
            const u = o(c);
            u !== c && (r9(t) || (t[r] = u), c = u);
          }
          e[c] = !0;
        }
        return e;
      }
      function P_(e) {
        for (let t = 0; t < e.length; t++)
          cu(e, t) || (e[t] = null);
        return e;
      }
      function Pm(e) {
        const t = hx(null);
        for (const [o, r] of $P(e))
          cu(e, o) && (Array.isArray(r) ? t[o] = P_(r) : r && typeof r == "object" && r.constructor === Object ? t[o] = Pm(r) : t[o] = r);
        return t;
      }
      function Zv(e, t) {
        for (; e !== null; ) {
          const r = c9(e, t);
          if (r) {
            if (r.get)
              return Yc(r.get);
            if (typeof r.value == "function")
              return Yc(r.value);
          }
          e = a9(e);
        }
        function o() {
          return null;
        }
        return o;
      }
      const B_ = Ei(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), yp = Ei(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), pT = Ei(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), HP = Ei(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), bT = Ei(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), vT = Ei(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), $_ = Ei(["#text"]), I_ = Ei(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), yT = Ei(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), F_ = Ei(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), Ld = Ei(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), Cp = Fd(/\{\{[\w\W]*|[\w\W]*\}\}/gm), Hd = Fd(/<%[\w\W]*|[\w\W]*%>/gm), i9 = Fd(/\$\{[\w\W]*/gm), u9 = Fd(/^data-[\-\w.\u00B7-\uFFFF]+$/), d9 = Fd(/^aria-[\-\w]+$/), zP = Fd(
        /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
        // eslint-disable-line no-useless-escape
      ), m9 = Fd(/^(?:\w+script|data):/i), f9 = Fd(
        /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
        // eslint-disable-line no-control-regex
      ), VP = Fd(/^html$/i), g9 = Fd(/^[a-z][.\w]*(-[.\w]+)+$/i);
      var UP = /* @__PURE__ */ Object.freeze({
        __proto__: null,
        ARIA_ATTR: d9,
        ATTR_WHITESPACE: f9,
        CUSTOM_ELEMENT: g9,
        DATA_ATTR: u9,
        DOCTYPE_NAME: VP,
        ERB_EXPR: Hd,
        IS_ALLOWED_URI: zP,
        IS_SCRIPT_OR_DATA: m9,
        MUSTACHE_EXPR: Cp,
        TMPLIT_EXPR: i9
      });
      const bx = {
        element: 1,
        text: 3,
        // Deprecated
        progressingInstruction: 7,
        comment: 8,
        document: 9
      }, h9 = function() {
        return typeof window > "u" ? null : window;
      }, p9 = function(t, o) {
        if (typeof t != "object" || typeof t.createPolicy != "function")
          return null;
        let r = null;
        const c = "data-tt-policy-suffix";
        o && o.hasAttribute(c) && (r = o.getAttribute(c));
        const u = "dompurify" + (r ? "#" + r : "");
        try {
          return t.createPolicy(u, {
            createHTML(f) {
              return f;
            },
            createScriptURL(f) {
              return f;
            }
          });
        } catch {
          return console.warn("TrustedTypes policy " + u + " could not be created."), null;
        }
      }, CT = function() {
        return {
          afterSanitizeAttributes: [],
          afterSanitizeElements: [],
          afterSanitizeShadowDOM: [],
          beforeSanitizeAttributes: [],
          beforeSanitizeElements: [],
          beforeSanitizeShadowDOM: [],
          uponSanitizeAttribute: [],
          uponSanitizeElement: [],
          uponSanitizeShadowNode: []
        };
      };
      function xT() {
        let e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : h9();
        const t = (so) => xT(so);
        if (t.version = "3.2.6", t.removed = [], !e || !e.document || e.document.nodeType !== bx.document || !e.Element)
          return t.isSupported = !1, t;
        let {
          document: o
        } = e;
        const r = o, c = r.currentScript, {
          DocumentFragment: u,
          HTMLTemplateElement: f,
          Node: b,
          Element: v,
          NodeFilter: S,
          NamedNodeMap: O = e.NamedNodeMap || e.MozNamedAttrMap,
          HTMLFormElement: R,
          DOMParser: M,
          trustedTypes: H
        } = e, J = v.prototype, W = Zv(J, "cloneNode"), Q = Zv(J, "remove"), ge = Zv(J, "nextSibling"), be = Zv(J, "childNodes"), ve = Zv(J, "parentNode");
        if (typeof f == "function") {
          const so = o.createElement("template");
          so.content && so.content.ownerDocument && (o = so.content.ownerDocument);
        }
        let Be, je = "";
        const {
          implementation: xt,
          createNodeIterator: Kt,
          createDocumentFragment: Me,
          getElementsByTagName: Te
        } = o, {
          importNode: $e
        } = r;
        let yt = CT();
        t.isSupported = typeof $P == "function" && typeof ve == "function" && xt && xt.createHTMLDocument !== void 0;
        const {
          MUSTACHE_EXPR: Sn,
          ERB_EXPR: wn,
          TMPLIT_EXPR: uo,
          DATA_ATTR: Go,
          ARIA_ATTR: ys,
          IS_SCRIPT_OR_DATA: Ps,
          ATTR_WHITESPACE: Ra,
          CUSTOM_ELEMENT: Ai
        } = UP;
        let {
          IS_ALLOWED_URI: At
        } = UP, sn = null;
        const Lo = us({}, [...B_, ...yp, ...pT, ...bT, ...$_]);
        let Ao = null;
        const Ga = us({}, [...I_, ...yT, ...F_, ...Ld]);
        let Le = Object.seal(hx(null, {
          tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
          },
          attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null
          },
          allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1
          }
        })), ut = null, $t = null, to = !0, Zn = !0, Qo = !1, _i = !0, Kd = !1, od = !0, fu = !1, $p = !1, Qc = !1, Xl = !1, ih = !1, zy = !1, E3 = !0, bn = !1;
        const ho = "user-content-";
        let _r = !0, ks = !1, ts = {}, Cr = null;
        const Oi = us({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
        let wl = null;
        const sd = us({}, ["audio", "video", "img", "source", "image", "track"]);
        let uh = null;
        const T3 = us({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), k3 = "http://www.w3.org/1998/Math/MathML", RS = "http://www.w3.org/2000/svg", Xf = "http://www.w3.org/1999/xhtml";
        let Vy = Xf, VN = !1, A3 = null;
        const DX = us({}, [k3, RS, Xf], M_);
        let UN = us({}, ["mi", "mo", "mn", "ms", "mtext"]), jN = us({}, ["annotation-xml"]);
        const RX = us({}, ["title", "style", "font", "a", "script"]);
        let _3 = null;
        const Uy = ["application/xhtml+xml", "text/html"], u7 = "text/html";
        let Se = null, ke = null;
        const Dt = o.createElement("form"), dt = function(Ae) {
          return Ae instanceof RegExp || Ae instanceof Function;
        }, Tn = function() {
          let Ae = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          if (!(ke && ke === Ae)) {
            if ((!Ae || typeof Ae != "object") && (Ae = {}), Ae = Pm(Ae), _3 = // eslint-disable-next-line unicorn/prefer-includes
            Uy.indexOf(Ae.PARSER_MEDIA_TYPE) === -1 ? u7 : Ae.PARSER_MEDIA_TYPE, Se = _3 === "application/xhtml+xml" ? M_ : fT, sn = cu(Ae, "ALLOWED_TAGS") ? us({}, Ae.ALLOWED_TAGS, Se) : Lo, Ao = cu(Ae, "ALLOWED_ATTR") ? us({}, Ae.ALLOWED_ATTR, Se) : Ga, A3 = cu(Ae, "ALLOWED_NAMESPACES") ? us({}, Ae.ALLOWED_NAMESPACES, M_) : DX, uh = cu(Ae, "ADD_URI_SAFE_ATTR") ? us(Pm(T3), Ae.ADD_URI_SAFE_ATTR, Se) : T3, wl = cu(Ae, "ADD_DATA_URI_TAGS") ? us(Pm(sd), Ae.ADD_DATA_URI_TAGS, Se) : sd, Cr = cu(Ae, "FORBID_CONTENTS") ? us({}, Ae.FORBID_CONTENTS, Se) : Oi, ut = cu(Ae, "FORBID_TAGS") ? us({}, Ae.FORBID_TAGS, Se) : Pm({}), $t = cu(Ae, "FORBID_ATTR") ? us({}, Ae.FORBID_ATTR, Se) : Pm({}), ts = cu(Ae, "USE_PROFILES") ? Ae.USE_PROFILES : !1, to = Ae.ALLOW_ARIA_ATTR !== !1, Zn = Ae.ALLOW_DATA_ATTR !== !1, Qo = Ae.ALLOW_UNKNOWN_PROTOCOLS || !1, _i = Ae.ALLOW_SELF_CLOSE_IN_ATTR !== !1, Kd = Ae.SAFE_FOR_TEMPLATES || !1, od = Ae.SAFE_FOR_XML !== !1, fu = Ae.WHOLE_DOCUMENT || !1, Xl = Ae.RETURN_DOM || !1, ih = Ae.RETURN_DOM_FRAGMENT || !1, zy = Ae.RETURN_TRUSTED_TYPE || !1, Qc = Ae.FORCE_BODY || !1, E3 = Ae.SANITIZE_DOM !== !1, bn = Ae.SANITIZE_NAMED_PROPS || !1, _r = Ae.KEEP_CONTENT !== !1, ks = Ae.IN_PLACE || !1, At = Ae.ALLOWED_URI_REGEXP || zP, Vy = Ae.NAMESPACE || Xf, UN = Ae.MATHML_TEXT_INTEGRATION_POINTS || UN, jN = Ae.HTML_INTEGRATION_POINTS || jN, Le = Ae.CUSTOM_ELEMENT_HANDLING || {}, Ae.CUSTOM_ELEMENT_HANDLING && dt(Ae.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Le.tagNameCheck = Ae.CUSTOM_ELEMENT_HANDLING.tagNameCheck), Ae.CUSTOM_ELEMENT_HANDLING && dt(Ae.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Le.attributeNameCheck = Ae.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), Ae.CUSTOM_ELEMENT_HANDLING && typeof Ae.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Le.allowCustomizedBuiltInElements = Ae.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), Kd && (Zn = !1), ih && (Xl = !0), ts && (sn = us({}, $_), Ao = [], ts.html === !0 && (us(sn, B_), us(Ao, I_)), ts.svg === !0 && (us(sn, yp), us(Ao, yT), us(Ao, Ld)), ts.svgFilters === !0 && (us(sn, pT), us(Ao, yT), us(Ao, Ld)), ts.mathMl === !0 && (us(sn, bT), us(Ao, F_), us(Ao, Ld))), Ae.ADD_TAGS && (sn === Lo && (sn = Pm(sn)), us(sn, Ae.ADD_TAGS, Se)), Ae.ADD_ATTR && (Ao === Ga && (Ao = Pm(Ao)), us(Ao, Ae.ADD_ATTR, Se)), Ae.ADD_URI_SAFE_ATTR && us(uh, Ae.ADD_URI_SAFE_ATTR, Se), Ae.FORBID_CONTENTS && (Cr === Oi && (Cr = Pm(Cr)), us(Cr, Ae.FORBID_CONTENTS, Se)), _r && (sn["#text"] = !0), fu && us(sn, ["html", "head", "body"]), sn.table && (us(sn, ["tbody"]), delete ut.tbody), Ae.TRUSTED_TYPES_POLICY) {
              if (typeof Ae.TRUSTED_TYPES_POLICY.createHTML != "function")
                throw Mm('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
              if (typeof Ae.TRUSTED_TYPES_POLICY.createScriptURL != "function")
                throw Mm('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
              Be = Ae.TRUSTED_TYPES_POLICY, je = Be.createHTML("");
            } else
              Be === void 0 && (Be = p9(H, c)), Be !== null && typeof je == "string" && (je = Be.createHTML(""));
            Ei && Ei(Ae), ke = Ae;
          }
        }, Ro = us({}, [...yp, ...pT, ...HP]), Zr = us({}, [...bT, ...vT]), dh = function(Ae) {
          let rn = ve(Ae);
          (!rn || !rn.tagName) && (rn = {
            namespaceURI: Vy,
            tagName: "template"
          });
          const Xn = fT(Ae.tagName), Na = fT(rn.tagName);
          return A3[Ae.namespaceURI] ? Ae.namespaceURI === RS ? rn.namespaceURI === Xf ? Xn === "svg" : rn.namespaceURI === k3 ? Xn === "svg" && (Na === "annotation-xml" || UN[Na]) : !!Ro[Xn] : Ae.namespaceURI === k3 ? rn.namespaceURI === Xf ? Xn === "math" : rn.namespaceURI === RS ? Xn === "math" && jN[Na] : !!Zr[Xn] : Ae.namespaceURI === Xf ? rn.namespaceURI === RS && !jN[Na] || rn.namespaceURI === k3 && !UN[Na] ? !1 : !Zr[Xn] && (RX[Xn] || !Ro[Xn]) : !!(_3 === "application/xhtml+xml" && A3[Ae.namespaceURI]) : !1;
        }, Qf = function(Ae) {
          pb(t.removed, {
            element: Ae
          });
          try {
            ve(Ae).removeChild(Ae);
          } catch {
            Q(Ae);
          }
        }, O3 = function(Ae, rn) {
          try {
            pb(t.removed, {
              attribute: rn.getAttributeNode(Ae),
              from: rn
            });
          } catch {
            pb(t.removed, {
              attribute: null,
              from: rn
            });
          }
          if (rn.removeAttribute(Ae), Ae === "is")
            if (Xl || ih)
              try {
                Qf(rn);
              } catch {
              }
            else
              try {
                rn.setAttribute(Ae, "");
              } catch {
              }
        }, NX = function(Ae) {
          let rn = null, Xn = null;
          if (Qc)
            Ae = "<remove></remove>" + Ae;
          else {
            const El = LP(Ae, /^[\r\n\t ]+/);
            Xn = El && El[0];
          }
          _3 === "application/xhtml+xml" && Vy === Xf && (Ae = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + Ae + "</body></html>");
          const Na = Be ? Be.createHTML(Ae) : Ae;
          if (Vy === Xf)
            try {
              rn = new M().parseFromString(Na, _3);
            } catch {
            }
          if (!rn || !rn.documentElement) {
            rn = xt.createDocument(Vy, "template", null);
            try {
              rn.documentElement.innerHTML = VN ? je : Na;
            } catch {
            }
          }
          const gu = rn.body || rn.documentElement;
          return Ae && Xn && gu.insertBefore(o.createTextNode(Xn), gu.childNodes[0] || null), Vy === Xf ? Te.call(rn, fu ? "html" : "body")[0] : fu ? rn.documentElement : gu;
        }, MX = function(Ae) {
          return Kt.call(
            Ae.ownerDocument || Ae,
            Ae,
            // eslint-disable-next-line no-bitwise
            S.SHOW_ELEMENT | S.SHOW_COMMENT | S.SHOW_TEXT | S.SHOW_PROCESSING_INSTRUCTION | S.SHOW_CDATA_SECTION,
            null
          );
        }, _Y = function(Ae) {
          return Ae instanceof R && (typeof Ae.nodeName != "string" || typeof Ae.textContent != "string" || typeof Ae.removeChild != "function" || !(Ae.attributes instanceof O) || typeof Ae.removeAttribute != "function" || typeof Ae.setAttribute != "function" || typeof Ae.namespaceURI != "string" || typeof Ae.insertBefore != "function" || typeof Ae.hasChildNodes != "function");
        }, PX = function(Ae) {
          return typeof b == "function" && Ae instanceof b;
        };
        function Zb(so, Ae, rn) {
          N_(so, (Xn) => {
            Xn.call(t, Ae, rn, ke);
          });
        }
        const BX = function(Ae) {
          let rn = null;
          if (Zb(yt.beforeSanitizeElements, Ae, null), _Y(Ae))
            return Qf(Ae), !0;
          const Xn = Se(Ae.nodeName);
          if (Zb(yt.uponSanitizeElement, Ae, {
            tagName: Xn,
            allowedTags: sn
          }), od && Ae.hasChildNodes() && !PX(Ae.firstElementChild) && Ua(/<[/\w!]/g, Ae.innerHTML) && Ua(/<[/\w!]/g, Ae.textContent) || Ae.nodeType === bx.progressingInstruction || od && Ae.nodeType === bx.comment && Ua(/<[/\w]/g, Ae.data))
            return Qf(Ae), !0;
          if (!sn[Xn] || ut[Xn]) {
            if (!ut[Xn] && IX(Xn) && (Le.tagNameCheck instanceof RegExp && Ua(Le.tagNameCheck, Xn) || Le.tagNameCheck instanceof Function && Le.tagNameCheck(Xn)))
              return !1;
            if (_r && !Cr[Xn]) {
              const Na = ve(Ae) || Ae.parentNode, gu = be(Ae) || Ae.childNodes;
              if (gu && Na) {
                const El = gu.length;
                for (let Yd = El - 1; Yd >= 0; --Yd) {
                  const Gb = W(gu[Yd], !0);
                  Gb.__removalCount = (Ae.__removalCount || 0) + 1, Na.insertBefore(Gb, ge(Ae));
                }
              }
            }
            return Qf(Ae), !0;
          }
          return Ae instanceof v && !dh(Ae) || (Xn === "noscript" || Xn === "noembed" || Xn === "noframes") && Ua(/<\/no(script|embed|frames)/i, Ae.innerHTML) ? (Qf(Ae), !0) : (Kd && Ae.nodeType === bx.text && (rn = Ae.textContent, N_([Sn, wn, uo], (Na) => {
            rn = Nm(rn, Na, " ");
          }), Ae.textContent !== rn && (pb(t.removed, {
            element: Ae.cloneNode()
          }), Ae.textContent = rn)), Zb(yt.afterSanitizeElements, Ae, null), !1);
        }, $X = function(Ae, rn, Xn) {
          if (E3 && (rn === "id" || rn === "name") && (Xn in o || Xn in Dt))
            return !1;
          if (!(Zn && !$t[rn] && Ua(Go, rn))) {
            if (!(to && Ua(ys, rn))) {
              if (!Ao[rn] || $t[rn]) {
                if (
                  // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                  // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                  // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                  !(IX(Ae) && (Le.tagNameCheck instanceof RegExp && Ua(Le.tagNameCheck, Ae) || Le.tagNameCheck instanceof Function && Le.tagNameCheck(Ae)) && (Le.attributeNameCheck instanceof RegExp && Ua(Le.attributeNameCheck, rn) || Le.attributeNameCheck instanceof Function && Le.attributeNameCheck(rn)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                  // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                  rn === "is" && Le.allowCustomizedBuiltInElements && (Le.tagNameCheck instanceof RegExp && Ua(Le.tagNameCheck, Xn) || Le.tagNameCheck instanceof Function && Le.tagNameCheck(Xn)))
                ) return !1;
              } else if (!uh[rn]) {
                if (!Ua(At, Nm(Xn, Ra, ""))) {
                  if (!((rn === "src" || rn === "xlink:href" || rn === "href") && Ae !== "script" && bb(Xn, "data:") === 0 && wl[Ae])) {
                    if (!(Qo && !Ua(Ps, Nm(Xn, Ra, "")))) {
                      if (Xn)
                        return !1;
                    }
                  }
                }
              }
            }
          }
          return !0;
        }, IX = function(Ae) {
          return Ae !== "annotation-xml" && LP(Ae, Ai);
        }, FX = function(Ae) {
          Zb(yt.beforeSanitizeAttributes, Ae, null);
          const {
            attributes: rn
          } = Ae;
          if (!rn || _Y(Ae))
            return;
          const Xn = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: Ao,
            forceKeepAttr: void 0
          };
          let Na = rn.length;
          for (; Na--; ) {
            const gu = rn[Na], {
              name: El,
              namespaceURI: Yd,
              value: Gb
            } = gu, WN = Se(El), OY = Gb;
            let hu = El === "value" ? OY : gT(OY);
            if (Xn.attrName = WN, Xn.attrValue = hu, Xn.keepAttr = !0, Xn.forceKeepAttr = void 0, Zb(yt.uponSanitizeAttribute, Ae, Xn), hu = Xn.attrValue, bn && (WN === "id" || WN === "name") && (O3(El, Ae), hu = ho + hu), od && Ua(/((--!?|])>)|<\/(style|title)/i, hu)) {
              O3(El, Ae);
              continue;
            }
            if (Xn.forceKeepAttr)
              continue;
            if (!Xn.keepAttr) {
              O3(El, Ae);
              continue;
            }
            if (!_i && Ua(/\/>/i, hu)) {
              O3(El, Ae);
              continue;
            }
            Kd && N_([Sn, wn, uo], (HX) => {
              hu = Nm(hu, HX, " ");
            });
            const LX = Se(Ae.nodeName);
            if (!$X(LX, WN, hu)) {
              O3(El, Ae);
              continue;
            }
            if (Be && typeof H == "object" && typeof H.getAttributeType == "function" && !Yd)
              switch (H.getAttributeType(LX, WN)) {
                case "TrustedHTML": {
                  hu = Be.createHTML(hu);
                  break;
                }
                case "TrustedScriptURL": {
                  hu = Be.createScriptURL(hu);
                  break;
                }
              }
            if (hu !== OY)
              try {
                Yd ? Ae.setAttributeNS(Yd, El, hu) : Ae.setAttribute(El, hu), _Y(Ae) ? Qf(Ae) : FP(t.removed);
              } catch {
                O3(El, Ae);
              }
          }
          Zb(yt.afterSanitizeAttributes, Ae, null);
        }, IQ = function so(Ae) {
          let rn = null;
          const Xn = MX(Ae);
          for (Zb(yt.beforeSanitizeShadowDOM, Ae, null); rn = Xn.nextNode(); )
            Zb(yt.uponSanitizeShadowNode, rn, null), BX(rn), FX(rn), rn.content instanceof u && so(rn.content);
          Zb(yt.afterSanitizeShadowDOM, Ae, null);
        };
        return t.sanitize = function(so) {
          let Ae = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, rn = null, Xn = null, Na = null, gu = null;
          if (VN = !so, VN && (so = "<!-->"), typeof so != "string" && !PX(so))
            if (typeof so.toString == "function") {
              if (so = so.toString(), typeof so != "string")
                throw Mm("dirty is not a string, aborting");
            } else
              throw Mm("toString is not a function");
          if (!t.isSupported)
            return so;
          if ($p || Tn(Ae), t.removed = [], typeof so == "string" && (ks = !1), ks) {
            if (so.nodeName) {
              const Gb = Se(so.nodeName);
              if (!sn[Gb] || ut[Gb])
                throw Mm("root node is forbidden and cannot be sanitized in-place");
            }
          } else if (so instanceof b)
            rn = NX("<!---->"), Xn = rn.ownerDocument.importNode(so, !0), Xn.nodeType === bx.element && Xn.nodeName === "BODY" || Xn.nodeName === "HTML" ? rn = Xn : rn.appendChild(Xn);
          else {
            if (!Xl && !Kd && !fu && // eslint-disable-next-line unicorn/prefer-includes
            so.indexOf("<") === -1)
              return Be && zy ? Be.createHTML(so) : so;
            if (rn = NX(so), !rn)
              return Xl ? null : zy ? je : "";
          }
          rn && Qc && Qf(rn.firstChild);
          const El = MX(ks ? so : rn);
          for (; Na = El.nextNode(); )
            BX(Na), FX(Na), Na.content instanceof u && IQ(Na.content);
          if (ks)
            return so;
          if (Xl) {
            if (ih)
              for (gu = Me.call(rn.ownerDocument); rn.firstChild; )
                gu.appendChild(rn.firstChild);
            else
              gu = rn;
            return (Ao.shadowroot || Ao.shadowrootmode) && (gu = $e.call(r, gu, !0)), gu;
          }
          let Yd = fu ? rn.outerHTML : rn.innerHTML;
          return fu && sn["!doctype"] && rn.ownerDocument && rn.ownerDocument.doctype && rn.ownerDocument.doctype.name && Ua(VP, rn.ownerDocument.doctype.name) && (Yd = "<!DOCTYPE " + rn.ownerDocument.doctype.name + `>
` + Yd), Kd && N_([Sn, wn, uo], (Gb) => {
            Yd = Nm(Yd, Gb, " ");
          }), Be && zy ? Be.createHTML(Yd) : Yd;
        }, t.setConfig = function() {
          let so = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          Tn(so), $p = !0;
        }, t.clearConfig = function() {
          ke = null, $p = !1;
        }, t.isValidAttribute = function(so, Ae, rn) {
          ke || Tn({});
          const Xn = Se(so), Na = Se(Ae);
          return $X(Xn, Na, rn);
        }, t.addHook = function(so, Ae) {
          typeof Ae == "function" && pb(yt[so], Ae);
        }, t.removeHook = function(so, Ae) {
          if (Ae !== void 0) {
            const rn = px(yt[so], Ae);
            return rn === -1 ? void 0 : l9(yt[so], rn, 1)[0];
          }
          return FP(yt[so]);
        }, t.removeHooks = function(so) {
          yt[so] = [];
        }, t.removeAllHooks = function() {
          yt = CT();
        }, t;
      }
      var ST = xT();
      const jP = Je.each, b9 = Je.trim, WP = [
        "source",
        "protocol",
        "authority",
        "userInfo",
        "user",
        "password",
        "host",
        "port",
        "relative",
        "path",
        "directory",
        "file",
        "query",
        "anchor"
      ], ZP = {
        ftp: 21,
        http: 80,
        https: 443,
        mailto: 25
      }, L_ = ["img", "video"], GP = (e, t) => X(e) ? !e : X(t) ? !Lt(L_, t) : !0, qP = (e) => {
        try {
          return decodeURIComponent(e);
        } catch {
          return unescape(e);
        }
      }, wT = (e, t, o) => {
        const r = qP(t).replace(/\s/g, "");
        return e.allow_script_urls ? !1 : /((java|vb)script|mhtml):/i.test(r) ? !0 : e.allow_html_data_urls ? !1 : /^data:image\//i.test(r) ? GP(e.allow_svg_data_urls, o) && /^data:image\/svg\+xml/i.test(r) : /^data:/i.test(r);
      };
      class zd {
        static parseDataUri(t) {
          let o;
          const r = decodeURIComponent(t).split(","), c = /data:([^;]+)/.exec(r[0]);
          return c && (o = c[1]), {
            type: o,
            data: r[1]
          };
        }
        /**
         * Check to see if a URI is safe to use in the Document Object Model (DOM). This will return
         * true if the URI can be used in the DOM without potentially triggering a security issue.
         *
         * @method isDomSafe
         * @static
         * @param {String} uri The URI to be validated.
         * @param {Object} context An optional HTML tag name where the element is being used.
         * @param {Object} options An optional set of options to use when determining if the URI is safe.
         * @return {Boolean} True if the URI is safe, otherwise false.
         */
        static isDomSafe(t, o, r = {}) {
          if (r.allow_script_urls)
            return !0;
          {
            const c = gl.decode(t).replace(/[\s\u0000-\u001F]+/g, "");
            return !wT(r, c, o);
          }
        }
        static getDocumentBaseUrl(t) {
          let o;
          return t.protocol.indexOf("http") !== 0 && t.protocol !== "file:" ? o = t.href ?? "" : o = t.protocol + "//" + t.host + t.pathname, /^[^:]+:\/\/\/?[^\/]+\//.test(o) && (o = o.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(o) || (o += "/")), o;
        }
        source;
        protocol;
        authority;
        userInfo;
        user;
        password;
        host;
        port;
        relative;
        path = "";
        directory = "";
        file;
        query;
        anchor;
        settings;
        /**
         * Constructs a new URI instance.
         *
         * @constructor
         * @method URI
         * @param {String} url URI string to parse.
         * @param {Object} settings Optional settings object.
         */
        constructor(t, o = {}) {
          t = b9(t), this.settings = o;
          const r = o.base_uri, c = this;
          if (/^([\w\-]+):([^\/]{2})/i.test(t) || /^\s*#/.test(t)) {
            c.source = t;
            return;
          }
          const u = t.indexOf("//") === 0;
          if (t.indexOf("/") === 0 && !u && (t = (r && r.protocol || "http") + "://mce_host" + t), !/^[\w\-]*:?\/\//.test(t)) {
            const b = r ? r.path : new zd(document.location.href).directory;
            if (r?.protocol === "")
              t = "//mce_host" + c.toAbsPath(b, t);
            else {
              const v = /([^#?]*)([#?]?.*)/.exec(t);
              v && (t = (r && r.protocol || "http") + "://mce_host" + c.toAbsPath(b, v[1]) + v[2]);
            }
          }
          t = t.replace(/@@/g, "(mce_at)");
          const f = /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@\/]*):?([^:@\/]*))?@)?(\[[a-zA-Z0-9:.%]+\]|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/.exec(t);
          f && jP(WP, (b, v) => {
            let S = f[v];
            S && (S = S.replace(/\(mce_at\)/g, "@@")), c[b] = S;
          }), r && (c.protocol || (c.protocol = r.protocol), c.userInfo || (c.userInfo = r.userInfo), !c.port && c.host === "mce_host" && (c.port = r.port), (!c.host || c.host === "mce_host") && (c.host = r.host), c.source = ""), u && (c.protocol = "");
        }
        /**
         * Sets the internal path part of the URI.
         *
         * @method setPath
         * @param {String} path Path string to set.
         */
        setPath(t) {
          const o = /^(.*?)\/?(\w+)?$/.exec(t);
          o && (this.path = o[0], this.directory = o[1], this.file = o[2]), this.source = "", this.getURI();
        }
        /**
         * Converts the specified URI into a relative URI based on the current URI instance location.
         *
         * @method toRelative
         * @param {String} uri URI to convert into a relative path/URI.
         * @return {String} Relative URI from the point specified in the current URI instance.
         * @example
         * // Converts an absolute URL to an relative URL url will be somedir/somefile.htm
         * const url = new tinymce.util.URI('http://www.site.com/dir/').toRelative('http://www.site.com/dir/somedir/somefile.htm');
         */
        toRelative(t) {
          if (t === "./")
            return t;
          const o = new zd(t, { base_uri: this });
          if (o.host !== "mce_host" && this.host !== o.host && o.host || this.port !== o.port || this.protocol !== o.protocol && o.protocol !== "")
            return o.getURI();
          const r = this.getURI(), c = o.getURI();
          if (r === c || r.charAt(r.length - 1) === "/" && r.substr(0, r.length - 1) === c)
            return r;
          let u = this.toRelPath(this.path, o.path);
          return o.query && (u += "?" + o.query), o.anchor && (u += "#" + o.anchor), u;
        }
        /**
         * Converts the specified URI into a absolute URI based on the current URI instance location.
         *
         * @method toAbsolute
         * @param {String} uri URI to convert into a relative path/URI.
         * @param {Boolean} noHost No host and protocol prefix.
         * @return {String} Absolute URI from the point specified in the current URI instance.
         * @example
         * // Converts an relative URL to an absolute URL url will be http://www.site.com/dir/somedir/somefile.htm
         * const url = new tinymce.util.URI('http://www.site.com/dir/').toAbsolute('somedir/somefile.htm');
         */
        toAbsolute(t, o) {
          const r = new zd(t, { base_uri: this });
          return r.getURI(o && this.isSameOrigin(r));
        }
        /**
         * Determine whether the given URI has the same origin as this URI.  Based on RFC-6454.
         * Supports default ports for protocols listed in DEFAULT_PORTS.  Unsupported protocols will fail safe: they
         * won't match, if the port specifications differ.
         *
         * @method isSameOrigin
         * @param {tinymce.util.URI} uri Uri instance to compare.
         * @returns {Boolean} True if the origins are the same.
         */
        isSameOrigin(t) {
          if (this.host == t.host && this.protocol == t.protocol) {
            if (this.port == t.port)
              return !0;
            const o = this.protocol ? ZP[this.protocol] : null;
            if (o && (this.port || o) == (t.port || o))
              return !0;
          }
          return !1;
        }
        /**
         * Converts a absolute path into a relative path.
         *
         * @method toRelPath
         * @param {String} base Base point to convert the path from.
         * @param {String} path Absolute path to convert into a relative path.
         */
        toRelPath(t, o) {
          let r = 0, c = "", u, f;
          const b = t.substring(0, t.lastIndexOf("/")).split("/"), v = o.split("/");
          if (b.length >= v.length) {
            for (u = 0, f = b.length; u < f; u++)
              if (u >= v.length || b[u] !== v[u]) {
                r = u + 1;
                break;
              }
          }
          if (b.length < v.length) {
            for (u = 0, f = v.length; u < f; u++)
              if (u >= b.length || b[u] !== v[u]) {
                r = u + 1;
                break;
              }
          }
          if (r === 1)
            return o;
          for (u = 0, f = b.length - (r - 1); u < f; u++)
            c += "../";
          for (u = r - 1, f = v.length; u < f; u++)
            u !== r - 1 ? c += "/" + v[u] : c += v[u];
          return c;
        }
        /**
         * Converts a relative path into a absolute path.
         *
         * @method toAbsPath
         * @param {String} base Base point to convert the path from.
         * @param {String} path Relative path to convert into an absolute path.
         */
        toAbsPath(t, o) {
          let r = 0;
          const c = /\/$/.test(o) ? "/" : "", u = t.split("/"), f = o.split("/"), b = [];
          jP(u, (R) => {
            R && b.push(R);
          });
          const v = [];
          for (let R = f.length - 1; R >= 0; R--)
            if (!(f[R].length === 0 || f[R] === ".")) {
              if (f[R] === "..") {
                r++;
                continue;
              }
              if (r > 0) {
                r--;
                continue;
              }
              v.push(f[R]);
            }
          const S = b.length - r;
          let O;
          return S <= 0 ? O = ds(v).join("/") : O = b.slice(0, S).join("/") + "/" + ds(v).join("/"), O.indexOf("/") !== 0 && (O = "/" + O), c && O.lastIndexOf("/") !== O.length - 1 && (O += c), O;
        }
        /**
         * Returns the full URI of the internal structure.
         *
         * @method getURI
         * @param {Boolean} noProtoHost Optional no host and protocol part. Defaults to false.
         */
        getURI(t = !1) {
          let o;
          return (!this.source || t) && (o = "", t || (this.protocol ? o += this.protocol + "://" : o += "//", this.userInfo && (o += this.userInfo + "@"), this.host && (o += this.host), this.port && (o += ":" + this.port)), this.path && (o += this.path), this.query && (o += "?" + this.query), this.anchor && (o += "#" + this.anchor), this.source = o), this.source;
        }
      }
      const v9 = Je.makeMap("src,href,data,background,action,formaction,poster,xlink:href"), Vd = "data-mce-type";
      let qu = 0;
      const vx = (e, t, o, r, c) => {
        const u = t.validate, f = o.getSpecialElements();
        e.nodeType === gc && (!t.allow_conditional_comments && /^\[if/i.test(e.nodeValue ?? "") && (e.nodeValue = " " + e.nodeValue), t.sanitize && t.allow_html_in_comments && U(e.nodeValue) && (e.nodeValue = jz(e.nodeValue)));
        const b = c?.tagName ?? e.nodeName.toLowerCase();
        if (r !== "html" && o.isValid(r)) {
          X(c) && (c.allowedTags[b] = !0);
          return;
        }
        if (e.nodeType !== rg || b === "body")
          return;
        const v = te.fromDom(e), S = Cs(v, Vd), O = gs(v, "data-mce-bogus");
        if (!S && U(O)) {
          O === "all" ? qo(v) : hc(v);
          return;
        }
        const R = o.getElementRule(b);
        if (u && !R) {
          kn(f, b) ? qo(v) : hc(v);
          return;
        } else
          X(c) && (c.allowedTags[b] = !0);
        if (u && R && !S) {
          if (xe(R.attributesForced ?? [], (M) => {
            Ss(v, M.name, M.value === "{$uid}" ? `mce_${qu++}` : M.value);
          }), xe(R.attributesDefault ?? [], (M) => {
            Cs(v, M.name) || Ss(v, M.name, M.value === "{$uid}" ? `mce_${qu++}` : M.value);
          }), R.attributesRequired && !po(R.attributesRequired, (M) => Cs(v, M))) {
            hc(v);
            return;
          }
          if (R.removeEmptyAttrs && Qm(v)) {
            hc(v);
            return;
          }
          R.outputName && R.outputName !== b && ku(v, R.outputName);
        }
      }, KP = (e, t, o, r, c) => {
        const u = e.tagName.toLowerCase(), { attrName: f, attrValue: b } = c;
        c.keepAttr = yx(t, o, r, u, f, b), c.keepAttr ? (c.allowedAttributes[f] = !0, z_(f, o, e.nodeName) && (c.attrValue = f), t.allow_svg_data_urls && hn(b, "data:image/svg+xml") && (c.forceKeepAttr = !0)) : H_(e, f) && (c.forceKeepAttr = !0);
      }, yx = (e, t, o, r, c, u) => o !== "html" && !pg(r) ? !0 : !(c in v9 && wT(e, u, r)) && (!e.validate || t.isValid(r, c) || hn(c, "data-") || hn(c, "aria-")), H_ = (e, t) => e.hasAttribute(Vd) && (t === "id" || t === "class" || t === "style"), z_ = (e, t, o) => e in t.getBoolAttrs() && !kn(t.getCustomElements(), o.toLowerCase()), YP = (e, t, o, r) => {
        const { attributes: c } = e;
        for (let u = c.length - 1; u >= 0; u--) {
          const f = c[u], b = f.name, v = f.value;
          !yx(t, o, r, e.tagName.toLowerCase(), b, v) && !H_(e, b) ? e.removeAttribute(b) : z_(b, o, e.nodeName) && e.setAttribute(b, b);
        }
      }, XP = (e, t, o) => {
        const r = ST();
        return r.addHook("uponSanitizeElement", (c, u) => {
          vx(c, e, t, o.track(c), u);
        }), r.addHook("uponSanitizeAttribute", (c, u) => {
          KP(c, e, t, o.current(), u);
        }), r;
      }, QP = (e, t) => {
        const r = { ...{
          IN_PLACE: !0,
          ALLOW_UNKNOWN_PROTOCOLS: !0,
          // Deliberately ban all tags and attributes by default, and then un-ban them on demand in hooks
          // #comment and #cdata-section are always allowed as they aren't controlled via the schema
          // body is also allowed due to the DOMPurify checking the root node before sanitizing
          ALLOWED_TAGS: ["#comment", "#cdata-section", "body", "html"],
          ALLOWED_ATTR: []
        } };
        return r.PARSER_MEDIA_TYPE = t, e.allow_script_urls ? r.ALLOWED_URI_REGEXP = /.*/ : e.allow_html_data_urls && (r.ALLOWED_URI_REGEXP = /^(?!(\w+script|mhtml):)/i), r;
      }, JP = (e) => {
        const t = ["type", "href", "role", "arcrole", "title", "show", "actuate", "label", "from", "to"].map((r) => `xlink:${r}`), o = {
          IN_PLACE: !0,
          USE_PROFILES: {
            html: !0,
            svg: !0,
            svgFilters: !0
          },
          ALLOWED_ATTR: t
        };
        ST().sanitize(e, o);
      }, ET = (e, t) => {
        const o = {
          IN_PLACE: !0,
          USE_PROFILES: {
            mathMl: !0
          }
        }, r = ST(), c = t.allow_mathml_annotation_encodings, u = Ot(c) && c.length > 0, f = (v) => {
          const S = v.getAttribute("encoding");
          return u && U(S) && Lt(c, S);
        }, b = (v, S) => u && S === "semantics" ? P.some(!0) : S === "annotation" ? P.some(ht(v) && f(v)) : Ot(t.extended_mathml_elements) && t.extended_mathml_elements.includes(S) ? P.from(!0) : P.none();
        r.addHook("uponSanitizeElement", (v, S) => {
          const O = S.tagName ?? v.nodeName.toLowerCase();
          b(v, O).each((M) => {
            S.allowedTags[O] = M, !M && t.sanitize && ht(v) && v.remove();
          });
        }), r.addHook("uponSanitizeAttribute", (v, S) => {
          Ot(t.extended_mathml_attributes) && t.extended_mathml_attributes.includes(S.attrName) && (S.forceKeepAttr = !0);
        }), r.sanitize(e, o);
      }, V_ = (e) => (t) => {
        const o = h2(t);
        if (o === "svg")
          JP(t);
        else if (o === "math")
          ET(t, e);
        else
          throw new Error("Not a namespace element");
      }, y9 = (e, t) => {
        const o = US();
        if (e.sanitize) {
          const r = XP(e, t, o);
          return {
            sanitizeHtmlElement: (u, f) => {
              r.sanitize(u, QP(e, f)), r.removed = [], o.reset();
            },
            sanitizeNamespaceElement: V_(e)
          };
        } else
          return {
            sanitizeHtmlElement: (u, f) => {
              const b = document.createNodeIterator(u, NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_TEXT);
              let v;
              for (; v = b.nextNode(); ) {
                const S = o.track(v);
                vx(v, e, t, S), ht(v) && YP(v, e, t, S);
              }
              o.reset();
            },
            sanitizeNamespaceElement: St
          };
      }, eB = ["script", "style", "template", "param", "meta", "title", "link"], tB = Je.makeMap, nB = Je.extend, U_ = (e, t, o, r, c) => {
        const u = e.name, f = u in o && u !== "title" && u !== "textarea" && u !== "noscript", b = t.childNodes;
        for (let v = 0, S = b.length; v < S; v++) {
          const O = b[v], R = new _a(O.nodeName.toLowerCase(), O.nodeType);
          if (ht(O)) {
            const M = O.attributes;
            for (let H = 0, J = M.length; H < J; H++) {
              const W = M[H];
              R.attr(W.name, W.value);
            }
            pg(R.name) && (r(O), R.value = O.innerHTML);
          } else tt(O) ? (R.value = O.data, f && (R.raw = !0)) : zn(O) ? R.value = c ? Wz(O.data) : O.data : (i2(O) || Hr(O)) && (R.value = O.data);
          if (d2(O)) {
            const M = _a.create("#text");
            M.value = O.innerHTML, M.raw = !0, R.append(M);
          } else pg(R.name) || U_(R, O, o, r, c);
          e.append(R);
        }
      }, C9 = (e, t, o) => {
        const r = [];
        for (let c = e, u = c; c; u = c, c = c.walk()) {
          const f = c;
          xe(t, (b) => b(f)), jt(f.parent) && f !== e ? c = u : r.push(f);
        }
        for (let c = r.length - 1; c >= 0; c--) {
          const u = r[c];
          xe(o, (f) => f(u));
        }
      }, x9 = (e, t, o, r) => {
        const c = o.validate, u = t.getNonEmptyElements(), f = t.getWhitespaceElements(), b = nB(tB(eB), t.getBlockElements()), v = y0(t), S = /[ \t\r\n]+/g, O = /^[ \t\r\n]+/, R = /[ \t\r\n]+$/, M = (be) => {
          let ve = be.parent;
          for (; X(ve); ) {
            if (ve.name in f)
              return !0;
            ve = ve.parent;
          }
          return !1;
        }, H = (be) => {
          let ve = be;
          for (; X(ve); ) {
            if (ve.name in v)
              return fx(t, u, f, ve);
            ve = ve.parent;
          }
          return !1;
        }, J = (be) => be.name in b || fl(t, be) || pg(be.name) && be.parent === e, W = (be, ve) => {
          const Be = ve ? be.prev : be.next;
          return X(Be) || jt(be.parent) ? !1 : J(be.parent) && (be.parent !== e || r.isRootContent === !0);
        };
        return [(be) => {
          if (be.type === 3 && !M(be)) {
            let ve = be.value ?? "";
            ve = ve.replace(S, " "), (Rm(be.prev, J) || W(be, !0)) && (ve = ve.replace(O, "")), ve.length === 0 || ve === " " && be.prev && be.prev.type === gc && be.next && be.next.type === gc ? be.remove() : be.value = ve;
          }
        }, (be) => {
          if (be.type === 1) {
            const ve = t.getElementRule(be.name);
            if (c && ve) {
              const Be = fx(t, u, f, be);
              ve.paddInEmptyBlock && Be && H(be) ? bp(o, r, J, be) : ve.removeEmpty && Be ? J(be) ? be.remove() : be.unwrap() : ve.paddEmpty && (Be || jv(be)) && bp(o, r, J, be);
            }
          } else if (be.type === 3 && !M(be)) {
            let ve = be.value ?? "";
            (be.next && J(be.next) || W(be, !1)) && (ve = ve.replace(R, "")), ve.length === 0 ? be.remove() : be.value = ve;
          }
        }];
      }, j_ = (e, t) => {
        const o = t.forced_root_block ?? e.forced_root_block;
        return o === !1 ? "" : o === !0 ? "p" : o;
      }, oB = ' xmlns="http://www.w3.org/1999/xhtml"', Gv = (e = {}, t = wa()) => {
        const o = RP(), r = RP(), c = {
          validate: !0,
          root_name: "body",
          sanitize: !0,
          allow_html_in_comments: !1,
          ...e
        }, u = new DOMParser(), f = y9(c, t), b = (ve, Be, je = "html", xt = !1) => {
          const Kt = je === "xhtml", Me = Kt ? "application/xhtml+xml" : "text/html", Te = kn(t.getSpecialElements(), Be.toLowerCase()), $e = Te ? `<${Be}>${ve}</${Be}>` : ve, yt = () => /^[\s]*<head/i.test(ve) || /^[\s]*<html/i.test(ve) || /^[\s]*<!DOCTYPE/i.test(ve) ? `<html${Kt ? oB : ""}>${$e}</html>` : Kt ? `<html${oB}><head></head><body>${$e}</body></html>` : `<body>${$e}</body>`, Sn = u.parseFromString(yt(), Me), wn = xt ? Sn.documentElement : Sn.body;
          return f.sanitizeHtmlElement(wn, Me), Te ? wn.firstChild : wn;
        }, v = o.addFilter, S = o.getFilters, O = o.removeFilter, R = r.addFilter, M = r.getFilters, H = r.removeFilter, J = (ve, Be) => {
          gx(t, ve) && Be.push(ve);
        }, W = (ve, Be) => {
          const je = U(Be.attr(Vd)), xt = Be.type === 1 && !kn(ve, Be.name) && !fl(t, Be) && !pg(Be.name);
          return Be.type === 3 || xt && !je;
        }, Q = (ve, Be) => {
          const je = nB(tB(eB), t.getBlockElements()), xt = /^[ \t\r\n]+/, Kt = /[ \t\r\n]+$/;
          let Me = ve.firstChild, Te = null;
          const $e = (yt) => {
            yt && (Me = yt.firstChild, Me && Me.type === 3 && (Me.value = Me.value?.replace(xt, "")), Me = yt.lastChild, Me && Me.type === 3 && (Me.value = Me.value?.replace(Kt, "")));
          };
          if (t.isValidChild(ve.name, Be.toLowerCase())) {
            for (; Me; ) {
              const yt = Me.next;
              W(je, Me) ? (Te || (Te = new _a(Be, 1), Te.attr(c.forced_root_block_attrs), ve.insert(Te, Me)), Te.append(Me)) : ($e(Te), Te = null), Me = yt;
            }
            $e(Te);
          }
        }, be = {
          schema: t,
          addAttributeFilter: R,
          getAttributeFilters: M,
          removeAttributeFilter: H,
          addNodeFilter: v,
          getNodeFilters: S,
          removeNodeFilter: O,
          parse: (ve, Be = {}) => {
            const je = c.validate, xt = (Be.context ?? c.root_name) === "#document", Kt = Be.context ?? (xt ? "html" : c.root_name), Me = b(ve, Kt, Be.format, xt);
            ta(t, Me);
            const Te = new _a(Kt, 11);
            U_(Te, Me, t.getSpecialElements(), f.sanitizeNamespaceElement, c.sanitize && c.allow_html_in_comments), Me.innerHTML = "";
            const [$e, yt] = x9(Te, t, c, Be), Sn = [], wn = je ? (Ps) => J(Ps, Sn) : St, uo = { nodes: {}, attributes: {} }, Go = (Ps) => S_(S(), M(), Ps, uo);
            C9(Te, [$e, Go], [yt, wn]), Sn.reverse(), je && Sn.length > 0 && (Be.context ? Be.invalid = !0 : OP(Sn, t, Te, Go));
            const ys = j_(c, Be);
            return ys && (Te.name === "body" || Be.isRootContent) && Q(Te, ys), Be.invalid || AP(uo, Be), Te;
          }
        };
        return s9(be, c), qz(be, c, t), be;
      }, TT = (e) => e instanceof _a, S9 = (e) => TT(e) ? mp({ validate: !1 }).serialize(e) : e, sB = (e, t, o) => {
        const r = S9(e), c = t(r);
        if (c.isDefaultPrevented())
          return c;
        if (TT(e))
          if (c.content !== r) {
            const u = Gv({ validate: !1, forced_root_block: !1, ...o }).parse(c.content, { context: e.name });
            return { ...c, content: u };
          } else
            return { ...c, content: e };
        else
          return c;
      }, rB = (e) => ({
        sanitize: Cv(e),
        sandbox_iframes: lp(e),
        sandbox_iframes_exclusions: Sm(e)
      }), aB = (e, t) => {
        if (t.no_events)
          return xr.value(t);
        {
          const o = sp(e, t);
          return o.isDefaultPrevented() ? xr.error(Pw(e, { content: "", ...o }).content) : xr.value(o);
        }
      }, Cx = (e, t, o) => o.no_events ? t : sB(t, (c) => Pw(e, { ...o, content: c }), rB(e)).content, xx = (e, t) => {
        if (t.no_events)
          return xr.value(t);
        {
          const o = sB(t.content, (r) => Sk(e, { ...t, content: r }), rB(e));
          return o.isDefaultPrevented() ? (Mw(e, o), xr.error(void 0)) : xr.value(o);
        }
      }, W_ = (e, t, o) => {
        o.no_events || Mw(e, { ...o, content: t });
      }, w9 = "autoresize_on_init,content_editable_state,padd_empty_with_br,block_elements,boolean_attributes,editor_deselector,editor_selector,elements,file_browser_callback_types,filepicker_validator_handler,force_hex_style_colors,force_p_newlines,gecko_spellcheck,images_dataimg_filter,media_scripts,mode,move_caret_before_on_enter_elements,non_empty_elements,self_closing_elements,short_ended_elements,special,spellchecker_select_languages,spellchecker_whitelist,tab_focus,tabfocus_elements,table_responsive_width,text_block_elements,text_inline_elements,toolbar_drawer,types,validate,whitespace_elements,paste_enable_default_filters,paste_filter_drop,paste_word_valid_elements,paste_retain_style_properties,paste_convert_word_fake_lists,template_cdate_classes,template_mdate_classes,template_selected_content_classes,template_preview_replace_values,template_replace_values,templates,template_cdate_format,template_mdate_format".split(","), E9 = ["content_css_cors"], T9 = "bbcode,colorpicker,contextmenu,fullpage,legacyoutput,spellchecker,template,textcolor,rtc".split(","), Z_ = [
        {
          name: "export",
          replacedWith: "Export to PDF"
        }
      ], cB = (e, t) => {
        const o = ze(t, (r) => kn(e, r));
        return Tl(o);
      }, k9 = (e) => {
        const t = cB(e, w9), o = e.forced_root_block;
        return (o === !1 || o === "") && t.push("forced_root_block (false only)"), Tl(t);
      }, G_ = (e) => cB(e, E9), lB = (e, t) => {
        const o = Je.makeMap(e.plugins, " "), c = ze(t, (u) => kn(o, u));
        return Tl(c);
      }, A9 = (e) => lB(e, T9), _9 = (e) => lB(e, Z_.map((t) => t.name)), O9 = (e, t) => {
        const o = k9(e), r = A9(t), c = r.length > 0, u = o.length > 0, f = t.theme === "mobile";
        if (c || u || f) {
          const v = f ? `

Themes:
- mobile` : "", S = c ? `

Plugins:
- ${r.join(`
- `)}` : "", O = u ? `

Options:
- ${o.join(`
- `)}` : "";
          console.warn("The following deprecated features are currently enabled and have been removed in TinyMCE 8.0. These features will no longer work and should be removed from the TinyMCE configuration. See https://www.tiny.cloud/docs/tinymce/8/migration-from-7x/ for more information." + v + S + O);
        }
      }, D9 = (e) => _o(Z_, (t) => t.name === e).fold(() => e, (t) => t.replacedWith ? `${e}, replaced by ${t.replacedWith}` : e), R9 = (e, t) => {
        const o = G_(e), r = _9(t), c = r.length > 0, u = o.length > 0;
        if (c || u) {
          const b = c ? `

Plugins:
- ${r.map(D9).join(`
- `)}` : "", v = u ? `

Options:
- ${o.join(`
- `)}` : "";
          console.warn("The following deprecated features are currently enabled but will be removed soon." + b + v);
        }
      }, N9 = (e, t) => {
        O9(e, t), R9(e, t);
      }, kT = {
        fire: 'The "fire" event api has been deprecated and will be removed in TinyMCE 9. Use "dispatch" instead.',
        selectionSetContent: 'The "editor.selection.setContent" method has been deprecated and will be removed in TinyMCE 9. Use "editor.insertContent" instead.'
      }, Sx = (e) => {
        console.warn(kT[e], new Error().stack);
      }, iB = (e) => e.dom.length === 0 ? (qo(e), P.none()) : P.some(e), M9 = (e, t) => e.filter((o) => Iv.isBookmarkNode(o.dom)).bind(t ? tc : rl), AT = (e, t, o, r, c) => {
        const u = e.dom, f = t.dom, b = r ? u.length : f.length;
        r ? (nT(u, f, c, !1, !r), o.setStart(f, b)) : (nT(f, u, c, !1, !r), o.setEnd(f, b));
      }, P9 = (e, t, o) => {
        ec(e).each((r) => {
          const c = e.dom;
          t && sx(r, Re(c, 0), o) ? eT(c, 0, o) : !t && Dc(r, Re(c, c.length), o) && tT(c, c.length, o);
        });
      }, uB = (e, t, o, r, c) => {
        e.bind((u) => ((r ? tT : eT)(u.dom, r ? u.dom.length : 0, c), t.filter(Eo).map((b) => AT(u, b, o, r, c)))).orThunk(() => M9(t, r).or(t).filter(Eo).map((f) => P9(f, r, c)));
      }, B9 = (e, t, o) => {
        const r = P.from(t.firstChild).map(te.fromDom), c = P.from(t.lastChild).map(te.fromDom);
        e.deleteContents(), e.insertNode(t);
        const u = r.bind(rl).filter(Eo).bind(iB), f = c.bind(tc).filter(Eo).bind(iB);
        uB(u, r, e, !0, o), uB(f, c, e, !1, o), e.collapse(!1);
      }, $9 = (e, t) => ({
        format: "html",
        ...e,
        set: !0,
        selection: !0,
        content: t
      }), I9 = (e, t) => {
        if (t.format !== "raw") {
          const o = e.selection.getRng(), r = e.dom.getParent(o.commonAncestorContainer, e.dom.isBlock), c = r ? { context: r.nodeName.toLowerCase() } : {}, u = e.parser.parse(t.content, { forced_root_block: !1, ...c, ...t });
          return mp({ validate: !1 }, e.schema).serialize(u);
        } else
          return t.content;
      }, _T = (e, t, o = {}) => {
        const r = $9(o, t);
        xx(e, r).each((c) => {
          const u = I9(e, c), f = e.selection.getRng();
          B9(f, f.createContextualFragment(u), e.schema), e.selection.setRng(f), ru(e, f), W_(e, u, c);
        });
      }, F9 = (e, t, o = {}) => {
        Sx("selectionSetContent"), _T(e, t, o);
      }, L9 = (e) => X(e.firstChild) && e.firstChild === e.lastChild, H9 = (e) => e.name === "br" || e.value === $s, z9 = (e, t) => e.getBlockElements()[t.name] && L9(t) && H9(t.firstChild), V9 = (e, t) => {
        const o = e.getNonEmptyElements();
        return X(t) && (t.isEmpty(o) || z9(e, t));
      }, rX = (e, t) => {
        let o = t.firstChild, r = t.lastChild;
        return o && o.name === "meta" && (o = o.next), r && r.attr("id") === "mce_marker" && (r = r.prev), V9(e, r) && (r = r?.prev), !o || o !== r ? !1 : o.name === "ul" || o.name === "ol";
      }, Ud = (e) => {
        const t = e.firstChild, o = e.lastChild;
        return t && t.nodeName === "META" && t.parentNode?.removeChild(t), o && o.id === "mce_marker" && o.parentNode?.removeChild(o), e;
      }, dB = (e, t, o) => {
        const r = t.serialize(o), c = e.createFragment(r);
        return Ud(c);
      }, U9 = (e) => ze(e?.childNodes ?? [], (t) => t.nodeName === "LI"), mB = (e) => e.data === $s || zs(e), j9 = (e) => X(e?.firstChild) && e.firstChild === e.lastChild && mB(e.firstChild), W9 = (e) => !e.firstChild || j9(e), aX = (e) => e.length > 0 && W9(e[e.length - 1]) ? e.slice(0, -1) : e, ja = (e, t) => {
        const o = e.getParent(t, e.isBlock);
        return o && o.nodeName === "LI" ? o : null;
      }, Z9 = (e, t) => !!ja(e, t), q_ = (e, t) => {
        const o = t.cloneRange(), r = t.cloneRange();
        return o.setStartBefore(e), r.setEndAfter(e), [
          o.cloneContents(),
          r.cloneContents()
        ];
      }, fB = (e, t) => {
        const o = Re.before(e), c = Uu(t).next(o);
        return c ? c.toRange() : null;
      }, wx = (e, t) => {
        const o = Re.after(e), c = Uu(t).prev(o);
        return c ? c.toRange() : null;
      }, G9 = (e, t, o, r) => {
        const c = q_(e, r), u = e.parentNode;
        return u && (u.insertBefore(c[0], e), Je.each(t, (f) => {
          u.insertBefore(f, e);
        }), u.insertBefore(c[1], e), u.removeChild(e)), wx(t[t.length - 1], o);
      }, q9 = (e, t, o) => {
        const r = e.parentNode;
        return r && Je.each(t, (c) => {
          r.insertBefore(c, e);
        }), fB(e, o);
      }, K9 = (e, t, o, r) => (r.insertAfter(t.reverse(), e), wx(t[0], o)), Y9 = (e, t, o, r) => {
        const c = dB(t, e, r), u = ja(t, o.startContainer), f = aX(U9(c.firstChild)), b = 1, v = 2, S = t.getRoot(), O = (R) => {
          const M = Re.fromRangeStart(o), H = Uu(t.getRoot()), W = (R === b ? H.prev(M) : H.next(M))?.getNode();
          return W ? ja(t, W) !== u : !0;
        };
        return u ? O(b) ? q9(u, f, S) : O(v) ? K9(u, f, S, t) : G9(u, f, S, o) : null;
      }, X9 = ["pre"], gB = (e, t, o, r) => {
        const c = t.firstChild, u = t.lastChild, f = u.attr("data-mce-type") === "bookmark" ? u.prev : u, b = c === f, v = Lt(X9, c.name);
        if (b && v) {
          const S = c.attr("contenteditable") !== "false", O = e.getParent(o, e.isBlock)?.nodeName.toLowerCase() === c.name, R = P.from(Om(r, o)).forall(dl);
          return S && O && R;
        } else
          return !1;
      }, K_ = _h, hB = (e, t, o) => {
        if (X(o)) {
          const r = e.getParent(t.endContainer, K_);
          return o === r && rA(te.fromDom(o), t);
        } else
          return !1;
      }, pB = (e, t) => {
        if (e.isBlock(t) && e.isEditable(t)) {
          const o = t.childNodes;
          return o.length === 1 && zs(o[0]) || o.length === 0;
        } else
          return !1;
      }, Q9 = (e, t, o) => {
        o.getAttribute("data-mce-bogus") === "all" ? o.parentNode?.insertBefore(e.dom.createFragment(t), o) : pB(e.dom, o) ? e.dom.setHTML(o, t) : _T(e, t, { no_events: !0 });
      }, J9 = (e, t, o) => {
        P.from(e.getParent(t, "td,th")).map(te.fromDom).each((r) => P2(r, o));
      }, eV = (e, t) => {
        const o = e.schema.getTextInlineElements(), r = e.dom;
        if (t) {
          const c = e.getBody(), u = Dm(e), f = "*[data-mce-fragment]", b = r.select(f);
          Je.each(b, (v) => {
            const S = (M) => X(o[M.nodeName.toLowerCase()]), O = (M) => M.childNodes.length === 1;
            if (((M) => !(rM(r, M) || aM(r, M)))(v) && S(v) && O(v)) {
              const M = zv(r, v), H = (ge, be) => qa(ge, (ve) => Lt(be, ve)), J = (ge) => O(v) && r.is(ge, f) && S(ge) && (ge.nodeName === v.nodeName && H(M, zv(r, ge)) || J(ge.children[0])), W = (ge) => X(ge) && ge !== c && (u.compare(v, ge) || W(ge.parentElement)), Q = (ge) => X(ge) && ge !== c && r.is(ge, f) && (wH(r, v, ge) || Q(ge.parentElement));
              (J(v.children[0]) || W(v.parentElement) && !Q(v.parentElement)) && r.remove(v, !0);
            }
          }), $z(e, pd(b));
        }
      }, tV = (e) => {
        let t = e;
        for (; t = t.walk(); )
          t.type === 1 && t.attr("data-mce-fragment", "1");
      }, nV = (e) => {
        Je.each(e.getElementsByTagName("*"), (t) => {
          t.removeAttribute("data-mce-fragment");
        });
      }, OT = (e) => !!e.getAttribute("data-mce-fragment"), bB = (e, t) => X(t) && !e.schema.getVoidElements()[t.nodeName], vB = (e, t) => {
        let o;
        const r = e.dom, c = e.selection;
        if (!t)
          return;
        c.scrollIntoView(t);
        const u = Om(e.getBody(), t);
        if (u && r.getContentEditable(u) === "false") {
          r.remove(t), c.select(u);
          return;
        }
        let f = r.createRng();
        const b = t.previousSibling;
        if (tt(b)) {
          f.setStart(b, b.nodeValue?.length ?? 0);
          const O = t.nextSibling;
          tt(O) && (b.appendData(O.data), O.parentNode?.removeChild(O));
        } else
          f.setStartBefore(t), f.setEndBefore(t);
        const v = (O) => {
          let R = Re.fromRangeStart(O);
          return R = Uu(e.getBody()).next(R), R?.toRange();
        }, S = r.getParent(t, r.isBlock);
        if (r.remove(t), S && r.isEmpty(S)) {
          const O = K_(S);
          Il(te.fromDom(S)), f.setStart(S, 0), f.setEnd(S, 0), !O && !OT(S) && (o = v(f)) ? (f = o, r.remove(S)) : r.add(S, r.create("br", O ? {} : { "data-mce-bogus": "1" }));
        }
        c.setRng(f);
      }, oV = (e) => {
        const t = e.dom, o = E_(e.selection.getRng());
        e.selection.setRng(o);
        const r = t.getParent(o.startContainer, K_);
        hB(t, o, r) ? sT(e, o, te.fromDom(r)) : y7(o) || v7(o) ? o.deleteContents() : e.getDoc().execCommand("Delete", !1);
      }, yB = (e) => {
        for (let t = e; t; t = t.walk())
          if (t.attr("id") === "mce_marker")
            return P.some(t);
        return P.none();
      }, sV = (e, t, o) => po(o.children(), Kl) && e.getParent(t, e.isBlock)?.nodeName === "SUMMARY", rV = (e, t, o) => {
        const r = e.selection, c = e.dom, u = e.parser, f = o.merge, b = mp({
          validate: !0
        }, e.schema), v = '<span id="mce_marker" data-mce-type="bookmark">&#xFEFF;</span>';
        o.preserve_zwsp || (t = Gc(t)), t.indexOf("{$caret}") === -1 && (t += "{$caret}"), t = t.replace(/\{\$caret\}/, v);
        let S = r.getRng();
        const O = S.startContainer, R = e.getBody();
        O === R && r.isCollapsed() && c.isBlock(R.firstChild) && bB(e, R.firstChild) && c.isEmpty(R.firstChild) && (S = c.createRng(), S.setStart(R.firstChild, 0), S.setEnd(R.firstChild, 0), r.setRng(S)), r.isCollapsed() || oV(e);
        const M = r.getNode(), H = { context: M.nodeName.toLowerCase(), data: o.data, insert: !0 }, J = u.parse(t, H);
        if (o.paste === !0 && rX(e.schema, J) && Z9(c, M))
          return S = Y9(b, c, r.getRng(), J), S && r.setRng(S), t;
        o.paste === !0 && gB(c, J, M, e.getBody()) && J.firstChild?.unwrap(), tV(J);
        let W = J.lastChild;
        if (W && W.attr("id") === "mce_marker") {
          const Q = W;
          for (W = W.prev; W && W.name !== "table"; W = W.walk(!0))
            if (W.type === 3 || !c.isBlock(W.name)) {
              W.parent && e.schema.isValidChild(W.parent.name, "span") && W.parent.insert(Q, W, W.name === "br");
              break;
            }
        }
        if (e._selectionOverrides.showBlockCaretContainer(M), !H.invalid && !sV(c, M, J))
          t = b.serialize(J), Q9(e, t, M);
        else {
          _T(e, v);
          let Q = r.getNode(), ge;
          const be = e.getBody();
          for (lm(Q) ? Q = ge = be : ge = Q; ge && ge !== be; )
            Q = ge, ge = ge.parentNode;
          t = Q === be ? be.innerHTML : c.getOuterHTML(Q);
          const ve = u.parse(t), Be = yB(ve), je = Be.bind(zz).getOr(ve);
          Be.each((Me) => Me.replace(J));
          const xt = Vz(J);
          J.unwrap();
          const Kt = ze(xt, (Me) => gx(e.schema, Me));
          OP(Kt, e.schema, je), _P(u.getNodeFilters(), u.getAttributeFilters(), ve), t = b.serialize(ve), Q === be ? c.setHTML(be, t) : c.setOuterHTML(Q, t);
        }
        return eV(e, f), vB(e, c.get("mce_marker")), nV(e.getBody()), J9(c, r.getStart(), e.schema), h0(e.schema, e.getBody(), r.getStart()), t;
      }, aV = (e) => {
        Lv(e) && E(e.getBody()).each((t) => {
          const o = t.getNode(), r = Vc(o) ? E(o).getOr(t) : t;
          e.selection.setRng(r.toRange());
        });
      }, Ex = (e, t, o) => {
        e.dom.setHTML(e.getBody(), t), o !== !0 && aV(e);
      }, Y_ = (e, t, o, r) => {
        if (o = Gc(o), o.length === 0 || /^\s+$/.test(o)) {
          const c = '<br data-mce-bogus="1">';
          t.nodeName === "TABLE" ? o = "<tr><td>" + c + "</td></tr>" : /^(UL|OL)$/.test(t.nodeName) && (o = "<li>" + c + "</li>");
          const u = Ar(e);
          return e.schema.isValidChild(t.nodeName.toLowerCase(), u.toLowerCase()) ? (o = c, o = e.dom.createHTML(u, nu(e), o)) : o || (o = c), Ex(e, o, r.no_selection), { content: o, html: o };
        } else {
          r.format !== "raw" && (o = mp({ validate: !1 }, e.schema).serialize(e.parser.parse(o, { isRootContent: !0, insert: !0 })));
          const c = B0(te.fromDom(t)) ? o : Je.trim(o);
          return Ex(e, c, r.no_selection), { content: c, html: c };
        }
      }, cV = (e, t, o, r) => {
        _P(e.parser.getNodeFilters(), e.parser.getAttributeFilters(), o);
        const c = mp({ validate: !1 }, e.schema).serialize(o), u = Gc(B0(te.fromDom(t)) ? c : Je.trim(c));
        return Ex(e, u, r.no_selection), { content: o, html: u };
      }, X_ = (e, t, o) => P.from(e.getBody()).map((r) => TT(t) ? cV(e, r, t, o) : Y_(e, r, t, o)).getOr({ content: t, html: TT(o.content) ? "" : o.content }), Tx = {}, CB = hi(["pre"]), lV = (e, t) => {
        Tx[e] || (Tx[e] = []), Tx[e].push(t);
      }, iV = (e, t) => {
        kn(Tx, e) && xe(Tx[e], (o) => {
          o(t);
        });
      };
      lV("pre", (e) => {
        const t = e.selection.getRng(), o = (c) => (u) => {
          const f = u.previousSibling;
          return CB(f) && Lt(c, f);
        }, r = (c, u) => {
          const f = te.fromDom(u), b = Pl(f).dom;
          qo(f), ll(te.fromDom(c), [
            te.fromTag("br", b),
            te.fromTag("br", b),
            ...Os(f)
          ]);
        };
        if (!t.collapsed) {
          const c = e.selection.getSelectedBlocks(), u = ze(ze(c, CB), o(c));
          xe(u, (f) => {
            r(f.previousSibling, f);
          });
        }
      });
      const xB = Je.each, uV = (e, t, o, r) => {
        const c = (u) => {
          if (zc(u) && ht(u.parentNode) && e.isEditable(u)) {
            const f = g5(e, u.parentNode);
            e.getStyle(u, "color") && f ? e.setStyle(u, "text-decoration", f) : e.getStyle(u, "text-decoration") === f && e.setStyle(u, "text-decoration", null);
          }
        };
        t.styles && (t.styles.color || t.styles.textDecoration) && (Je.walk(r, c, "childNodes"), c(r));
      }, SB = (e, t, o, r) => {
        if (t.styles && t.styles.backgroundColor) {
          const c = h_(e, "fontSize");
          g_(r, (u) => c(u) && e.isEditable(u), hP(e, "backgroundColor", jg(t.styles.backgroundColor, o)));
        }
      }, dV = (e, t, o, r) => {
        if (Va(t) && (t.inline === "sub" || t.inline === "sup")) {
          const c = h_(e, "fontSize");
          g_(r, (f) => c(f) && e.isEditable(f), hP(e, "fontSize", ""));
          const u = ze(e.select(t.inline === "sup" ? "sub" : "sup", r), e.isEditable);
          e.remove(u, !0);
        }
      }, mV = (e, t, o, r) => {
        xB(t, (c) => {
          Va(c) && xB(e.dom.select(c.inline, r), (u) => {
            f_(u) && mx(e, c, o, u, c.exact ? u : null);
          }), Ez(e.dom, c, r);
        });
      }, fV = (e, t, o, r, c) => {
        const u = c.parentNode;
        Gu(e, u, o, r) && mx(e, t, r, c) || t.merge_with_parents && u && e.dom.getParent(u, (f) => Gu(e, f, o, r) ? (mx(e, t, r, c), !0) : !1);
      }, gV = Je.each, hV = (e, t, o, r) => {
        if (a5(e) && Va(t) && o.parentNode) {
          const c = y0(e.schema), u = Zt(te.fromDom(o), (f) => z(f.dom));
          return Zo(c, r) && on(e.schema, o.parentNode, { skipBogus: !1, includeZwsp: !0 }) && !u;
        } else
          return !1;
      }, pV = (e, t, o, r) => {
        const c = e.formatter.get(t), u = c[0], f = !r && e.selection.isCollapsed(), b = e.dom, v = e.selection, S = (H, J) => {
          let W = !1;
          return gV(H, (Q) => Md(Q) ? b.getContentEditable(J) === "false" && !Q.ceFalseOverride || X(Q.collapsed) && Q.collapsed !== f ? !0 : b.is(J, Q.selector) && !z(J) ? (fb(e, J, Q, o, J), W = !0, !1) : !0 : !1), W;
        }, O = (H) => {
          if (U(H)) {
            const J = b.create(H);
            return fb(e, J, u, o, r), J;
          } else
            return null;
        }, R = (H, J, W) => {
          const Q = [];
          let ge = !0;
          const be = u.inline || u.block, ve = O(be), Be = (Kt) => S7(u) && Gu(e, Kt, t, o), je = (Kt, Me, Te) => {
            const $e = w7(u) && GC(e.schema, Kt) && Bv(e, Me, be);
            return Te && $e;
          }, xt = (Kt, Me, Te, $e) => {
            const yt = Kt.nodeName.toLowerCase(), Sn = Bv(e, be, yt) && Bv(e, Me, be), wn = !W && tt(Kt) && A1(Kt.data), uo = z(Kt), Go = !Va(u) || !H.isBlock(Kt);
            return (Te || $e) && Sn && !wn && !uo && Go;
          };
          Pd(H, J, (Kt) => {
            let Me;
            const Te = ($e) => {
              let yt = !1, Sn = ge, wn = !1;
              const uo = $e.parentNode, Go = uo.nodeName.toLowerCase(), ys = H.getContentEditable($e);
              X(ys) && (Sn = ge, ge = ys === "true", yt = !0, wn = f5(e, $e));
              const Ps = ge && !yt;
              if (zs($e) && !hV(e, u, $e, Go)) {
                Me = null, km(u) && H.remove($e);
                return;
              }
              if (Be($e)) {
                Me = null;
                return;
              }
              if (je($e, Go, Ps)) {
                const Ra = H.rename($e, be);
                fb(e, Ra, u, o, $e), Q.push(Ra), Me = null;
                return;
              }
              if (Md(u)) {
                let Ra = S(c, $e);
                if (!Ra && X(uo) && lA(u) && (Ra = S(c, uo)), !Va(u) || Ra) {
                  Me = null;
                  return;
                }
              }
              X(ve) && xt($e, Go, Ps, wn) ? (Me || (Me = H.clone(ve, !1), uo.insertBefore(Me, $e), Q.push(Me)), wn && yt && (ge = Sn), Me.appendChild($e)) : (Me = null, xe(rs($e.childNodes), Te), yt && (ge = Sn), Me = null);
            };
            xe(Kt, Te);
          }), u.links === !0 && xe(Q, (Kt) => {
            const Me = (Te) => {
              Te.nodeName === "A" && fb(e, Te, u, o, r), xe(rs(Te.childNodes), Me);
            };
            Me(Kt);
          }), Bz(e, t, pd(Q)), xe(Q, (Kt) => {
            const Me = (yt) => {
              let Sn = 0;
              return xe(yt.childNodes, (wn) => {
                !C7(wn) && !Ys(wn) && Sn++;
              }), Sn;
            }, Te = (yt) => _o(yt.childNodes, ZC).filter((wn) => H.getContentEditable(wn) !== "false" && aT(H, wn, u)).map((wn) => {
              const uo = H.clone(wn, !1);
              return fb(e, uo, u, o, yt), H.replace(uo, yt, !0), H.remove(wn, !0), uo;
            }).getOr(yt), $e = Me(Kt);
            if ((Q.length > 1 || !H.isBlock(Kt)) && $e === 0) {
              H.remove(Kt, !0);
              return;
            }
            (Va(u) || km(u) && u.wrapper) && (!u.exact && $e === 1 && (Kt = Te(Kt)), mV(e, c, o, Kt), fV(e, u, t, o, Kt), SB(H, u, o, Kt), uV(H, u, o, Kt), dV(H, u, o, Kt), gP(e, u, o, Kt));
          });
        }, M = WC(r) ? r : v.getNode();
        if (b.getContentEditable(M) === "false" && !f5(e, M)) {
          r = M, S(c, r), Cm(e, t, r, o);
          return;
        }
        if (u) {
          if (r)
            if (WC(r)) {
              if (!S(c, r)) {
                const H = b.createRng();
                H.setStartBefore(r), H.setEndAfter(r), R(b, Pf(b, H, c), !0);
              }
            } else
              R(b, r, !0);
          else
            !f || !Va(u) || Ft(e).length ? (v.setRng(E_(v.getRng())), u5(e, () => {
              UC(e, (H, J) => {
                const W = J ? H : Pf(b, H, c);
                R(b, W, !1);
              });
            }, He), e.nodeChanged()) : eP(e, t, o), Sz(e.formatter, t).each((H) => {
              const J = m_(e.selection);
              xe(J, (W) => t_(b, W, H, o));
            });
          iV(t, e);
        }
        Cm(e, t, r, o);
      }, wB = (e, t, o, r) => {
        (r || e.selection.isEditable()) && pV(e, t, o, r);
      }, vb = (e) => kn(e, "vars"), DT = (e, t) => {
        e.set({}), t.on("NodeChange", (o) => {
          TB(t, o.element, e.get());
        }), t.on("FormatApply FormatRemove", (o) => {
          const r = P.from(o.node).map((c) => WC(c) ? c : c.startContainer).bind((c) => ht(c) ? P.some(c) : P.from(c.parentElement)).getOrThunk(() => Q_(t));
          TB(t, r, e.get());
        });
      }, Q_ = (e) => e.selection.getStart(), J_ = (e, t, o, r, c) => Jc(t, (b) => {
        const v = e.formatter.matchNode(b, o, c ?? {}, r);
        return !Gn(v);
      }, (b) => GM(e, b, o) ? !0 : r ? !1 : X(e.formatter.matchNode(b, o, c, !0))), EB = (e, t) => {
        const o = t ?? Q_(e);
        return ze(DE(e.dom, o), (r) => ht(r) && !uf(r));
      }, TB = (e, t, o) => {
        const r = EB(e, t);
        Un(o, (c, u) => {
          const f = (b) => {
            const v = J_(e, r, u, b.similar, vb(b) ? b.vars : void 0), S = v.isSome();
            if (b.state.get() !== S) {
              b.state.set(S);
              const O = v.getOr(t);
              vb(b) ? b.callback(S, { node: O, format: u, parents: r }) : xe(b.callbacks, (R) => R(S, { node: O, format: u, parents: r }));
            }
          };
          xe([c.withSimilar, c.withoutSimilar], f), xe(c.withVars, f);
        });
      }, eO = (e, t, o, r, c, u) => {
        const f = t.get();
        xe(o.split(","), (b) => {
          const v = Wo(f, b).getOrThunk(() => {
            const O = {
              withSimilar: {
                state: Wt(!1),
                similar: !0,
                callbacks: []
              },
              withoutSimilar: {
                state: Wt(!1),
                similar: !1,
                callbacks: []
              },
              withVars: []
            };
            return f[b] = O, O;
          }), S = () => {
            const O = EB(e);
            return J_(e, O, b, c, u).isSome();
          };
          if (Gn(u)) {
            const O = c ? v.withSimilar : v.withoutSimilar;
            O.callbacks.push(r), O.callbacks.length === 1 && O.state.set(S());
          } else
            v.withVars.push({
              state: Wt(S()),
              similar: c,
              vars: u,
              callback: r
            });
        }), t.set(f);
      }, bV = (e, t, o) => {
        const r = e.get();
        xe(t.split(","), (c) => Wo(r, c).each((u) => {
          r[c] = {
            withSimilar: {
              ...u.withSimilar,
              callbacks: ze(u.withSimilar.callbacks, (f) => f !== o)
            },
            withoutSimilar: {
              ...u.withoutSimilar,
              callbacks: ze(u.withoutSimilar.callbacks, (f) => f !== o)
            },
            withVars: ze(u.withVars, (f) => f.callback !== o)
          };
        })), e.set(r);
      }, vV = (e, t, o, r, c, u) => (eO(e, t, o, r, c, u), {
        unbind: () => bV(t, o, r)
      }), yV = (e, t, o, r) => {
        const c = e.formatter.get(t);
        c && (o_(e, t, o, r) && (!("toggle" in c[0]) || c[0].toggle) ? iT(e, t, o, r) : wB(e, t, o, r));
      }, tO = (e, t, o) => ({
        element: e,
        width: t,
        rows: o
      }), kB = (e, t) => ({
        element: e,
        cells: t
      }), RT = (e, t) => ({
        x: e,
        y: t
      }), qv = (e, t) => il(e, t).bind(Jf).getOr(1), CV = (e, t, o, r, c) => {
        const u = qv(c, "rowspan"), f = qv(c, "colspan"), b = e.rows;
        for (let v = o; v < o + u; v++) {
          b[v] || (b[v] = kB(Vi(r), []));
          for (let S = t; S < t + f; S++) {
            const O = b[v].cells;
            O[S] = v === o && S === t ? c : pr(c);
          }
        }
      }, Kv = (e, t, o) => {
        const r = e.rows;
        return !!(r[o] ? r[o].cells : [])[t];
      }, lu = (e, t, o) => {
        for (; Kv(e, t, o); )
          t++;
        return t;
      }, Yv = (e) => Io(e, (t, o) => o.cells.length > t ? o.cells.length : t, 0), Yo = (e, t) => {
        const o = e.rows;
        for (let r = 0; r < o.length; r++) {
          const c = o[r].cells;
          for (let u = 0; u < c.length; u++)
            if (Qn(c[u], t))
              return P.some(RT(u, r));
        }
        return P.none();
      }, Xv = (e, t, o, r, c) => {
        const u = [], f = e.rows;
        for (let b = o; b <= c; b++) {
          const v = f[b].cells, S = t < r ? v.slice(t, r + 1) : v.slice(r, t + 1);
          u.push(kB(f[b].element, S));
        }
        return u;
      }, AB = (e, t, o) => {
        const r = t.x, c = t.y, u = o.x, f = o.y, b = c < f ? Xv(e, r, c, u, f) : Xv(e, r, f, u, c);
        return tO(e.element, Yv(b), b);
      }, _B = (e, t) => {
        const o = pr(e.element), r = te.fromTag("tbody");
        return ll(r, t), bo(o, r), o;
      }, NT = (e) => en(e.rows, (t) => {
        const o = en(t.cells, (c) => {
          const u = Vi(c);
          return sr(u, "colspan"), sr(u, "rowspan"), u;
        }), r = pr(t.element);
        return ll(r, o), r;
      }), nO = (e) => {
        const t = tO(pr(e), 0, []);
        return xe(Ne(e, "tr"), (o, r) => {
          xe(Ne(o, "td,th"), (c, u) => {
            CV(t, lu(t, u, r), r, o, c);
          });
        }), tO(t.element, Yv(t.rows), t.rows);
      }, oO = (e) => _B(e, NT(e)), sO = (e, t, o) => Yo(e, t).bind((r) => Yo(e, o).map((c) => AB(e, r, c))), rO = (e) => _o(e, (t) => Hn(t) === "ul" || Hn(t) === "ol"), MT = (e, t) => _o(e, (o) => Hn(o) === "li" && rA(o, t)).fold(ot([]), (o) => rO(e).map((r) => {
        const c = te.fromTag(Hn(r)), u = Ri(tf(r), (f, b) => hn(b, "list-style"));
        return pc(c, u), [
          te.fromTag("li"),
          c
        ];
      }).getOr([])), aO = (e, t) => {
        const o = Io(t, (r, c) => (bo(c, r), c), e);
        return t.length > 0 ? vd([o]) : o;
      }, OB = (e) => Ec(e) ? ec(e).filter(xi).fold(ot([]), (t) => [e, t]) : xi(e) ? [e] : [], DB = (e, t, o) => {
        const r = te.fromDom(t.commonAncestorContainer), c = Id(r, e), u = ze(c, (v) => o.isWrapper(Hn(v))), f = MT(c, t), b = u.concat(f.length ? f : OB(r));
        return en(b, pr);
      }, cO = () => vd([]), RB = (e, t, o) => aO(te.fromDom(t.cloneContents()), DB(e, t, o)), NB = (e, t) => ar(t, "table", ue(Qn, e)), yb = (e, t) => NB(e, t[0]).bind((o) => {
        const r = t[0], c = t[t.length - 1], u = nO(o);
        return sO(u, r, c).map((f) => vd([oO(f)]));
      }).getOrThunk(cO), MB = (e, t, o) => t.length > 0 && t[0].collapsed ? cO() : RB(e, t[0], o), lO = (e, t, o) => {
        const r = TE(t, e);
        return r.length > 0 ? yb(e, r) : MB(e, t, o);
      }, PT = (e, t) => t >= 0 && t < e.length && Gl(e.charAt(t)), PB = (e) => Gc(e.innerText), BB = (e) => e.map((t) => t.nodeName).getOr("div").toLowerCase(), $B = (e) => P.from(e.selection.getRng()).map((t) => {
        const o = P.from(e.dom.getParent(t.commonAncestorContainer, e.dom.isBlock)), r = e.getBody(), c = BB(o), u = te.fromDom(t.cloneContents());
        tM(u), nM(u);
        const f = e.dom.add(r, c, {
          "data-mce-bogus": "all",
          style: "overflow: hidden; opacity: 0;"
        }, u.dom), b = PB(f), v = Gc(f.textContent ?? "");
        if (e.dom.remove(f), PT(v, 0) || PT(v, v.length - 1)) {
          const S = o.getOr(r), O = PB(S), R = O.indexOf(b);
          if (R === -1)
            return b;
          {
            const M = PT(O, R - 1), H = PT(O, R + b.length);
            return (M ? " " : "") + b + (H ? " " : "");
          }
        } else
          return b;
      }).getOr(""), IB = (e, t) => {
        const o = e.selection.getRng(), r = e.dom.create("body"), c = e.selection.getSel(), u = _A(e, Mv(c)), f = t.contextual ? lO(te.fromDom(e.getBody()), u, e.schema).dom : o.cloneContents();
        return f && r.appendChild(f), e.selection.serializer.serialize(r, t);
      }, BT = (e, t) => {
        if (t.format === "text")
          return $B(e);
        {
          const o = IB(e, t);
          return t.format === "tree" ? o : e.selection.isCollapsed() ? "" : o;
        }
      }, FB = (e, t) => ({
        ...e,
        format: t,
        get: !0,
        selection: !0,
        getInner: !0
      }), LB = (e, t, o = {}) => {
        const r = FB(o, t);
        return aB(e, r).fold(jo, (c) => {
          const u = BT(e, c);
          return Cx(e, u, c);
        });
      }, $T = 0, iO = 1, uO = 2, HB = (e, t) => {
        const o = e.length + t.length + 2, r = new Array(o), c = new Array(o), u = (O, R, M) => ({
          start: O,
          end: R,
          diag: M
        }), f = (O, R, M, H, J) => {
          const W = v(O, R, M, H);
          if (W === null || W.start === R && W.diag === R - H || W.end === O && W.diag === O - M) {
            let Q = O, ge = M;
            for (; Q < R || ge < H; )
              Q < R && ge < H && e[Q] === t[ge] ? (J.push([$T, e[Q]]), ++Q, ++ge) : R - O > H - M ? (J.push([uO, e[Q]]), ++Q) : (J.push([iO, t[ge]]), ++ge);
          } else {
            f(O, W.start, M, W.start - W.diag, J);
            for (let Q = W.start; Q < W.end; ++Q)
              J.push([$T, e[Q]]);
            f(W.end, R, W.end - W.diag, H, J);
          }
        }, b = (O, R, M, H) => {
          let J = O;
          for (; J - R < H && J < M && e[J] === t[J - R]; )
            ++J;
          return u(O, J, R);
        }, v = (O, R, M, H) => {
          const J = R - O, W = H - M;
          if (J === 0 || W === 0)
            return null;
          const Q = J - W, ge = W + J, be = (ge % 2 === 0 ? ge : ge + 1) / 2;
          r[1 + be] = O, c[1 + be] = R + 1;
          let ve, Be, je, xt, Kt;
          for (ve = 0; ve <= be; ++ve) {
            for (Be = -ve; Be <= ve; Be += 2) {
              for (je = Be + be, Be === -ve || Be !== ve && r[je - 1] < r[je + 1] ? r[je] = r[je + 1] : r[je] = r[je - 1] + 1, xt = r[je], Kt = xt - O + M - Be; xt < R && Kt < H && e[xt] === t[Kt]; )
                r[je] = ++xt, ++Kt;
              if (Q % 2 !== 0 && Q - ve <= Be && Be <= Q + ve && c[je - Q] <= r[je])
                return b(c[je - Q], Be + O - M, R, H);
            }
            for (Be = Q - ve; Be <= Q + ve; Be += 2) {
              for (je = Be + be - Q, Be === Q - ve || Be !== Q + ve && c[je + 1] <= c[je - 1] ? c[je] = c[je + 1] - 1 : c[je] = c[je - 1], xt = c[je] - 1, Kt = xt - O + M - Be; xt >= O && Kt >= M && e[xt] === t[Kt]; )
                c[je] = xt--, Kt--;
              if (Q % 2 === 0 && -ve <= Be && Be <= ve && c[je] <= r[je + Q])
                return b(c[je], Be + O - M, R, H);
            }
          }
          return null;
        }, S = [];
        return f(0, e.length, 0, t.length, S), S;
      }, dO = (e) => ht(e) ? e.outerHTML : tt(e) ? gl.encodeRaw(e.data, !1) : zn(e) ? "<!--" + e.data + "-->" : "", zB = (e) => {
        let t;
        const o = document.createElement("div"), r = document.createDocumentFragment();
        for (e && (o.innerHTML = e); t = o.firstChild; )
          r.appendChild(t);
        return r;
      }, VB = (e, t, o) => {
        const r = zB(t);
        if (e.hasChildNodes() && o < e.childNodes.length) {
          const c = e.childNodes[o];
          e.insertBefore(r, c);
        } else
          e.appendChild(r);
      }, UB = (e, t) => {
        if (e.hasChildNodes() && t < e.childNodes.length) {
          const o = e.childNodes[t];
          e.removeChild(o);
        }
      }, mO = (e, t) => {
        let o = 0;
        xe(e, (r) => {
          r[0] === $T ? o++ : r[0] === iO ? (VB(t, r[1], o), o++) : r[0] === uO && UB(t, o);
        });
      }, jB = (e, t) => ze(en(rs(e.childNodes), A(Gc, dO)), (o) => o.length > 0), WB = (e, t) => {
        const o = en(rs(t.childNodes), dO);
        return mO(HB(o, e), t), t;
      }, ZB = ha(() => document.implementation.createHTMLDocument("undo")), GB = (e) => e.querySelector(`iframe, ${m2}`) !== null, qB = (e) => ({
        type: "fragmented",
        fragments: e,
        content: "",
        bookmark: null,
        beforeBookmark: null
      }), KB = (e) => ({
        type: "complete",
        fragments: null,
        content: e,
        bookmark: null,
        beforeBookmark: null
      }), kx = (e) => {
        const t = e.serializer.getTempAttrs(), o = eM(e.getBody(), t);
        return GB(o) ? qB(jB(o)) : KB(Gc(o.innerHTML));
      }, Ax = (e, t, o) => {
        const r = o ? t.beforeBookmark : t.bookmark;
        t.type === "fragmented" ? WB(t.fragments, e.getBody()) : e.setContent(t.content, {
          format: "raw",
          // If we have a path bookmark, we need to check if the bookmark location was a fake caret.
          // If the bookmark was not a fake caret, then we need to ensure that setContent does not move the selection
          // as this can create a new fake caret - particularly if the first element in the body is contenteditable=false.
          // The creation of this new fake caret will cause our path offset to be off by one when restoring the original selection.
          no_selection: X(r) && wt(r) ? !r.isFakeCaret : !0
        }), r && (e.selection.moveToBookmark(r), e.selection.scrollIntoView());
      }, Qv = (e) => e.type === "fragmented" ? e.fragments.join("") : e.content, fO = (e, t) => {
        const o = te.fromTag("body", ZB());
        return Au(o, Qv(t)), xe(Ne(o, "*[data-mce-bogus]"), hc), e && xe(Ne(o, "details[open]"), (r) => sr(r, "open")), la(o);
      }, xV = (e, t) => Qv(e) === Qv(t), YB = (e, t, o) => fO(e, t) === fO(e, o), Jv = (e, t, o) => !t || !o ? !1 : xV(t, o) ? !0 : YB(e, t, o), _x = (e) => e.get() === 0, xp = (e, t, o) => {
        _x(o) && (e.typing = t);
      }, IT = (e, t) => {
        e.typing && (xp(e, !1, t), e.add());
      }, XB = (e) => {
        e.typing && (e.typing = !1, e.add());
      }, ey = (e, t, o) => {
        _x(t) && o.set(Xh(e.selection));
      }, gO = (e, t, o, r, c, u, f) => {
        const b = kx(e), v = Je.extend(u || {}, b);
        if (!_x(r) || e.removed)
          return null;
        const S = t.data[o.get()];
        if (e.dispatch("BeforeAddUndo", { level: v, lastLevel: S, originalEvent: f }).isDefaultPrevented() || S && Jv(e.readonly, S, v))
          return null;
        t.data[o.get()] && c.get().each((M) => {
          t.data[o.get()].beforeBookmark = M;
        });
        const O = tE(e);
        if (O && t.data.length > O) {
          for (let M = 0; M < t.data.length - 1; M++)
            t.data[M] = t.data[M + 1];
          t.data.length--, o.set(t.data.length);
        }
        v.bookmark = Xh(e.selection), o.get() < t.data.length - 1 && (t.data.length = o.get() + 1), t.data.push(v), o.set(t.data.length - 1);
        const R = { level: v, lastLevel: S, originalEvent: f };
        return o.get() > 0 ? (e.setDirty(!0), e.dispatch("AddUndo", R), e.dispatch("change", R)) : e.dispatch("AddUndo", R), v;
      }, hO = (e, t, o) => {
        t.data = [], o.set(0), t.typing = !1, e.dispatch("ClearUndos");
      }, ty = (e, t, o, r, c) => {
        if (t.transact(r)) {
          const u = t.data[o.get()].bookmark, f = t.data[o.get() - 1];
          Ax(e, f, !0), t.transact(c) && (t.data[o.get() - 1].beforeBookmark = u);
        }
      }, Sp = (e, t, o) => {
        let r;
        return t.get() < o.length - 1 && (t.set(t.get() + 1), r = o[t.get()], Ax(e, r, !1), e.setDirty(!0), e.dispatch("Redo", { level: r })), r;
      }, QB = (e, t, o, r) => {
        let c;
        return t.typing && (t.add(), t.typing = !1, xp(t, !1, o)), r.get() > 0 && (r.set(r.get() - 1), c = t.data[r.get()], Ax(e, c, !0), e.setDirty(!0), e.dispatch("Undo", { level: c })), c;
      }, SV = (e) => {
        e.clear(), e.add();
      }, wV = (e, t, o) => (
        // Has undo levels or typing and content isn't the same as the initial level
        o.get() > 0 || t.typing && t.data[0] && !Jv(e.readonly, kx(e), t.data[0])
      ), JB = (e, t) => t.get() < e.data.length - 1 && !e.typing, e6 = (e, t, o) => (IT(e, t), e.beforeChange(), e.ignore(o), e.add()), t6 = (e, t) => {
        try {
          e.set(e.get() + 1), t();
        } finally {
          e.set(e.get() - 1);
        }
      }, EV = (e, t) => {
        const o = e.dom, r = X(t) ? t : e.getBody();
        xe(o.select("table,a", r), (c) => {
          switch (c.nodeName) {
            case "TABLE":
              const u = oE(e), f = o.getAttrib(c, "border");
              (!f || f === "0") && e.hasVisual ? o.addClass(c, u) : o.removeClass(c, u);
              break;
            case "A":
              if (!o.getAttrib(c, "href")) {
                const b = o.getAttrib(c, "name") || c.id, v = bv(e);
                b && e.hasVisual ? o.addClass(c, v) : o.removeClass(c, v);
              }
              break;
          }
        }), e.dispatch("VisualAid", { element: t, hasVisual: e.hasVisual });
      }, Yg = (e) => ({
        init: {
          bindEvents: St
        },
        undoManager: {
          beforeChange: (t, o) => ey(e, t, o),
          add: (t, o, r, c, u, f) => gO(e, t, o, r, c, u, f),
          undo: (t, o, r) => QB(e, t, o, r),
          redo: (t, o) => Sp(e, t, o),
          clear: (t, o) => hO(e, t, o),
          reset: (t) => SV(t),
          hasUndo: (t, o) => wV(e, t, o),
          hasRedo: (t, o) => JB(t, o),
          transact: (t, o, r) => e6(t, o, r),
          ignore: (t, o) => t6(t, o),
          extra: (t, o, r, c) => ty(e, t, o, r, c)
        },
        formatter: {
          match: (t, o, r, c) => o_(e, t, o, r, c),
          matchAll: (t, o) => s_(e, t, o),
          matchNode: (t, o, r, c) => Gu(e, t, o, r, c),
          canApply: (t) => r_(e, t),
          closest: (t) => KM(e, t),
          apply: (t, o, r) => wB(e, t, o, r),
          remove: (t, o, r, c) => iT(e, t, o, r, c),
          toggle: (t, o, r) => yV(e, t, o, r),
          formatChanged: (t, o, r, c, u) => vV(e, t, o, r, c, u)
        },
        editor: {
          getContent: (t) => yH(e, t),
          setContent: (t, o) => X_(e, t, o),
          insertContent: (t, o) => rV(e, t, o),
          addVisual: (t) => EV(e, t)
        },
        selection: {
          getContent: (t, o) => LB(e, t, o)
        },
        autocompleter: {
          addDecoration: St,
          // This was never fully implemented in RTC
          removeDecoration: St
          // This was never fully implemented in RTC
        },
        raw: {
          getModel: () => P.none()
        }
      }), Cb = (e) => {
        const t = (S) => Ye(S) ? S : {}, { init: o, undoManager: r, formatter: c, editor: u, selection: f, autocompleter: b, raw: v } = e;
        return {
          init: {
            bindEvents: o.bindEvents
          },
          undoManager: {
            beforeChange: r.beforeChange,
            add: r.add,
            undo: r.undo,
            redo: r.redo,
            clear: r.clear,
            reset: r.reset,
            hasUndo: r.hasUndo,
            hasRedo: r.hasRedo,
            transact: (S, O, R) => r.transact(R),
            ignore: (S, O) => r.ignore(O),
            extra: (S, O, R, M) => r.extra(R, M)
          },
          formatter: {
            match: (S, O, R, M) => c.match(S, t(O), M),
            matchAll: c.matchAll,
            matchNode: c.matchNode,
            canApply: (S) => c.canApply(S),
            closest: (S) => c.closest(S),
            apply: (S, O, R) => c.apply(S, t(O)),
            remove: (S, O, R, M) => c.remove(S, t(O)),
            toggle: (S, O, R) => c.toggle(S, t(O)),
            formatChanged: (S, O, R, M, H) => c.formatChanged(O, R, M, H)
          },
          editor: {
            getContent: (S) => u.getContent(S),
            setContent: (S, O) => ({ content: u.setContent(S, O), html: "" }),
            insertContent: (S, O) => (u.insertContent(S), ""),
            addVisual: u.addVisual
          },
          selection: {
            getContent: (S, O) => f.getContent(O)
          },
          autocompleter: {
            addDecoration: b.addDecoration,
            removeDecoration: b.removeDecoration
          },
          raw: {
            getModel: () => P.some(v.getRawModel())
          }
        };
      }, n6 = () => {
        const e = ot(null), t = ot("");
        return {
          init: {
            bindEvents: St
          },
          undoManager: {
            beforeChange: St,
            add: e,
            undo: e,
            redo: e,
            clear: St,
            reset: St,
            hasUndo: ye,
            hasRedo: ye,
            transact: e,
            ignore: St,
            extra: St
          },
          formatter: {
            match: ye,
            matchAll: ot([]),
            matchNode: ot(void 0),
            canApply: ye,
            closest: t,
            apply: St,
            remove: St,
            toggle: St,
            formatChanged: ot({ unbind: St })
          },
          editor: {
            getContent: t,
            setContent: ot({ content: "", html: "" }),
            insertContent: ot(""),
            addVisual: St
          },
          selection: {
            getContent: t
          },
          autocompleter: {
            addDecoration: St,
            removeDecoration: St
          },
          raw: {
            getModel: ot(P.none())
          }
        };
      }, Bm = (e) => kn(e.plugins, "rtc"), TV = (e) => Wo(e.plugins, "rtc").bind((t) => (
        // This might not exist if the stub plugin is loaded on cloud
        P.from(t.setup)
      )), kV = (e) => {
        const t = e;
        return TV(e).fold(() => (t.rtcInstance = Yg(e), P.none()), (o) => (t.rtcInstance = n6(), P.some(() => o().then((r) => (t.rtcInstance = Cb(r), r.rtc.isRemote)))));
      }, pO = (e) => (
        // Calls to editor.getContent/editor.setContent should still work even if the rtcInstance is not yet available
        e.rtcInstance ? e.rtcInstance : Yg(e)
      ), bs = (e) => {
        const t = e.rtcInstance;
        if (t)
          return t;
        throw new Error("Failed to get RTC instance not yet initialized.");
      }, jd = (e, t, o) => {
        bs(e).undoManager.beforeChange(t, o);
      }, o6 = (e, t, o, r, c, u, f) => bs(e).undoManager.add(t, o, r, c, u, f), bO = (e, t, o, r) => bs(e).undoManager.undo(t, o, r), vO = (e, t, o) => bs(e).undoManager.redo(t, o), FT = (e, t, o) => {
        bs(e).undoManager.clear(t, o);
      }, AV = (e, t) => {
        bs(e).undoManager.reset(t);
      }, s6 = (e, t, o) => bs(e).undoManager.hasUndo(t, o), Ox = (e, t, o) => bs(e).undoManager.hasRedo(t, o), _V = (e, t, o, r) => bs(e).undoManager.transact(t, o, r), LT = (e, t, o) => {
        bs(e).undoManager.ignore(t, o);
      }, yO = (e, t, o, r, c) => {
        bs(e).undoManager.extra(t, o, r, c);
      }, r6 = (e, t, o, r, c) => bs(e).formatter.match(t, o, r, c), Dx = (e, t, o) => bs(e).formatter.matchAll(t, o), OV = (e, t, o, r, c) => bs(e).formatter.matchNode(t, o, r, c), DV = (e, t) => bs(e).formatter.canApply(t), $m = (e, t) => bs(e).formatter.closest(t), Ti = (e, t, o, r) => {
        bs(e).formatter.apply(t, o, r);
      }, Rx = (e, t, o, r, c) => {
        bs(e).formatter.remove(t, o, r, c);
      }, ki = (e, t, o, r) => {
        bs(e).formatter.toggle(t, o, r);
      }, RV = (e, t, o, r, c, u) => bs(e).formatter.formatChanged(t, o, r, c, u), vs = (e, t) => pO(e).editor.getContent(t), NV = (e, t, o) => pO(e).editor.setContent(t, o), Xg = (e, t, o) => pO(e).editor.insertContent(t, o), Nx = (e, t, o) => bs(e).selection.getContent(t, o), a6 = (e, t) => bs(e).editor.addVisual(t), HT = (e) => bs(e).init.bindEvents(), CO = (e, t = {}) => {
        const o = t.format ? t.format : "html";
        return Nx(e, o, t);
      }, c6 = (e, t, o) => {
        if (kn(e, t)) {
          const r = ze(e[t], (c) => c !== o);
          r.length === 0 ? delete e[t] : e[t] = r;
        }
      };
      var xO = (e, t) => {
        let o, r;
        const c = (b, v) => _o(v, (S) => e.is(S, b)), u = (b) => e.getParents(b, void 0, e.getRoot()), f = () => {
          o = {}, r = {}, t.on("NodeChange", (b) => {
            const v = b.element, S = u(v), O = {};
            Un(o, (R, M) => {
              c(M, S).each((H) => {
                r[M] || (xe(R, (J) => {
                  J(!0, { node: H, selector: M, parents: S });
                }), r[M] = R), O[M] = R;
              });
            }), Un(r, (R, M) => {
              O[M] || (delete r[M], xe(R, (H) => {
                H(!1, { node: v, selector: M, parents: S });
              }));
            });
          });
        };
        return {
          selectorChangedWithUnbind: (b, v) => (o || f(), o[b] || (o[b] = []), o[b].push(v), c(b, u(t.selection.getStart())).each(() => {
            r[b] = o[b];
          }), {
            unbind: () => {
              c6(o, b, v), c6(r, b, v);
            }
          })
        };
      };
      const l6 = (e) => !!(e && e.ownerDocument) && Ja(te.fromDom(e.ownerDocument), te.fromDom(e)), i6 = (e) => e ? l6(e.startContainer) && l6(e.endContainer) : !1, SO = (e, t, o, r) => {
        let c, u;
        const { selectorChangedWithUnbind: f } = xO(e, r), b = (At, sn) => {
          const Lo = e.createRng();
          X(At) && X(sn) ? (Lo.setStart(At, sn), Lo.setEnd(At, sn), Be(Lo), ge(!1)) : (AE(e, Lo, r.getBody(), !0), Be(Lo));
        }, v = (At) => CO(r, At), S = (At, sn) => F9(r, At, sn), O = (At) => jE(r.getBody(), ve(), At), R = (At) => TA(r.getBody(), ve(), At), M = (At, sn) => Ra.getBookmark(At, sn), H = (At) => Ra.moveToBookmark(At), J = (At, sn) => (q5(e, At, sn).each(Be), At), W = () => {
          const At = ve(), sn = be();
          return !At || At.item ? !1 : At.compareEndPoints ? At.compareEndPoints("StartToEnd", At) === 0 : !sn || At.collapsed;
        }, Q = () => {
          if (r.mode.isReadOnly())
            return !1;
          const At = ve(), sn = r.getBody().querySelectorAll('[data-mce-selected="1"]');
          return sn.length > 0 ? qa(sn, (Lo) => e.isEditable(Lo.parentElement)) : rH(e, At);
        }, ge = (At) => {
          const sn = ve();
          sn.collapse(!!At), Be(sn);
        }, be = () => t.getSelection ? t.getSelection() : t.document.selection, ve = () => {
          let At;
          const sn = (Ao, Ga, Le) => {
            try {
              return Ga.compareBoundaryPoints(Ao, Le);
            } catch {
              return -1;
            }
          }, Lo = t.document;
          if (X(r.bookmark) && !Lv(r)) {
            const Ao = IE(r);
            if (Ao.isSome())
              return Ao.map((Ga) => _A(r, [Ga])[0]).getOr(Lo.createRange());
          }
          try {
            const Ao = be();
            Ao && !m0(Ao.anchorNode) && (Ao.rangeCount > 0 ? At = Ao.getRangeAt(0) : At = Lo.createRange(), At = _A(r, [At])[0]);
          } catch {
          }
          if (At || (At = Lo.createRange()), lm(At.startContainer) && At.collapsed) {
            const Ao = e.getRoot();
            At.setStart(Ao, 0), At.setEnd(Ao, 0);
          }
          return c && u && (sn(At.START_TO_START, At, c) === 0 && sn(At.END_TO_END, At, c) === 0 ? At = u : (c = null, u = null)), At;
        }, Be = (At, sn) => {
          if (!i6(At))
            return;
          const Lo = be();
          if (At = r.dispatch("SetSelectionRange", { range: At, forward: sn }).range, Lo) {
            u = At;
            try {
              Lo.removeAllRanges(), Lo.addRange(At);
            } catch {
            }
            sn === !1 && Lo.extend && (Lo.collapse(At.endContainer, At.endOffset), Lo.extend(At.startContainer, At.startOffset)), c = Lo.rangeCount > 0 ? Lo.getRangeAt(0) : null;
          }
          if (!At.collapsed && At.startContainer === At.endContainer && Lo?.setBaseAndExtent && At.endOffset - At.startOffset < 2 && At.startContainer.hasChildNodes()) {
            const Ga = At.startContainer.childNodes[At.startOffset];
            Ga && Ga.nodeName === "IMG" && (Lo.setBaseAndExtent(At.startContainer, At.startOffset, At.endContainer, At.endOffset), (Lo.anchorNode !== At.startContainer || Lo.focusNode !== At.endContainer) && Lo.setBaseAndExtent(Ga, 0, Ga, 1));
          }
          r.dispatch("AfterSetSelectionRange", { range: At, forward: sn });
        }, je = (At) => (_T(r, e.getOuterHTML(At)), At), xt = () => AA(r.getBody(), ve()), Kt = (At, sn) => aH(e, ve(), At, sn), Me = () => {
          const At = be(), sn = At?.anchorNode, Lo = At?.focusNode;
          if (!At || !sn || !Lo || m0(sn) || m0(Lo))
            return !0;
          const Ao = e.createRng(), Ga = e.createRng();
          try {
            Ao.setStart(sn, At.anchorOffset), Ao.collapse(!0), Ga.setStart(Lo, At.focusOffset), Ga.collapse(!0);
          } catch {
            return !0;
          }
          return Ao.compareBoundaryPoints(Ao.START_TO_START, Ga) <= 0;
        }, Ps = {
          dom: e,
          win: t,
          serializer: o,
          editor: r,
          expand: (At = { type: "word" }) => Be(_m(e).expand(ve(), At)),
          collapse: ge,
          setCursorLocation: b,
          getContent: v,
          setContent: S,
          getBookmark: M,
          moveToBookmark: H,
          select: J,
          isCollapsed: W,
          isEditable: Q,
          isForward: Me,
          setNode: je,
          getNode: xt,
          getSel: be,
          setRng: Be,
          getRng: ve,
          getStart: O,
          getEnd: R,
          getSelectedBlocks: Kt,
          normalize: () => {
            const At = ve(), sn = be();
            if (!Tm(sn) && VC(r)) {
              const Lo = zE(e, At);
              return Lo.each((Ao) => {
                Be(Ao, Me());
              }), Lo.getOr(At);
            }
            return At;
          },
          selectorChanged: (At, sn) => (f(At, sn), Ps),
          selectorChangedWithUnbind: f,
          getScrollContainer: () => {
            let At, sn = e.getRoot();
            for (; sn && sn.nodeName !== "BODY"; ) {
              if (sn.scrollHeight > sn.clientHeight) {
                At = sn;
                break;
              }
              sn = sn.parentNode;
            }
            return At;
          },
          scrollIntoView: (At, sn) => {
            X(At) ? _t(r, At, sn) : ru(r, ve(), sn);
          },
          placeCaretAt: (At, sn) => Be(B5(At, sn, r.getDoc())),
          getBoundingClientRect: () => {
            const At = ve();
            return At.collapsed ? Re.fromRangeStart(At).getClientRects()[0] : At.getBoundingClientRect();
          },
          destroy: () => {
            t = c = u = null, Ai.destroy();
          }
        }, Ra = Iv(Ps), Ai = Z7(Ps, r);
        return Ps.bookmarkManager = Ra, Ps.controlSelection = Ai, Ps;
      }, wO = (e, t, o) => {
        t.addNodeFilter("br", (r, c, u) => {
          const f = Je.extend({}, o.getBlockElements()), b = o.getNonEmptyElements(), v = o.getWhitespaceElements();
          f.body = 1;
          const S = (O) => O.name in f || fl(o, O);
          for (let O = 0, R = r.length; O < R; O++) {
            let M = r[O], H = M.parent;
            if (H && S(H) && M === H.lastChild) {
              let J = M.prev;
              for (; J; ) {
                const W = J.name;
                if (W !== "span" || J.attr("data-mce-type") !== "bookmark") {
                  W === "br" && (M = null);
                  break;
                }
                J = J.prev;
              }
              if (M && (M.remove(), fx(o, b, v, H))) {
                const W = o.getElementRule(H.name);
                W && (W.removeEmpty ? H.remove() : W.paddEmpty && bp(e, u, S, H));
              }
            } else {
              let J = M;
              for (; H && H.firstChild === J && H.lastChild === J && (J = H, !f[H.name]); )
                H = H.parent;
              if (J === H) {
                const W = new _a("#text", 3);
                W.value = $s, M.replace(W);
              }
            }
          }
        });
      }, u6 = (e, t, o) => {
        e.addAttributeFilter("data-mce-tabindex", (r, c) => {
          let u = r.length;
          for (; u--; ) {
            const f = r[u];
            f.attr("tabindex", f.attr("data-mce-tabindex")), f.attr(c, null);
          }
        }), e.addAttributeFilter("src,href,style", (r, c) => {
          const u = "data-mce-" + c, f = t.url_converter, b = t.url_converter_scope;
          let v = r.length;
          for (; v--; ) {
            const S = r[v];
            let O = S.attr(u);
            O !== void 0 ? (S.attr(c, O.length > 0 ? O : null), S.attr(u, null)) : (O = S.attr(c), c === "style" ? O = o.serializeStyle(o.parseStyle(O), S.name) : f && (O = f.call(b, O, c, S.name)), S.attr(c, O.length > 0 ? O : null));
          }
        }), e.addAttributeFilter("class", (r) => {
          let c = r.length;
          for (; c--; ) {
            const u = r[c];
            let f = u.attr("class");
            f && (f = f.replace(/(?:^|\s)mce-item-\w+(?!\S)/g, ""), u.attr("class", f.length > 0 ? f : null));
          }
        }), e.addAttributeFilter("data-mce-type", (r, c, u) => {
          let f = r.length;
          for (; f--; ) {
            const b = r[f];
            b.attr("data-mce-type") === "bookmark" && !u.cleanup && (P.from(b.firstChild).exists((S) => !A1(S.value ?? "")) ? b.unwrap() : b.remove());
          }
        }), e.addNodeFilter("script,style", (r, c) => {
          const u = (b) => b.replace(/(<!--\[CDATA\[|\]\]-->)/g, `
`).replace(/^[\r\n]*|[\r\n]*$/g, "").replace(/^\s*((<!--)?(\s*\/\/)?\s*<!\[CDATA\[|(<!--\s*)?\/\*\s*<!\[CDATA\[\s*\*\/|(\/\/)?\s*<!--|\/\*\s*<!--\s*\*\/)\s*[\r\n]*/gi, "").replace(/\s*(\/\*\s*\]\]>\s*\*\/(-->)?|\s*\/\/\s*\]\]>(-->)?|\/\/\s*(-->)?|\]\]>|\/\*\s*-->\s*\*\/|\s*-->\s*)\s*$/g, "");
          let f = r.length;
          for (; f--; ) {
            const b = r[f], v = b.firstChild, S = v?.value ?? "";
            if (c === "script") {
              const O = b.attr("type");
              O && b.attr("type", O === "mce-no/type" ? null : O.replace(/^mce\-/, "")), t.element_format === "xhtml" && v && S.length > 0 && (v.value = `// <![CDATA[
` + u(S) + `
// ]]>`);
            } else
              t.element_format === "xhtml" && v && S.length > 0 && (v.value = `<!--
` + u(S) + `
-->`);
          }
        }), e.addNodeFilter("#comment", (r) => {
          let c = r.length;
          for (; c--; ) {
            const u = r[c], f = u.value;
            t.preserve_cdata && f?.indexOf("[CDATA[") === 0 ? (u.name = "#cdata", u.type = 4, u.value = o.decode(f.replace(/^\[CDATA\[|\]\]$/g, ""))) : f?.indexOf("mce:protected ") === 0 && (u.name = "#text", u.type = 3, u.raw = !0, u.value = unescape(f).substr(14));
          }
        }), e.addNodeFilter("xml:namespace,input", (r, c) => {
          let u = r.length;
          for (; u--; ) {
            const f = r[u];
            f.type === 7 ? f.remove() : f.type === 1 && c === "input" && !f.attr("type") && f.attr("type", "text");
          }
        }), e.addAttributeFilter("data-mce-type", (r) => {
          xe(r, (c) => {
            c.attr("data-mce-type") === "format-caret" && (c.isEmpty(e.schema.getNonEmptyElements()) ? c.remove() : c.unwrap());
          });
        }), e.addAttributeFilter("data-mce-src,data-mce-href,data-mce-style,data-mce-selected,data-mce-expando,data-mce-block,data-mce-type,data-mce-resize,data-mce-placeholder", (r, c) => {
          let u = r.length;
          for (; u--; )
            r[u].attr(c, null);
        }), t.remove_trailing_brs && wO(t, e, e.schema);
      }, zT = (e) => {
        const t = (r) => r?.name === "br", o = e.lastChild;
        if (t(o)) {
          const r = o.prev;
          t(r) && (o.remove(), r.remove());
        }
      }, MV = (e, t, o) => {
        let r;
        const c = e.dom;
        let u = t.cloneNode(!0);
        const f = document.implementation;
        if (f.createHTMLDocument) {
          const b = f.createHTMLDocument("");
          Je.each(u.nodeName === "BODY" ? u.childNodes : [u], (v) => {
            b.body.appendChild(b.importNode(v, !0));
          }), u.nodeName !== "BODY" ? u = b.body.firstChild : u = b.body, r = c.doc, c.doc = b;
        }
        return tv(e, { ...o, node: u }), r && (c.doc = r), u;
      }, PV = (e, t) => X(e) && e.hasEventListeners("PreProcess") && !t.no_events, BV = (e, t, o) => PV(e, o) ? MV(e, t, o) : t, $V = (e, t, o) => {
        Je.inArray(t, o) === -1 && (e.addAttributeFilter(o, (r, c) => {
          let u = r.length;
          for (; u--; )
            r[u].attr(c, null);
        }), t.push(o));
      }, IV = (e, t, o) => !t.no_events && e ? sC(e, { ...t, content: o }).content : o, d6 = (e, t, o) => {
        const r = Gc(o.getInner ? t.innerHTML : e.getOuterHTML(t));
        return o.selection || B0(te.fromDom(t)) ? r : Je.trim(r);
      }, FV = (e, t, o) => {
        const r = o.selection ? { forced_root_block: !1, ...o } : o, c = e.parse(t, r);
        return zT(c), c;
      }, LV = (e, t, o) => mp(e, t).serialize(o), m6 = (e, t, o, r, c) => {
        const u = LV(t, o, r);
        return IV(e, c, u);
      }, HV = (e, t) => {
        const o = ["data-mce-selected"], r = {
          entity_encoding: "named",
          remove_trailing_brs: !0,
          pad_empty_with_br: !1,
          ...e
        }, c = t && t.dom ? t.dom : lo.DOM, u = t && t.schema ? t.schema : wa(r), f = Gv(r, u);
        u6(f, r, c);
        const b = (v, S = {}) => {
          const { indent: O, entity_encoding: R, ...M } = S, H = { format: "html", ...M }, J = BV(t, v, H), W = d6(c, J, H), Q = FV(f, W, H);
          if (H.format === "tree")
            return Q;
          const ge = {
            ...r,
            ...X(O) ? { indent: O } : {},
            ...X(R) ? { entity_encoding: R } : {}
          };
          return m6(t, ge, u, Q, H);
        };
        return {
          schema: u,
          addNodeFilter: f.addNodeFilter,
          addAttributeFilter: f.addAttributeFilter,
          serialize: b,
          addRules: u.addValidElements,
          setRules: u.setValidElements,
          addTempAttr: ue($V, f, o),
          getTempAttrs: ot(o),
          getNodeFilters: f.getNodeFilters,
          getAttributeFilters: f.getAttributeFilters,
          removeNodeFilter: f.removeNodeFilter,
          removeAttributeFilter: f.removeAttributeFilter
        };
      }, EO = (e, t) => {
        const o = HV(e, t);
        return {
          /**
           * Schema instance that was used to when the Serializer was constructed.
           *
           * @field {tinymce.html.Schema} schema
           */
          schema: o.schema,
          /**
           * Adds a node filter function to the parser used by the serializer, the parser will collect the specified nodes by name
           * and then execute the callback once it has finished parsing the document.
           *
           * @method addNodeFilter
           * @param {String} name Comma separated list of nodes to collect.
           * @param {Function} callback Callback function to execute once it has collected nodes.
           * @example
           * serializer.addNodeFilter('p,h1', (nodes, name) => {
           *   for (let i = 0; i < nodes.length; i++) {
           *     console.log(nodes[i].name);
           *   }
           * });
           */
          addNodeFilter: o.addNodeFilter,
          /**
           * Adds an attribute filter function to the parser used by the serializer, the parser will
           * collect nodes that has the specified attributes
           * and then execute the callback once it has finished parsing the document.
           *
           * @method addAttributeFilter
           * @param {String} name Comma separated list of attributes to collect.
           * @param {Function} callback Callback function to execute once it has collected nodes.
           * @example
           * serializer.addAttributeFilter('src,href', (nodes, name) => {
           *   for (let i = 0; i < nodes.length; i++) {
           *     console.log(nodes[i].name);
           *   }
           * });
           */
          addAttributeFilter: o.addAttributeFilter,
          /**
           * Serializes the specified browser DOM node into a HTML string.
           *
           * @method serialize
           * @param {DOMNode} node DOM node to serialize.
           * @param {Object} args Arguments option that gets passed to event handlers.
           */
          serialize: o.serialize,
          /**
           * Adds valid elements rules to the serializers schema instance this enables you to specify things
           * like what elements should be outputted and what attributes specific elements might have.
           * Consult the TinyMCE Documentation for more details on this format.
           *
           * @method addRules
           * @param {String} rules Valid elements rules string to add to schema.
           */
          addRules: o.addRules,
          /**
           * Sets the valid elements rules to the serializers schema instance this enables you to specify things
           * like what elements should be outputted and what attributes specific elements might have.
           * Consult the TinyMCE Documentation for more details on this format.
           *
           * @method setRules
           * @param {String} rules Valid elements rules string.
           */
          setRules: o.setRules,
          /**
           * Adds a temporary internal attribute these attributes will get removed on undo and
           * when getting contents out of the editor.
           *
           * @method addTempAttr
           * @param {String} name string
           */
          addTempAttr: o.addTempAttr,
          /**
           * Returns an array of all added temp attrs names.
           *
           * @method getTempAttrs
           * @return {String[]} Array with attribute names.
           */
          getTempAttrs: o.getTempAttrs,
          getNodeFilters: o.getNodeFilters,
          getAttributeFilters: o.getAttributeFilters,
          /**
           * Removes a node filter function or removes all filter functions from the parser used by the serializer for the node names provided.
           *
           * @method removeNodeFilter
           * @param {String} name Comma separated list of node names to remove filters for.
           * @param {Function} callback Optional callback function to only remove a specific callback.
           * @example
           * // Remove a single filter
           * serializer.removeNodeFilter('p,h1', someCallback);
           *
           * // Remove all filters
           * serializer.removeNodeFilter('p,h1');
           */
          removeNodeFilter: o.removeNodeFilter,
          /**
           * Removes an attribute filter function or removes all filter functions from the parser used by the serializer for the attribute names provided.
           *
           * @method removeAttributeFilter
           * @param {String} name Comma separated list of attribute names to remove filters for.
           * @param {Function} callback Optional callback function to only remove a specific callback.
           * @example
           * // Remove a single filter
           * serializer.removeAttributeFilter('src,href', someCallback);
           *
           * // Remove all filters
           * serializer.removeAttributeFilter('src,href');
           */
          removeAttributeFilter: o.removeAttributeFilter
        };
      }, Mx = "html", zV = (e, t) => ({
        ...e,
        format: t,
        get: !0,
        getInner: !0
      }), VV = (e, t = {}) => {
        const o = t.format ? t.format : Mx, r = zV(t, o);
        return aB(e, r).fold(jo, (c) => {
          const u = vs(e, c);
          return Cx(e, u, c);
        });
      }, f6 = "html", g6 = (e, t) => ({
        format: f6,
        ...e,
        set: !0,
        content: t
      }), TO = (e, t, o = {}) => {
        const r = g6(o, t);
        xx(e, r).each((c) => {
          const u = NV(e, c.content, c);
          W_(e, u.html, c);
        });
      }, Px = lo.DOM, Rc = (e) => {
        Px.setStyle(e.id, "display", e.orgDisplay);
      }, VT = (e) => P.from(e).each((t) => t.destroy()), h6 = (e) => {
        const t = e;
        t.contentAreaContainer = t.formElement = t.container = t.editorContainer = null, t.bodyElement = t.contentDocument = t.contentWindow = null, t.iframeElement = t.targetElm = null;
        const o = e.selection;
        if (o) {
          const r = o.dom;
          t.selection = o.win = o.dom = r.doc = null;
        }
      }, kO = (e) => {
        const t = e.formElement;
        t && (t._mceOldSubmit && (t.submit = t._mceOldSubmit, delete t._mceOldSubmit), Px.unbind(t, "submit reset", e.formEventDelegate));
      }, AO = (e) => {
        if (!e.removed) {
          const { _selectionOverrides: t, editorUpload: o } = e, r = e.getBody(), c = e.getElement();
          r && e.save({ is_removing: !0 }), e.removed = !0, e.unbindAllNativeEvents(), e.hasHiddenInput && X(c?.nextSibling) && Px.remove(c.nextSibling), rC(e), e.editorManager.remove(e), !e.inline && r && Rc(e), Ow(e), Px.remove(e.getContainer()), VT(t), VT(o), e.destroy();
        }
      }, p6 = (e, t) => {
        const { selection: o, dom: r } = e;
        if (!e.destroyed) {
          if (!t && !e.removed) {
            e.remove();
            return;
          }
          t || (e.editorManager.off("beforeunload", e._beforeUnload), e.theme && e.theme.destroy && e.theme.destroy(), VT(o), VT(r)), kO(e), h6(e), e.destroyed = !0;
        }
      }, UT = (() => {
        const e = {};
        return {
          add: (c, u) => {
            e[c] = u;
          },
          get: (c) => e[c] ? e[c] : { icons: {} },
          has: (c) => kn(e, c)
        };
      })(), ny = Vr.ModelManager, _O = (e, t) => t.dom[e], OO = (e, t) => parseInt(Ls(t, e), 10), iu = ue(_O, "clientWidth"), jV = ue(_O, "clientHeight"), WV = ue(OO, "margin-top"), cX = ue(OO, "margin-left"), DO = (e) => e.dom.getBoundingClientRect(), ZV = (e, t, o) => {
        const r = iu(e), c = jV(e);
        return t >= 0 && o >= 0 && t <= r && o <= c;
      }, lX = (e, t, o, r) => {
        const c = DO(t), u = e ? c.left + t.dom.clientLeft + cX(t) : 0, f = e ? c.top + t.dom.clientTop + WV(t) : 0, b = o - u, v = r - f;
        return { x: b, y: v };
      }, GV = (e, t, o) => {
        const r = te.fromDom(e.getBody()), c = e.inline ? r : gr(r), u = lX(e.inline, c, t, o);
        return ZV(c, u.x, u.y);
      }, RO = (e) => P.from(e).map(te.fromDom), Wd = (e) => {
        const t = e.inline ? e.getBody() : e.getContentAreaContainer();
        return RO(t).map(Mo).getOr(!1);
      };
      var NO = () => {
        const e = () => {
          throw new Error("Theme did not provide a NotificationManager implementation.");
        };
        return {
          open: e,
          close: e,
          getArgs: e
        };
      };
      const Bx = (e) => {
        const t = [], o = () => {
          const M = e.theme;
          return M && M.getNotificationManagerImpl ? M.getNotificationManagerImpl() : NO();
        }, r = () => P.from(t[0]), c = (M, H) => M.type === H.type && M.text === H.text && !M.progressBar && !M.timeout && !H.progressBar && !H.timeout, u = () => {
          r().each((M) => {
            M.reposition();
          });
        }, f = (M) => {
          t.push(M);
        }, b = (M) => {
          Ql(t, (H) => H === M).each((H) => {
            t.splice(H, 1);
          });
        }, v = (M, H = !0) => e.removed || !Wd(e) ? {} : (H && e.dispatch("BeforeOpenNotification", { notification: M }), _o(t, (J) => c(o().getArgs(J), M)).getOrThunk(() => {
          e.editorManager.setActive(e);
          const J = o().open(M, () => {
            b(J);
          }, () => N5(e));
          return f(J), u(), e.dispatch("OpenNotification", { notification: { ...J } }), J;
        })), S = () => {
          r().each((M) => {
            o().close(M), b(M), u();
          });
        }, O = ot(t);
        return ((M) => {
          M.on("SkinLoaded", () => {
            const H = bC(M);
            H && v({
              text: H,
              type: "warning",
              timeout: 0
            }, !1), u();
          }), M.on("show ResizeEditor ResizeWindow NodeChange ToggleView FullscreenStateChanged", () => {
            requestAnimationFrame(u);
          }), M.on("remove", () => {
            xe(t.slice(), (H) => {
              o().close(H);
            });
          }), M.on("keydown", (H) => {
            const J = H.key?.toLowerCase() === "f12" || H.keyCode === 123;
            H.altKey && J && (H.preventDefault(), r().map((W) => te.fromDom(W.getEl())).each((W) => cg(W)));
          });
        })(e), {
          /**
           * Opens a new notification.
           *
           * @method open
           * @param {Object} args A <code>name: value</code> collection containing settings such as: <code>timeout</code>, <code>type</code>, and message (<code>text</code>).
           * <br /><br />
           * For information on the available settings, see: <a href="https://www.tiny.cloud/docs/tinymce/8/creating-custom-notifications/">Create custom notifications</a>.
           */
          open: v,
          /**
           * Closes the top most notification.
           *
           * @method close
           */
          close: S,
          /**
           * Returns the currently opened notification objects.
           *
           * @method getNotifications
           * @return {Array} Array of the currently opened notifications.
           */
          getNotifications: O
        };
      }, wp = Vr.PluginManager, xb = Vr.ThemeManager;
      var MO = () => {
        const e = () => {
          throw new Error("Theme did not provide a WindowManager implementation.");
        };
        return {
          open: e,
          openUrl: e,
          alert: e,
          confirm: e,
          close: e
        };
      };
      const b6 = (e) => {
        let t = [];
        const o = () => {
          const Q = e.theme;
          return Q && Q.getWindowManagerImpl ? Q.getWindowManagerImpl() : MO();
        }, r = (Q, ge) => (...be) => ge ? ge.apply(Q, be) : void 0, c = (Q) => {
          e.dispatch("OpenWindow", {
            dialog: Q
          });
        }, u = (Q) => {
          e.dispatch("CloseWindow", {
            dialog: Q
          });
        }, f = (Q, ge) => {
          t.push({ instanceApi: Q, triggerElement: ge }), c(Q);
        }, b = (Q) => {
          u(Q);
          const ge = cc(t, ({ instanceApi: be, triggerElement: ve }) => be === Q ? ve : P.none());
          t = ze(t, ({ instanceApi: be }) => be !== Q), t.length === 0 ? e.focus() : ge.filter(Mo).each(cg);
        }, v = () => P.from(t[t.length - 1]), S = (Q) => {
          e.editorManager.setActive(e), $E(e);
          const ge = $l();
          e.ui.show();
          const be = Q();
          return f(be, ge), be;
        }, O = (Q, ge) => S(() => o().open(Q, ge, b)), R = (Q) => S(() => o().openUrl(Q, b)), M = (Q) => {
          t.length !== 0 && Q.each((ge) => cg(ge));
        }, H = (Q, ge, be) => {
          const ve = $l(), Be = o();
          Be.alert(Q, r(be || Be, () => {
            M(ve), ge?.();
          }));
        }, J = (Q, ge, be) => {
          const ve = $l(), Be = o();
          Be.confirm(Q, r(be || Be, (je) => {
            M(ve), ge?.(je);
          }));
        }, W = () => {
          v().each(({ instanceApi: Q }) => {
            o().close(Q), b(Q);
          });
        };
        return e.on("remove", () => {
          xe(t, ({ instanceApi: Q }) => {
            o().close(Q);
          });
        }), {
          /**
           * Opens a new window.
           *
           * @method open
           * @param {Object} config For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/8/dialog-configuration/#options">Dialog - Configuration options</a>.
           * @param {Object} params (Optional) For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/8/dialog-configuration/#configuration-parameters">Dialog - Configuration parameters</a>.
           * @returns {WindowManager.DialogInstanceApi} A new dialog instance.
           */
          open: O,
          /**
           * Opens a new window for the specified url.
           *
           * @method openUrl
           * @param {Object} config For information on the available options, see: <a href="https://www.tiny.cloud/docs/tinymce/8/urldialog/#configuration">URL dialog - Configuration</a>.
           * @returns {WindowManager.UrlDialogInstanceApi} A new URL dialog instance.
           */
          openUrl: R,
          /**
           * Creates an alert dialog. Do not use the blocking behavior of this
           * native version. Use the callback method instead; then it can be extended.
           *
           * @method alert
           * @param {String} message Text to display in the new alert dialog.
           * @param {Function} callback (Optional) Callback function to be executed after the user has selected ok.
           * @param {Object} scope (Optional) Scope to execute the callback in.
           * @example
           * // Displays an alert box using the active editors window manager instance
           * tinymce.activeEditor.windowManager.alert('Hello world!');
           */
          alert: H,
          /**
           * Creates an alert dialog. Do not use the blocking behavior of this
           * native version. Use the callback method instead; then it can be extended.
           *
           * @method confirm
           * @param {String} message Text to display in the new confirm dialog.
           * @param {Function} callback (Optional) Callback function to be executed after the user has selected ok or cancel.
           * @param {Object} scope (Optional) Scope to execute the callback in.
           * @example
           * // Displays a confirm box and an alert message will be displayed depending on what you choose in the confirm
           * tinymce.activeEditor.windowManager.confirm('Do you want to do something?', (state) => {
           *   const message = state ? 'Ok' : 'Cancel';
           *   tinymce.activeEditor.windowManager.alert(message);
           * });
           */
          confirm: J,
          /**
           * Closes the top most window.
           *
           * @method close
           */
          close: W
        };
      }, PO = (e, t) => {
        e.notificationManager.open({
          type: "error",
          text: t
        });
      }, jT = (e, t) => {
        e._skinLoaded ? PO(e, t) : e.on("SkinLoaded", () => {
          PO(e, t);
        });
      }, qV = (e, t) => {
        jT(e, pl.translate(["Failed to upload image: {0}", t]));
      }, Qg = (e, t, o) => {
        nv(e, t, { message: o }), console.error(o);
      }, Sb = (e, t, o) => o ? `Failed to load ${e}: ${o} from url ${t}` : `Failed to load ${e} url: ${t}`, v6 = (e, t, o) => {
        Qg(e, "PluginLoadError", Sb("plugin", t, o));
      }, KV = (e, t, o) => {
        Qg(e, "IconsLoadError", Sb("icons", t, o));
      }, wb = (e, t, o) => {
        Qg(e, "LanguageLoadError", Sb("language", t, o));
      }, y6 = (e, t, o) => {
        Qg(e, "ThemeLoadError", Sb("theme", t, o));
      }, YV = (e, t, o) => {
        Qg(e, "ModelLoadError", Sb("model", t, o));
      }, C6 = (e, t) => {
        Qg(e, "LicenseKeyManagerLoadError", Sb("license key manager", t));
      }, XV = (e, t) => {
        Qg(e, "ComponentLoadError", Sb("component", t));
      }, QV = (e, t, o) => {
        const r = pl.translate(["Failed to initialize plugin: {0}", t]);
        nv(e, "PluginLoadError", { message: r }), WT(r, o), jT(e, r);
      }, WT = (e, ...t) => {
        const o = window.console;
        o && (o.error ? o.error(e, ...t) : o.log(e, ...t));
      }, x6 = /* @__PURE__ */ new WeakMap(), JV = (e) => {
        if (x6.has(e))
          return;
        x6.set(e, !0);
        const t = () => {
          e.on("SwitchMode", (r) => {
            const { mode: c } = r;
            c !== "readonly" && e.mode.set("readonly");
          });
        }, o = () => {
          e.on("DisabledStateChange", (r) => {
            const { state: c } = r;
            c || r.preventDefault();
          }, !0);
        };
        e.initialized ? (e.removed || e.mode.set("readonly"), e.options.set("disabled", !0)) : e.on("init", () => {
          e.removed || e.mode.set("readonly"), e.options.set("disabled", !0);
        }), o(), t();
      }, BO = (e, t) => {
        const { type: o, message: r } = t;
        e.notificationManager.open({
          type: o,
          text: r
        });
      }, eU = (e) => {
        switch (e) {
          case "error":
            return console.error;
          case "info":
            return console.info;
          case "warn":
            return console.warn;
          case "log":
          default:
            return console.log;
        }
      }, $O = (e) => {
        eU(e.type)(e.message);
      }, Lf = (e, t) => {
        const { console: o, editor: r } = t;
        X(r) && (e._skinLoaded ? BO(e, r) : e.on("SkinLoaded", () => {
          BO(e, r);
        })), X(o) && $O(o);
      }, IO = "Read more: https://www.tiny.cloud/docs/tinymce/latest/license-key/", $x = "Make sure to provide a valid license key or add license_key: 'gpl' to the init config to agree to the open source license terms.", S6 = (e) => {
        const t = "The editor is disabled because a TinyMCE license key has not been provided.";
        Lf(e, {
          console: {
            type: "error",
            message: [
              `${t}`,
              $x,
              IO
            ].join(" ")
          },
          editor: {
            type: "warning",
            message: `${t}`
          }
        });
      }, w6 = (e, t) => {
        const o = `${t === "online" ? "API" : "license"} key`, r = `The editor is disabled because the TinyMCE ${o} could not be validated.`;
        Lf(e, {
          console: {
            type: "error",
            message: [
              `${r}`,
              `The TinyMCE Commercial License Key Manager plugin is required for the provided ${o} to be validated but could not be loaded.`,
              IO
            ].join(" ")
          },
          editor: {
            type: "warning",
            message: `${r}`
          }
        });
      }, E6 = (e, t, o) => {
        const r = `The "${t}" plugin requires a valid TinyMCE license key.`;
        Lf(e, {
          console: {
            type: "error",
            message: [
              `${r}`,
              IO
            ].join(" ")
          },
          ...o ? {} : {
            editor: {
              type: "warning",
              message: "One or more premium plugins are disabled due to license key restrictions."
            }
          }
        });
      }, Ix = "licensekeymanager", T6 = (e) => U(eb(e)) ? "online" : "offline", tU = (e) => {
        const t = uE(e)?.toLowerCase();
        return t === "gpl" ? "gpl" : jt(t) ? "no_key" : "non_gpl";
      }, FO = (e) => {
        const t = T6(e), o = tU(e), r = (/* @__PURE__ */ new Set([
          ...K1(e),
          ...Vt(CC(e))
        ])).has(Ix);
        return o !== "gpl" || t === "online" || r ? {
          type: "use_plugin",
          onlineStatus: t,
          licenseKeyType: o,
          forcePlugin: r
        } : {
          type: "use_gpl",
          onlineStatus: t,
          licenseKeyType: o,
          forcePlugin: r
        };
      }, k6 = (e) => (t) => {
        let o = !1;
        return {
          validate: (r) => {
            const { plugin: c } = r, u = U(c);
            return u && (E6(t, c, o), o = !0), Promise.resolve(e && !u);
          }
        };
      }, nU = k6(!1), ZT = k6(!0), Fx = "manager", LO = Ix, zO = (() => {
        const e = Vr();
        return {
          load: (c, u) => {
            if (FO(c).type === "use_plugin") {
              const v = Wo(CC(c), LO).map(_s).filter(ms).getOr(`plugins/${LO}/plugin${u}.js`);
              e.load(Fx, v).catch(() => {
                C6(c, v);
              });
            }
          },
          add: (c) => {
            e.add(Fx, c);
          },
          init: (c) => {
            const u = (v) => {
              Object.defineProperty(c, "licenseKeyManager", {
                value: v,
                writable: !1,
                configurable: !1,
                enumerable: !0
              });
            }, f = FO(c), b = e.get(Fx);
            if (X(b)) {
              const v = b(c, e.urls[Fx]);
              u(v);
            } else
              switch (f.type) {
                case "use_gpl": {
                  u(ZT(c));
                  break;
                }
                case "use_plugin": {
                  JV(c), u(nU(c)), f.onlineStatus === "offline" && f.licenseKeyType === "no_key" ? S6(c) : w6(c, f.onlineStatus);
                  break;
                }
              }
            c.licenseKeyManager.validate({});
          }
        };
      })(), oU = (e) => {
        P.from(e.selection.getNode()).each((t) => {
          t.removeAttribute("data-mce-selected");
        });
      }, VO = (e, t, o) => {
        try {
          e.getDoc().execCommand(t, !1, String(o));
        } catch {
        }
      }, A6 = (e, t) => {
        VO(e, "StyleWithCSS", t), VO(e, "enableInlineTableEditing", t), VO(e, "enableObjectResizing", t);
      }, UO = (e) => {
        e.selection.setRng(e.selection.getRng());
      }, _6 = (e, t, o) => {
        yh(e, t) && !o ? cr(e, t) : o && bc(e, t);
      }, jO = (e) => {
        const t = te.fromDom(e.getBody());
        _6(t, "mce-content-readonly", !0), e.selection.controlSelection.hideResizeRect(), e._selectionOverrides.hideFakeCaret(), oU(e);
      }, O6 = (e) => {
        const t = te.fromDom(e.getBody());
        _6(t, "mce-content-readonly", !1), e.hasEditableRoot() && w(t, !0), A6(e, !1), N5(e) && e.focus(), UO(e), e.nodeChanged();
      }, Jg = (e) => ou(e), Eb = "data-mce-contenteditable", Lx = (e) => {
        xe(Ne(e, '*[contenteditable="true"]'), (t) => {
          Ss(t, Eb, "true"), w(t, !1);
        });
      }, Im = (e) => {
        xe(Ne(e, `*[${Eb}="true"]`), (t) => {
          sr(t, Eb), w(t, !0);
        });
      }, D6 = (e, t) => {
        const o = te.fromDom(e.getBody());
        t ? (jO(e), w(o, !1), Lx(o)) : (Im(o), O6(e));
      }, WO = (e) => {
        e.serializer ? tr(e) : e.on("PreInit", () => {
          tr(e);
        });
      }, tr = (e) => {
        e.parser.addAttributeFilter("contenteditable", (t) => {
          Jg(e) && xe(t, (o) => {
            o.attr(Eb, o.attr("contenteditable")), o.attr("contenteditable", "false");
          });
        }), e.serializer.addAttributeFilter(Eb, (t) => {
          Jg(e) && xe(t, (o) => {
            o.attr("contenteditable", o.attr(Eb));
          });
        }), e.serializer.addTempAttr(Eb);
      }, ZO = (e) => e.type === "click", GT = ["copy"], eh = (e) => Lt(GT, e.type), R6 = (e, t) => ia(t, "a", (r) => Qn(r, te.fromDom(e.getBody()))).bind((r) => il(r, "href")), GO = (e, t) => ws(t, "details", (r) => Qn(r, te.fromDom(e.getBody()))), sU = (e, t) => {
        if (ZO(t) && !Et.metaKeyPressed(t)) {
          const o = te.fromDom(t.target);
          R6(e, o).fold(() => {
            GO(e, o) && t.preventDefault();
          }, (r) => {
            if (t.preventDefault(), /^#/.test(r)) {
              const c = e.dom.select(`${r},[name="${Zm(r, "#")}"]`);
              c.length && e.selection.scrollIntoView(c[0], !0);
            } else
              window.open(r, "_blank", "rel=noopener noreferrer,menubar=yes,toolbar=yes,location=yes,status=yes,resizable=yes,scrollbars=yes");
          });
        } else eh(t) && e.dispatch(t.type, t);
      }, oy = (e) => {
        e.on("ShowCaret ObjectSelected", (t) => {
          Jg(e) && t.preventDefault();
        }), e.on("DisabledStateChange", (t) => {
          t.isDefaultPrevented() || D6(e, t.state);
        });
      }, rU = (e) => {
        WO(e), oy(e);
      }, aU = (e) => /^[a-z0-9\-]+$/i.test(e), Ep = (e) => "content/" + e + "/content.css", cU = (e) => tinymce.Resource.has(Ep(e)), Tb = (e) => th(e, Tk(e)), lU = (e) => th(e, hC(e)), th = (e, t) => {
        const o = e.editorManager.baseURL + "/skins/content", c = `content${e.editorManager.suffix}.css`;
        return en(t, (u) => cU(u) ? u : aU(u) && !e.inline ? `${o}/${u}/${c}` : e.documentBaseURI.toAbsolute(u));
      }, iU = (e) => {
        e.contentCSS = e.contentCSS.concat(Tb(e), lU(e));
      }, Ku = (e) => e ? rs(e.getElementsByTagName("img")) : [], kb = (e, t) => {
        const o = {};
        return {
          findAll: (c, u = He) => {
            const f = ze(Ku(c), (v) => {
              const S = v.src;
              return v.hasAttribute("data-mce-bogus") || v.hasAttribute("data-mce-placeholder") || !S || S === fo.transparentSrc ? !1 : hn(S, "blob:") ? !e.isUploaded(S) && u(v) : hn(S, "data:") ? u(v) : !1;
            }), b = en(f, (v) => {
              const S = v.src;
              if (kn(o, S))
                return o[S].then((O) => U(O) ? O : {
                  image: v,
                  blobInfo: O.blobInfo
                });
              {
                const O = __(t, S).then((R) => (delete o[S], { image: v, blobInfo: R })).catch((R) => (delete o[S], R));
                return o[S] = O, O;
              }
            });
            return Promise.all(b);
          }
        };
      }, N6 = () => {
        let o = {};
        const r = (M, H) => ({
          status: M,
          resultUri: H
        }), c = (M) => M in o;
        return {
          hasBlobUri: c,
          getResultUri: (M) => {
            const H = o[M];
            return H ? H.resultUri : null;
          },
          isPending: (M) => c(M) ? o[M].status === 1 : !1,
          isUploaded: (M) => c(M) ? o[M].status === 2 : !1,
          markPending: (M) => {
            o[M] = r(1, null);
          },
          markUploaded: (M, H) => {
            o[M] = r(2, H);
          },
          removeFailed: (M) => {
            delete o[M];
          },
          destroy: () => {
            o = {};
          }
        };
      };
      let Hx = 0;
      const qO = () => {
        const e = () => Math.round(Jl() * 4294967295).toString(36);
        return "s" + (/* @__PURE__ */ new Date()).getTime().toString(36) + e() + e() + e();
      }, uU = (e) => e + Hx++ + qO(), sy = () => {
        let e = [];
        const t = (R) => ({
          "image/jpeg": "jpg",
          "image/jpg": "jpg",
          "image/gif": "gif",
          "image/png": "png",
          "image/apng": "apng",
          "image/avif": "avif",
          "image/svg+xml": "svg",
          "image/webp": "webp",
          "image/bmp": "bmp",
          "image/tiff": "tiff"
        })[R.toLowerCase()] || "dat", o = (R, M, H, J, W) => {
          if (U(R))
            return r({
              id: R,
              name: J,
              filename: W,
              blob: M,
              base64: H
            });
          if (Ye(R))
            return r(R);
          throw new Error("Unknown input type");
        }, r = (R) => {
          if (!R.blob || !R.base64)
            throw new Error("blob and base64 representations of the image are required for BlobInfo to be created");
          const M = R.id || uU("blobid"), H = R.name || M, J = R.blob;
          return {
            id: ot(M),
            name: ot(H),
            filename: ot(R.filename || H + "." + t(J.type)),
            blob: ot(J),
            base64: ot(R.base64),
            blobUri: ot(R.blobUri || URL.createObjectURL(J)),
            uri: ot(R.uri)
          };
        }, c = (R) => {
          f(R.id()) || e.push(R);
        }, u = (R) => _o(e, R).getOrUndefined(), f = (R) => u((M) => M.id() === R);
        return {
          create: o,
          add: c,
          get: f,
          getByUri: (R) => u((M) => M.blobUri() === R),
          getByData: (R, M) => u((H) => H.base64() === R && H.blob().type === M),
          findFirst: u,
          removeByUri: (R) => {
            e = ze(e, (M) => M.blobUri() === R ? (URL.revokeObjectURL(M.blobUri()), !1) : !0);
          },
          destroy: () => {
            xe(e, (R) => {
              URL.revokeObjectURL(R.blobUri());
            }), e = [];
          }
        };
      }, dU = (e, t) => {
        const o = {}, r = (W, Q) => W ? W.replace(/\/$/, "") + "/" + Q.replace(/^\//, "") : Q, c = (W, Q) => new Promise((ge, be) => {
          const ve = new XMLHttpRequest();
          ve.open("POST", t.url), ve.withCredentials = t.credentials, ve.upload.onprogress = (je) => {
            Q(je.loaded / je.total * 100);
          }, ve.onerror = () => {
            be("Image upload failed due to a XHR Transport error. Code: " + ve.status);
          }, ve.onload = () => {
            if (ve.status < 200 || ve.status >= 300) {
              be("HTTP Error: " + ve.status);
              return;
            }
            const je = JSON.parse(ve.responseText);
            if (!je || !U(je.location)) {
              be("Invalid JSON: " + ve.responseText);
              return;
            }
            ge(r(t.basePath, je.location));
          };
          const Be = new FormData();
          Be.append("file", W.blob(), W.filename()), ve.send(Be);
        }), u = se(t.handler) ? t.handler : c, f = () => new Promise((W) => {
          W([]);
        }), b = (W, Q) => ({
          url: Q,
          blobInfo: W,
          status: !0
        }), v = (W, Q) => ({
          url: "",
          blobInfo: W,
          status: !1,
          error: Q
        }), S = (W, Q) => {
          Je.each(o[W], (ge) => {
            ge(Q);
          }), delete o[W];
        }, O = (W, Q, ge) => (e.markPending(W.blobUri()), new Promise((be) => {
          let ve, Be;
          try {
            const je = () => {
              ve && (ve.close(), Be = St);
            }, xt = (Me) => {
              je();
              const Te = U(Me) ? Me : Me.url;
              e.markUploaded(W.blobUri(), Te), S(W.blobUri(), b(W, Te)), be(b(W, Te));
            }, Kt = (Me) => {
              je(), e.removeFailed(W.blobUri()), S(W.blobUri(), v(W, Me)), be(v(W, Me));
            };
            Be = (Me) => {
              Me < 0 || Me > 100 || P.from(ve).orThunk(() => P.from(ge).map(fn)).each((Te) => {
                ve = Te, Te.progressBar.value(Me);
              });
            }, Q(W, Be).then(xt, (Me) => {
              Kt(U(Me) ? { message: Me } : Me);
            });
          } catch (je) {
            be(v(W, je));
          }
        })), R = (W) => W === c, M = (W) => {
          const Q = W.blobUri();
          return new Promise((ge) => {
            o[Q] = o[Q] || [], o[Q].push(ge);
          });
        }, H = (W, Q) => (W = Je.grep(W, (ge) => !e.isUploaded(ge.blobUri())), Promise.all(Je.map(W, (ge) => e.isPending(ge.blobUri()) ? M(ge) : O(ge, u, Q))));
        return {
          upload: (W, Q) => !t.url && R(u) ? f() : H(W, Q)
        };
      }, Yu = (e) => () => e.notificationManager.open({
        text: e.translate("Image uploading..."),
        type: "info",
        timeout: -1,
        progressBar: !0
      }), zx = (e, t) => dU(t, {
        url: uv(e),
        basePath: gC(e),
        credentials: wk(e),
        handler: Kw(e)
      }), M6 = (e) => {
        const t = N6(), o = zx(e, t);
        return {
          /**
           * Uploads images to the configured image upload URL (`images_upload_url`) or passes the images to the defined image upload handler function (`images_upload_handler`).
           *
           * @method upload
           * @param {Array} blobInfos  A BlobInfo array containing the image data to upload. A BlobInfo can be created by calling `editor.editorUpload.blobCache.create()`.
           * @param {Boolean} showNotification (Optional) When set to true, a notification with a progress bar will be shown during image uploads.
           */
          upload: (r, c = !0) => o.upload(r, c ? Yu(e) : void 0)
        };
      }, KO = (e, t) => e.dom.isEmpty(t.dom) && X(e.schema.getTextBlockElements()[Hn(t)]), YO = (e) => (t) => {
        KO(e, t) && bo(t, te.fromHtml('<br data-mce-bogus="1" />'));
      }, Ab = (e) => {
        const t = sy();
        let o, r;
        const c = N6(), u = [], f = (ve) => (Be) => e.selection ? ve(Be) : [], b = (ve) => ve + (ve.indexOf("?") === -1 ? "?" : "&") + (/* @__PURE__ */ new Date()).getTime(), v = (ve, Be, je) => {
          let xt = 0;
          do
            xt = ve.indexOf(Be, xt), xt !== -1 && (ve = ve.substring(0, xt) + je + ve.substr(xt + Be.length), xt += je.length - Be.length + 1);
          while (xt !== -1);
          return ve;
        }, S = (ve, Be, je) => {
          const xt = `src="${je}"${je === fo.transparentSrc ? ' data-mce-placeholder="1"' : ""}`;
          return ve = v(ve, `src="${Be}"`, xt), ve = v(ve, 'data-mce-src="' + Be + '"', 'data-mce-src="' + je + '"'), ve;
        }, O = (ve, Be) => {
          xe(e.undoManager.data, (je) => {
            je.type === "fragmented" ? je.fragments = en(je.fragments, (xt) => S(xt, ve, Be)) : je.content = S(je.content, ve, Be);
          });
        }, R = (ve, Be) => {
          const je = e.convertURL(Be, "src");
          O(ve.src, Be), ea(te.fromDom(ve), {
            src: Gw(e) ? b(Be) : Be,
            "data-mce-src": je
          });
        }, M = () => (o || (o = zx(e, c)), Q().then(f((ve) => {
          const Be = en(ve, (je) => je.blobInfo);
          return o.upload(Be, Yu(e)).then(f((je) => {
            const xt = [];
            let Kt = !1;
            const Me = en(je, (Te, $e) => {
              const { blobInfo: yt, image: Sn } = ve[$e];
              let wn = !1;
              return Te.status && qw(e) ? (Te.url && !As(Sn.src, Te.url) && (Kt = !0), t.removeByUri(Sn.src), Bm(e) || R(Sn, Te.url)) : Te.error && (Te.error.remove && (O(Sn.src, fo.transparentSrc), xt.push(Sn), wn = !0), qV(e, Te.error.message)), {
                element: Sn,
                status: Te.status,
                uploadUri: Te.url,
                blobInfo: yt,
                removed: wn
              };
            });
            return xt.length > 0 && !Bm(e) ? e.undoManager.transact(() => {
              xe(pd(xt), (Te) => {
                const $e = ec(Te);
                qo(Te), $e.each(YO(e)), t.removeByUri(Te.dom.src);
              });
            }) : Kt && e.undoManager.dispatchChange(), Me;
          }));
        }))), H = () => mC(e) ? M() : Promise.resolve([]), J = (ve) => qa(u, (Be) => Be(ve)), W = (ve) => {
          u.push(ve);
        }, Q = () => (r || (r = kb(c, t)), r.findAll(e.getBody(), J).then(f((ve) => {
          const Be = ze(ve, (je) => U(je) ? (jT(e, je), !1) : je.uriType !== "blob");
          return Bm(e) || xe(Be, (je) => {
            O(je.image.src, je.blobInfo.blobUri()), je.image.src = je.blobInfo.blobUri(), je.image.removeAttribute("data-mce-src");
          }), Be;
        }))), ge = () => {
          t.destroy(), c.destroy(), r = o = null;
        }, be = (ve) => ve.replace(/src="(blob:[^"]+)"/g, (Be, je) => {
          const xt = c.getResultUri(je);
          if (xt)
            return 'src="' + xt + '"';
          let Kt = t.getByUri(je);
          return Kt || (Kt = Io(e.editorManager.get(), (Me, Te) => Me || Te.editorUpload && Te.editorUpload.blobCache.getByUri(je), void 0)), Kt ? 'src="data:' + Kt.blob().type + ";base64," + Kt.base64() + '"' : Be;
        });
        return e.on("SetContent", () => {
          mC(e) ? H() : Q();
        }), e.on("RawSaveContent", (ve) => {
          ve.content = be(ve.content);
        }), e.on("GetContent", (ve) => {
          ve.source_view || ve.format === "raw" || ve.format === "tree" || (ve.content = be(ve.content));
        }), e.on("PostRender", () => {
          e.parser.addNodeFilter("img", (ve) => {
            xe(ve, (Be) => {
              const je = Be.attr("src");
              if (!je || t.getByUri(je))
                return;
              const xt = c.getResultUri(je);
              xt && Be.attr("src", xt);
            });
          });
        }), {
          blobCache: t,
          addFilter: W,
          uploadImages: M,
          uploadImagesAuto: H,
          scanForImages: Q,
          destroy: ge
        };
      }, XO = (e) => {
        const t = e.dom, o = e.schema.type, r = {
          valigntop: [
            { selector: "td,th", styles: { verticalAlign: "top" } }
          ],
          valignmiddle: [
            { selector: "td,th", styles: { verticalAlign: "middle" } }
          ],
          valignbottom: [
            { selector: "td,th", styles: { verticalAlign: "bottom" } }
          ],
          alignleft: [
            {
              selector: "figure.image",
              collapsed: !1,
              classes: "align-left",
              ceFalseOverride: !0,
              preview: "font-family font-size"
            },
            {
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: {
                textAlign: "left"
              },
              inherit: !1,
              preview: !1
            },
            {
              selector: "img,audio,video",
              collapsed: !1,
              styles: {
                float: "left"
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-placeholder",
              styles: {
                float: "left"
              },
              ceFalseOverride: !0
            },
            {
              selector: "table",
              collapsed: !1,
              styles: {
                marginLeft: "0px",
                marginRight: "auto"
              },
              onformat: (c) => {
                t.setStyle(c, "float", null);
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-preview-object,[data-ephox-embed-iri]",
              ceFalseOverride: !0,
              styles: {
                float: "left"
              }
            }
          ],
          aligncenter: [
            {
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: {
                textAlign: "center"
              },
              inherit: !1,
              preview: "font-family font-size"
            },
            {
              selector: "figure.image",
              collapsed: !1,
              classes: "align-center",
              ceFalseOverride: !0,
              preview: "font-family font-size"
            },
            {
              selector: "img,audio,video",
              collapsed: !1,
              styles: {
                display: "block",
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: !1
            },
            {
              selector: ".mce-placeholder",
              styles: {
                display: "block",
                marginLeft: "auto",
                marginRight: "auto"
              },
              ceFalseOverride: !0
            },
            {
              selector: "table",
              collapsed: !1,
              styles: {
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-preview-object",
              ceFalseOverride: !0,
              styles: {
                display: "table",
                // Needs to be `table` to properly render while editing
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: !1
            },
            {
              selector: "[data-ephox-embed-iri]",
              ceFalseOverride: !0,
              styles: {
                marginLeft: "auto",
                marginRight: "auto"
              },
              preview: !1
            }
          ],
          alignright: [
            {
              selector: "figure.image",
              collapsed: !1,
              classes: "align-right",
              ceFalseOverride: !0,
              preview: "font-family font-size"
            },
            {
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: {
                textAlign: "right"
              },
              inherit: !1,
              preview: "font-family font-size"
            },
            {
              selector: "img,audio,video",
              collapsed: !1,
              styles: {
                float: "right"
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-placeholder",
              styles: {
                float: "right"
              },
              ceFalseOverride: !0
            },
            {
              selector: "table",
              collapsed: !1,
              styles: {
                marginRight: "0px",
                marginLeft: "auto"
              },
              onformat: (c) => {
                t.setStyle(c, "float", null);
              },
              preview: "font-family font-size"
            },
            {
              selector: ".mce-preview-object,[data-ephox-embed-iri]",
              ceFalseOverride: !0,
              styles: {
                float: "right"
              },
              preview: !1
            }
          ],
          alignjustify: [
            {
              selector: "figure,p,h1,h2,h3,h4,h5,h6,td,th,tr,div,ul,ol,li,pre",
              styles: {
                textAlign: "justify"
              },
              inherit: !1,
              preview: "font-family font-size"
            }
          ],
          bold: [
            { inline: "strong", remove: "all", preserve_attributes: ["class", "style"] },
            { inline: "span", styles: { fontWeight: "bold" } },
            { inline: "b", remove: "all", preserve_attributes: ["class", "style"] }
          ],
          italic: [
            { inline: "em", remove: "all", preserve_attributes: ["class", "style"] },
            { inline: "span", styles: { fontStyle: "italic" } },
            { inline: "i", remove: "all", preserve_attributes: ["class", "style"] }
          ],
          underline: [
            { inline: "span", styles: { textDecoration: "underline" }, exact: !0 },
            { inline: "u", remove: "all", preserve_attributes: ["class", "style"] }
          ],
          strikethrough: /* @__PURE__ */ (() => {
            const c = { inline: "span", styles: { textDecoration: "line-through" }, exact: !0 }, u = { inline: "strike", remove: "all", preserve_attributes: ["class", "style"] }, f = { inline: "s", remove: "all", preserve_attributes: ["class", "style"] };
            return o !== "html4" ? [f, c, u] : [c, f, u];
          })(),
          forecolor: { inline: "span", styles: { color: "%value" }, links: !0, remove_similar: !0, clear_child_styles: !0 },
          hilitecolor: { inline: "span", styles: { backgroundColor: "%value" }, links: !0, remove_similar: !0, clear_child_styles: !0 },
          fontname: { inline: "span", toggle: !1, styles: { fontFamily: "%value" }, clear_child_styles: !0 },
          fontsize: { inline: "span", toggle: !1, styles: { fontSize: "%value" }, clear_child_styles: !0 },
          lineheight: { selector: "h1,h2,h3,h4,h5,h6,p,li,td,th,div", styles: { lineHeight: "%value" }, remove_similar: !0 },
          fontsize_class: { inline: "span", attributes: { class: "%value" } },
          blockquote: { block: "blockquote", wrapper: !0, remove: "all" },
          subscript: { inline: "sub" },
          superscript: { inline: "sup" },
          code: { inline: "code" },
          samp: { inline: "samp" },
          link: {
            inline: "a",
            selector: "a",
            remove: "all",
            split: !0,
            deep: !0,
            onmatch: (c, u, f) => ht(c) && c.hasAttribute("href"),
            onformat: (c, u, f) => {
              Je.each(f, (b, v) => {
                t.setAttrib(c, v, b);
              });
            }
          },
          lang: {
            inline: "span",
            clear_child_styles: !0,
            remove_similar: !0,
            attributes: {
              lang: "%value",
              "data-mce-lang": (c) => c?.customValue ?? null
            }
          },
          removeformat: [
            {
              selector: "b,strong,em,i,font,u,strike,s,sub,sup,dfn,code,samp,kbd,var,cite,mark,q,del,ins,small",
              remove: "all",
              split: !0,
              expand: !1,
              block_expand: !0,
              deep: !0
            },
            { selector: "span", attributes: ["style", "class"], remove: "empty", split: !0, expand: !1, deep: !0 },
            { selector: "*", attributes: ["style", "class"], split: !1, expand: !1, deep: !0 }
          ]
        };
        return Je.each("p h1 h2 h3 h4 h5 h6 div address pre dt dd".split(/\s/), (c) => {
          r[c] = { block: c, remove: "all" };
        }), r;
      }, P6 = {
        remove_similar: !0,
        inherit: !1
      }, ry = {
        selector: "td,th",
        ...P6
      }, mU = {
        tablecellbackgroundcolor: {
          styles: { backgroundColor: "%value" },
          ...ry
        },
        tablecellverticalalign: {
          styles: {
            "vertical-align": "%value"
          },
          ...ry
        },
        tablecellbordercolor: {
          styles: { borderColor: "%value" },
          ...ry
        },
        tablecellclass: {
          classes: ["%value"],
          ...ry
        },
        tableclass: {
          selector: "table",
          classes: ["%value"],
          ...P6
        },
        tablecellborderstyle: {
          styles: { borderStyle: "%value" },
          ...ry
        },
        tablecellborderwidth: {
          styles: { borderWidth: "%value" },
          ...ry
        }
      }, fU = ot(mU), gU = (e) => {
        const t = {}, o = (f) => X(f) ? t[f] : t, r = (f) => kn(t, f), c = (f, b) => {
          f && (U(f) ? (Ot(b) || (b = [b]), xe(b, (v) => {
            Gn(v.deep) && (v.deep = !Md(v)), Gn(v.split) && (v.split = !Md(v) || Va(v)), Gn(v.remove) && Md(v) && !Va(v) && (v.remove = "none"), Md(v) && Va(v) && (v.mixed = !0, v.block_expand = !0), U(v.classes) && (v.classes = v.classes.split(/\s+/));
          }), t[f] = b) : Un(f, (v, S) => {
            c(S, v);
          }));
        }, u = (f) => (f && t[f] && delete t[f], t);
        return c(XO(e)), c(fU()), c(Dk(e)), {
          get: o,
          has: r,
          register: c,
          unregister: u
        };
      }, qT = Je.each, Xc = lo.DOM, Xu = (e) => X(e) && Ye(e), B6 = (e, t) => {
        const o = t && t.schema || wa({}), r = (v, S) => {
          S.classes.length > 0 && Xc.addClass(v, S.classes.join(" ")), Xc.setAttribs(v, S.attrs);
        }, c = (v) => {
          const S = U(v) ? {
            name: v,
            classes: [],
            attrs: {}
          } : v, O = Xc.create(S.name);
          return r(O, S), O;
        }, u = (v, S) => {
          const R = o.getElementRule(v.nodeName.toLowerCase())?.parentsRequired;
          return R && R.length ? S && Lt(R, S) ? S : R[0] : !1;
        }, f = (v, S, O) => {
          let R;
          const M = S[0], H = Xu(M) ? M.name : void 0, J = u(v, H);
          if (J)
            H === J ? (R = M, S = S.slice(1)) : R = J;
          else if (M)
            R = M, S = S.slice(1);
          else if (!O)
            return v;
          const W = R ? c(R) : Xc.create("div");
          W.appendChild(v), O && Je.each(O, (ge) => {
            const be = c(ge);
            W.insertBefore(be, v);
          });
          const Q = Xu(R) ? R.siblings : void 0;
          return f(W, S, Q);
        }, b = Xc.create("div");
        if (e.length > 0) {
          const v = e[0], S = c(v), O = Xu(v) ? v.siblings : void 0;
          b.appendChild(f(S, e.slice(1), O));
        }
        return b;
      }, hU = (e) => {
        e = Je.trim(e);
        let t = "div";
        const o = {
          name: t,
          classes: [],
          attrs: {},
          selector: e
        };
        return e !== "*" && (t = e.replace(/(?:([#\.]|::?)([\w\-]+)|(\[)([^\]]+)\]?)/g, (r, c, u, f, b) => {
          switch (c) {
            case "#":
              o.attrs.id = u;
              break;
            case ".":
              o.classes.push(u);
              break;
            case ":":
              Je.inArray("checked disabled enabled read-only required".split(" "), u) !== -1 && (o.attrs[u] = u);
              break;
          }
          if (f === "[") {
            const v = b.match(/([\w\-]+)(?:\=\"([^\"]+))?/);
            v && (o.attrs[v[1]] = v[2]);
          }
          return "";
        })), o.name = t || "div", o;
      }, pU = (e) => U(e) ? (e = e.split(/\s*,\s*/)[0], e = e.replace(/\s*(~\+|~|\+|>)\s*/g, "$1"), Je.map(e.split(/(?:>|\s+(?![^\[\]]+\]))/), (t) => {
        const o = Je.map(t.split(/(?:~\+|~|\+)/), hU), r = o.pop();
        return o.length && (r.siblings = o), r;
      }).reverse()) : [], bU = (e, t) => {
        let o = "", r = Rk(e);
        if (r === "")
          return "";
        const c = (M) => U(M) ? M.replace(/%(\w+)/g, "") : "", u = (M, H) => Xc.getStyle(H ?? e.getBody(), M, !0);
        if (U(t)) {
          const M = e.formatter.get(t);
          if (!M)
            return "";
          t = M[0];
        }
        if ("preview" in t) {
          const M = t.preview;
          if (M === !1)
            return "";
          r = M || r;
        }
        let f = t.block || t.inline || "span", b;
        const v = pU(t.selector);
        v.length > 0 ? (v[0].name || (v[0].name = f), f = t.selector, b = B6(v, e)) : b = B6([f], e);
        const S = Xc.select(f, b)[0] || b.firstChild;
        qT(t.styles, (M, H) => {
          const J = c(M);
          J && Xc.setStyle(S, H, J);
        }), qT(t.attributes, (M, H) => {
          const J = c(M);
          J && Xc.setAttrib(S, H, J);
        }), qT(t.classes, (M) => {
          const H = c(M);
          Xc.hasClass(S, H) || Xc.addClass(S, H);
        }), e.dispatch("PreviewFormats"), Xc.setStyles(b, { position: "absolute", left: -65535 }), e.getBody().appendChild(b);
        const O = u("fontSize"), R = /px$/.test(O) ? parseInt(O, 10) : 0;
        return qT(r.split(" "), (M) => {
          let H = u(M, S);
          if (!(M === "background-color" && /transparent|rgba\s*\([^)]+,\s*0\)/.test(H) && (H = u(M), Ci(H).toLowerCase() === "#ffffff")) && !(M === "color" && Ci(H).toLowerCase() === "#000000")) {
            if (M === "font-size" && /em|%$/.test(H)) {
              if (R === 0)
                return;
              H = parseFloat(H) / (/%$/.test(H) ? 100 : 1) * R + "px";
            }
            M === "border" && H && (o += "padding:0 2px;"), o += M + ":" + H + ";";
          }
        }), e.dispatch("AfterPreviewFormats"), Xc.remove(b), o;
      }, vU = (e) => {
        e.addShortcut("meta+b", "", "Bold"), e.addShortcut("meta+i", "", "Italic"), e.addShortcut("meta+u", "", "Underline");
        for (let t = 1; t <= 6; t++)
          e.addShortcut("access+" + t, "", ["FormatBlock", !1, "h" + t]);
        e.addShortcut("access+7", "", ["FormatBlock", !1, "p"]), e.addShortcut("access+8", "", ["FormatBlock", !1, "div"]), e.addShortcut("access+9", "", ["FormatBlock", !1, "address"]);
      }, $6 = (e) => {
        const t = gU(e), o = Wt({});
        return vU(e), sP(e), Bm(e) || DT(o, e), {
          /**
           * Returns the format by name or all formats if no name is specified.
           *
           * @method get
           * @param {String} name Optional name to retrieve by.
           * @return {Array/Object} Array/Object with all registered formats or a specific format.
           */
          get: t.get,
          /**
           * Returns true or false if a format is registered for the specified name.
           *
           * @method has
           * @param {String} name Format name to check if a format exists.
           * @return {Boolean} True/False if a format for the specified name exists.
           */
          has: t.has,
          /**
           * Registers a specific format by name.
           *
           * @method register
           * @param {Object/String} name Name of the format for example "bold".
           * @param {Object/Array} format Optional format object or array of format variants
           * can only be omitted if the first arg is an object.
           */
          register: t.register,
          /**
           * Unregister a specific format by name.
           *
           * @method unregister
           * @param {String} name Name of the format for example "bold".
           */
          unregister: t.unregister,
          /**
           * Applies the specified format to the current selection or specified node.
           *
           * @method apply
           * @param {String} name Name of format to apply.
           * @param {Object} vars Optional list of variables to replace within format before applying it.
           * @param {Node} node Optional node to apply the format to defaults to current selection.
           */
          apply: (r, c, u) => {
            Ti(e, r, c, u);
          },
          /**
           * Removes the specified format from the current selection or specified node.
           *
           * @method remove
           * @param {String} name Name of format to remove.
           * @param {Object} vars Optional list of variables to replace within format before removing it.
           * @param {Node/Range} node Optional node or DOM range to remove the format from defaults to current selection.
           */
          remove: (r, c, u, f) => {
            Rx(e, r, c, u, f);
          },
          /**
           * Toggles the specified format on/off.
           *
           * @method toggle
           * @param {String} name Name of format to apply/remove.
           * @param {Object} vars Optional list of variables to replace within format before applying/removing it.
           * @param {Node} node Optional node to apply the format to or remove from. Defaults to current selection.
           */
          toggle: (r, c, u) => {
            ki(e, r, c, u);
          },
          /**
           * Matches the current selection or specified node against the specified format name.
           *
           * @method match
           * @param {String} name Name of format to match.
           * @param {Object} vars Optional list of variables to replace before checking it.
           * @param {Node} node Optional node to check.
           * @param {Boolean} similar Optional argument to specify that similar formats should be checked instead of only exact formats.
           * @return {Boolean} true/false if the specified selection/node matches the format.
           */
          match: (r, c, u, f) => r6(e, r, c, u, f),
          /**
           * Finds the closest matching format from a set of formats for the current selection.
           *
           * @method closest
           * @param {Array} names Format names to check for.
           * @return {String} The closest matching format name or null.
           */
          closest: (r) => $m(e, r),
          /**
           * Matches the current selection against the array of formats and returns a new array with matching formats.
           *
           * @method matchAll
           * @param {Array} names Name of format to match.
           * @param {Object} vars Optional list of variables to replace before checking it.
           * @return {Array} Array with matched formats.
           */
          matchAll: (r, c) => Dx(e, r, c),
          /**
           * Return true/false if the specified node has the specified format.
           *
           * @method matchNode
           * @param {Node} node Node to check the format on.
           * @param {String} name Format name to check.
           * @param {Object} vars Optional list of variables to replace before checking it.
           * @param {Boolean} similar Match format that has similar properties.
           * @return {Object} Returns the format object it matches or undefined if it doesn't match.
           */
          matchNode: (r, c, u, f) => OV(e, r, c, u, f),
          /**
           * Returns true/false if the specified format can be applied to the current selection or not. It
           * will currently only check the state for selector formats, it returns true on all other format types.
           *
           * @method canApply
           * @param {String} name Name of format to check.
           * @return {Boolean} true/false if the specified format can be applied to the current selection/node.
           */
          canApply: (r) => DV(e, r),
          /**
           * Executes the specified callback when the current selection matches the formats or not.
           *
           * @method formatChanged
           * @param {String} formats Comma separated list of formats to check for.
           * @param {Function} callback Callback with state and args when the format is changed/toggled on/off.
           * @param {Boolean} similar True/false state if the match should handle similar or exact formats.
           * @param {Object} vars Restrict the format being watched to only match if the variables applied are equal to vars.
           */
          formatChanged: (r, c, u, f) => RV(e, o, r, c, u, f),
          /**
           * Returns a preview css text for the specified format.
           *
           * @method getCssText
           * @param {String/Object} format Format to generate preview css text for.
           * @return {String} Css text for the specified format.
           * @example
           * const cssText1 = editor.formatter.getCssText('bold');
           * const cssText2 = editor.formatter.getCssText({ inline: 'b' });
           */
          getCssText: ue(bU, e)
        };
      }, I6 = (e) => {
        switch (e.toLowerCase()) {
          case "undo":
          case "redo":
          case "mcefocus":
            return !0;
          default:
            return !1;
        }
      }, yU = (e, t, o) => {
        const r = Wt(!1), c = (v) => {
          xp(t, !1, o), t.add({}, v);
        };
        e.on("init", () => {
          t.add();
        }), e.on("BeforeExecCommand", (v) => {
          const S = v.command;
          I6(S) || (IT(t, o), t.beforeChange());
        }), e.on("ExecCommand", (v) => {
          const S = v.command;
          I6(S) || c(v);
        }), e.on("ObjectResizeStart cut", () => {
          t.beforeChange();
        }), e.on("SaveContent ObjectResized blur", c), e.on("dragend", c), e.on("keyup", (v) => {
          const S = v.keyCode;
          if (v.isDefaultPrevented())
            return;
          const O = fo.os.isMacOS() && v.key === "Meta";
          (S >= 33 && S <= 36 || S >= 37 && S <= 40 || S === 45 || v.ctrlKey || O) && (c(), e.nodeChanged()), (S === 46 || S === 8) && e.nodeChanged(), r.get() && t.typing && !Jv(e.readonly, kx(e), t.data[0]) && (e.isDirty() || e.setDirty(!0), e.dispatch("TypingUndo"), r.set(!1), e.nodeChanged());
        }), e.on("keydown", (v) => {
          const S = v.keyCode;
          if (v.isDefaultPrevented())
            return;
          if (S >= 33 && S <= 36 || S >= 37 && S <= 40 || S === 45) {
            t.typing && c(v);
            return;
          }
          const O = v.ctrlKey && !v.altKey || v.metaKey;
          if ((S < 16 || S > 20) && S !== 224 && S !== 91 && !t.typing && !O) {
            t.beforeChange(), xp(t, !0, o), t.add({}, v), r.set(!0);
            return;
          }
          (fo.os.isMacOS() ? v.metaKey : v.ctrlKey && !v.altKey) && t.beforeChange();
        }), e.on("mousedown", (v) => {
          t.typing && c(v);
        });
        const u = (v) => v.inputType === "insertReplacementText", f = (v) => v.inputType === "insertText" && v.data === null, b = (v) => v.inputType === "insertFromPaste" || v.inputType === "insertFromDrop";
        e.on("input", (v) => {
          v.inputType && (u(v) || f(v) || b(v)) && c(v);
        }), e.on("AddUndo Undo Redo ClearUndos", (v) => {
          v.isDefaultPrevented() || e.nodeChanged();
        });
      }, CU = (e) => {
        e.addShortcut("meta+z", "", "Undo"), e.addShortcut("meta+y,meta+shift+z", "", "Redo");
      }, xU = (e) => {
        const t = Mc(), o = Wt(0), r = Wt(0), c = {
          data: [],
          // Gets mutated both internally and externally by plugins like remark, not documented
          /**
           * State if the user is currently typing or not. This will add a typing operation into one undo
           * level instead of one new level for each keystroke.
           *
           * @field {Boolean} typing
           */
          typing: !1,
          /**
           * Stores away a bookmark to be used when performing an undo action so that the selection is before
           * the change has been made.
           *
           * @method beforeChange
           */
          beforeChange: () => {
            jd(e, o, t);
          },
          /**
           * Adds a new undo level/snapshot to the undo list.
           *
           * @method add
           * @param {Object} level Optional undo level object to add.
           * @param {EditorEvent} event Optional event responsible for the creation of the undo level.
           * @return {Object} Undo level that got added or null if a level wasn't needed.
           */
          add: (u, f) => o6(e, c, r, o, t, u, f),
          /**
           * Dispatch a change event with current editor status as level and current undoManager layer as lastLevel
           *
           * @method dispatchChange
           */
          dispatchChange: () => {
            e.setDirty(!0);
            const u = kx(e);
            u.bookmark = Xh(e.selection), e.dispatch("change", {
              level: u,
              lastLevel: Gr(c.data, r.get()).getOrUndefined()
            });
          },
          /**
           * Undoes the last action.
           *
           * @method undo
           * @return {Object} Undo level or null if no undo was performed.
           */
          undo: () => bO(e, c, o, r),
          /**
           * Redoes the last action.
           *
           * @method redo
           * @return {Object} Redo level or null if no redo was performed.
           */
          redo: () => vO(e, r, c.data),
          /**
           * Removes all undo levels.
           *
           * @method clear
           */
          clear: () => {
            FT(e, c, r);
          },
          /**
           * Resets the undo manager levels by clearing all levels and then adding an initial level.
           *
           * @method reset
           */
          reset: () => {
            AV(e, c);
          },
          /**
           * Returns true/false if the undo manager has any undo levels.
           *
           * @method hasUndo
           * @return {Boolean} true/false if the undo manager has any undo levels.
           */
          hasUndo: () => s6(e, c, r),
          /**
           * Returns true/false if the undo manager has any redo levels.
           *
           * @method hasRedo
           * @return {Boolean} true/false if the undo manager has any redo levels.
           */
          hasRedo: () => Ox(e, c, r),
          /**
           * Executes the specified mutator function as an undo transaction. The selection
           * before the modification will be stored to the undo stack and if the DOM changes
           * it will add a new undo level. Any logic within the translation that adds undo levels will
           * be ignored. So a translation can include calls to execCommand or editor.insertContent.
           *
           * @method transact
           * @param {Function} callback Function that gets executed and has dom manipulation logic in it.
           * @return {Object} Undo level that got added or null it a level wasn't needed.
           */
          transact: (u) => _V(e, c, o, u),
          /**
           * Executes the specified mutator function as an undo transaction. But without adding an undo level.
           * Any logic within the translation that adds undo levels will be ignored. So a translation can
           * include calls to execCommand or editor.insertContent.
           *
           * @method ignore
           * @param {Function} callback Function that gets executed and has dom manipulation logic in it.
           */
          ignore: (u) => {
            LT(e, o, u);
          },
          /**
           * Adds an extra "hidden" undo level by first applying the first mutation and store that to the undo stack
           * then roll back that change and do the second mutation on top of the stack. This will produce an extra
           * undo level that the user doesn't see until they undo.
           *
           * @method extra
           * @param {Function} callback1 Function that does mutation but gets stored as a "hidden" extra undo level.
           * @param {Function} callback2 Function that does mutation but gets displayed to the user.
           */
          extra: (u, f) => {
            yO(e, c, r, u, f);
          }
        };
        return Bm(e) || yU(e, c, o), CU(e), c;
      }, SU = [
        // tab, esc, home, end
        9,
        27,
        Et.HOME,
        Et.END,
        // pause, capslock, print screen, numlock, scroll lock
        19,
        20,
        44,
        144,
        145,
        // page up/down, insert
        33,
        34,
        45,
        // alt, shift, ctrl
        16,
        17,
        18,
        // meta/windows key
        91,
        92,
        93,
        // direction
        Et.DOWN,
        Et.UP,
        Et.LEFT,
        Et.RIGHT
      ].concat(
        // Meta key on firefox is different
        fo.browser.isFirefox() ? [224] : []
      ), F6 = "data-mce-placeholder", L6 = (e) => e.type === "keydown" || e.type === "keyup", H6 = (e) => {
        const t = e.keyCode;
        return t === Et.BACKSPACE || t === Et.DELETE;
      }, wU = (e) => {
        if (L6(e)) {
          const t = e.keyCode;
          return !H6(e) && (Et.metaKeyPressed(e) || e.altKey || t >= 112 && t <= 123 || Lt(SU, t));
        } else
          return !1;
      }, EU = (e) => (
        // 229 === Unidentified, so since we don't know what it is treat it as a non typing event on keyup but as a typing event on keydown
        // Android will generally always send a 229 keycode since it uses an IME to input text
        L6(e) && !(H6(e) || e.type === "keyup" && e.keyCode === 229)
      ), Tp = (e, t, o) => {
        if (e.isEmpty(t, void 0, { skipBogus: !1, includeZwsp: !0 })) {
          const r = t.firstElementChild;
          return r ? e.getStyle(t.firstElementChild, "padding-left") || e.getStyle(t.firstElementChild, "padding-right") ? !1 : o === r.nodeName.toLowerCase() : !0;
        } else
          return !1;
      }, TU = (e) => {
        const t = e.dom, o = Ar(e), r = pC(e) ?? "", c = (u, f) => {
          if (wU(u))
            return;
          const b = e.getBody(), v = EU(u) ? !1 : Tp(t, b, o);
          (t.getAttrib(b, F6) !== "" !== v || f) && (t.setAttrib(b, F6, v ? r : null), cC(e, v), e.on(v ? "keydown" : "keyup", c), e.off(v ? "keyup" : "keydown", c));
        };
        ms(r) && e.on("init", (u) => {
          c(u, !0), e.on("change SetContent ExecCommand", c), e.on("paste", (f) => $d.setEditorTimeout(e, () => c(f)));
        });
      }, kU = (e) => (t) => X(t) && t.nodeName.toLowerCase() === e, ay = (e) => (t) => X(t) && e.test(t.nodeName), Fm = (e) => X(e) && e.nodeType === 3, KT = (e) => X(e) && e.nodeType === 1, Qu = ay(/^(OL|UL|DL)$/), AU = ay(/^(OL|UL)$/), YT = ay(/^(LI|DT|DD)$/), _U = ay(/^(DT|DD)$/), _b = kU("br"), OU = (e) => e.parentNode?.firstChild === e, QO = (e, t) => X(t) && t.nodeName in e.schema.getTextBlockElements(), JO = (e, t) => X(e) && e.nodeName in t, DU = (e, t) => X(t) && t.nodeName in e.schema.getVoidElements(), RU = (e, t) => _b(t) ? e.isBlock(t.nextSibling) && !_b(t.previousSibling) : !1, Ob = (e, t, o) => {
        const r = e.isEmpty(t);
        return o && e.select("span[data-mce-type=bookmark]", t).length > 0 ? !1 : r;
      }, z6 = (e, t) => e.isChildOf(t, e.getRoot()), V6 = lo.DOM, NU = (e, t) => {
        const o = t.parentElement;
        if (o && o.nodeName === "LI" && o.firstChild === t) {
          const r = o.previousSibling;
          r && r.nodeName === "LI" ? (r.appendChild(t), Ob(e, o) && V6.remove(o)) : V6.setStyle(o, "listStyleType", "none");
        }
        if (Qu(o)) {
          const r = o.previousSibling;
          r && r.nodeName === "LI" && r.appendChild(t);
        }
      }, eD = (e, t) => {
        const o = Je.grep(e.select("ol,ul", t));
        Je.each(o, (r) => {
          NU(e, r);
        });
      }, U6 = (e, t) => {
        if (Fm(e))
          return { container: e, offset: t };
        const o = _m.getNode(e, t);
        return Fm(o) ? {
          container: o,
          offset: t >= e.childNodes.length ? o.data.length : 0
        } : o.previousSibling && Fm(o.previousSibling) ? {
          container: o.previousSibling,
          offset: o.previousSibling.data.length
        } : o.nextSibling && Fm(o.nextSibling) ? {
          container: o.nextSibling,
          offset: 0
        } : { container: e, offset: t };
      }, tD = (e) => {
        const t = e.cloneRange(), o = U6(e.startContainer, e.startOffset);
        t.setStart(o.container, o.offset);
        const r = U6(e.endContainer, e.endOffset);
        return t.setEnd(r.container, r.offset), t;
      }, j6 = ["OL", "UL", "DL"], W6 = j6.join(","), Vx = (e, t) => {
        const o = e.selection.getStart(!0);
        return e.dom.getParent(o, W6, Ux(e, o));
      }, Z6 = (e, t) => X(e) && t.length === 1 && t[0] === e, MU = (e) => ze(e.querySelectorAll(W6), Qu), PU = (e) => {
        const t = Vx(e), o = e.selection.getSelectedBlocks();
        return Z6(t, o) ? MU(t) : ze(o, (r) => Qu(r) && t !== r);
      }, BU = (e, t) => {
        const o = Je.map(t, (r) => {
          const c = e.dom.getParent(r, "li,dd,dt", Ux(e, r));
          return c || r;
        });
        return Ka(o);
      }, nD = (e) => {
        const t = e.selection.getSelectedBlocks();
        return ze(BU(e, t), YT);
      }, $U = (e) => ze(nD(e), _U), oD = (e, t) => {
        const o = e.dom.getParents(t, "TD,TH");
        return o.length > 0 ? o[0] : e.getBody();
      }, IU = (e, t) => !Qu(t) && !YT(t) && po(j6, (o) => e.isValidChild(t.nodeName, o)), Ux = (e, t) => {
        const o = e.dom.getParents(t, e.dom.isBlock), r = (u) => u.nodeName.toLowerCase() !== Ar(e);
        return _o(o, (u) => r(u) && IU(e.schema, u)).getOr(e.getBody());
      }, G6 = (e) => ec(e).exists((t) => YT(t.dom) && Ir(t).exists((o) => !Qu(o.dom)) && or(t).exists((o) => !Qu(o.dom))), q6 = (e, t) => {
        const o = e.dom.getParents(t, "ol,ul", Ux(e, t));
        return dr(o);
      }, FU = (e) => {
        const t = q6(e, e.selection.getStart()), o = ze(e.selection.getSelectedBlocks(), AU);
        return t.toArray().concat(o);
      }, LU = (e) => {
        const t = e.selection.getStart();
        return e.dom.getParents(t, "ol,ul", Ux(e, t));
      }, HU = (e) => {
        const t = FU(e), o = LU(e);
        return _o(o, (r) => G6(te.fromDom(r))).fold(() => zU(e, t), (r) => [r]);
      }, zU = (e, t) => {
        const o = en(t, (r) => q6(e, r).getOr(r));
        return Ka(o);
      }, XT = (e) => /\btox\-/.test(e.className), K6 = (e, t) => t !== null && !e.dom.isEditable(t), VU = (e) => {
        const t = Vx(e);
        return K6(e, t) || !e.selection.isEditable();
      }, sD = (e, t) => {
        const o = e.dom.getParent(t, "ol,ul,dl");
        return K6(e, o) || !e.selection.isEditable();
      }, kp = (e, t, o) => e.dispatch("ListMutation", { action: t, element: o }), rD = (e, t, o = {}) => {
        const r = e.dom, c = e.schema.getBlockElements(), u = r.createFragment(), f = Ar(e), b = nu(e);
        let v, S, O = !1;
        for (S = r.create(f, {
          ...b,
          ...o.style ? { style: o.style } : {}
        }), JO(t.firstChild, c) || u.appendChild(S); v = t.firstChild; ) {
          const R = v.nodeName;
          !O && (R !== "SPAN" || v.getAttribute("data-mce-type") !== "bookmark") && (O = !0), JO(v, c) ? (u.appendChild(v), S = null) : (S || (S = r.create(f, b), u.appendChild(S)), S.appendChild(v));
        }
        return !O && S && S.appendChild(r.create("br", { "data-mce-bogus": "1" })), u;
      }, cy = (e) => Xm(e, "OL,UL"), uX = (e) => Xm(e, "LI"), aD = (e) => Ir(e).exists(cy), UU = (e) => or(e).exists(cy), Y6 = (e, t) => OC(e).map((o) => o >= t).getOr(!0), Db = (e) => "listAttributes" in e, X6 = (e) => "isComment" in e, jU = (e) => "isFragment" in e, Q6 = (e) => e.depth > 0, WU = (e) => e.isSelected, ZU = (e) => {
        const t = Os(e), o = UU(e) ? t.slice(0, -1) : t;
        return en(o, Vi);
      }, cD = (e, t, o) => ec(e).filter(Is).map((r) => ({
        depth: t,
        dirty: !1,
        isSelected: o,
        content: ZU(e),
        itemAttributes: Kn(e),
        listAttributes: Kn(r),
        listType: Hn(r),
        isInPreviousLi: !1
      })), QT = (e, t) => {
        bo(e.item, t.list);
      }, GU = (e) => {
        for (let t = 1; t < e.length; t++)
          QT(e[t - 1], e[t]);
      }, J6 = (e, t) => {
        Xs(dr(e), js(t), QT);
      }, qU = (e, t) => {
        const o = {
          list: te.fromTag(t, e),
          item: te.fromTag("li", e)
        };
        return bo(o.list, o.item), o;
      }, KU = (e, t, o) => {
        const r = [];
        for (let c = 0; c < o; c++)
          r.push(qU(e, Db(t) ? t.listType : t.parentListType));
        return r;
      }, YU = (e, t) => {
        for (let o = 0; o < e.length - 1; o++)
          Ca(e[o].item, "list-style-type", "none");
        dr(e).each((o) => {
          Db(t) && (ea(o.list, t.listAttributes), ea(o.item, t.itemAttributes)), ll(o.item, t.content);
        });
      }, XU = (e, t) => {
        Hn(e.list) !== t.listType && (e.list = ku(e.list, t.listType)), ea(e.list, t.listAttributes);
      }, QU = (e, t, o) => {
        const r = te.fromTag("li", e);
        return ea(r, t), ll(r, o), r;
      }, JU = (e, t) => {
        bo(e.list, t), e.item = t;
      }, e$ = (e, t, o) => {
        const r = t.slice(0, o.depth);
        return dr(r).each((c) => {
          if (Db(o)) {
            const u = QU(e, o.itemAttributes, o.content);
            JU(c, u), XU(c, o);
          } else if (jU(o))
            ll(c.item, o.content);
          else {
            const u = te.fromHtml(`<!--${o.content}-->`);
            bo(c.list, u);
          }
        }), r;
      }, ej = (e, t, o) => {
        const r = KU(e, o, o.depth - t.length);
        return GU(r), YU(r, o), J6(t, r), t.concat(r);
      }, tj = (e, t) => {
        let o = P.none();
        const r = Io(t, (c, u, f) => X6(u) ? f === 0 ? (o = P.some(u), c) : e$(e, c, u) : u.depth > c.length ? ej(e, c, u) : e$(e, c, u), []);
        return o.each((c) => {
          const u = te.fromHtml(`<!--${c.content}-->`);
          js(r).each((f) => {
            zi(f.list, u);
          });
        }), js(r).map((c) => c.list);
      }, nj = (e, t, o) => {
        switch (t) {
          case "Indent":
            if (Y6(e, o.depth))
              o.depth++;
            else
              return;
            break;
          case "Outdent":
            o.depth--;
            break;
          case "Flatten":
            o.depth = 0;
        }
        o.dirty = !0;
      }, lD = (e, t) => {
        Db(e) && Db(t) && (e.listType = t.listType, e.listAttributes = { ...t.listAttributes });
      }, oj = (e) => {
        e.listAttributes = Ri(e.listAttributes, (t, o) => o !== "start");
      }, sj = (e, t) => {
        const o = e[t].depth, r = (u) => u.depth === o && !u.dirty, c = (u) => u.depth < o;
        return Jc(ds(e.slice(0, t)), r, c).orThunk(() => Jc(e.slice(t + 1), r, c));
      }, t$ = (e) => (xe(e, (t, o) => {
        sj(e, o).fold(() => {
          t.dirty && Db(t) && oj(t);
        }, (r) => lD(t, r));
      }), e), n$ = (e, t, o, r) => {
        if (ci(r))
          return [{
            depth: e + 1,
            content: r.dom.nodeValue ?? "",
            dirty: !1,
            isSelected: !1,
            isComment: !0
          }];
        t.each((f) => {
          Qn(f.start, r) && o.set(!0);
        });
        const c = cD(r, e, o.get());
        t.each((f) => {
          Qn(f.end, r) && o.set(!1);
        });
        const u = or(r).filter(cy).map((f) => jx(e, t, o, f)).getOr([]);
        return c.toArray().concat(u);
      }, rj = (e, t, o, r) => Ir(r).filter(cy).fold(() => n$(e, t, o, r), (c) => {
        const u = Io(Os(r), (f, b, v) => {
          if (v === 0)
            return f;
          if (uX(b))
            return f.concat(n$(e, t, o, b));
          {
            const S = {
              isFragment: !0,
              depth: e,
              content: [b],
              isSelected: !1,
              dirty: !1,
              parentListType: Hn(c)
            };
            return f.concat(S);
          }
        }, []);
        return jx(e, t, o, c).concat(u);
      }), jx = (e, t, o, r) => xo(Os(r), (c) => {
        const u = cy(c) ? jx : rj, f = e + 1;
        return u(f, t, o, c);
      }), Rb = (e, t) => {
        const o = Wt(!1), r = 0;
        return en(e, (c) => ({
          sourceList: c,
          entries: jx(r, t, o, c)
        }));
      }, o$ = (e, t) => {
        const o = t$(t);
        return en(o, (r) => {
          const c = X6(r) ? vd([te.fromHtml(`<!--${r.content}-->`)]) : vd(r.content), u = Db(r) ? r.itemAttributes : {};
          return te.fromDom(rD(e, c.dom, u));
        });
      }, aj = (e, t) => {
        const o = t$(t);
        return tj(e.contentDocument, o).toArray();
      }, cj = (e, t) => xo(no(t, Q6), (o) => js(o).exists(Q6) ? aj(e, o) : o$(e, o)), lj = (e, t, o) => {
        xe(ze(t, WU), (r) => nj(e, o, r));
      }, ij = (e) => {
        const t = en(nD(e), te.fromDom);
        return Xs(_o(t, bt(aD)), _o(ds(t), bt(aD)), (o, r) => ({ start: o, end: r }));
      }, ly = (e, t, o) => {
        const r = Rb(t, ij(e));
        xe(r, (c) => {
          lj(e, c.entries, o);
          const u = cj(e, c.entries);
          xe(u, (f) => {
            kp(e, o === "Indent" ? "IndentList" : "OutdentList", f.dom);
          }), o0(c.sourceList, u), qo(c.sourceList);
        });
      }, uj = (e) => OC(e).forall((t) => {
        const o = e.selection.getSelectedBlocks();
        return po(o, (r) => ia(te.fromDom(r), "li").forall((c) => de(c, "ol,ul").length <= t));
      }), Hf = lo.DOM, iD = (e, t, o) => {
        const r = (S) => {
          const O = S.parentNode;
          O && Je.each(c, (R) => {
            O.insertBefore(R, o.parentNode);
          }), Hf.remove(S);
        }, c = Hf.select('span[data-mce-type="bookmark"]', t), u = rD(e, o), f = Hf.createRng();
        f.setStartAfter(o), f.setEndAfter(t);
        const b = f.extractContents();
        for (let S = b.firstChild; S; S = S.firstChild)
          if (S.nodeName === "LI" && e.dom.isEmpty(S)) {
            Hf.remove(S);
            break;
          }
        e.dom.isEmpty(b) || Hf.insertAfter(b, t), Hf.insertAfter(u, t);
        const v = o.parentElement;
        v && Ob(e.dom, v) && r(v), Hf.remove(o), Ob(e.dom, t) && Hf.remove(t);
      }, dj = fr("dd"), uD = fr("dt"), JT = (e, t) => {
        dj(t) ? ku(t, "dt") : uD(t) && Fc(t).each((o) => iD(e, o.dom, t.dom));
      }, mj = (e) => {
        uD(e) && ku(e, "dd");
      }, fj = (e, t, o) => {
        t === "Indent" ? xe(o, mj) : xe(o, (r) => JT(e, r));
      }, gj = (e, t) => {
        const o = pd(HU(e)), r = pd($U(e));
        let c = !1;
        if (o.length || r.length) {
          const u = e.selection.getBookmark();
          ly(e, o, t), fj(e, t, r), e.selection.moveToBookmark(u), e.selection.setRng(tD(e.selection.getRng())), e.nodeChanged(), c = !0;
        }
        return c;
      }, dD = (e, t) => !VU(e) && gj(e, t), s$ = (e) => dD(
        e,
        "Indent"
        /* Indentation.Indent */
      ), Wx = (e) => dD(
        e,
        "Outdent"
        /* Indentation.Outdent */
      ), e4 = (e) => dD(
        e,
        "Flatten"
        /* Indentation.Flatten */
      ), iy = (e) => {
        switch (e) {
          case "UL":
            return "ToggleUlList";
          case "OL":
            return "ToggleOlList";
          case "DL":
            return "ToggleDLList";
        }
      }, hj = (e, t, o) => {
        const r = o["list-style-type"] ? o["list-style-type"] : null;
        e.setStyle(t, "list-style-type", r);
      }, r$ = (e, t) => {
        Je.each(t, (o, r) => {
          e.setAttribute(r, o);
        });
      }, pj = (e, t, o) => {
        r$(t, o["list-attributes"]), Je.each(e.select("li", t), (r) => {
          r$(r, o["list-item-attributes"]);
        });
      }, uy = (e, t, o) => {
        hj(e, t, o), pj(e, t, o);
      }, bj = (e, t, o) => {
        Je.each(o, (r) => e.setStyle(t, r, ""));
      }, t4 = (e, t) => X(t) && !JO(t, e.schema.getBlockElements()), mD = (e, t, o, r) => {
        let c = t[o ? "startContainer" : "endContainer"];
        const u = t[o ? "startOffset" : "endOffset"];
        KT(c) && (c = c.childNodes[Math.min(u, c.childNodes.length - 1)] || c), !o && _b(c.nextSibling) && (c = c.nextSibling);
        const f = (v) => {
          for (; !e.dom.isBlock(v) && v.parentNode && r !== v; )
            v = v.parentNode;
          return v;
        }, b = (v, S) => {
          const O = new Js(v, f(v)), R = S ? "next" : "prev";
          let M;
          for (; M = O[R](); )
            if (!(DU(e, M) || Xa(M.textContent) || M.textContent?.length === 0))
              return P.some(M);
          return P.none();
        };
        if (o && Fm(c))
          if (Xa(c.textContent))
            c = b(c, !1).getOr(c);
          else
            for (c.parentNode !== null && t4(e, c.parentNode) && (c = c.parentNode); c.previousSibling !== null && (t4(e, c.previousSibling) || Fm(c.previousSibling)); )
              c = c.previousSibling;
        if (!o && Fm(c))
          if (Xa(c.textContent))
            c = b(c, !0).getOr(c);
          else
            for (c.parentNode !== null && t4(e, c.parentNode) && (c = c.parentNode); c.nextSibling !== null && (t4(e, c.nextSibling) || Fm(c.nextSibling)); )
              c = c.nextSibling;
        for (; c.parentNode !== r; ) {
          const v = c.parentNode;
          if (QO(e, c) || /^(TD|TH)$/.test(v.nodeName))
            return c;
          c = v;
        }
        return c;
      }, vj = (e, t, o) => {
        const r = [], c = e.dom, u = mD(e, t, !0, o), f = mD(e, t, !1, o);
        let b;
        const v = [];
        for (let S = u; S && (v.push(S), S !== f); S = S.nextSibling)
          ;
        return Je.each(v, (S) => {
          if (QO(e, S)) {
            r.push(S), b = null;
            return;
          }
          if (c.isBlock(S) || _b(S)) {
            _b(S) && c.remove(S), b = null;
            return;
          }
          const O = S.nextSibling;
          if (Iv.isBookmarkNode(S) && (Qu(O) || QO(e, O) || !O && S.parentNode === o)) {
            b = null;
            return;
          }
          b || (b = c.create("p"), S.parentNode?.insertBefore(b, S), r.push(b)), b.appendChild(S);
        }), r;
      }, yj = (e, t, o) => {
        const r = e.getStyle(t, "list-style-type");
        let c = o ? o["list-style-type"] : "";
        return c = c === null ? "" : c, r === c;
      }, Cj = (e, t) => {
        const o = e.selection.getStart(!0), r = mD(e, t, !0, e.getBody());
        return Vn(te.fromDom(r), te.fromDom(t.commonAncestorContainer)) ? t.commonAncestorContainer : o;
      }, fD = (e, t, o) => {
        const r = e.selection.getRng();
        let c = "LI";
        const u = Ux(e, Cj(e, r)), f = e.dom;
        if (f.getContentEditable(e.selection.getNode()) === "false")
          return;
        t = t.toUpperCase(), t === "DL" && (c = "DT");
        const b = If(r), v = ze(vj(e, r, u), e.dom.isEditable);
        Je.each(v, (S) => {
          let O;
          const R = S.previousSibling, M = S.parentNode;
          YT(M) || (R && Qu(R) && R.nodeName === t && yj(f, R, o) ? (O = R, S = f.rename(S, c), R.appendChild(S)) : (O = f.create(t), M.insertBefore(O, S), O.appendChild(S), S = f.rename(S, c)), bj(f, S, [
            "margin",
            "margin-right",
            "margin-bottom",
            "margin-left",
            "margin-top",
            "padding",
            "padding-right",
            "padding-bottom",
            "padding-left",
            "padding-top"
          ]), uy(f, O, o), gD(e.dom, O));
        }), e.selection.setRng(Zu(b));
      }, xj = (e, t) => Qu(e) && e.nodeName === t?.nodeName, a$ = (e, t, o) => {
        const r = e.getStyle(t, "list-style-type", !0), c = e.getStyle(o, "list-style-type", !0);
        return r === c;
      }, Sj = (e, t) => e.className === t.className, c$ = (e, t, o) => xj(t, o) && // Note: isValidLists will ensure list1 and list2 are a HTMLElement. Unfortunately TypeScript doesn't
      // support type guards on multiple variables. See https://github.com/microsoft/TypeScript/issues/26916
      a$(e, t, o) && Sj(t, o), gD = (e, t) => {
        let o, r = t.nextSibling;
        if (c$(e, t, r)) {
          const c = r;
          for (; o = c.firstChild; )
            t.appendChild(o);
          e.remove(c);
        }
        if (r = t.previousSibling, c$(e, t, r)) {
          const c = r;
          for (; o = c.lastChild; )
            t.insertBefore(o, t.firstChild);
          e.remove(c);
        }
      }, wj = (e, t, o, r) => {
        if (t.nodeName !== o) {
          const c = e.dom.rename(t, o);
          uy(e.dom, c, r), kp(e, iy(o), c);
        } else
          uy(e.dom, t, r), kp(e, iy(o), t);
      }, Ej = (e, t, o, r) => {
        if (t.classList.forEach((c, u, f) => {
          c.startsWith("tox-") && (f.remove(c), f.length === 0 && t.removeAttribute("class"));
        }), t.nodeName !== o) {
          const c = e.dom.rename(t, o);
          uy(e.dom, c, r), kp(e, iy(o), c);
        } else
          uy(e.dom, t, r), kp(e, iy(o), t);
      }, hD = (e, t, o, r, c) => {
        const u = Qu(t);
        if (u && t.nodeName === r && !l$(c) && !XT(t))
          e4(e);
        else {
          fD(e, r, c);
          const f = If(e.selection.getRng()), b = u ? [t, ...o] : o, v = u && XT(t) ? Ej : wj;
          Je.each(b, (S) => {
            v(e, S, r, c);
          }), e.selection.setRng(Zu(f));
        }
      }, l$ = (e) => "list-style-type" in e, Tj = (e, t, o, r) => {
        if (t !== e.getBody())
          if (t)
            if (t.nodeName === o && !l$(r) && !XT(t))
              e4(e);
            else {
              const c = If(e.selection.getRng());
              XT(t) && t.classList.forEach((f, b, v) => {
                f.startsWith("tox-") && (v.remove(f), v.length === 0 && t.removeAttribute("class"));
              }), uy(e.dom, t, r);
              const u = e.dom.rename(t, o);
              gD(e.dom, u), e.selection.setRng(Zu(c)), fD(e, o, r), kp(e, iy(o), u);
            }
          else
            fD(e, o, r), kp(e, iy(o), t);
      }, pD = (e, t, o) => {
        const r = Vx(e);
        if (sD(e, r))
          return;
        const c = PU(e), u = Ye(o) ? o : {};
        c.length > 0 ? hD(e, r, c, t, u) : Tj(e, r, t, u);
      }, i$ = (e, t, o, r) => {
        let c = t.startContainer;
        const u = t.startOffset;
        if (Fm(c) && (o ? u < c.data.length : u > 0))
          return c;
        const f = e.schema.getNonEmptyElements();
        KT(c) && (c = _m.getNode(c, u));
        const b = new Js(c, r);
        o && RU(e.dom, c) && b.next();
        const v = o ? b.next.bind(b) : b.prev2.bind(b);
        for (; c = v(); )
          if (c.nodeName === "LI" && !c.hasChildNodes() || f[c.nodeName] || Fm(c) && c.data.length > 0)
            return c;
        return null;
      }, u$ = (e, t) => {
        const o = t.childNodes;
        return o.length === 1 && !Qu(o[0]) && e.isBlock(o[0]);
      }, kj = (e) => P.from(e).map(te.fromDom).filter(li).exists((t) => Ll(t) && !Lt(["details"], Hn(t))), Aj = (e, t) => {
        u$(e, t) && kj(t.firstChild) && e.remove(t.firstChild, !0);
      }, d$ = (e, t, o) => {
        let r;
        const c = u$(e, o) ? o.firstChild : o;
        if (Aj(e, t), !Ob(e, t, !0))
          for (; r = t.firstChild; )
            c.appendChild(r);
      }, bD = (e, t, o) => {
        let r;
        const c = t.parentNode;
        if (!z6(e, t) || !z6(e, o))
          return;
        Qu(o.lastChild) && (r = o.lastChild), c === o.lastChild && _b(c.previousSibling) && e.remove(c.previousSibling);
        const u = o.lastChild;
        u && _b(u) && t.hasChildNodes() && e.remove(u), Ob(e, o, !0) && Il(te.fromDom(o)), d$(e, t, o), r && o.appendChild(r);
        const b = Ja(te.fromDom(o), te.fromDom(t)) ? e.getParents(t, Qu, o) : [];
        e.remove(t), xe(b, (v) => {
          Ob(e, v) && v !== e.getRoot() && e.remove(v);
        });
      }, _j = (e, t, o) => {
        Il(te.fromDom(o)), bD(e.dom, t, o), e.selection.setCursorLocation(o, 0);
      }, Oj = (e, t, o, r) => {
        const c = e.dom;
        if (c.isEmpty(r))
          _j(e, o, r);
        else {
          const u = If(t);
          bD(c, o, r), e.selection.setRng(Zu(u));
        }
      }, Dj = (e, t, o, r) => {
        const c = If(t);
        bD(e.dom, o, r);
        const u = Zu(c);
        e.selection.setRng(u);
      }, Rj = (e, t) => {
        const o = e.dom, r = e.selection, c = r.getStart(), u = oD(e, c), f = o.getParent(r.getStart(), "LI", u);
        if (f) {
          const b = f.parentElement;
          if (b === e.getBody() && Ob(o, b))
            return !0;
          const v = tD(r.getRng()), S = o.getParent(i$(e, v, t, u), "LI", u), O = S && (t ? o.isChildOf(f, S) : o.isChildOf(S, f));
          if (S && S !== f && !O)
            return e.undoManager.transact(() => {
              t ? Oj(e, v, S, f) : OU(f) ? Wx(e) : Dj(e, v, f, S);
            }), !0;
          if (O && !t && S !== f) {
            const R = v.commonAncestorContainer.parentElement;
            return !R || o.isChildOf(S, R) ? !1 : (e.undoManager.transact(() => {
              const M = If(v);
              d$(o, R, S), R.remove();
              const H = Zu(M);
              e.selection.setRng(H);
            }), !0);
          } else if (!S && !t && v.startOffset === 0 && v.endOffset === 0)
            return e.undoManager.transact(() => {
              e4(e);
            }), !0;
        }
        return !1;
      }, Nj = (e, t, o) => {
        const r = e.getParent(t.parentNode, e.isBlock, o);
        e.remove(t), r && e.isEmpty(r) && e.remove(r);
      }, Mj = (e, t) => {
        const o = e.dom, r = e.selection.getStart(), c = oD(e, r), u = o.getParent(r, o.isBlock, c);
        if (u && o.isEmpty(u, void 0, { checkRootAsContent: !0 })) {
          const f = tD(e.selection.getRng()), b = i$(e, f, t, c), v = o.getParent(b, "LI", c);
          if (b && v) {
            const S = (H) => Lt(["td", "th", "caption"], Hn(H)), O = (H) => H.dom === c, R = Uo(te.fromDom(v), S, O), M = Uo(te.fromDom(f.startContainer), S, O);
            return cd(R, M, Qn) ? (e.undoManager.transact(() => {
              const H = v.parentNode;
              Nj(o, u, c), gD(o, H), e.selection.select(b, !0), e.selection.collapse(t);
            }), !0) : !1;
          }
        }
        return !1;
      }, Pj = (e, t) => Rj(e, t) || Mj(e, t), vD = (e) => {
        const t = e.selection.getStart(), o = oD(e, t), r = e.dom.getParent(t, "LI,DT,DD", o);
        return X(r) || nD(e).length > 0;
      }, Bj = (e) => vD(e) ? (e.undoManager.transact(() => {
        let t = !0;
        const o = () => t = !1;
        e.on("input", o), e.execCommand("Delete"), e.off("input", o), t && e.dispatch("input"), eD(e.dom, e.getBody());
      }), !0) : !1, yD = (e, t) => {
        const o = e.selection;
        return !sD(e, o.getNode()) && (o.isCollapsed() ? Pj(e, t) : Bj(e));
      }, $j = (e, t) => ({
        block: e,
        position: t
      }), Ij = (e, t) => ({
        from: e,
        to: t
      }), n4 = (e, t) => {
        const o = te.fromDom(e), r = te.fromDom(t.container());
        return ZA(o, r).map((c) => $j(c, t));
      }, Fj = (e) => !(Ja(e.to.block, e.from.block) || Ja(e.from.block, e.to.block)), Lj = (e) => !Qn(e.from.block, e.to.block), CD = (e, t) => Uo(t, (c) => kg(c) || dl(c.dom), (c) => Qn(c, e)).filter(Is).getOr(e), Hj = (e, t) => {
        const o = te.fromDom(e);
        return Qn(CD(o, t.from.block), CD(o, t.to.block));
      }, zj = (e) => Es(e.from.block.dom) === !1 && Es(e.to.block.dom) === !1, Vj = (e) => {
        const t = (o) => nc(o) || Ze(o.dom) || Ec(o);
        return t(e.from.block) && t(e.to.block);
      }, Uj = (e, t, o, r) => zs(r.position.getNode()) && !er(e, r.block) ? m(!1, r.block.dom).bind((c) => c.isEqual(r.position) ? Zl(o, t, c).bind((u) => n4(t, u)) : P.some(r)).getOr(r) : r, xD = (e, t, o, r) => {
        const c = n4(t, Re.fromRangeStart(r)), u = c.bind((f) => Zl(o, t, f.position).bind((b) => n4(t, b).map((v) => Uj(e, t, o, v))));
        return Xs(c, u, Ij).filter((f) => Lj(f) && Hj(t, f) && zj(f) && Vj(f) && Fj(f));
      }, m$ = (e, t, o, r) => r.collapsed ? xD(e, t, o, r) : P.none(), dX = (e, t) => {
        const o = Os(e);
        return Ql(o, (r) => t.isBlock(Hn(r))).fold(ot(o), (r) => o.slice(0, r));
      }, dy = (e, t) => {
        const o = dX(e, t);
        return xe(o, qo), o;
      }, jj = (e, t, o) => {
        const r = Id(o, t);
        return _o(r.reverse(), (c) => er(e, c)).each(qo);
      }, mX = (e, t) => ze(Xr(t), (o) => !er(e, o)).length === 0, fX = (e, t, o, r, c) => {
        if (er(r, o))
          return vf(o), E(o.dom);
        mX(r, c) && er(r, t) && ca(c, te.fromTag("br"));
        const u = y(o.dom, Re.before(c.dom));
        return xe(dy(t, r), (f) => {
          ca(c, f);
        }), jj(r, e, t), u;
      }, gX = (e, t) => e.isInline(Hn(t)), Lm = (e, t, o, r) => {
        if (er(r, o)) {
          if (er(r, t)) {
            const f = qn(((b) => {
              const v = (S, O) => Ir(S).fold(() => O, (R) => gX(r, R) ? v(R, O.concat(pr(R))) : O);
              return v(b, []);
            })(o), (b, v) => (Lc(b, v), v), bf());
            Il(t), bo(t, f);
          }
          return qo(o), E(t.dom);
        }
        const c = D(o.dom);
        return xe(dy(t, r), (u) => {
          bo(o, u);
        }), jj(r, e, t), c;
      }, Zx = (e, t) => {
        const o = Id(t, e);
        return P.from(o[o.length - 1]);
      }, Hm = (e, t) => Ja(t, e) ? Zx(t, e) : P.none(), Ap = (e, t) => {
        m(e, t.dom).bind((o) => P.from(o.getNode())).map(te.fromDom).filter(Xi).each(qo);
      }, o4 = (e, t, o, r) => (Ap(!0, t), Ap(!1, o), Hm(t, o).fold(ue(Lm, e, t, o, r), ue(fX, e, t, o, r))), SD = (e, t, o, r, c) => t ? o4(e, r, o, c) : o4(e, o, r, c), Nb = (e, t) => {
        const o = te.fromDom(e.getBody());
        return m$(e.schema, o.dom, t, e.selection.getRng()).map((c) => () => {
          SD(o, t, c.from.block, c.to.block, e.schema).each((u) => {
            e.selection.setRng(u.toRange());
          });
        });
      }, Wj = (e, t, o) => {
        const r = t.getRng();
        return Xs(ZA(e, te.fromDom(r.startContainer)), ZA(e, te.fromDom(r.endContainer)), (c, u) => Qn(c, u) ? P.none() : P.some(() => {
          r.deleteContents(), SD(e, !0, c, u, o).each((f) => {
            t.setRng(f.toRange());
          });
        })).getOr(P.none());
      }, wD = (e, t) => {
        const o = te.fromDom(t), r = ue(Qn, e);
        return Wi(o, kg, r).isSome();
      }, hX = (e, t) => wD(e, t.startContainer) || wD(e, t.endContainer), Zj = (e, t) => {
        const o = y(e.dom, Re.fromRangeStart(t)).isNone(), r = p(e.dom, Re.fromRangeEnd(t)).isNone();
        return !hX(e, t) && o && r;
      }, Gx = (e) => P.some(() => {
        e.setContent(""), e.selection.setCursorLocation();
      }), f$ = (e) => {
        const t = te.fromDom(e.getBody()), o = e.selection.getRng();
        return Zj(t, o) ? Gx(e) : Wj(t, e.selection, e.schema);
      }, yr = (e, t) => e.selection.isCollapsed() ? P.none() : f$(e), nh = (e, t, o, r, c) => (
        // TODO: Figure out a better way to handle this dependency
        P.from(t._selectionOverrides.showCaret(e, o, r, c))
      ), Gj = (e) => {
        const t = e.ownerDocument.createRange();
        return t.selectNode(e), t;
      }, zf = (e, t) => e.dispatch("BeforeObjectSelected", { target: t }).isDefaultPrevented() ? P.none() : P.some(Gj(t)), Mb = (e, t, o) => {
        const r = Av(1, e.getBody(), t), c = Re.fromRangeStart(r), u = c.getNode();
        if (Wl(u))
          return nh(1, e, u, !c.isAtEnd(), !1);
        const f = c.getNode(!0);
        if (Wl(f))
          return nh(1, e, f, !1, !1);
        const b = Om(e.dom.getRoot(), c.getNode());
        return Wl(b) ? nh(1, e, b, !1, o) : P.none();
      }, oh = (e, t, o) => t.collapsed ? Mb(e, t, o).getOr(t) : t, qj = (e) => Zg(e) || tx(e), Kj = (e) => Bf(e) || nx(e), ED = (e, t) => {
        tt(t) && t.data.length === 0 && e.remove(t);
      }, s4 = (e, t, o, r, c, u) => {
        nh(r, e, u.getNode(!c), c, !0).each((f) => {
          if (t.collapsed) {
            const b = t.cloneRange();
            c ? b.setEnd(f.startContainer, f.startOffset) : b.setStart(f.endContainer, f.endOffset), b.deleteContents();
          } else
            t.deleteContents();
          e.selection.setRng(f);
        }), ED(e.dom, o);
      }, g$ = (e, t) => {
        const o = e.selection.getRng();
        if (!tt(o.commonAncestorContainer))
          return P.none();
        const r = t ? 1 : -1, c = Uu(e.getBody()), u = ue(Ov, t ? c.next : c.prev), f = t ? qj : Kj, b = Rf(r, e.getBody(), o), v = u(b), S = v && Wu(t, v);
        if (!S || !Vu(b, S))
          return P.none();
        if (f(S))
          return P.some(() => s4(e, o, b.getNode(), r, t, S));
        const O = u(S);
        return O && f(O) && Vu(S, O) ? P.some(() => s4(e, o, b.getNode(), r, t, O)) : P.none();
      }, r4 = (e, t) => g$(e, t), TD = (e, t) => {
        const o = e.getBody();
        return t ? E(o).filter(Zg) : D(o).filter(Bf);
      }, kD = (e) => {
        const t = e.selection.getRng();
        return !t.collapsed && (TD(e, !0).exists((o) => o.isEqual(Re.fromRangeStart(t))) || TD(e, !1).exists((o) => o.isEqual(Re.fromRangeEnd(t))));
      }, AD = (e) => X(e) && (kg(te.fromDom(e)) || Ec(te.fromDom(e))), uu = el.generate([
        { remove: ["element"] },
        { moveToElement: ["element"] },
        { moveToPosition: ["position"] }
      ]), Yj = (e, t) => {
        const o = t.getNode(!e), r = e ? "after" : "before";
        return ht(o) && o.getAttribute("data-mce-caret") === r;
      }, Xj = (e, t, o, r, c) => {
        const u = (f) => c.isInline(f.nodeName.toLowerCase()) && !Rd(o, r, e);
        return _v(!t, o).fold(() => _v(t, r).fold(ye, u), u);
      }, h$ = (e, t, o, r, c) => {
        const u = c.getNode(!o);
        return ZA(te.fromDom(t), te.fromDom(r.getNode())).map((f) => er(e, f) ? uu.remove(f.dom) : uu.moveToElement(u)).orThunk(() => P.some(uu.moveToElement(u)));
      }, p$ = (e, t, o, r) => Zl(t, e, o).bind((c) => AD(c.getNode()) || Xj(e, t, o, c, r) ? P.none() : t && Es(c.getNode()) || !t && Es(c.getNode(!0)) ? h$(r, e, t, o, c) : t && Bf(o) || !t && Zg(o) ? P.some(uu.moveToPosition(c)) : P.none()), _D = (e, t) => jt(t) ? P.none() : e && Es(t.nextSibling) ? P.some(uu.moveToElement(t.nextSibling)) : !e && Es(t.previousSibling) ? P.some(uu.moveToElement(t.previousSibling)) : P.none(), b$ = (e, t, o) => o.fold((r) => P.some(uu.remove(r)), (r) => P.some(uu.moveToElement(r)), (r) => Rd(t, r, e) ? P.none() : P.some(uu.moveToPosition(r))), Qj = (e, t, o, r) => Yj(t, o) ? _D(t, o.getNode(!t)).orThunk(() => p$(e, t, o, r)) : p$(e, t, o, r).bind((c) => b$(e, o, c)), Jj = (e, t, o, r) => {
        const c = Av(t ? 1 : -1, e, o), u = Re.fromRangeStart(c), f = te.fromDom(e);
        return !t && Bf(u) ? P.some(uu.remove(u.getNode(!0))) : t && Zg(u) ? P.some(uu.remove(u.getNode())) : !t && Zg(u) && QE(f, u, r) ? hM(f, u, r).map((b) => uu.remove(b.getNode())) : t && Bf(u) && HA(f, u, r) ? kH(f, u, r).map((b) => uu.remove(b.getNode())) : Qj(e, t, u, r);
      }, my = (e, t) => (o) => (e._selectionOverrides.hideFakeCaret(), $f(e, t, te.fromDom(o)), !0), v$ = (e, t) => (o) => {
        const r = t ? Re.before(o) : Re.after(o);
        return e.selection.setRng(r.toRange()), !0;
      }, eW = (e) => (t) => (e.selection.setRng(t.toRange()), !0), OD = (e, t) => P.from(Om(e.getBody(), t)), tW = (e, t) => {
        const o = e.selection.getNode();
        return OD(e, o).filter(Es).fold(() => Jj(e.getBody(), t, e.selection.getRng(), e.schema).map((r) => () => r.fold(my(e, t), v$(e, t), eW(e))), () => P.some(St));
      }, y$ = (e) => {
        xe(Ne(e, ".mce-offscreen-selection"), qo);
      }, nW = (e, t) => {
        const o = e.selection.getNode();
        return Es(o) && !_h(o) ? OD(e, o.parentNode).filter(Es).fold(() => P.some(() => {
          y$(te.fromDom(e.getBody())), $f(e, t, te.fromDom(e.selection.getNode())), PM(e);
        }), () => P.some(St)) : kD(e) ? P.some(() => {
          qH(e, e.selection.getRng(), te.fromDom(e.getBody()));
        }) : P.none();
      }, DD = (e) => {
        const t = e.dom, o = e.selection, r = Om(e.getBody(), o.getNode());
        if (dl(r) && t.isBlock(r) && t.isEmpty(r)) {
          const c = t.create("br", { "data-mce-bogus": "1" });
          t.setHTML(r, ""), r.appendChild(c), o.setRng(Re.before(c).toRange());
        }
        return !0;
      }, a4 = (e, t) => e.selection.isCollapsed() ? tW(e, t) : nW(e, t), c4 = (e, t) => {
        const o = e.dom, r = o.getParent(e.selection.getStart(), o.isBlock), c = o.getParent(e.selection.getEnd(), o.isBlock), u = e.getBody();
        if (r?.nodeName?.toLowerCase() === "div" && r && c && r === u.firstChild && c === u.lastChild && !o.isEmpty(u)) {
          const b = r.cloneNode(!1), v = () => {
            if (t ? ZH(e) : WA(e), u.firstChild !== r) {
              const S = If(e.selection.getRng(), () => document.createElement("span"));
              Array.from(u.childNodes).forEach((O) => b.appendChild(O)), u.appendChild(b), e.selection.setRng(Zu(S));
            }
          };
          return P.some(v);
        }
        return P.none();
      }, C$ = (e, t) => {
        const o = Re.fromRangeStart(e.selection.getRng());
        return Zl(t, e.getBody(), o).filter((r) => t ? PA(r) : lM(r)).bind((r) => IC(t ? 0 : -1, r)).map((r) => () => e.selection.select(r));
      }, l4 = (e, t) => e.selection.isCollapsed() ? C$(e, t) : P.none(), Pb = tt, x$ = (e) => Pb(e) && e.data[0] === Ur, S$ = (e) => Pb(e) && e.data[e.data.length - 1] === Ur, w$ = (e) => (e.ownerDocument ?? document).createTextNode(Ur), RD = (e) => {
        if (Pb(e.previousSibling))
          return S$(e.previousSibling) || e.previousSibling.appendData(Ur), e.previousSibling;
        if (Pb(e))
          return x$(e) || e.insertData(0, Ur), e;
        {
          const t = w$(e);
          return e.parentNode?.insertBefore(t, e), t;
        }
      }, qx = (e) => {
        if (Pb(e.nextSibling))
          return x$(e.nextSibling) || e.nextSibling.insertData(0, Ur), e.nextSibling;
        if (Pb(e))
          return S$(e) || e.appendData(Ur), e;
        {
          const t = w$(e);
          return e.nextSibling ? e.parentNode?.insertBefore(t, e.nextSibling) : e.parentNode?.appendChild(t), t;
        }
      }, _p = (e, t) => e ? RD(t) : qx(t), ND = ue(_p, !0), E$ = ue(_p, !1), MD = (e, t) => tt(e.container()) ? _p(t, e.container()) : _p(t, e.getNode()), Kx = (e, t) => {
        const o = t.get();
        return o && e.container() === o && $u(o);
      }, PD = (e, t) => t.fold((o) => {
        Lg(e.get());
        const r = ND(o);
        return e.set(r), P.some(Re(r, r.length - 1));
      }, (o) => (
        // Start
        E(o).map((r) => {
          if (Kx(r, e)) {
            const c = e.get();
            return Re(c, 1);
          } else {
            Lg(e.get());
            const c = MD(r, !0);
            return e.set(c), Re(c, 1);
          }
        })
      ), (o) => (
        // End
        D(o).map((r) => {
          if (Kx(r, e)) {
            const c = e.get();
            return Re(c, c.length - 1);
          } else {
            Lg(e.get());
            const c = MD(r, !1);
            return e.set(c), Re(c, c.length - 1);
          }
        })
      ), (o) => {
        Lg(e.get());
        const r = E$(o);
        return e.set(r), P.some(Re(r, 1));
      }), T$ = (e, t) => {
        for (let o = 0; o < e.length; o++) {
          const r = e[o].apply(null, t);
          if (r.isSome())
            return r;
        }
        return P.none();
      }, fa = el.generate([
        { before: ["element"] },
        { start: ["element"] },
        { end: ["element"] },
        { after: ["element"] }
      ]), i4 = (e, t) => {
        const o = Of(t, e);
        return o || e;
      }, k$ = (e, t, o) => {
        const r = RM(o), c = i4(t, r.container());
        return hp(e, c, r).fold(() => p(c, r).bind(ue(hp, e, c)).map((u) => fa.before(u)), P.none);
      }, Yx = (e, t) => K(e, t) === null, BD = (e, t, o) => hp(e, t, o).filter(ue(Yx, t)), $D = (e, t, o) => {
        const r = NM(o);
        return BD(e, t, r).bind((c) => y(c, r).isNone() ? P.some(fa.start(c)) : P.none());
      }, A$ = (e, t, o) => {
        const r = RM(o);
        return BD(e, t, r).bind((c) => p(c, r).isNone() ? P.some(fa.end(c)) : P.none());
      }, _$ = (e, t, o) => {
        const r = NM(o), c = i4(t, r.container());
        return hp(e, c, r).fold(() => y(c, r).bind(ue(hp, e, c)).map((u) => fa.after(u)), P.none);
      }, O$ = (e) => !UA(ID(e)), zm = (e, t, o) => T$([
        k$,
        $D,
        A$,
        _$
      ], [e, t, o]).filter(O$), ID = (e) => e.fold(
        jo,
        // Before
        jo,
        // Start
        jo,
        // End
        jo
        // After
      ), D$ = (e) => e.fold(
        ot("before"),
        // Before
        ot("start"),
        // Start
        ot("end"),
        // End
        ot("after")
        // After
      ), u4 = (e) => e.fold(
        fa.before,
        // Before
        fa.before,
        // Start
        fa.after,
        // End
        fa.after
        // After
      ), FD = (e) => e.fold(
        fa.start,
        // Before
        fa.start,
        // Start
        fa.end,
        // End
        fa.end
        // After
      ), LD = (e, t) => D$(e) === D$(t) && ID(e) === ID(t), oW = (e, t, o, r, c, u) => Xs(hp(t, o, r), hp(t, o, c), (f, b) => f !== b && jH(o, f, b) ? fa.after(e ? f : b) : u).getOr(u), R$ = (e, t) => e.fold(He, (o) => !LD(o, t)), sW = (e, t, o, r, c) => {
        const u = Wu(e, c);
        return Zl(e, o, u).map(ue(Wu, e)).fold(() => r.map(u4), (v) => zm(t, o, v).map(ue(oW, e, t, o, u, v)).filter(ue(R$, r))).filter(O$);
      }, rW = (e, t) => e ? t.fold(
        A(P.some, fa.start),
        // Before -> Start
        P.none,
        A(P.some, fa.after),
        // End -> After
        P.none
      ) : t.fold(
        P.none,
        A(P.some, fa.before),
        // Before <- Start
        P.none,
        A(P.some, fa.end)
        // End <- After
      ), aW = (e, t, o, r) => {
        const c = Wu(e, r), u = zm(t, o, c);
        return zm(t, o, c).bind(ue(rW, e)).orThunk(() => sW(e, t, o, u, r));
      }, cW = (e) => se(e.selection.getSel().modify), N$ = (e, t, o) => {
        const r = e ? 1 : -1;
        return t.setRng(Re(o.container(), o.offset() + r).toRange()), t.getSel().modify("move", e ? "forward" : "backward", "word"), !0;
      }, lW = (e, t) => {
        const o = t.selection.getRng(), r = e ? Re.fromRangeEnd(o) : Re.fromRangeStart(o);
        return cW(t) ? e && pm(r) ? N$(!0, t.selection, r) : !e && Ag(r) ? N$(!1, t.selection, r) : !1 : !1;
      };
      var Vf;
      (function(e) {
        e[e.Br = 0] = "Br", e[e.Block = 1] = "Block", e[e.Wrap = 2] = "Wrap", e[e.Eol = 3] = "Eol";
      })(Vf || (Vf = {}));
      const d4 = (e, t) => e === -1 ? ds(t) : t, iW = (e, t, o) => e === 1 ? t.next(o) : t.prev(o), uW = (e, t, o, r) => zs(r.getNode(
        t === 1
        /* HDirection.Forwards */
      )) ? Vf.Br : Rd(o, r) === !1 ? Vf.Block : Vf.Wrap, M$ = (e, t, o, r) => {
        const c = Uu(o);
        let u = r;
        const f = [];
        for (; u; ) {
          const b = iW(t, c, u);
          if (!b)
            break;
          if (zs(b.getNode(!1)))
            return t === 1 ? { positions: d4(t, f).concat([b]), breakType: Vf.Br, breakAt: P.some(b) } : { positions: d4(t, f), breakType: Vf.Br, breakAt: P.some(b) };
          if (!b.isVisible()) {
            u = b;
            continue;
          }
          if (e(u, b)) {
            const v = uW(o, t, u, b);
            return { positions: d4(t, f), breakType: v, breakAt: P.some(b) };
          }
          f.push(b), u = b;
        }
        return { positions: d4(t, f), breakType: Vf.Eol, breakAt: P.none() };
      }, HD = (e, t, o, r) => t(o, r).breakAt.map((c) => {
        const u = t(o, c).positions;
        return e === -1 ? u.concat(c) : [c].concat(u);
      }).getOr([]), zD = (e, t) => Io(e, (o, r) => o.fold(() => P.some(r), (c) => Xs(js(c.getClientRects()), js(r.getClientRects()), (u, f) => {
        const b = Math.abs(t - u.left);
        return Math.abs(t - f.left) <= b ? r : c;
      }).or(o)), P.none()), Bb = (e, t) => js(t.getClientRects()).bind((o) => zD(e, o.left)), Oa = ue(M$, Re.isAbove, -1), Xx = ue(M$, Re.isBelow, 1), Qx = ue(HD, -1, Oa), Op = ue(HD, 1, Xx), m4 = (e, t) => Oa(e, t).breakAt.isNone(), Cl = (e, t) => Xx(e, t).breakAt.isNone(), $b = (e) => E(e).map((t) => [t].concat(Xx(e, t).positions)).getOr([]), P$ = (e) => D(e).map((t) => Oa(e, t).positions.concat(t)).getOr([]), B$ = (e, t) => Bb(Qx(e, t), t), VD = (e, t) => Bb(Op(e, t), t), dW = Es, UD = (e, t) => Math.abs(e.left - t), f4 = (e, t) => Math.abs(e.right - t), jD = (e) => Zo(e, "node"), $$ = (e, t) => Bi(e, (o, r) => {
        const c = Math.min(UD(o, t), f4(o, t)), u = Math.min(UD(r, t), f4(r, t));
        return u === c && jD(r) && dW(r.node) || u < c ? r : o;
      }), mW = (e) => {
        const t = (o) => en(o, (r) => {
          const c = Cf(r);
          return c.node = e, c;
        });
        if (ht(e))
          return t(e.getClientRects());
        if (tt(e)) {
          const o = e.ownerDocument.createRange();
          return o.setStart(e, 0), o.setEnd(e, e.data.length), t(o.getClientRects());
        } else
          return [];
      }, WD = (e) => xo(e, mW);
      var xl;
      (function(e) {
        e[e.Up = -1] = "Up", e[e.Down = 1] = "Down";
      })(xl || (xl = {}));
      const ZD = (e, t, o, r) => {
        let c = r;
        for (; c = ob(c, e, V0, t); )
          if (o(c))
            return;
      }, I$ = (e, t, o, r, c, u) => {
        let f = 0;
        const b = [], v = (R) => {
          let M = WD([R]);
          e === xl.Up && (M = M.reverse());
          for (let H = 0; H < M.length; H++) {
            const J = M[H];
            if (!o(J, S)) {
              if (b.length > 0 && t(J, ol(b)) && f++, J.line = f, c(J))
                return !0;
              b.push(J);
            }
          }
          return !1;
        }, S = ol(u.getClientRects());
        if (!S)
          return b;
        const O = u.getNode();
        return O && (v(O), ZD(e, r, v, O)), b;
      }, g4 = (e, t) => t.line > e, GD = (e, t) => t.line === e, F$ = ue(I$, xl.Up, Og, xf), L$ = ue(I$, xl.Down, xf, Og), qD = (e) => ol(e.getClientRects()), fW = (e, t, o, r) => {
        const c = Uu(t);
        let u, f, b, v;
        const S = [];
        let O = 0;
        e === xl.Down ? (u = c.next, f = xf, b = Og, v = Re.after(r)) : (u = c.prev, f = Og, b = xf, v = Re.before(r));
        const R = qD(v);
        do {
          if (!v.isVisible())
            continue;
          const M = qD(v);
          if (b(M, R))
            continue;
          S.length > 0 && f(M, ol(S)) && O++;
          const H = Cf(M);
          if (H.position = v, H.line = O, o(H))
            return S;
          S.push(H);
        } while (v = u(v));
        return S;
      }, H$ = (e) => (t) => g4(e, t), KD = (e) => (t) => GD(e, t), Uf = (e, t) => {
        e.selection.setRng(t), ru(e, e.selection.getRng());
      }, YD = (e, t, o) => P.some(oh(e, t, o)), XD = (e, t) => {
        const o = e.getNode(
          t === -1
          /* HDirection.Backwards */
        );
        return X(o) && Wr(o) ? P.some(o) : P.none();
      }, z$ = (e, t) => {
        const o = e.dom.createRng();
        return o.selectNode(t), o;
      }, V$ = (e, t, o, r, c, u) => {
        const f = t === 1, b = Uu(e.getBody()), v = ue(Ov, f ? b.next : b.prev), S = f ? r : c;
        if (!o.collapsed) {
          const J = jr(o);
          if (u(J))
            if (Wr(J)) {
              const W = Rf(t, e.getBody(), o);
              return P.from(v(W)).map((Q) => Q.toRange());
            } else
              return nh(t, e, J, t === -1, !1);
          else if (kD(e)) {
            const W = o.cloneRange();
            return W.collapse(
              t === -1
              /* HDirection.Backwards */
            ), P.from(W);
          }
        }
        const O = Rf(t, e.getBody(), o);
        if (S(O))
          return zf(e, O.getNode(!f));
        let R = v(O);
        const M = F0(o);
        if (R)
          R = Wu(f, R);
        else
          return M ? P.some(o) : P.none();
        if (S(R))
          return XD(R, t).fold(() => nh(t, e, R?.getNode(!f), f, !1), (J) => P.some(z$(e, J)));
        const H = v(R);
        return H && S(H) && Vu(R, H) ? XD(R, t).fold(() => nh(t, e, H.getNode(!f), f, !1), (J) => P.some(z$(e, J))) : M ? YD(e, R.toRange(), !1) : P.none();
      }, U$ = (e, t, o, r, c, u) => {
        const f = Rf(t, e.getBody(), o), b = ol(f.getClientRects()), v = t === xl.Down, S = e.getBody();
        if (!b)
          return P.none();
        if (kD(e)) {
          const Q = v ? Re.fromRangeEnd(o) : Re.fromRangeStart(o);
          return (v ? VD : B$)(S, Q).orThunk(() => P.from(Q)).map((be) => be.toRange());
        }
        const R = (v ? L$ : F$)(S, H$(1), f), M = ze(R, KD(1)), H = b.left, J = $$(M, H);
        if (J && u(J.node)) {
          const Q = Math.abs(H - J.left), ge = Math.abs(H - J.right);
          return nh(t, e, J.node, Q < ge, !1);
        }
        let W;
        if (r(f) ? W = f.getNode() : c(f) ? W = f.getNode(!0) : W = jr(o), W) {
          const Q = fW(t, S, H$(1), W);
          let ge = $$(ze(Q, KD(1)), H);
          if (ge || (ge = ol(ze(Q, KD(0))), ge))
            return YD(e, ge.position.toRange(), !1);
        }
        return M.length === 0 ? h4(e, v).filter(v ? c : r).map((Q) => oh(e, Q.toRange(), !1)) : P.none();
      }, h4 = (e, t) => {
        const o = e.selection.getRng(), r = t ? Re.fromRangeEnd(o) : Re.fromRangeStart(o), c = Tv(r.container(), e.getBody());
        if (t) {
          const u = Xx(c, r);
          return dr(u.positions);
        } else {
          const u = Oa(c, r);
          return js(u.positions);
        }
      }, p4 = (e, t, o) => h4(e, t).filter(o).exists((r) => (e.selection.setRng(r.toRange()), !0)), fy = (e, t) => {
        const o = e.dom.createRng();
        o.setStart(t.container(), t.offset()), o.setEnd(t.container(), t.offset()), e.selection.setRng(o);
      }, QD = (e, t) => {
        e ? t.setAttribute("data-mce-selected", "inline-boundary") : t.removeAttribute("data-mce-selected");
      }, b4 = (e, t, o) => PD(t, o).map((r) => (fy(e, r), o)), j$ = (e, t, o) => {
        const r = Re.fromRangeStart(e);
        if (e.collapsed)
          return r;
        {
          const c = Re.fromRangeEnd(e);
          return o ? y(t, c).getOr(c) : p(t, r).getOr(r);
        }
      }, W$ = (e, t, o) => {
        const r = e.getBody(), c = j$(e.selection.getRng(), r, o), u = ue(db, e);
        return aW(o, u, r, c).bind((b) => b4(e, t, b));
      }, JD = (e, t, o) => {
        const r = en(Ne(te.fromDom(t.getRoot()), '*[data-mce-selected="inline-boundary"]'), (f) => f.dom), c = ze(r, e), u = ze(o, e);
        xe(Bs(c, u), ue(QD, !1)), xe(Bs(u, c), ue(QD, !0));
      }, Z$ = (e, t) => {
        const o = t.get();
        if (e.selection.isCollapsed() && !e.composing && o) {
          const r = Re.fromRangeStart(e.selection.getRng());
          Re.isTextPosition(r) && !WH(r) && (fy(e, Zk(o, r)), t.set(null));
        }
      }, G$ = (e, t, o, r) => {
        if (t.selection.isCollapsed()) {
          const c = ze(r, e);
          xe(c, (u) => {
            const f = Re.fromRangeStart(t.selection.getRng());
            zm(e, t.getBody(), f).bind((b) => b4(t, o, b));
          });
        }
      }, eR = (e, t, o) => _f(e) ? W$(e, t, o).isSome() : !1, q$ = (e, t, o) => _f(t) ? lW(e, t) : !1, gW = (e) => {
        const t = Wt(null), o = ue(db, e);
        return e.on("NodeChange", (r) => {
          _f(e) && (JD(o, e.dom, r.parents), Z$(e, t), G$(o, e, t, r.parents));
        }), t;
      }, v4 = ue(q$, !0), hW = ue(q$, !1), Dp = (e, t, o) => {
        if (_f(e)) {
          const r = h4(e, t).getOrThunk(() => {
            const c = e.selection.getRng();
            return t ? Re.fromRangeEnd(c) : Re.fromRangeStart(c);
          });
          return zm(ue(db, e), e.getBody(), r).exists((c) => {
            const u = u4(c);
            return PD(o, u).exists((f) => (fy(e, f), !0));
          });
        } else
          return !1;
      }, pW = (e, t) => {
        const o = document.createRange();
        return o.setStart(e.container(), e.offset()), o.setEnd(t.container(), t.offset()), o;
      }, bW = (e) => Xs(E(e), D(e), (t, o) => {
        const r = Wu(!0, t), c = Wu(!1, o);
        return p(e, r).forall((u) => u.isEqual(c));
      }).getOr(!0), K$ = (e, t) => (o) => PD(t, o).map((r) => () => fy(e, r)), Y$ = (e, t, o, r) => {
        const c = e.getBody(), u = ue(db, e);
        e.undoManager.ignore(() => {
          e.selection.setRng(pW(o, r)), WA(e), zm(u, c, Re.fromRangeStart(e.selection.getRng())).map(FD).bind(K$(e, t)).each(Fn);
        }), e.nodeChanged();
      }, X$ = (e, t) => {
        const o = Of(t, e);
        return o || e;
      }, Q$ = (e, t, o, r) => {
        const c = X$(e.getBody(), r.container()), u = ue(db, e), f = zm(u, c, r);
        return f.bind((v) => o ? v.fold(
          ot(P.some(FD(v))),
          // Before
          P.none,
          // Start
          ot(P.some(u4(v))),
          // End
          P.none
          // After
        ) : v.fold(
          P.none,
          // Before
          ot(P.some(u4(v))),
          // Start
          P.none,
          // End
          ot(P.some(FD(v)))
          // After
        )).map(K$(e, t)).getOrThunk(() => {
          const v = dp(o, c, r), S = v.bind((O) => zm(u, c, O));
          return Xs(f, S, () => hp(u, c, r).bind((O) => bW(O) ? P.some(() => {
            $f(e, o, te.fromDom(O));
          }) : P.none())).getOrThunk(() => S.bind(() => v.map((O) => () => {
            o ? Y$(e, t, r, O) : Y$(e, t, O, r);
          })));
        });
      }, tR = (e, t, o) => {
        if (e.selection.isCollapsed() && _f(e)) {
          const r = Re.fromRangeStart(e.selection.getRng());
          return Q$(e, t, o, r);
        }
        return P.none();
      }, vW = (e) => fd(e) > 1, J$ = (e, t) => {
        const o = te.fromDom(e.getBody()), r = te.fromDom(e.selection.getStart()), c = Id(r, o);
        return Ql(c, t).fold(ot(c), (u) => c.slice(0, u));
      }, yW = (e) => fd(e) === 1, CW = (e) => J$(e, (t) => e.schema.isBlock(Hn(t)) || vW(t)), eI = (e) => J$(e, (t) => e.schema.isBlock(Hn(t))), xW = (e, t) => {
        const o = ue(aP, e);
        return xo(t, (r) => o(r) ? [r.dom] : []);
      }, nR = (e) => {
        const t = eI(e);
        return xW(e, t);
      }, SW = (e, t, o, r) => {
        const c = xW(t, r);
        if (c.length === 0)
          $f(t, e, o);
        else {
          const u = i_(o.dom, c);
          t.selection.setRng(u.toRange());
        }
      }, wW = (e, t) => {
        const o = ze(CW(e), yW);
        return dr(o).bind((r) => {
          const c = Re.fromRangeStart(e.selection.getRng());
          return BM(t, c, r.dom) && !iA(r) ? P.some(() => SW(t, e, r, o)) : P.none();
        });
      }, EW = (e, t) => {
        const o = t.parentElement;
        return zs(t) && !oe(o) && e.dom.isEmpty(o);
      }, TW = (e) => iA(te.fromDom(e)), tI = (e, t) => {
        const o = e.selection.getStart(), r = EW(e, o) || TW(o) ? i_(o, t) : yz(e.selection.getRng(), t);
        e.selection.setRng(r.toRange());
      }, nI = (e, t) => {
        const o = Bs(t, nR(e));
        o.length > 0 && tI(e, o);
      }, oR = (e) => tt(e.startContainer), kW = (e) => e.startOffset === 0 && oR(e), AW = (e, t) => {
        const o = t.startContainer.parentElement;
        return !oe(o) && aP(e, te.fromDom(o));
      }, _W = (e) => {
        const t = e.startContainer.parentNode, o = e.endContainer.parentNode;
        return !oe(t) && !oe(o) && t.isEqualNode(o);
      }, OW = (e) => {
        const t = e.endContainer;
        return e.endOffset === (tt(t) ? t.length : t.childNodes.length);
      }, DW = (e) => _W(e) && OW(e), RW = (e) => !e.endContainer.isEqualNode(e.commonAncestorContainer), NW = (e) => DW(e) || RW(e), MW = (e) => {
        const t = e.selection.getRng();
        return kW(t) && AW(e, t) && NW(t);
      }, PW = (e) => {
        if (MW(e)) {
          const t = nR(e);
          return P.some(() => {
            WA(e), nI(e, t);
          });
        } else
          return P.none();
      }, sR = (e, t) => e.selection.isCollapsed() ? wW(e, t) : PW(e), oI = (e, t) => ft(e, (o) => z(o.dom), (o) => t.isBlock(Hn(o))), BW = (e) => oI(te.fromDom(e.selection.getStart()), e.schema), $W = (e) => {
        const t = e.selection.getRng();
        return t.collapsed && (oR(t) || e.dom.isEmpty(t.startContainer)) && !BW(e);
      }, Jx = (e) => ($W(e) && tI(e, []), !0), gy = (e, t, o) => X(o) ? P.some(() => {
        e._selectionOverrides.hideFakeCaret(), $f(e, t, te.fromDom(o));
      }) : P.none(), IW = (e, t) => {
        const o = t ? tx : nx, c = Rf(t ? 1 : -1, e.getBody(), e.selection.getRng());
        return o(c) ? gy(e, t, c.getNode(!t)) : P.from(Wu(t, c)).filter((u) => o(u) && Vu(c, u)).bind((u) => gy(e, t, u.getNode(!t)));
      }, FW = (e, t) => {
        const o = e.selection.getNode();
        return vi(o) ? gy(e, t, o) : P.none();
      }, y4 = (e, t) => e.selection.isCollapsed() ? IW(e, t) : FW(e, t), rR = (e) => Uo(e, (t) => dl(t.dom) || Es(t.dom)).exists((t) => dl(t.dom)), aR = (e) => Jf(e ?? "").getOr(0), sI = (e, t) => {
        const o = e || uw(t) ? "margin" : "padding", r = Ls(t, "direction") === "rtl" ? "-right" : "-left";
        return o + r;
      }, pX = (e, t, o, r, c, u) => {
        const f = sI(o, te.fromDom(u)), b = aR(e.getStyle(u, f));
        if (t === "outdent") {
          const v = Math.max(0, b - r);
          e.setStyle(u, f, v ? v + c : "");
        } else {
          const v = b + r + c;
          e.setStyle(u, f, v);
        }
      }, LW = (e, t) => qa(t, (o) => {
        const r = sI(mv(e), o), c = rr(o, r).map(aR).getOr(0);
        return e.dom.getContentEditable(o.dom) !== "false" && c > 0;
      }), rI = (e) => {
        const t = aI(e);
        return !e.mode.isReadOnly() && (t.length > 1 || LW(e, t));
      }, HW = (e) => !e.mode.isReadOnly() && uj(e), hy = (e) => xi(e) || Ec(e), zW = (e) => ec(e).exists(hy), aI = (e) => ze(pd(e.selection.getSelectedBlocks()), (t) => !hy(t) && !zW(t) && rR(t)), cI = (e, t) => {
        if (e.mode.isReadOnly())
          return;
        const { dom: o } = e, r = Ek(e), c = /[a-z%]+$/i.exec(r)?.[0] ?? "px", u = aR(r), f = mv(e);
        xe(aI(e), (b) => {
          pX(o, t, f, u, c, b.dom);
        }), t === "indent" ? s$(e) : Wx(e);
      }, lI = (e) => cI(e, "indent"), sh = (e) => cI(e, "outdent"), Sl = (e) => {
        if (e.selection.isCollapsed() && rI(e)) {
          const t = e.dom, o = e.selection.getRng(), r = Re.fromRangeStart(o), c = t.getParent(o.startContainer, t.isBlock);
          if (c !== null && YE(te.fromDom(c), r, e.schema))
            return P.some(() => sh(e));
        }
        return P.none();
      }, iI = (e, t) => {
        const o = E_(e.selection.getRng());
        return b7(o) ? P.some(() => $f(e, t, te.fromDom(e.selection.getNode()))) : P.none();
      }, Ib = (e, t) => e.selection.isCollapsed() ? P.none() : iI(e, t), rh = (e, t, o) => cc([
        Sl,
        a4,
        r4,
        (r, c) => tR(r, t, c),
        Nb,
        e_,
        l4,
        y4,
        yr,
        sR,
        c4,
        Ib
      ], (r) => r(e, o)).filter((r) => e.selection.isEditable()), Zd = (e, t) => {
        rh(e, t, !1).fold(() => {
          e.selection.isEditable() && (WA(e), PM(e));
        }, Fn), vD(e) && eD(e.dom, e.getBody());
      }, eS = (e, t) => {
        rh(e, t, !0).fold(() => {
          e.selection.isEditable() && ZH(e);
        }, Fn), vD(e) && eD(e.dom, e.getBody());
      }, cR = (e, t) => {
        e.addCommand("delete", () => {
          Zd(e, t);
        }), e.addCommand("forwardDelete", () => {
          eS(e, t);
        });
      }, C4 = 5, uI = 400, lR = (e) => e.touches === void 0 || e.touches.length !== 1 ? P.none() : P.some(e.touches[0]), VW = (e, t) => {
        const o = Math.abs(e.clientX - t.x), r = Math.abs(e.clientY - t.y);
        return o > C4 || r > C4;
      }, UW = (e) => {
        const t = Mc(), o = Wt(!1), r = ni((c) => {
          e.dispatch("longpress", { ...c, type: "longpress" }), o.set(!0);
        }, uI);
        e.on("touchstart", (c) => {
          lR(c).each((u) => {
            r.cancel();
            const f = {
              x: u.clientX,
              y: u.clientY,
              target: c.target
            };
            r.throttle(c), o.set(!1), t.set(f);
          });
        }, !0), e.on("touchmove", (c) => {
          r.cancel(), lR(c).each((u) => {
            t.on((f) => {
              VW(u, f) && (t.clear(), o.set(!1), e.dispatch("longpresscancel"));
            });
          });
        }, !0), e.on("touchend touchcancel", (c) => {
          r.cancel(), c.type !== "touchcancel" && t.get().filter((u) => u.target.isEqualNode(c.target)).each(() => {
            o.get() ? c.preventDefault() : e.dispatch("tap", { ...c, type: "tap" });
          });
        }, !0);
      }, x4 = (e, t) => kn(e, t.nodeName), dI = (e, t) => tt(t) ? !0 : ht(t) ? !x4(e.getBlockElements(), t) && !Ys(t) && !qs(e, t) && !Dh(t) && !d2(t) : !1, mI = (e, t, o) => po(uM(te.fromDom(o), te.fromDom(t)), (r) => x4(e, r.dom)), jW = (e, t) => {
        if (tt(t)) {
          if (t.data.length === 0)
            return !0;
          if (/^\s+$/.test(t.data))
            return !t.nextSibling || x4(e, t.nextSibling) || Dh(t.nextSibling);
        }
        return !1;
      }, fI = (e) => e.dom.create(Ar(e), nu(e)), bX = (e) => {
        const t = e.dom, o = e.selection, r = e.schema, c = r.getBlockElements(), u = o.getStart(), f = e.getBody();
        let b, v, S = null;
        const O = Ar(e);
        if (!u || !ht(u))
          return;
        const R = f.nodeName.toLowerCase();
        if (!r.isValidChild(R, O.toLowerCase()) || mI(c, f, u))
          return;
        if (f.firstChild === f.lastChild && zs(f.firstChild)) {
          b = fI(e), b.appendChild(bf().dom), f.replaceChild(b, f.firstChild), e.selection.setCursorLocation(b, 0), e.nodeChanged();
          return;
        }
        let M = f.firstChild;
        for (; M; )
          if (ht(M) && xc(r, M), dI(r, M)) {
            if (jW(c, M)) {
              v = M, M = M.nextSibling, t.remove(v);
              continue;
            }
            if (!b) {
              if (!S && e.hasFocus() && (S = If(e.selection.getRng(), () => document.createElement("span"))), !M.parentNode) {
                M = null;
                break;
              }
              b = fI(e), f.insertBefore(b, M);
            }
            v = M, M = M.nextSibling, b.appendChild(v);
          } else
            b = null, M = M.nextSibling;
        S && (e.selection.setRng(Zu(S)), e.nodeChanged());
      }, WW = (e, t, o) => {
        const r = te.fromDom(fI(e)), c = bf();
        bo(r, c), o(t, r);
        const u = document.createRange();
        return u.setStartBefore(c.dom), u.setEndBefore(c.dom), u;
      }, Gd = (e) => {
        e.on("NodeChange", () => bX(e));
      }, gI = (e) => (t) => (" " + t.attr("class") + " ").indexOf(e) !== -1, ZW = (e, t, o) => function(r) {
        const c = arguments, u = c[c.length - 2], f = u > 0 ? t.charAt(u - 1) : "";
        if (f === '"')
          return r;
        if (f === ">") {
          const b = t.lastIndexOf("<", u);
          if (b !== -1 && t.substring(b, u).indexOf('contenteditable="false"') !== -1)
            return r;
        }
        return '<span class="' + o + '" data-mce-content="' + e.dom.encode(c[0]) + '">' + e.dom.encode(typeof c[1] == "string" ? c[1] : c[0]) + "</span>";
      }, Fb = (e, t, o) => {
        let r = t.length, c = o.content;
        if (o.format !== "raw") {
          for (; r--; )
            c = c.replace(t[r], ZW(e, c, X1(e)));
          o.content = c;
        }
      }, hI = (e, t) => qa(e, (o) => {
        const r = t.match(o);
        return r !== null && r[0].length === t.length;
      }), GW = (e) => {
        const t = "contenteditable", o = " " + Je.trim(cE(e)) + " ", r = " " + Je.trim(X1(e)) + " ", c = gI(o), u = gI(r), f = jk(e);
        f.length > 0 && e.on("BeforeSetContent", (b) => {
          Fb(e, f, b);
        }), e.parser.addAttributeFilter("class", (b) => {
          let v = b.length;
          for (; v--; ) {
            const S = b[v];
            c(S) ? S.attr(t, "true") : u(S) && S.attr(t, "false");
          }
        }), e.serializer.addAttributeFilter(t, (b) => {
          let v = b.length;
          for (; v--; ) {
            const S = b[v];
            if (!c(S) && !u(S))
              continue;
            const O = S.attr("data-mce-content");
            f.length > 0 && O ? hI(f, O) ? (S.name = "#text", S.type = 3, S.raw = !0, S.value = O) : S.remove() : S.attr(t, null);
          }
        });
      }, S4 = (e) => Zi(te.fromDom(e.getBody()), "*[data-mce-caret]").map((t) => t.dom).getOrNull(), w4 = (e, t) => {
        t.hasAttribute("data-mce-caret") && (Qi(t), e.selection.setRng(e.selection.getRng()), e.selection.scrollIntoView(t));
      }, pI = (e, t) => {
        const o = S4(e);
        if (o) {
          if (t.type === "compositionstart") {
            t.preventDefault(), t.stopPropagation(), w4(e, o);
            return;
          }
          I0(o) && (w4(e, o), e.undoManager.add());
        }
      }, bI = (e) => {
        e.on("keyup compositionstart", ue(pI, e));
      }, vI = Es, yI = (e, t, o) => V$(t, e, o, Zg, Bf, vI), CI = (e, t, o) => U$(t, e, o, (u) => Zg(u) || ox(u), (u) => Bf(u) || BA(u), vI), xI = (e) => {
        const t = e.dom.create(Ar(e));
        return t.innerHTML = '<br data-mce-bogus="1">', t;
      }, E4 = (e, t, o) => {
        const r = Uu(e.getBody()), c = ue(Ov, t === 1 ? r.next : r.prev);
        if (o.collapsed) {
          const u = e.dom.getParent(o.startContainer, "PRE");
          if (!u)
            return;
          if (!c(Re.fromRangeStart(o))) {
            const b = te.fromDom(xI(e));
            t === 1 ? cl(te.fromDom(u), b) : ca(te.fromDom(u), b), e.selection.select(b.dom, !0), e.selection.collapse();
          }
        }
      }, qW = (e, t) => {
        const o = t ? 1 : -1, r = e.selection.getRng();
        return yI(o, e, r).orThunk(() => (E4(e, o, r), P.none()));
      }, KW = (e, t) => {
        const o = t ? 1 : -1, r = e.selection.getRng();
        return CI(o, e, r).orThunk(() => (E4(e, o, r), P.none()));
      }, YW = (e, t) => {
        const o = t ? e.getEnd(!0) : e.getStart(!0);
        return UA(o) ? !t : t;
      }, SI = (e, t) => qW(e, YW(e.selection, t)).exists((o) => (Uf(e, o), !0)), wI = (e, t) => KW(e, t).exists((o) => (Uf(e, o), !0)), EI = (e, t) => p4(e, t, t ? Bf : Zg), T4 = (e, t) => TD(e, !t).map((o) => {
        const r = o.toRange(), c = e.selection.getRng();
        return t ? r.setStart(c.startContainer, c.startOffset) : r.setEnd(c.endContainer, c.endOffset), r;
      }).exists((o) => (Uf(e, o), !0)), TI = (e, t) => {
        const o = (f) => Qn(f, t), r = (f) => dl(f.dom), c = te.fromDom(e.container());
        return Uo(c, r, o).filter((f) => !o(f));
      }, kI = (e, t, o) => (o ? VD : B$)(e.getBody(), t).map((c) => c.toRange()), XW = (e, t) => {
        const o = Re.fromRangeStart(e.selection.getRng()), r = Re.fromRangeEnd(e.selection.getRng()), c = te.fromDom(e.getBody());
        return ld(Xs(TI(o, c), TI(r, c), (f, b) => Qn(f, b) ? P.some(f) : P.none())).fold(ye, (f) => t && Cl(f.dom, r) || !t && m4(f.dom, o) ? kI(e, t ? r : o, t).exists((b) => (Uf(e, b), !0)) : !1);
      }, jf = (e, t) => XW(e, t), iR = (e) => Lt(["figcaption"], Hn(e)), QW = (e, t, o) => {
        const r = ue(Qn, t);
        return Uo(te.fromDom(e.container()), (c) => o.isBlock(Hn(c)), r).filter(iR);
      }, JW = (e, t, o) => t ? Cl(e.dom, o) : m4(e.dom, o), eZ = (e, t) => {
        const o = te.fromDom(e.getBody()), r = Re.fromRangeStart(e.selection.getRng());
        return QW(r, o, e.schema).exists(() => {
          if (JW(o, t, r)) {
            const u = WW(e, o, t ? bo : zi);
            return e.selection.setRng(u), !0;
          } else
            return !1;
        });
      }, k4 = (e, t) => e.selection.isCollapsed() ? eZ(e, t) : !1, uR = (e, t, o) => {
        const r = e.selection.getRng(), c = Re.fromRangeStart(r);
        return e.getBody().firstChild === t && m4(o, c) ? (e.execCommand("InsertNewBlockBefore"), !0) : !1;
      }, AI = (e, t) => {
        const o = e.selection.getRng(), r = Re.fromRangeStart(o);
        return e.getBody().lastChild === t && Cl(t, r) ? (e.execCommand("InsertNewBlockAfter"), !0) : !1;
      }, _I = (e, t) => t ? P.from(e.dom.getParent(e.selection.getNode(), "details")).map((o) => AI(e, o)).getOr(!1) : P.from(e.dom.getParent(e.selection.getNode(), "summary")).bind((o) => P.from(e.dom.getParent(o, "details")).map((r) => uR(e, r, o))).getOr(!1), dR = (e, t) => _I(e, t), OI = {
        shiftKey: !1,
        altKey: !1,
        ctrlKey: !1,
        metaKey: !1,
        keyCode: 0
      }, tS = (e) => en(e, (t) => ({
        ...OI,
        ...t
      })), A4 = (e) => en(e, (t) => ({
        ...OI,
        ...t
      })), mR = (e, t) => t.keyCode === e.keyCode && t.shiftKey === e.shiftKey && t.altKey === e.altKey && t.ctrlKey === e.ctrlKey && t.metaKey === e.metaKey, DI = (e, t) => xo(tS(e), (o) => mR(o, t) ? [o] : []), RI = (e, t) => xo(A4(e), (o) => mR(o, t) ? [o] : []), yn = (e, ...t) => () => e.apply(null, t), Rp = (e, t) => _o(DI(e, t), (o) => o.action()), _4 = (e, t) => cc(RI(e, t), (o) => o.action()), py = (e, t) => {
        const o = t ? 1 : -1, r = e.selection.getRng();
        return V$(e, o, r, tx, nx, vi).exists((c) => (Uf(e, c), !0));
      }, NI = (e, t) => {
        const o = t ? 1 : -1, r = e.selection.getRng();
        return U$(e, o, r, tx, nx, vi).exists((c) => (Uf(e, c), !0));
      }, fR = (e, t) => p4(e, t, t ? nx : tx), tZ = (e, t) => MI(e, t, He), MI = (e, t, o) => xo(Os(e), (r) => Ic(r, t) ? o(r) ? [r] : [] : MI(r, t, o)), PI = (e, t, o = ye) => {
        if (o(t))
          return P.none();
        if (Lt(e, Hn(t)))
          return P.some(t);
        const r = (c) => Ic(c, "table") || o(c);
        return ar(t, e.join(","), r);
      }, nZ = (e, t) => PI(["td", "th"], e, t), BI = (e) => tZ(e, "th,td"), oZ = (e, t) => ia(e, "table", t), $I = el.generate([
        { none: ["current"] },
        { first: ["current"] },
        { middle: ["current", "target"] },
        { last: ["current"] }
      ]), nS = {
        ...$I,
        none: (e) => $I.none(e)
      }, gR = (e, t, o, r, c = He) => {
        const u = r === 1;
        if (!u && o <= 0)
          return nS.first(e[0]);
        if (u && o >= e.length - 1)
          return nS.last(e[e.length - 1]);
        {
          const f = o + r, b = e[f];
          return c(b) ? nS.middle(t, b) : gR(e, t, f, r, c);
        }
      }, II = (e, t) => oZ(e, t).bind((o) => {
        const r = BI(o);
        return Ql(r, (u) => Qn(e, u)).map((u) => ({ index: u, all: r }));
      }), sZ = (e, t, o) => II(e, o).fold(() => nS.none(e), (c) => gR(c.all, e, c.index, 1, t)), rZ = (e, t, o) => II(e, o).fold(() => nS.none(), (c) => gR(c.all, e, c.index, -1, t));
      var hR = [
        "body",
        "p",
        "div",
        "article",
        "aside",
        "figcaption",
        "figure",
        "footer",
        "header",
        "nav",
        "section",
        "ol",
        "ul",
        "li",
        "table",
        "thead",
        "tbody",
        "tfoot",
        "caption",
        "tr",
        "td",
        "th",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "blockquote",
        "pre",
        "address"
      ], aZ = () => {
        const e = (S) => te.fromDom(S.dom.cloneNode(!1)), t = (S) => Pl(S).dom, o = (S) => Is(S) ? Hn(S) === "body" ? !0 : Lt(hR, Hn(S)) : !1, r = (S) => Is(S) ? Lt(["br", "img", "hr", "input"], Hn(S)) : !1, c = (S) => Is(S) && gs(S, "contenteditable") === "false", u = (S, O) => S.dom.compareDocumentPosition(O.dom), f = (S, O) => {
          const R = Kn(S);
          ea(O, R);
        }, b = (S) => {
          const O = Hn(S);
          return Lt([
            "script",
            "noscript",
            "iframe",
            "noframes",
            "noembed",
            "title",
            "style",
            "textarea",
            "xmp"
          ], O);
        }, v = (S) => Is(S) ? il(S, "lang") : P.none();
        return {
          up: ot({
            selector: ar,
            closest: ia,
            predicate: Wi,
            all: ya
          }),
          down: ot({
            selector: Ne,
            predicate: q
          }),
          styles: ot({
            get: Ls,
            getRaw: rr,
            set: Ca,
            remove: bh
          }),
          attrs: ot({
            get: gs,
            set: Ss,
            remove: sr,
            copyTo: f
          }),
          insert: ot({
            before: ca,
            after: cl,
            afterAll: lg,
            append: bo,
            appendAll: ll,
            prepend: zi,
            wrap: Lc
          }),
          remove: ot({
            unwrap: hc,
            remove: qo
          }),
          create: ot({
            nu: te.fromTag,
            clone: e,
            text: te.fromText
          }),
          query: ot({
            comparePosition: u,
            prevSibling: rl,
            nextSibling: tc
          }),
          property: ot({
            children: Os,
            name: Hn,
            parent: ec,
            document: t,
            isText: Eo,
            isComment: ci,
            isElement: Is,
            isSpecial: b,
            getLanguage: v,
            getText: xa,
            setText: s1,
            isBoundary: o,
            isEmptyTag: r,
            isNonEditable: c
          }),
          eq: Qn,
          is: Xm
        };
      };
      const Wf = (e, t) => ({
        element: e,
        offset: t
      }), pR = (e, t) => {
        if (e.property().isText(t))
          return Wf(t, e.property().getText(t).length);
        {
          const o = e.property().children(t);
          return o.length > 0 ? pR(e, o[o.length - 1]) : Wf(t, o.length);
        }
      }, O4 = (e, t, o) => {
        const r = e.property().children(t);
        return r.length > 0 && o < r.length ? O4(e, r[o], 0) : r.length > 0 && e.property().isElement(t) && r.length === o ? pR(e, r[r.length - 1]) : Wf(t, o);
      }, FI = O4, bR = aZ(), Np = (e, t) => FI(bR, e, t), vR = nr("image"), Ju = (e) => {
        const t = e;
        return P.from(t[vR]);
      }, Lb = (e, t) => {
        const o = e;
        o[vR] = t;
      }, D4 = nr("event"), yR = (e) => {
        const t = e;
        return P.from(t[D4]);
      }, R4 = (e) => (t) => {
        const o = t;
        o[D4] = e;
      }, LI = (e, t) => R4(t)(e), HI = R4(
        0
        /* Event.Dragstart */
      ), cZ = R4(
        2
        /* Event.Drop */
      ), lZ = R4(
        1
        /* Event.Dragend */
      ), iZ = ((e) => (t) => {
        const o = t;
        return P.from(o[D4]).exists((r) => r === e);
      })(
        0
        /* Event.Dragstart */
      ), zI = () => Object.freeze({
        length: 0,
        item: (e) => null
      }), CR = nr("mode"), uZ = (e) => {
        const t = e;
        return P.from(t[CR]);
      }, ah = (e) => (t) => {
        const o = t;
        o[CR] = e;
      }, oS = (e, t) => ah(t)(e), xR = ah(
        0
        /* Mode.ReadWrite */
      ), N4 = ah(
        2
        /* Mode.ReadOnly */
      ), SR = ah(
        1
        /* Mode.Protected */
      ), VI = (e) => (t) => {
        const o = t;
        return P.from(o[CR]).exists((r) => r === e);
      }, by = VI(
        0
        /* Mode.ReadWrite */
      ), UI = VI(
        1
        /* Mode.Protected */
      ), jI = (e, t) => ({
        ...t,
        get length() {
          return t.length;
        },
        add: (o, r) => {
          if (by(e))
            if (U(o)) {
              if (!Gn(r))
                return t.add(o, r);
            } else
              return t.add(o);
          return null;
        },
        remove: (o) => {
          by(e) && t.remove(o);
        },
        clear: () => {
          by(e) && t.clear();
        }
      }), M4 = ["none", "copy", "link", "move"], WI = ["none", "copy", "copyLink", "copyMove", "link", "linkMove", "move", "all", "uninitialized"], vy = () => {
        const e = new window.DataTransfer();
        let t = "move", o = "all";
        const r = {
          get dropEffect() {
            return t;
          },
          set dropEffect(c) {
            Lt(M4, c) && (t = c);
          },
          get effectAllowed() {
            return o;
          },
          set effectAllowed(c) {
            iZ(r) && Lt(WI, c) && (o = c);
          },
          get items() {
            return jI(r, e.items);
          },
          get files() {
            return UI(r) ? zI() : e.files;
          },
          get types() {
            return e.types;
          },
          setDragImage: (c, u, f) => {
            by(r) && (Lb(r, { image: c, x: u, y: f }), e.setDragImage(c, u, f));
          },
          getData: (c) => UI(r) ? "" : e.getData(c),
          setData: (c, u) => {
            by(r) && e.setData(c, u);
          },
          clearData: (c) => {
            by(r) && e.clearData(c);
          }
        };
        return xR(r), r;
      }, dZ = (e) => {
        const t = vy(), o = uZ(e);
        return N4(e), HI(t), t.dropEffect = e.dropEffect, t.effectAllowed = e.effectAllowed, Ju(e).each((r) => t.setDragImage(r.image, r.x, r.y)), xe(e.types, (r) => {
          r !== "Files" && t.setData(r, e.getData(r));
        }), xe(e.files, (r) => t.items.add(r)), yR(e).each((r) => {
          LI(t, r);
        }), o.each((r) => {
          oS(e, r), oS(t, r);
        }), t;
      }, ZI = (e) => {
        const t = e.getData("text/html");
        return t === "" ? P.none() : P.some(t);
      }, GI = (e, t) => e.setData("text/html", t), mZ = (e, t) => ({
        left: e.left - t,
        top: e.top - t,
        right: e.right + t * 2,
        bottom: e.bottom + t * 2,
        width: e.width + t,
        height: e.height + t
      }), fZ = (e, t) => xo(t, (o) => {
        const r = mZ(Cf(o.getBoundingClientRect()), -1);
        return [
          { x: r.left, y: e(r), cell: o },
          { x: r.right, y: e(r), cell: o }
        ];
      }), qI = (e, t, o) => Io(e, (r, c) => r.fold(() => P.some(c), (u) => {
        const f = Math.sqrt(Math.abs(u.x - t) + Math.abs(u.y - o)), b = Math.sqrt(Math.abs(c.x - t) + Math.abs(c.y - o));
        return P.some(b < f ? c : u);
      }), P.none()), KI = (e, t, o, r, c) => {
        const u = Ne(te.fromDom(o), "td,th,caption").map((b) => b.dom), f = ze(fZ(e, u), (b) => t(b, c));
        return qI(f, r, c).map((b) => b.cell);
      }, gZ = (e) => e.bottom, YI = (e) => e.top, sS = (e, t) => e.y < t, hZ = (e, t) => e.y > t, XI = ue(KI, gZ, sS), QI = ue(KI, YI, hZ), JI = (e, t) => js(t.getClientRects()).bind((o) => XI(e, o.left, o.top)).bind((o) => Bb(P$(o), t)), wR = (e, t) => dr(t.getClientRects()).bind((o) => QI(e, o.left, o.top)).bind((o) => Bb($b(o), t)), eF = (e, t, o) => o.breakAt.exists((r) => e(t, r).breakAt.isSome()), pZ = (e) => e.breakType === Vf.Wrap && e.positions.length === 0, tF = (e) => e.breakType === Vf.Br && e.positions.length === 1, nF = (e, t, o) => {
        const r = e(t, o);
        return pZ(r) || !zs(o.getNode()) && tF(r) ? !eF(e, t, r) : r.breakAt.isNone();
      }, bZ = ue(nF, Oa), vZ = ue(nF, Xx), ER = (e, t, o) => {
        const r = Re.fromRangeStart(t);
        return m(!e, o).exists((c) => c.isEqual(r));
      }, yZ = (e, t, o, r) => {
        const c = e.selection.getRng(), u = t ? 1 : -1;
        return wv() && ER(t, c, o) ? (nh(u, e, o, !t, !1).each((f) => {
          Uf(e, f);
        }), !0) : !1;
      }, CZ = (e, t, o) => JI(t, o).orThunk(() => js(o.getClientRects()).bind((r) => zD(Qx(e, Re.before(t)), r.left))).getOr(Re.before(t)), P4 = (e, t, o) => wR(t, o).orThunk(() => js(o.getClientRects()).bind((r) => zD(Op(e, Re.after(t)), r.left))).getOr(Re.after(t)), oF = (e, t) => {
        const o = t.getNode(e);
        return Vc(o) ? P.some(o) : P.none();
      }, TR = (e, t, o) => {
        t.undoManager.transact(() => {
          const r = e ? cl : ca, c = WW(t, te.fromDom(o), r);
          Uf(t, c);
        });
      }, kR = (e, t, o) => {
        const r = oF(!!t, o), c = t === !1;
        r.fold(() => Uf(e, o.toRange()), (u) => m(c, e.getBody()).filter((f) => f.isEqual(o)).fold(() => Uf(e, o.toRange()), (f) => TR(t, e, u)));
      }, sF = (e, t, o, r) => {
        const c = e.selection.getRng(), u = Re.fromRangeStart(c), f = e.getBody();
        if (!t && bZ(r, u)) {
          const b = CZ(f, o, u);
          return kR(e, t, b), !0;
        } else if (t && vZ(r, u)) {
          const b = P4(f, o, u);
          return kR(e, t, b), !0;
        } else
          return !1;
      }, AR = (e, t, o) => P.from(e.dom.getParent(e.selection.getNode(), "td,th")).bind((r) => P.from(e.dom.getParent(r, "table")).map((c) => o(e, t, c, r))).getOr(!1), rF = (e, t) => AR(e, t, yZ), _R = (e, t) => AR(e, t, sF), xZ = (e) => {
        const t = af.exact(e, 0, e, 0);
        return lf(t);
      }, SZ = (e) => yy(e) || Oo(e).some((t) => li(t) && yy(t)), rS = (e, t, o) => o.fold(P.none, P.none, (r, c) => mg(c).map((u) => xZ(u)), (r) => e.mode.isReadOnly() || !wZ(r) || !SZ(r) ? P.none() : (e.execCommand("mceTableInsertRowAfter"), aF(e, t, r))), wZ = (e) => Uo(e, fr("table")).exists(Ll), aF = (e, t, o) => rS(e, t, sZ(o, yy)), EZ = (e, t, o) => rS(e, t, rZ(o, yy)), yy = (e) => Ll(e) || Dn(e, TZ), TZ = (e) => li(e) && Ll(e), cF = (e, t) => {
        const o = ["table", "li", "dl"], r = te.fromDom(e.getBody()), c = (b) => {
          const v = Hn(b);
          return Qn(b, r) || Lt(o, v);
        }, u = e.selection.getRng(), f = te.fromDom(t ? u.endContainer : u.startContainer);
        return nZ(f, c).map((b) => (oZ(b, c).each((O) => {
          e.model.table.clearSelectedCells(O.dom);
        }), e.selection.collapse(!t), (t ? aF : EZ)(e, c, b).each((O) => {
          e.selection.setRng(O);
        }), !0)).getOr(!1);
      }, lF = (e, t, o) => {
        const r = fo.os.isMacOS() || fo.os.isiOS(), c = fo.browser.isFirefox();
        Rp([
          { keyCode: Et.RIGHT, action: yn(SI, e, !0) },
          { keyCode: Et.LEFT, action: yn(SI, e, !1) },
          { keyCode: Et.UP, action: yn(wI, e, !1) },
          { keyCode: Et.DOWN, action: yn(wI, e, !0) },
          ...r ? [
            { keyCode: Et.UP, action: yn(T4, e, !1), metaKey: !0, shiftKey: !0 },
            { keyCode: Et.DOWN, action: yn(T4, e, !0), metaKey: !0, shiftKey: !0 }
          ] : [],
          { keyCode: Et.RIGHT, action: yn(rF, e, !0) },
          { keyCode: Et.LEFT, action: yn(rF, e, !1) },
          { keyCode: Et.UP, action: yn(_R, e, !1) },
          { keyCode: Et.DOWN, action: yn(_R, e, !0) },
          { keyCode: Et.UP, action: yn(_R, e, !1) },
          { keyCode: Et.UP, action: yn(dR, e, !1) },
          { keyCode: Et.DOWN, action: yn(dR, e, !0) },
          { keyCode: Et.RIGHT, action: yn(py, e, !0) },
          { keyCode: Et.LEFT, action: yn(py, e, !1) },
          { keyCode: Et.UP, action: yn(NI, e, !1) },
          { keyCode: Et.DOWN, action: yn(NI, e, !0) },
          { keyCode: Et.RIGHT, action: yn(eR, e, t, !0) },
          { keyCode: Et.LEFT, action: yn(eR, e, t, !1) },
          { keyCode: Et.RIGHT, ctrlKey: !r, altKey: r, action: yn(v4, e, t) },
          { keyCode: Et.LEFT, ctrlKey: !r, altKey: r, action: yn(hW, e, t) },
          { keyCode: Et.UP, action: yn(k4, e, !1) },
          { keyCode: Et.DOWN, action: yn(k4, e, !0) },
          ...c ? [
            { keyCode: Et.UP, action: yn(jf, e, !1) },
            { keyCode: Et.DOWN, action: yn(jf, e, !0) }
          ] : []
        ], o).each((u) => {
          o.preventDefault();
        });
      }, kZ = (e, t) => {
        e.on("keydown", (o) => {
          o.isDefaultPrevented() || lF(e, t, o);
        });
      }, Vm = (e, t) => ({
        container: e,
        offset: t
      }), B4 = lo.DOM, $4 = (e) => (t) => e === t ? -1 : 0, AZ = (e) => (t) => e.isBlock(t) || Lt(["BR", "IMG", "HR", "INPUT"], t.nodeName) || e.getContentEditable(t) === "false", OR = (e, t, o) => {
        if (tt(e) && t >= 0)
          return P.some(Vm(e, t));
        {
          const r = wd(B4);
          return P.from(r.backwards(e, t, $4(e), o)).map((c) => Vm(c.container, c.container.data.length));
        }
      }, DR = (e, t, o) => {
        if (tt(e) && t >= e.length)
          return P.some(Vm(e, t));
        {
          const r = wd(B4);
          return P.from(r.forwards(e, t, $4(e), o)).map((c) => Vm(c.container, 0));
        }
      }, RR = (e, t, o) => {
        if (!tt(e))
          return P.none();
        const r = e.data;
        if (t >= 0 && t <= r.length)
          return P.some(Vm(e, t));
        {
          const c = wd(B4);
          return P.from(c.backwards(e, t, $4(e), o)).bind((u) => {
            const f = u.container.data;
            return RR(u.container, t + f.length, o);
          });
        }
      }, NR = (e, t, o) => {
        if (!tt(e))
          return P.none();
        const r = e.data;
        if (t <= r.length)
          return P.some(Vm(e, t));
        {
          const c = wd(B4);
          return P.from(c.forwards(e, t, $4(e), o)).bind((u) => NR(u.container, t - r.length, o));
        }
      }, MR = (e, t, o, r, c) => {
        const u = wd(e, AZ(e));
        return P.from(u.backwards(t, o, r, c));
      }, _Z = (e) => e.collapsed && tt(e.startContainer), OZ = (e) => Gc(e.toString().replace(/\u00A0/g, " ")), iF = (e) => e !== "" && `  \uFEFF\f
\r	\v`.indexOf(e) !== -1, ra = (e, t) => e.substring(t.length), DZ = (e, t, o, r = !1) => {
        let c;
        const u = o.charAt(0);
        for (c = t - 1; c >= 0; c--) {
          const f = e.charAt(c);
          if (!r && iF(f))
            return P.none();
          if (u === f && As(e, o, c, t))
            break;
        }
        return P.some(c);
      }, PR = (e, t, o, r = !1) => {
        if (!_Z(t))
          return P.none();
        const c = { text: "", offset: 0 }, u = (b, v, S) => (c.text = S + c.text, c.offset += v, DZ(c.text, c.offset, o, r).getOr(v)), f = e.getParent(t.startContainer, e.isBlock) || e.getRoot();
        return MR(e, t.startContainer, t.startOffset, u, f).bind((b) => {
          const v = t.cloneRange();
          if (v.setStart(b.container, b.offset), v.setEnd(t.endContainer, t.endOffset), v.collapsed)
            return P.none();
          const S = OZ(v);
          return S.lastIndexOf(o) !== 0 ? P.none() : P.some({ text: ra(S, o), range: v, trigger: o });
        });
      }, RZ = (e) => e.nodeType === qp, uF = (e) => e.nodeType === rg, I4 = (e) => {
        if (RZ(e))
          return Vm(e, e.data.length);
        {
          const t = e.childNodes;
          return t.length > 0 ? I4(t[t.length - 1]) : Vm(e, t.length);
        }
      }, BR = (e, t) => {
        const o = e.childNodes;
        return o.length > 0 && t < o.length ? BR(o[t], 0) : o.length > 0 && uF(e) && o.length === t ? I4(o[o.length - 1]) : Vm(e, t);
      }, aS = (e, t) => {
        const o = e.getParent(t.container, e.isBlock) ?? e.getRoot();
        return MR(e, t.container, t.offset, (r, c) => c === 0 ? -1 : c, o).filter((r) => {
          const c = r.container.data.charAt(r.offset - 1);
          return !iF(c);
        }).isSome();
      }, NZ = (e) => (t) => {
        const o = BR(t.startContainer, t.startOffset);
        return !aS(e, o);
      }, MZ = (e, t, o) => cc(o.triggers, (r) => PR(e, t, r)), PZ = (e, t) => {
        const o = t(), r = e.selection.getRng();
        return MZ(e.dom, r, o).bind((c) => dF(e, t, c));
      }, dF = (e, t, o, r = {}) => {
        const c = t(), f = e.selection.getRng().startContainer.nodeValue ?? "", b = ze(c.lookupByTrigger(o.trigger), (S) => o.text.length >= S.minChars && S.matches.getOrThunk(() => NZ(e.dom))(o.range, f, o.text));
        if (b.length === 0)
          return P.none();
        const v = Promise.all(en(b, (S) => S.fetch(o.text, S.maxResults, r).then((R) => ({
          matchText: o.text,
          items: R,
          columns: S.columns,
          onAction: S.onAction,
          highlightOn: S.highlightOn
        }))));
        return P.some({
          lookupData: v,
          context: o
        });
      }, BZ = oC("type"), $Z = Aw("fetch"), IZ = Aw("onAction"), FZ = (e) => op("columns", e), LZ = Ac([
        BZ,
        oC("trigger"),
        hk("minChars", 1),
        FZ(1),
        hk("maxResults", 10),
        n5("matches"),
        $Z,
        IZ,
        pk("highlightOn", [], J2)
      ]), HZ = (e) => np("Autocompleter", LZ, e), zZ = () => {
        const e = {}, t = {}, o = {}, r = {}, c = {}, u = {}, f = {}, b = {}, v = {}, S = (H, J) => (W, Q) => {
          H[W.toLowerCase()] = { ...Q, type: J };
        }, O = (H, J) => (W, Q) => {
          H[W.toLowerCase()] = { type: J, ...Q };
        }, R = (H, J) => r[H.toLowerCase()] = J, M = (H, J) => f[H.toLowerCase()] = J;
        return {
          addButton: S(e, "button"),
          addGroupToolbarButton: S(e, "grouptoolbarbutton"),
          addToggleButton: S(e, "togglebutton"),
          addMenuButton: S(e, "menubutton"),
          addSplitButton: S(e, "splitbutton"),
          addMenuItem: S(t, "menuitem"),
          addNestedMenuItem: S(t, "nestedmenuitem"),
          addToggleMenuItem: S(t, "togglemenuitem"),
          addAutocompleter: S(o, "autocompleter"),
          addContextMenu: S(c, "contextmenu"),
          addContextToolbar: S(u, "contexttoolbar"),
          addContextForm: O(u, "contextform"),
          addSidebar: S(b, "sidebar"),
          addView: S(v, "views"),
          addIcon: R,
          addContext: M,
          getAll: () => ({
            buttons: e,
            menuItems: t,
            icons: r,
            // TODO: should popups be combined with context menus? We'd need to make a new add function.
            // Right now using `add` shares the key namespace, which prevents registering both
            // a completer and a context menu with the same name
            popups: o,
            contextMenus: c,
            contextToolbars: u,
            sidebars: b,
            views: v,
            contexts: f
          })
        };
      }, VZ = (e) => {
        const t = e.ui.registry.getAll().popups, o = lc(t, (f) => HZ(f).fold((b) => {
          throw new Error(Ad(b));
        }, jo)), r = Gm(ic(o, (f) => f.trigger)), c = Pa(o);
        return {
          dataset: o,
          triggers: r,
          lookupByTrigger: (f) => ze(c, (b) => b.trigger === f)
        };
      }, UZ = (e, t) => {
        const o = ni(t.load, 50);
        e.on("input", (r) => {
          r.inputType === "insertCompositionText" && !e.composing || o.throttle();
        }), e.on("keydown", (r) => {
          const c = r.which;
          c === 8 ? o.throttle() : c === 27 ? (o.cancel(), t.cancelIfNecessary()) : (c === 38 || c === 40) && o.cancel();
        }, !0), e.on("remove", o.cancel);
      }, jZ = (e) => {
        const t = Mc(), o = Wt(!1), r = t.isSet, c = () => {
          r() && (kf(e), o.set(!1), t.clear());
        }, u = (R) => {
          r() || t.set({
            trigger: R.trigger,
            matchLength: R.text.length
          });
        }, f = ha(() => VZ(e)), b = (R) => t.get().map((M) => PR(e.dom, e.selection.getRng(), M.trigger, !0).bind((H) => dF(e, f, H, R))).getOrThunk(() => PZ(e, f)), v = (R) => {
          b(R).fold(c, (M) => {
            u(M.context), M.lookupData.then((H) => {
              t.get().map((J) => {
                const W = M.context;
                J.trigger === W.trigger && (t.set({
                  ...J,
                  matchLength: W.text.length
                }), o.get() ? (iC(e, { range: W.range }), U1(e, { lookupData: H })) : (o.set(!0), iC(e, { range: W.range }), V1(e, { lookupData: H })));
              });
            });
          });
        }, S = (R, M) => {
          const H = R.compareBoundaryPoints(window.Range.START_TO_START, M), J = R.compareBoundaryPoints(window.Range.END_TO_END, M);
          return H >= 0 && J <= 0;
        }, O = () => t.get().bind(({ trigger: R }) => {
          const M = e.selection.getRng();
          return PR(e.dom, M, R, o.get()).filter(({ range: H }) => S(M, H)).map(({ range: H }) => H);
        });
        e.addCommand("mceAutocompleterReload", (R, M) => {
          const H = Ye(M) ? M.fetchOptions : {};
          v(H);
        }), e.addCommand("mceAutocompleterClose", c), e.addCommand("mceAutocompleterRefreshActiveRange", () => {
          O().each((R) => {
            iC(e, { range: R });
          });
        }), e.editorCommands.addQueryStateHandler("mceAutoCompleterInRange", () => O().isSome()), UZ(e, {
          cancelIfNecessary: c,
          load: v
        });
      }, mF = Ii().browser.isSafari(), $R = (e) => vf(te.fromDom(e)), fF = (e, t) => e.startOffset === 0 && e.endOffset === t.textContent?.length, F4 = (e, t) => P.from(e.getParent(t.container(), "details")), gF = (e, t) => F4(e, t).isSome(), ZZ = (e, t) => {
        const o = P.from(e.getParent(t.startContainer, "details")), r = P.from(e.getParent(t.endContainer, "details"));
        if (o.isSome() || r.isSome()) {
          const c = o.bind((u) => P.from(e.select("summary", u)[0]));
          return P.some({ startSummary: c, startDetails: o, endDetails: r });
        } else
          return P.none();
      }, hF = (e, t) => E(t).exists((o) => o.isEqual(e)), GZ = (e, t) => D(t).exists((o) => zs(o.getNode()) && y(t, o).exists((r) => r.isEqual(e)) || o.isEqual(e)), pF = (e, t) => t.startSummary.exists((o) => hF(e, o)), qZ = (e, t) => t.startSummary.exists((o) => GZ(e, o)), bF = (e, t) => t.startDetails.exists((o) => y(o, e).forall((r) => t.startSummary.exists((c) => !c.contains(e.container()) && c.contains(r.container())))), vF = (e, t, o) => o.startDetails.exists((r) => p(e, t).forall((c) => !r.contains(c.container()))), yF = (e, t) => {
        const o = t.getNode();
        Gn(o) || e.selection.setCursorLocation(o, t.offset());
      }, CF = (e, t, o) => {
        const r = e.dom.getParent(t.container(), "details");
        if (r && !r.open) {
          const c = e.dom.select("summary", r)[0];
          c && (o ? E(c) : D(c)).each((f) => yF(e, f));
        } else
          yF(e, t);
      }, KZ = (e, t) => {
        const o = (v) => v.contains(e.startContainer), r = (v) => v.contains(e.endContainer), c = t.startSummary.exists(o), u = t.startSummary.exists(r), f = t.startDetails.forall((v) => t.endDetails.forall((S) => v !== S));
        return (c || u) && !(c && u) || f;
      }, xF = (e, t, o) => {
        const { dom: r, selection: c } = e, u = e.getBody();
        if (o === "character") {
          const f = Re.fromRangeStart(c.getRng()), b = r.getParent(f.container(), r.isBlock), v = F4(r, f), S = b && r.isEmpty(b), O = oe(b?.previousSibling), R = oe(b?.nextSibling);
          return S && (t ? R : O) && dp(!t, u, f).exists((J) => gF(r, J) && !cd(v, F4(r, J))) ? !0 : dp(t, u, f).fold(ye, (M) => {
            const H = F4(r, M);
            if (gF(r, M) && !cd(v, H)) {
              if (t || CF(e, M, !1), b && S) {
                if (t && O)
                  return !0;
                if (!t && R)
                  return !0;
                CF(e, M, t), e.dom.remove(b);
              }
              return !0;
            } else
              return !1;
          });
        } else
          return !1;
      }, SF = (e, t, o, r) => {
        const u = e.selection.getRng(), f = Re.fromRangeStart(u), b = e.getBody();
        return r === "selection" ? KZ(u, t) : o ? qZ(f, t) || vF(b, f, t) : pF(f, t) || bF(f, t);
      }, YZ = (e, t, o) => ZZ(e.dom, e.selection.getRng()).fold(() => xF(e, t, o), (r) => SF(e, r, t, o) || xF(e, t, o)), XZ = (e, t, o) => {
        const r = e.selection, c = r.getNode(), u = r.getRng(), f = Re.fromRangeStart(u);
        return I3(c) ? (o === "selection" && fF(u, c) || BM(t, f, c) ? $R(c) : e.undoManager.transact(() => {
          const b = r.getSel();
          let { anchorNode: v, anchorOffset: S, focusNode: O, focusOffset: R } = b ?? {};
          const M = () => {
            X(v) && X(S) && X(O) && X(R) && b?.setBaseAndExtent(v, S, O, R);
          }, H = () => {
            v = b?.anchorNode, S = b?.anchorOffset, O = b?.focusNode, R = b?.focusOffset;
          }, J = (Q, ge) => {
            xe(Q.childNodes, (be) => {
              WC(be) && ge.appendChild(be);
            });
          }, W = e.dom.create("span", { "data-mce-bogus": "1" });
          J(c, W), c.appendChild(W), M(), (o === "word" || o === "line") && b?.modify("extend", t ? "right" : "left", o), !r.isCollapsed() && fF(r.getRng(), W) ? $R(c) : (e.execCommand(t ? "ForwardDelete" : "Delete"), H(), J(W, c), M()), e.dom.remove(W);
        }), !0) : !1;
      }, Mp = (e, t, o) => YZ(e, t, o) || mF && XZ(e, t, o) ? P.some(St) : P.none(), wF = (e) => (t, o, r = {}) => {
        const c = t.getBody(), u = {
          bubbles: !0,
          composed: !0,
          data: null,
          isComposing: !1,
          detail: 0,
          view: null,
          target: c,
          currentTarget: c,
          eventPhase: Event.AT_TARGET,
          originalTarget: c,
          explicitOriginalTarget: c,
          isTrusted: !1,
          srcElement: c,
          cancelable: !1,
          preventDefault: St,
          inputType: o
        }, f = k2(new InputEvent(e));
        return t.dispatch(e, { ...f, ...u, ...r });
      }, cS = wF("input"), lS = wF("beforeinput"), EF = Ii(), TF = EF.os, kF = TF.isMacOS() || TF.isiOS(), AF = EF.browser.isFirefox(), JZ = (e, t, o) => {
        const r = o.keyCode === Et.BACKSPACE ? "deleteContentBackward" : "deleteContentForward", c = e.selection.isCollapsed(), u = c ? "character" : "selection", f = (b) => c ? b ? "word" : "line" : "selection";
        _4([
          { keyCode: Et.BACKSPACE, action: yn(Sl, e) },
          { keyCode: Et.BACKSPACE, action: yn(a4, e, !1) },
          { keyCode: Et.DELETE, action: yn(a4, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(r4, e, !1) },
          { keyCode: Et.DELETE, action: yn(r4, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(tR, e, t, !1) },
          { keyCode: Et.DELETE, action: yn(tR, e, t, !0) },
          { keyCode: Et.BACKSPACE, action: yn(e_, e, !1) },
          { keyCode: Et.DELETE, action: yn(e_, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(Mp, e, !1, u) },
          { keyCode: Et.DELETE, action: yn(Mp, e, !0, u) },
          ...kF ? [
            { keyCode: Et.BACKSPACE, altKey: !0, action: yn(Mp, e, !1, f(!0)) },
            { keyCode: Et.DELETE, altKey: !0, action: yn(Mp, e, !0, f(!0)) },
            { keyCode: Et.BACKSPACE, metaKey: !0, action: yn(Mp, e, !1, f(!1)) }
          ] : [
            { keyCode: Et.BACKSPACE, ctrlKey: !0, action: yn(Mp, e, !1, f(!0)) },
            { keyCode: Et.DELETE, ctrlKey: !0, action: yn(Mp, e, !0, f(!0)) }
          ],
          { keyCode: Et.BACKSPACE, action: yn(l4, e, !1) },
          { keyCode: Et.DELETE, action: yn(l4, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(y4, e, !1) },
          { keyCode: Et.DELETE, action: yn(y4, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(yr, e, !1) },
          { keyCode: Et.DELETE, action: yn(yr, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(Nb, e, !1) },
          { keyCode: Et.DELETE, action: yn(Nb, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(sR, e, !1) },
          { keyCode: Et.DELETE, action: yn(sR, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(c4, e, !1) },
          { keyCode: Et.DELETE, action: yn(c4, e, !0) },
          { keyCode: Et.BACKSPACE, action: yn(Ib, e, !1) },
          { keyCode: Et.DELETE, action: yn(Ib, e, !0) }
        ], o).filter((b) => e.selection.isEditable()).each((b) => {
          o.preventDefault(), lS(e, r).isDefaultPrevented() || (b(), cS(e, r));
        });
      }, eG = (e, t, o, r) => Rp([
        { keyCode: Et.BACKSPACE, action: yn(DD, e) },
        { keyCode: Et.DELETE, action: yn(DD, e) },
        ...kF ? [
          { keyCode: Et.BACKSPACE, altKey: !0, action: yn(Jx, e) },
          { keyCode: Et.DELETE, altKey: !0, action: yn(Jx, e) },
          // macOS surpresses keyup events for most keys including Backspace when Meta key is engaged
          // To emulate Meta + Backspace on macOS, add a pattern for the meta key when backspace was
          // detected on keydown
          ...o ? [{
            // Firefox detects macOS Command key code as "Command" not "Meta"
            keyCode: AF ? 224 : 91,
            action: yn(() => (nI(e, r), Jx(e)))
          }] : []
        ] : [
          { keyCode: Et.BACKSPACE, ctrlKey: !0, action: yn(Jx, e) },
          { keyCode: Et.DELETE, ctrlKey: !0, action: yn(Jx, e) }
        ]
      ], t), tG = (e, t) => {
        let o = !1, r = [];
        e.on("keydown", (c) => {
          o = c.keyCode === Et.BACKSPACE, r = nR(e), c.isDefaultPrevented() || JZ(e, t, c);
        }), e.on("keyup", (c) => {
          c.isDefaultPrevented() || (eG(e, c, o, r), r.length = 0), o = !1;
        });
      }, nG = (e, t) => {
        const o = te.fromDom(e), r = te.fromDom(t), c = fr("span"), u = ue(Qn, o), f = (v) => Is(v) && rr(v, "font-size").isSome(), b = [
          ...f(r) ? [r] : [],
          ...k(r, f, u)
        ];
        xe(b.slice(1), (v) => {
          bh(v, "font-size"), sr(v, "data-mce-style"), c(v) && Qm(v) && hc(v);
        });
      }, oG = (e) => {
        for (; e; ) {
          if (ht(e) || tt(e) && e.data && /[\r\n\s]/.test(e.data))
            return P.from(te.fromDom(e));
          e = e.nextSibling;
        }
        return P.none();
      }, Cy = (e, t) => {
        const o = e.dom, r = e.schema.getMoveCaretBeforeOnEnterElements();
        if (!t)
          return;
        if (/^(LI|DT|DD)$/.test(t.nodeName)) {
          const u = (v) => /^(ul|ol|dl)$/.test(Hn(v)), f = (v) => u(v) ? P.from(v) : of(v, u), b = (v) => o.isEmpty(v.dom);
          oG(t.firstChild).each((v) => {
            f(v).fold(() => {
              if (b(v)) {
                const S = Np(v, 0).element;
                Is(S) && !Xi(S) && bo(S, te.fromText($s));
              }
            }, (S) => {
              ca(S, te.fromText($s));
            });
          });
        }
        const c = o.createRng();
        if (t.normalize(), t.hasChildNodes()) {
          const u = new Js(t, t);
          let f = t, b;
          for (; b = u.current(); ) {
            if (tt(b)) {
              c.setStart(b, 0), c.setEnd(b, 0);
              break;
            }
            if (r[b.nodeName.toLowerCase()]) {
              c.setStartBefore(b), c.setEndBefore(b);
              break;
            }
            f = b, b = u.next();
          }
          b || (c.setStart(f, 0), c.setEnd(f, 0));
        } else
          zs(t) ? t.nextSibling && o.isBlock(t.nextSibling) ? (c.setStartBefore(t), c.setEndBefore(t)) : (c.setStartAfter(t), c.setEndAfter(t)) : (c.setStart(t, 0), c.setEnd(t, 0));
        e.selection.setRng(c), ru(e, c);
      }, iS = (e, t) => {
        const o = e.getRoot();
        let r, c = t;
        for (; c !== o && c && e.getContentEditable(c) !== "false"; ) {
          if (e.getContentEditable(c) === "true") {
            r = c;
            break;
          }
          c = c.parentNode;
        }
        return c !== o ? r : o;
      }, IR = (e) => P.from(e.dom.getParent(e.selection.getStart(!0), e.dom.isBlock)), CX = (e) => IR(e).fold(ot(""), (t) => t.nodeName.toUpperCase()), sG = (e) => IR(e).filter((t) => Ec(te.fromDom(t))).isSome(), xy = (e) => {
        e.innerHTML = '<br data-mce-bogus="1">';
      }, _F = (e, t, o) => {
        const r = e.dom;
        P.from(o.style).map(r.parseStyle).each((v) => {
          const O = { ...tf(te.fromDom(t)), ...v };
          r.setStyles(t, O);
        });
        const c = P.from(o.class).map((v) => v.split(/\s+/)), u = P.from(t.className).map((v) => ze(v.split(/\s+/), (S) => S !== ""));
        Xs(c, u, (v, S) => {
          const O = ze(S, (M) => !Lt(v, M)), R = [...v, ...O];
          r.setAttrib(t, "class", R.join(" "));
        });
        const f = ["style", "class"], b = Ri(o, (v, S) => !Lt(f, S));
        r.setAttribs(t, b);
      }, Sy = (e, t) => {
        if (Ar(e).toLowerCase() === t.tagName.toLowerCase()) {
          const r = nu(e);
          _F(e, t, r);
        }
      }, OF = (e, t, o, r, c = !0, u, f) => {
        const b = e.dom, v = e.schema, S = Ar(e), O = o ? o.nodeName.toUpperCase() : "";
        let R = t;
        const M = v.getTextInlineElements();
        let H;
        u || O === "TABLE" || O === "HR" ? H = b.create(u || S, f || {}) : H = o.cloneNode(!1);
        let J = H;
        if (!c)
          b.setAttrib(H, "style", null), b.setAttrib(H, "class", null);
        else {
          do
            if (M[R.nodeName]) {
              if (z(R) || Ys(R))
                continue;
              const W = R.cloneNode(!1);
              b.setAttrib(W, "id", ""), H.hasChildNodes() ? (W.appendChild(H.firstChild), H.appendChild(W)) : (J = W, H.appendChild(W));
            }
          while ((R = R.parentNode) && R !== r);
          H.nodeName !== "LI" && nG(H, J);
        }
        return Sy(e, H), xy(J), H;
      }, DF = (e, t) => e.dom.getParent(t, m1), RF = (e, t, o) => {
        let r = t;
        for (; r && r !== e && oe(r.nextSibling); ) {
          const c = r.parentElement;
          if (!c || !o(c))
            return m1(c);
          r = c;
        }
        return !1;
      }, rG = (e, t, o) => !t && o.nodeName.toLowerCase() === Ar(e) && e.dom.isEmpty(o) && RF(e.getBody(), o, (r) => kn(e.schema.getTextBlockElements(), r.nodeName.toLowerCase())), aG = (e, t, o) => {
        const r = t(Ar(e)), c = DF(e, o);
        c && (e.dom.insertAfter(r, c), Cy(e, r), (o.parentElement?.childNodes?.length ?? 0) > 1 && e.dom.remove(o));
      }, cG = (e, t) => e.firstChild && e.firstChild.nodeName === t, NF = (e) => e.parentNode?.firstChild === e, MF = (e, t) => {
        const o = e?.parentNode;
        return X(o) && o.nodeName === t;
      }, L4 = (e) => X(e) && /^(OL|UL|LI)$/.test(e.nodeName), FR = (e) => X(e) && /^(LI|DT|DD)$/.test(e.nodeName), lG = (e) => L4(e) && L4(e.parentNode), H4 = (e) => {
        const t = e.parentNode;
        return FR(t) ? t : e;
      }, uS = (e, t, o) => {
        let r = e[o ? "firstChild" : "lastChild"];
        for (; r && !ht(r); )
          r = r[o ? "nextSibling" : "previousSibling"];
        return r === t;
      }, PF = (e) => Io(ic(tf(te.fromDom(e)), (t, o) => `${o}: ${t};`), (t, o) => t + o, ""), iG = (e, t, o, r, c) => {
        const u = e.dom, f = e.selection.getRng(), b = o.parentNode;
        if (o === e.getBody() || !b)
          return;
        lG(o) && (c = "LI");
        const v = FR(r) ? PF(r) : void 0;
        let S = FR(r) && v ? t(c, { style: PF(r) }) : t(c);
        if (uS(o, r, !0) && uS(o, r, !1))
          if (MF(o, "LI")) {
            const O = H4(o);
            u.insertAfter(S, O), NF(o) ? u.remove(O) : u.remove(o);
          } else
            u.replace(S, o);
        else if (uS(o, r, !0))
          MF(o, "LI") ? (u.insertAfter(S, H4(o)), S.appendChild(u.doc.createTextNode(" ")), S.appendChild(o)) : b.insertBefore(S, o), u.remove(r);
        else if (uS(o, r, !1))
          u.insertAfter(S, H4(o)), u.remove(r);
        else {
          o = H4(o);
          const O = f.cloneRange();
          O.setStartAfter(r), O.setEndAfter(o);
          const R = O.extractContents();
          if (c === "LI" && cG(R, "LI")) {
            const M = ze(en(S.children, te.fromDom), bt(fr("br")));
            S = R.firstChild, u.insertAfter(R, o), xe(M, (H) => zi(te.fromDom(S), H)), v && S.setAttribute("style", v);
          } else
            u.insertAfter(R, o), u.insertAfter(S, o);
          u.remove(r);
        }
        Cy(e, S);
      }, uG = (e) => {
        xe(q(te.fromDom(e), Eo), (t) => {
          const o = t.dom;
          o.nodeValue = Gc(o.data);
        });
      }, dG = (e, t) => {
        const o = e.dom.getParent(t, "ol,ul,dl");
        return o !== null && e.dom.getContentEditableParent(o) === "false";
      }, xX = (e, t) => t && t.nodeName === "A" && e.isEmpty(t), LR = (e, t) => e.nodeName === t || e.previousSibling && e.previousSibling.nodeName === t, mG = (e, t) => e.nodeName === t || e.nextSibling && e.nextSibling.nodeName === t, HR = (e, t) => X(t) && e.isBlock(t) && !/^(TD|TH|CAPTION|FORM)$/.test(t.nodeName) && !/^(fixed|absolute)/i.test(t.style.position) && e.isEditable(t.parentNode) && e.getContentEditable(t) !== "false", fG = (e, t, o) => {
        const r = [];
        if (!o)
          return;
        let c = o;
        for (; c = c.firstChild; ) {
          if (e.isBlock(c))
            return;
          ht(c) && !t[c.nodeName.toLowerCase()] && r.push(c);
        }
        let u = r.length;
        for (; u--; )
          c = r[u], (!c.hasChildNodes() || c.firstChild === c.lastChild && c.firstChild?.nodeValue === "" || xX(e, c)) && e.remove(c);
      }, zR = (e, t, o) => tt(t) ? e ? o === 1 && t.data.charAt(o - 1) === Ur ? 0 : o : o === t.data.length - 1 && t.data.charAt(o) === Ur ? t.data.length : o : o, BF = (e) => {
        const t = e.cloneRange();
        return t.setStart(e.startContainer, zR(!0, e.startContainer, e.startOffset)), t.setEnd(e.endContainer, zR(!1, e.endContainer, e.endOffset)), t;
      }, gG = (e) => {
        let t = e;
        do
          tt(t) && (t.data = t.data.replace(/^[\r\n]+/, "")), t = t.firstChild;
        while (t);
      }, VR = (e, t, o, r, c) => {
        const u = e.dom, f = iS(u, r) ?? u.getRoot();
        let b = u.getParent(r, u.isBlock);
        if (!b || !HR(u, b)) {
          if (b = b || f, !b.hasChildNodes()) {
            const R = u.create(t);
            return Sy(e, R), b.appendChild(R), o.setStart(R, 0), o.setEnd(R, 0), R;
          }
          let v = r;
          for (; v && v.parentNode !== b; )
            v = v.parentNode;
          let S;
          for (; v && !u.isBlock(v); )
            S = v, v = v.previousSibling;
          const O = S?.parentElement?.nodeName;
          if (S && O && e.schema.isValidChild(O, t.toLowerCase())) {
            const R = S.parentNode, M = u.create(t);
            for (Sy(e, M), R.insertBefore(M, S), v = S; v && !u.isBlock(v); ) {
              const H = v.nextSibling;
              M.appendChild(v), v = H;
            }
            o.setStart(r, c), o.setEnd(r, c);
          }
        }
        return r;
      }, Zf = (e, t) => {
        t.normalize();
        const o = t.lastChild;
        (!o || ht(o) && /^(left|right)$/gi.test(e.getStyle(o, "float", !0))) && e.add(t, "br");
      }, $F = (e, t) => {
        const o = iv(e);
        return jt(t) ? !1 : U(o) ? Lt(Je.explode(o), t.nodeName.toLowerCase()) : o;
      }, dS = {
        insert: (e, t) => {
          let o, r, c, u, f = !1;
          const b = e.dom, v = e.schema, S = v.getNonEmptyElements(), O = e.selection.getRng(), R = Ar(e), M = te.fromDom(O.startContainer), H = Bl(M, O.startOffset), J = H.exists(($e) => li($e) && !Ll($e)), W = O.collapsed && J, Q = ($e, yt) => OF(e, o, xt, je, Zw(e), $e, yt), ge = ($e) => {
            const yt = zR($e, o, r);
            if (tt(o) && ($e ? yt > 0 : yt < o.data.length))
              return !1;
            if ((o.parentNode === xt || o === xt) && f && !$e || $e && ht(o) && o === xt.firstChild)
              return !0;
            if (LR(o, "TABLE") || LR(o, "HR"))
              return mG(o, "BR") ? !$e : f && !$e || !f && $e;
            const Sn = new Js(o, xt);
            tt(o) && ($e && yt === 0 ? Sn.prev() : !$e && yt === o.data.length && Sn.next());
            let wn;
            for (; wn = Sn.current(); ) {
              if (ht(wn)) {
                if (!wn.getAttribute("data-mce-bogus")) {
                  const uo = wn.nodeName.toLowerCase();
                  if (S[uo] && uo !== "br")
                    return !1;
                }
              } else if (tt(wn) && !Th(wn.data))
                return !1;
              $e ? Sn.prev() : Sn.next();
            }
            return !0;
          }, be = () => {
            let $e;
            return /^(H[1-6]|PRE|FIGURE)$/.test(c) && Kt !== "HGROUP" ? $e = Q(R) : $e = Q(), $F(e, u) && HR(b, u) && b.isEmpty(xt, void 0, { includeZwsp: !0 }) ? $e = b.split(u, xt) : b.insertAfter($e, xt), Cy(e, $e), $e;
          };
          zE(b, O).each(($e) => {
            O.setStart($e.startContainer, $e.startOffset), O.setEnd($e.endContainer, $e.endOffset);
          }), o = O.startContainer, r = O.startOffset;
          const ve = !!(t && t.shiftKey), Be = !!(t && t.ctrlKey);
          ht(o) && o.hasChildNodes() && !W && (f = r > o.childNodes.length - 1, o = o.childNodes[Math.min(r, o.childNodes.length - 1)] || o, f && tt(o) ? r = o.data.length : r = 0);
          const je = iS(b, o);
          if (!je || dG(e, o))
            return;
          ve || (o = VR(e, R, O, o, r));
          let xt = b.getParent(o, b.isBlock) || b.getRoot();
          u = X(xt?.parentNode) ? b.getParent(xt.parentNode, b.isBlock) : null, c = xt ? xt.nodeName.toUpperCase() : "";
          const Kt = u ? u.nodeName.toUpperCase() : "";
          if (Kt === "LI" && !Be) {
            const $e = u;
            xt = $e, u = $e.parentNode, c = Kt;
          }
          if (ht(u) && rG(e, ve, xt))
            return aG(e, Q, xt);
          if (/^(LI|DT|DD)$/.test(c) && ht(u) && b.isEmpty(xt)) {
            iG(e, Q, u, xt, R);
            return;
          }
          if (!W && (xt === e.getBody() || !HR(b, xt)))
            return;
          const Me = xt.parentNode;
          let Te;
          if (W)
            Te = Q(R), H.fold(() => {
              bo(M, te.fromDom(Te));
            }, ($e) => {
              ca($e, te.fromDom(Te));
            }), e.selection.setCursorLocation(Te, 0);
          else if (hm(xt))
            Te = Qi(xt), b.isEmpty(xt) && xy(xt), Sy(e, Te), Cy(e, Te);
          else if (ge(!1))
            Te = be();
          else if (ge(!0) && Me) {
            const $e = Re.fromRangeStart(O), yt = BA($e), Sn = te.fromDom(xt), uo = QE(Sn, $e, e.schema) ? hM(Sn, $e, e.schema).bind((ys) => P.from(ys.getNode())) : P.none();
            Te = Me.insertBefore(Q(), xt);
            const Go = LR(xt, "HR") || yt ? Te : uo.getOr(xt);
            Cy(e, Go);
          } else {
            const $e = BF(O).cloneRange();
            $e.setEndAfter(xt);
            const yt = $e.extractContents();
            uG(yt), gG(yt), Te = yt.firstChild, xt === Te ? X(Me) && b.insertAfter(yt, Me) : b.insertAfter(yt, xt), fG(b, S, Te), Zf(b, xt), b.isEmpty(xt) && xy(xt), Te.normalize(), b.isEmpty(Te) ? (b.remove(Te), be()) : (Sy(e, Te), Cy(e, Te));
          }
          b.setAttrib(Te, "id", ""), e.dispatch("NewBlock", { newBlock: Te });
        },
        fakeEventName: "insertParagraph"
      }, UR = (e, t, o) => {
        const r = new Js(t, o);
        let c;
        const u = e.getNonEmptyElements();
        for (; c = r.next(); )
          if (u[c.nodeName.toLowerCase()] || tt(c) && c.length > 0)
            return !0;
        return !1;
      }, jR = (e, t, o) => {
        const r = e.dom.createRng();
        o ? (r.setStartBefore(t), r.setEndBefore(t)) : (r.setStartAfter(t), r.setEndAfter(t)), e.selection.setRng(r), ru(e, r);
      }, IF = (e, t) => {
        const o = e.selection, r = e.dom, c = o.getRng();
        let u, f = !1;
        zE(r, c).each((H) => {
          c.setStart(H.startContainer, H.startOffset), c.setEnd(H.endContainer, H.endOffset);
        });
        let b = c.startOffset, v = c.startContainer;
        if (ht(v) && v.hasChildNodes()) {
          const H = b > v.childNodes.length - 1;
          v = v.childNodes[Math.min(b, v.childNodes.length - 1)] || v, H && tt(v) ? b = v.data.length : b = 0;
        }
        let S = r.getParent(v, r.isBlock);
        const O = S && S.parentNode ? r.getParent(S.parentNode, r.isBlock) : null, R = O ? O.nodeName.toUpperCase() : "", M = !!(t && t.ctrlKey);
        R === "LI" && !M && (S = O), tt(v) && b >= v.data.length && (UR(e.schema, v, S || r.getRoot()) || (u = r.create("br"), c.insertNode(u), c.setStartAfter(u), c.setEndAfter(u), f = !0)), u = r.create("br"), qh(r, c, u), jR(e, u, f), e.undoManager.add();
      }, pG = (e, t) => {
        const o = te.fromTag("br");
        ca(te.fromDom(t), o), e.undoManager.add();
      }, bG = (e, t) => {
        yG(e.getBody(), t) || cl(te.fromDom(t), te.fromTag("br"));
        const o = te.fromTag("br");
        cl(te.fromDom(t), o), jR(e, o.dom, !1), e.undoManager.add();
      }, vG = (e) => zs(e.getNode()), yG = (e, t) => vG(Re.after(t)) ? !0 : p(e, Re.after(t)).map((o) => zs(o.getNode())).getOr(!1), FF = (e) => e && e.nodeName === "A" && "href" in e, LF = (e) => e.fold(ye, FF, FF, ye), CG = (e) => {
        const t = ue(db, e), o = Re.fromRangeStart(e.selection.getRng());
        return zm(t, e.getBody(), o).filter(LF);
      }, xG = (e, t) => {
        t.fold(St, ue(pG, e), ue(bG, e), St);
      }, zF = {
        insert: (e, t) => {
          const o = CG(e);
          o.isSome() ? o.each(ue(xG, e)) : IF(e, t);
        },
        fakeEventName: "insertLineBreak"
      }, VF = (e, t) => IR(e).filter((o) => t.length > 0 && Ic(te.fromDom(o), t)).isSome(), SG = (e) => VF(e, jw(e)), wG = (e) => VF(e, Ww(e)), du = el.generate([
        { br: [] },
        { block: [] },
        { none: [] }
      ]), EG = (e, t) => wG(e), UF = (e) => (t, o) => sG(t) === e, jF = (e, t) => (o, r) => CX(o) === e.toUpperCase() === t, z4 = (e) => {
        const t = iS(e.dom, e.selection.getStart());
        return jt(t);
      }, mS = (e) => jF("pre", e), TG = () => jF("summary", !0), wy = (e) => (t, o) => cv(t) === e, WR = (e, t) => SG(e), V4 = (e, t) => t, kG = (e) => {
        const t = Ar(e), o = iS(e.dom, e.selection.getStart());
        return X(o) && e.schema.isValidChild(o.nodeName, t);
      }, WF = (e) => {
        const t = e.selection.getRng(), o = te.fromDom(t.startContainer), c = Bl(o, t.startOffset).map((u) => li(u) && !Ll(u));
        return t.collapsed && c.getOr(!0);
      }, ed = (e, t) => (o, r) => Io(e, (u, f) => u && f(o, r), !0) ? P.some(t) : P.none(), AG = (e, t) => T$([
        ed([EG], du.none()),
        // If the pre block is cef, do not try to insert a new line (or delete contents)
        ed([mS(!0), z4], du.none()),
        ed([TG()], du.br()),
        ed([mS(!0), wy(!1), V4], du.br()),
        ed([mS(!0), wy(!1)], du.block()),
        ed([mS(!0), wy(!0), V4], du.block()),
        ed([mS(!0), wy(!0)], du.br()),
        // TODO: TINY-9127 investigate if the list handling (and pre) is correct here.
        ed([UF(!0), V4], du.br()),
        ed([UF(!0)], du.block()),
        ed([WR], du.br()),
        ed([V4], du.br()),
        ed([kG], du.block()),
        ed([WF], du.block())
      ], [e, !!(t && t.shiftKey)]).getOr(du.none()), U4 = (e, t, o) => {
        t.mode.isReadOnly() || (t.selection.isCollapsed() || MM(t), !(X(o) && lS(t, e.fakeEventName).isDefaultPrevented()) && (e.insert(t, o), X(o) && cS(t, e.fakeEventName)));
      }, ZF = (e, t) => {
        if (e.mode.isReadOnly())
          return;
        const o = () => U4(zF, e, t), r = () => U4(dS, e, t), c = AG(e, t);
        switch (lv(e)) {
          case "linebreak":
            c.fold(o, o, St);
            break;
          case "block":
            c.fold(r, r, St);
            break;
          case "invert":
            c.fold(r, o, St);
            break;
          // implied by the options processor, unnecessary
          // case 'default':
          default:
            c.fold(o, r, St);
            break;
        }
      }, GF = Ii(), _G = GF.os.isiOS() && GF.browser.isSafari(), ZR = (e, t) => {
        t.isDefaultPrevented() || (t.preventDefault(), XB(e.undoManager), e.undoManager.transact(() => {
          ZF(e, t);
        }));
      }, j4 = (e) => {
        if (!e.collapsed)
          return !1;
        const t = e.startContainer;
        if (tt(t)) {
          const o = /^[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uD7B0-\uD7FF]$/, r = t.data.charAt(e.startOffset - 1);
          return o.test(r);
        } else
          return !1;
      }, qF = (e) => {
        let t = P.none();
        const o = (c) => {
          t = P.some(c.selection.getBookmark()), c.undoManager.add();
        }, r = (c, u) => {
          c.undoManager.undo(), t.fold(St, (f) => c.selection.moveToBookmark(f)), ZR(c, u), t = P.none();
        };
        e.on("keydown", (c) => {
          c.keyCode === Et.ENTER && (_G && j4(e.selection.getRng()) ? o(e) : ZR(e, c));
        }), e.on("keyup", (c) => {
          c.keyCode === Et.ENTER && t.each(() => r(e, c));
        });
      }, KF = (e, t, o) => {
        const r = fo.os.isMacOS() || fo.os.isiOS();
        Rp([
          { keyCode: Et.END, action: yn(EI, e, !0) },
          { keyCode: Et.HOME, action: yn(EI, e, !1) },
          ...r ? [] : [
            { keyCode: Et.HOME, action: yn(T4, e, !1), ctrlKey: !0, shiftKey: !0 },
            { keyCode: Et.END, action: yn(T4, e, !0), ctrlKey: !0, shiftKey: !0 }
          ],
          { keyCode: Et.END, action: yn(fR, e, !0) },
          { keyCode: Et.HOME, action: yn(fR, e, !1) },
          { keyCode: Et.END, action: yn(Dp, e, !0, t) },
          { keyCode: Et.HOME, action: yn(Dp, e, !1, t) }
        ], o).each((c) => {
          o.preventDefault();
        });
      }, OG = (e, t) => {
        e.on("keydown", (o) => {
          o.isDefaultPrevented() || KF(e, t, o);
        });
      }, DG = (e) => {
        e.on("input", (t) => {
          t.isComposing || EM(e);
        });
      }, W4 = Ii(), RG = (e, t, o) => {
        Rp([
          { keyCode: Et.PAGE_UP, action: yn(Dp, e, !1, t) },
          { keyCode: Et.PAGE_DOWN, action: yn(Dp, e, !0, t) }
        ], o);
      }, GR = (e) => e.stopImmediatePropagation(), YF = (e) => e.keyCode === Et.PAGE_UP || e.keyCode === Et.PAGE_DOWN, qR = (e, t, o) => {
        o && !e.get() ? t.on("NodeChange", GR, !0) : !o && e.get() && t.off("NodeChange", GR), e.set(o);
      }, NG = (e, t) => {
        if (W4.os.isMacOS())
          return;
        const o = Wt(!1);
        e.on("keydown", (r) => {
          YF(r) && qR(o, e, !0);
        }), e.on("keyup", (r) => {
          r.isDefaultPrevented() || RG(e, t, r), YF(r) && o.get() && (qR(o, e, !1), e.nodeChanged());
        });
      }, XF = (e, t) => e === t || e.contains(t), MG = (e, t) => !XF(e.getBody(), t.startContainer) || !XF(e.getBody(), t.endContainer) ? !0 : rH(e.dom, t), PG = (e) => {
        e.on("beforeinput", (t) => {
          (!e.selection.isEditable() || po(t.getTargetRanges(), (o) => !MG(e, o))) && t.preventDefault();
        });
      }, QF = (e, t) => {
        const o = t.container(), r = t.offset();
        return tt(o) ? (o.insertData(r, e), P.some(Re(o, r + e.length))) : rb(t).map((c) => {
          const u = te.fromText(e);
          return t.isAtEnd() ? cl(c, u) : ca(c, u), Re(u.dom, e.length);
        });
      }, Hb = ue(QF, $s), JF = ue(QF, " "), BG = (e, t, o) => DH(e, t, o) ? Hb(t) : JF(t), e8 = (e) => (t) => t.fold((o) => y(e.dom, Re.before(o)), (o) => E(o), (o) => D(o), (o) => p(e.dom, Re.after(o))), $G = (e, t, o) => (r) => DH(e, r, o) ? Hb(t) : JF(t), t8 = (e) => (t) => {
        e.selection.setRng(t.toRange()), e.nodeChanged();
      }, IG = (e, t) => e.isEditable(e.getParent(t, "summary")), n8 = (e) => {
        const t = Re.fromRangeStart(e.selection.getRng()), o = te.fromDom(e.getBody());
        if (e.selection.isCollapsed()) {
          const r = ue(db, e), c = Re.fromRangeStart(e.selection.getRng());
          return zm(r, e.getBody(), c).bind(e8(o)).map((u) => () => $G(o, t, e.schema)(u).each(t8(e)));
        } else
          return P.none();
      }, FG = (e) => {
        const t = () => {
          const o = te.fromDom(e.getBody());
          e.selection.isCollapsed() || e.getDoc().execCommand("Delete");
          const r = Re.fromRangeStart(e.selection.getRng());
          BG(o, r, e.schema).each(t8(e));
        };
        return $a(fo.browser.isFirefox() && e.selection.isEditable() && IG(e.dom, e.selection.getRng().startContainer), t);
      }, LG = (e, t) => {
        _4([
          { keyCode: Et.SPACEBAR, action: yn(n8, e) },
          { keyCode: Et.SPACEBAR, action: yn(FG, e) }
        ], t).each((o) => {
          t.preventDefault(), lS(e, "insertText", { data: " " }).isDefaultPrevented() || (o(), cS(e, "insertText", { data: " " }));
        });
      }, wX = (e) => {
        e.on("keydown", (t) => {
          t.isDefaultPrevented() || LG(e, t);
        });
      }, Z4 = (e) => iE(e) ? [
        { keyCode: Et.TAB, action: yn(cF, e, !0) },
        { keyCode: Et.TAB, shiftKey: !0, action: yn(cF, e, !1) }
      ] : [], HG = (e, t) => {
        Rp([
          ...Z4(e)
        ], t).each((o) => {
          t.preventDefault();
        });
      }, zG = (e) => {
        e.on("keydown", (t) => {
          t.isDefaultPrevented() || HG(e, t);
        });
      }, VG = (e) => {
        if (e.addShortcut("Meta+P", "", "mcePrint"), jZ(e), Bm(e))
          return Wt(null);
        {
          const t = gW(e);
          return PG(e), bI(e), kZ(e, t), tG(e, t), qF(e), wX(e), DG(e), zG(e), OG(e, t), NG(e, t), t;
        }
      }, UG = (e, t) => {
        const o = Vx(e);
        o === null || sD(e, o) || e.undoManager.transact(() => {
          Ye(t.styles) && e.dom.setStyles(o, t.styles), Ye(t.attrs) && Un(t.attrs, (r, c) => e.dom.setAttrib(o, c, r));
        });
      }, KR = (e, t) => () => {
        const o = Vx(e);
        return X(o) && o.nodeName === t;
      }, jG = (e) => {
        e.addCommand("InsertUnorderedList", (t, o) => {
          pD(e, "UL", o);
        }), e.addCommand("InsertOrderedList", (t, o) => {
          pD(e, "OL", o);
        }), e.addCommand("InsertDefinitionList", (t, o) => {
          pD(e, "DL", o);
        }), e.addCommand("RemoveList", () => {
          e4(e);
        }), e.addCommand("mceListUpdate", (t, o) => {
          Ye(o) && UG(e, o);
        }), e.addCommand("mceListBackspaceDelete", (t, o) => {
          yD(e, o);
        }), e.addQueryStateHandler("InsertUnorderedList", KR(e, "UL")), e.addQueryStateHandler("InsertOrderedList", KR(e, "OL")), e.addQueryStateHandler("InsertDefinitionList", KR(e, "DL"));
      }, WG = (e) => {
        e.on("keydown", (t) => {
          t.keyCode === Et.BACKSPACE ? yD(e, !1) && t.preventDefault() : t.keyCode === Et.DELETE && yD(e, !0) && t.preventDefault();
        });
      }, o8 = (e) => e.type === 3, s8 = (e) => e.length === 0, ZG = (e) => {
        const t = (c, u) => {
          const f = _a.create("li");
          xe(c, (b) => f.append(b)), u ? e.insert(f, u, !0) : e.append(f);
        }, o = (c, u) => o8(u) ? [...c, u] : !s8(c) && !o8(u) ? (t(c, u), []) : c, r = Io(e.children(), o, []);
        s8(r) || t(r);
      }, GG = (e) => {
        e.on("PreInit", () => {
          const { parser: t } = e;
          t.addNodeFilter("ul,ol", (o) => xe(o, ZG));
        });
      }, qG = (e) => {
        e.on("keydown", (t) => {
          t.keyCode !== Et.TAB || Et.metaKeyPressed(t) || e.undoManager.transact(() => {
            (t.shiftKey ? Wx(e) : s$(e)) && t.preventDefault();
          });
        });
      }, KG = (e) => {
        _C(e) && qG(e);
      }, es = (e) => {
        WG(e), jG(e), GG(e), KG(e);
      };
      class YG {
        editor;
        lastPath = [];
        constructor(t) {
          this.editor = t;
          let o;
          const r = this;
          "onselectionchange" in t.getDoc() || t.on("NodeChange click mouseup keyup focus", (c) => {
            const u = t.selection.getRng(), f = {
              startContainer: u.startContainer,
              startOffset: u.startOffset,
              endContainer: u.endContainer,
              endOffset: u.endOffset
            };
            (c.type === "nodechange" || !Wg(f, o)) && t.dispatch("SelectionChange"), o = f;
          }), t.on("contextmenu", () => {
            $E(t), t.dispatch("SelectionChange");
          }), t.on("SelectionChange", () => {
            const c = t.selection.getStart(!0);
            c && VC(t) && !r.isSameElementPath(c) && t.dom.isChildOf(c, t.getBody()) && t.nodeChanged({ selectionChange: !0 });
          }), t.on("mouseup", (c) => {
            !c.isDefaultPrevented() && VC(t) && (t.selection.getNode().nodeName === "IMG" ? $d.setEditorTimeout(t, () => {
              t.nodeChanged();
            }) : t.nodeChanged());
          });
        }
        /**
         * Dispatches out a onNodeChange event to all observers. This method should be called when you
         * need to update the UI states or element path etc.
         *
         * @method nodeChanged
         * @param {Object} args Optional args to pass to NodeChange event handlers.
         */
        nodeChanged(t = {}) {
          const o = this.editor, r = o.selection;
          let c;
          if (o.initialized && r && !nE(o) && !ou(o)) {
            const u = o.getBody();
            c = r.getStart(!0) || u, (c.ownerDocument !== o.getDoc() || !o.dom.isChildOf(c, u)) && (c = u);
            const f = [];
            o.dom.getParent(c, (b) => b === u ? !0 : (f.push(b), !1)), o.dispatch("NodeChange", {
              ...t,
              element: c,
              parents: f
            });
          }
        }
        /**
         * Returns true/false if the current element path has been changed or not.
         *
         * @private
         * @return {Boolean} True if the element path is the same false if it's not.
         */
        isSameElementPath(t) {
          let o;
          const r = this.editor, c = ds(r.dom.getParents(t, He, r.getBody()));
          if (c.length === this.lastPath.length) {
            for (o = c.length; o >= 0 && c[o] === this.lastPath[o]; o--)
              ;
            if (o === -1)
              return this.lastPath = c, !0;
          }
          return this.lastPath = c, !1;
        }
      }
      const YR = "x-tinymce/html", G4 = ot(YR), fS = "<!-- " + YR + " -->", r8 = (e) => fS + e, XG = (e) => e.replace(fS, ""), a8 = (e) => e.indexOf(fS) !== -1, QG = (e) => !/<(?:\/?(?!(?:div|p|br|span)>)\w+|(?:(?!(?:span style="white-space:\s?pre;?">)|br\s?\/>))\w+\s[^>]+)>/i.test(e), c8 = (e, t) => {
        let o = "<" + e;
        const r = ic(t, (c, u) => u + '="' + gl.encodeAllRaw(c) + '"');
        return r.length && (o += " " + r.join(" ")), o + ">";
      }, q4 = (e, t, o) => {
        const r = e.split(/\n\n/), c = c8(t, o), u = "</" + t + ">", f = en(r, (v) => v.split(/\n/).join("<br />")), b = (v) => c + v + u;
        return f.length === 1 ? f[0] : en(f, b).join("");
      }, l8 = "%MCEPASTEBIN%", JG = (e, t) => {
        const { dom: o, selection: r } = e, c = e.getBody();
        t.set(r.getRng());
        const u = o.add(e.getBody(), "div", {
          id: "mcepastebin",
          class: "mce-pastebin",
          contentEditable: !0,
          "data-mce-bogus": "all",
          style: "position: fixed; top: 50%; width: 10px; height: 10px; overflow: hidden; opacity: 0"
        }, l8);
        fo.browser.isFirefox() && o.setStyle(u, "left", o.getStyle(c, "direction", !0) === "rtl" ? 65535 : -65535), o.bind(u, "beforedeactivate focusin focusout", (f) => {
          f.stopPropagation();
        }), u.focus(), r.select(u, !0);
      }, XR = (e, t) => {
        const o = e.dom;
        if (QR(e)) {
          let r;
          const c = t.get();
          for (; r = QR(e); )
            o.remove(r), o.unbind(r);
          c && e.selection.setRng(c);
        }
        t.set(null);
      }, QR = (e) => e.dom.get("mcepastebin"), eq = (e) => X(e) && e.id === "mcepastebin", tq = (e) => {
        const t = e.dom, o = (f, b) => {
          f.appendChild(b), t.remove(b, !0);
        }, [r, ...c] = ze(e.getBody().childNodes, eq);
        xe(c, (f) => {
          o(r, f);
        });
        const u = t.select("div[id=mcepastebin]", r);
        for (let f = u.length - 1; f >= 0; f--) {
          const b = t.create("div");
          r.insertBefore(b, u[f]), o(b, u[f]);
        }
        return r ? r.innerHTML : "";
      }, i8 = (e) => e === l8, u8 = (e) => {
        const t = Wt(null);
        return {
          create: () => JG(e, t),
          remove: () => XR(e, t),
          getEl: () => QR(e),
          getHtml: () => tq(e),
          getLastRng: t.get
        };
      }, d8 = (e, t) => (Je.each(t, (o) => {
        lt(o, RegExp) ? e = e.replace(o, "") : e = e.replace(o[0], o[1]);
      }), e), nq = (e) => {
        const t = wa(), o = Gv({}, t);
        let r = "";
        const c = t.getVoidElements(), u = Je.makeMap("script noscript style textarea video audio iframe object", " "), f = t.getBlockElements(), b = (v) => {
          const S = v.name, O = v;
          if (S === "br") {
            r += `
`;
            return;
          }
          if (S !== "wbr") {
            if (c[S] && (r += " "), u[S]) {
              r += " ";
              return;
            }
            if (v.type === 3 && (r += v.value), !(v.name in t.getVoidElements())) {
              let R = v.firstChild;
              if (R)
                do
                  b(R);
                while (R = R.next);
            }
            f[S] && O.next && (r += `
`, S === "p" && (r += `
`));
          }
        };
        return e = d8(e, [
          /<!\[[^\]]+\]>/g
          // Conditional comments
        ]), b(o.parse(e)), r;
      }, JR = (e) => (e = d8(e, [
        /^[\s\S]*<body[^>]*>\s*|\s*<\/body[^>]*>[\s\S]*$/ig,
        // Remove anything but the contents within the BODY element
        /<!--StartFragment-->|<!--EndFragment-->/g,
        // Inner fragments (tables from excel on mac)
        [/( ?)<span class="Apple-converted-space">\u00a0<\/span>( ?)/g, (o, r, c) => !r && !c ? " " : $s],
        /<br class="Apple-interchange-newline">/g,
        /<br>$/i
        // Trailing BR elements
      ]), e), oq = (e) => {
        let t = 0;
        return () => e + t++;
      }, sq = (e) => {
        const t = e.toLowerCase(), o = {
          jpg: "jpeg",
          jpe: "jpeg",
          jfi: "jpeg",
          jif: "jpeg",
          jfif: "jpeg",
          pjpeg: "jpeg",
          pjp: "jpeg",
          svg: "svg+xml"
        };
        return Je.hasOwn(o, t) ? "image/" + o[t] : "image/" + t;
      }, rq = (e, t) => {
        const o = Gv({
          sanitize: Cv(e),
          sandbox_iframes: lp(e),
          sandbox_iframes_exclusions: Sm(e),
          convert_unsafe_embeds: wm(e)
        }, e.schema);
        o.addNodeFilter("meta", (c) => {
          Je.each(c, (u) => {
            u.remove();
          });
        });
        const r = o.parse(t, { forced_root_block: !1, isRootContent: !0 });
        return mp({ validate: !0 }, e.schema).serialize(r);
      }, K4 = (e, t) => ({ content: e, cancelled: t }), aq = (e, t, o) => {
        const r = e.dom.create("div", { style: "display:none" }, t), c = $w(e, r, o);
        return K4(c.node.innerHTML, c.isDefaultPrevented());
      }, m8 = (e, t, o) => {
        const r = Bw(e, t, o), c = rq(e, r.content);
        return e.hasEventListeners("PastePostProcess") && !r.isDefaultPrevented() ? aq(e, c, o) : K4(c, r.isDefaultPrevented());
      }, cq = (e, t, o) => m8(e, t, o), gS = (e, t) => (e.insertContent(t, {
        merge: rE(e),
        paste: !0
      }), !0), eN = (e) => /^https?:\/\/[\w\-\/+=.,!;:&%@^~(){}?#]+$/i.test(e), f8 = (e, t) => eN(t) && po(AC(e), (o) => qr(t.toLowerCase(), `.${o.toLowerCase()}`)), lq = (e, t, o) => (e.undoManager.extra(() => {
        o(e, t);
      }, () => {
        e.insertContent('<img src="' + t + '">');
      }), !0), iq = (e, t, o) => (e.undoManager.extra(() => {
        o(e, t);
      }, () => {
        e.execCommand("mceInsertLink", !1, t);
      }), !0), uq = (e, t, o) => !e.selection.isCollapsed() && eN(t) ? iq(e, t, o) : !1, dq = (e, t, o) => f8(e, t) ? lq(e, t, o) : !1, g8 = (e, t) => {
        Je.each([
          uq,
          dq,
          gS
        ], (o) => !o(e, t, gS));
      }, mq = (e, t, o) => {
        o || !SC(e) ? gS(e, t) : g8(e, t);
      }, h8 = oq("mceclip"), Y4 = (e) => {
        const t = vy();
        return GI(t, e), N4(t), t;
      }, X4 = (e, t, o, r, c) => {
        const u = cq(e, t, o);
        if (!u.cancelled) {
          const f = u.content, b = () => mq(e, f, r);
          c ? lS(e, "insertFromPaste", { dataTransfer: Y4(f) }).isDefaultPrevented() || (b(), cS(e, "insertFromPaste")) : b();
        }
      }, Ey = (e, t, o, r) => {
        const c = o || a8(t);
        X4(e, XG(t), c, !1, r);
      }, tN = (e, t, o) => {
        const r = e.dom.encode(t).replace(/\r\n/g, `
`), c = d0(r, Uk(e)), u = q4(c, Ar(e), nu(e));
        X4(e, u, !1, !0, o);
      }, p8 = (e) => {
        const t = {};
        if (e && e.types)
          for (let o = 0; o < e.types.length; o++) {
            const r = e.types[o];
            try {
              t[r] = e.getData(r);
            } catch {
              t[r] = "";
            }
          }
        return t;
      }, td = (e, t) => t in e && e[t].length > 0, b8 = (e) => td(e, "text/html") || td(e, "text/plain"), Ty = (e, t) => {
        const o = t.match(/([\s\S]+?)(?:\.[a-z0-9.]+)$/i);
        return X(o) ? e.dom.encode(o[1]) : void 0;
      }, hS = (e, t, o, r) => {
        const c = h8(), u = Gw(e) && X(o.name), f = u ? Ty(e, o.name) : c, b = u ? o.name : void 0, v = t.create(c, o, r, f, b);
        return t.add(v), v;
      }, fq = (e, t) => {
        T_(t.uri).each(({ data: o, type: r, base64Encoded: c }) => {
          const u = c ? o : btoa(o), f = t.file, b = e.editorUpload.blobCache, S = b.getByData(u, r) ?? hS(e, b, f, u);
          Ey(e, `<img src="${S.blobUri()}">`, !1, !0);
        });
      }, gq = (e) => e.type === "paste", ky = (e) => Promise.all(en(e, (t) => k_(t).then((o) => ({ file: t, uri: o })))), hq = (e) => {
        const t = AC(e);
        return (o) => hn(o.type, "image/") && po(t, (r) => sq(r) === o.type);
      }, nN = (e, t) => {
        const o = t.items ? xo(rs(t.items), (c) => c.kind === "file" ? [c.getAsFile()] : []) : [], r = t.files ? rs(t.files) : [];
        return ze(o.length > 0 ? o : r, hq(e));
      }, v8 = (e, t, o) => {
        const r = gq(t) ? t.clipboardData : t.dataTransfer;
        if (yv(e) && r) {
          const c = nN(e, r);
          if (c.length > 0)
            return t.preventDefault(), ky(c).then((u) => {
              o && e.selection.setRng(o), xe(u, (f) => {
                fq(e, f);
              });
            }), !0;
        }
        return !1;
      }, y8 = (e) => fo.os.isAndroid() && e.clipboardData?.items?.length === 0, C8 = (e) => Et.metaKeyPressed(e) && e.keyCode === 86 || e.shiftKey && e.keyCode === 45, pS = (e, t, o, r, c) => {
        let u = JR(o);
        const f = td(t, G4()) || a8(o), b = !f && QG(u), v = eN(u);
        (i8(u) || !u.length || b && !v) && (r = !0), (r || v) && (td(t, "text/plain") && b ? u = t["text/plain"] : u = nq(u)), !i8(u) && (r ? tN(e, u, c) : Ey(e, u, f, c));
      }, x8 = (e, t, o) => {
        let r;
        const c = () => t.getLastRng() || e.selection.getRng();
        e.on("keydown", (u) => {
          C8(u) && !u.isDefaultPrevented() && (r = u.shiftKey && u.keyCode === 86);
        }), e.on("paste", (u) => {
          if (u.isDefaultPrevented() || y8(u))
            return;
          const f = o.get() === "text" || r;
          r = !1;
          const b = p8(u.clipboardData);
          !b8(b) && v8(e, u, c()) || (td(b, "text/html") ? (u.preventDefault(), pS(e, b, b["text/html"], f, !0)) : td(b, "text/plain") && td(b, "text/uri-list") ? (u.preventDefault(), pS(e, b, b["text/plain"], f, !0)) : (t.create(), $d.setEditorTimeout(e, () => {
            const v = t.getHtml();
            t.remove(), pS(e, b, v, f, !1);
          }, 0)));
        });
      }, pq = (e) => {
        const t = (c) => hn(c, "webkit-fake-url"), o = (c) => hn(c, "data:"), r = (c) => c.data?.paste === !0;
        e.parser.addNodeFilter("img", (c, u, f) => {
          if (!yv(e) && r(f))
            for (const b of c) {
              const v = b.attr("src");
              U(v) && !b.attr("data-mce-object") && v !== fo.transparentSrc && (t(v) || !wC(e) && o(v)) && b.remove();
            }
        });
      }, bq = (e, t, o) => {
        x8(e, t, o), pq(e);
      }, S8 = (e, t) => {
        t.get() === "text" ? (t.set("html"), Iw(e, !1)) : (t.set("text"), Iw(e, !0)), e.focus();
      }, vq = (e, t) => {
        e.addCommand("mceTogglePlainTextPaste", () => {
          S8(e, t);
        }), e.addCommand("mceInsertClipboardContent", (o, r) => {
          r.html && Ey(e, r.html, r.internal, !1), r.text && tN(e, r.text, !1);
        });
      }, w8 = (e, t, o) => {
        if (e)
          try {
            return e.clearData(), e.setData("text/html", t), e.setData("text/plain", o), e.setData(G4(), t), !0;
          } catch {
            return !1;
          }
        else
          return !1;
      }, Q4 = (e, t, o, r) => {
        w8(e.clipboardData, t.html, t.text) ? (e.preventDefault(), r()) : o(t.html, r);
      }, oN = (e) => (t, o) => {
        const { dom: r, selection: c } = e, u = r.create("div", { contenteditable: "false", "data-mce-bogus": "all" }), f = r.create("div", { contenteditable: "true" }, t);
        r.setStyles(u, {
          position: "fixed",
          top: "0",
          left: "-3000px",
          width: "1000px",
          overflow: "hidden"
        }), u.appendChild(f), r.add(e.getBody(), u);
        const b = c.getRng();
        f.focus();
        const v = r.createRng();
        v.selectNodeContents(f), c.setRng(v), $d.setEditorTimeout(e, () => {
          c.setRng(b), r.remove(u), o();
        }, 0);
      }, E8 = (e) => ({
        html: r8(e.selection.getContent({ contextual: !0 })),
        text: e.selection.getContent({ format: "text" })
      }), yq = (e) => !!e.dom.getParent(e.selection.getStart(), "td[data-mce-selected],th[data-mce-selected]", e.getBody()), T8 = (e) => !e.selection.isCollapsed() || yq(e), k8 = (e, t) => (o) => {
        !o.isDefaultPrevented() && T8(e) && e.selection.isEditable() && Q4(o, E8(e), oN(e), () => {
          if (fo.browser.isChromium() || fo.browser.isFirefox()) {
            const r = e.selection.getRng();
            $d.setEditorTimeout(e, () => {
              e.selection.setRng(r), Zd(e, t);
            }, 0);
          } else
            Zd(e, t);
        });
      }, sN = (e) => (t) => {
        !t.isDefaultPrevented() && T8(e) && Q4(t, E8(e), oN(e), St);
      }, Cq = (e, t) => {
        e.on("cut", k8(e, t)), e.on("copy", sN(e));
      }, rN = (e, t) => (
        // TODO: TINY-7075 Remove the "?? 0" here when agar passes valid client coords
        _m.getCaretRangeFromPoint(t.clientX ?? 0, t.clientY ?? 0, e.getDoc())
      ), A8 = (e) => {
        const t = e["text/plain"];
        return t ? t.indexOf("file://") === 0 : !1;
      }, _8 = (e, t) => {
        t && e.selection.setRng(t), e.focus();
      }, O8 = (e) => po(e.files, (t) => /^image\//.test(t.type)), xq = (e, t, o, r) => {
        const c = e.getParent(o, (f) => qs(t, f));
        if (!oe(e.getParent(o, "summary")))
          return !0;
        if (c && kn(r, "text/html")) {
          const f = new DOMParser().parseFromString(r["text/html"], "text/html").body;
          return !oe(f.querySelector(c.nodeName.toLowerCase()));
        } else
          return !1;
      }, Sq = (e) => {
        e.on("input", (t) => {
          const o = (r) => oe(r.querySelector("summary"));
          if (t.inputType === "deleteByDrag") {
            const r = ze(e.dom.select("details"), o);
            xe(r, (c) => {
              zs(c.firstChild) && c.firstChild.remove();
              const u = e.dom.create("summary");
              u.appendChild(bf().dom), c.prepend(u);
            });
          }
        });
      }, J4 = (e, t) => {
        l5(e) && e.on("dragend dragover draggesture dragdrop drop drag", (o) => {
          o.preventDefault(), o.stopPropagation();
        }), yv(e) || e.on("drop", (o) => {
          const r = o.dataTransfer;
          r && O8(r) && o.preventDefault();
        }), e.on("drop", (o) => {
          if (o.isDefaultPrevented())
            return;
          const r = rN(e, o);
          if (jt(r))
            return;
          const c = p8(o.dataTransfer), u = td(c, G4());
          if ((!b8(c) || A8(c)) && v8(e, o, r))
            return;
          const f = c[G4()], b = f || c["text/html"] || c["text/plain"], v = xq(e.dom, e.schema, r.startContainer, c), S = t.get();
          S && !v || b && (o.preventDefault(), $d.setEditorTimeout(e, () => {
            e.undoManager.transact(() => {
              (f || S && v) && e.execCommand("Delete"), _8(e, r);
              const O = JR(b);
              c["text/html"] ? Ey(e, O, u, !0) : tN(e, O, !0);
            });
          }));
        }), e.on("dragstart", (o) => {
          t.set(!0);
        }), e.on("dragover dragend", (o) => {
          yv(e) && !t.get() && (o.preventDefault(), _8(e, rN(e, o))), o.type === "dragend" && t.set(!1);
        }), Sq(e);
      }, wq = (e) => {
        const t = (c) => (u) => {
          c(e, u);
        }, o = Fk(e);
        se(o) && e.on("PastePreProcess", t(o));
        const r = Lk(e);
        se(r) && e.on("PastePostProcess", t(r));
      }, Eq = (e, t) => {
        e.on("PastePreProcess", (o) => {
          o.content = t(e, o.content, o.internal);
        });
      }, D8 = /rgb\s*\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/gi, aN = (e) => Je.trim(e).replace(D8, Ci).toLowerCase(), Tq = (e, t, o) => {
        const r = xC(e);
        if (o || r === "all" || !zk(e))
          return t;
        const c = r ? r.split(/[, ]/) : [];
        if (c && r !== "none") {
          const u = e.dom, f = e.selection.getNode();
          t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, (b, v, S, O) => {
            const R = u.parseStyle(u.decode(S)), M = {};
            for (let J = 0; J < c.length; J++) {
              const W = R[c[J]];
              let Q = W, ge = u.getStyle(f, c[J], !0);
              /color/.test(c[J]) && (Q = aN(Q), ge = aN(ge)), ge !== Q && (M[c[J]] = W);
            }
            const H = u.serializeStyle(M, "span");
            return H ? v + ' style="' + H + '"' + O : v + O;
          });
        } else
          t = t.replace(/(<[^>]+) style="([^"]*)"([^>]*>)/gi, "$1$3");
        return t = t.replace(/(<[^>]+) data-mce-style="([^"]+)"([^>]*>)/gi, (u, f, b, v) => f + ' style="' + b + '"' + v), t;
      }, kq = (e) => {
        (fo.browser.isChromium() || fo.browser.isSafari()) && Eq(e, Tq);
      }, Aq = (e, t) => {
        const o = Wt(!1), r = Wt(Vk(e) ? "text" : "html"), c = u8(e);
        kq(e), vq(e, r), wq(e), e.addQueryStateHandler("mceTogglePlainTextPaste", () => r.get() === "text"), e.on("PreInit", () => {
          Cq(e, t), J4(e, o), bq(e, c, r);
        });
      }, _q = (e) => {
        e.on("click", (t) => {
          e.dom.getParent(t.target, "details") && t.preventDefault();
        });
      }, Oq = (e) => {
        e.parser.addNodeFilter("details", (t) => {
          const o = cp(e);
          xe(t, (r) => {
            o === "expanded" ? r.attr("open", "open") : o === "collapsed" && r.attr("open", null);
          });
        }), e.serializer.addNodeFilter("details", (t) => {
          const o = xm(e);
          xe(t, (r) => {
            o === "expanded" ? r.attr("open", "open") : o === "collapsed" && r.attr("open", null);
          });
        });
      }, R8 = (e) => {
        _q(e), Oq(e);
      }, Dq = zs, N8 = tt, Rq = (e) => Es(e.dom), Nq = (e) => dl(e.dom), M8 = (e) => (t) => Qn(te.fromDom(e), t), Mq = (e, t, o) => Uo(te.fromDom(e), (r) => Nq(r) || o.isBlock(Hn(r)), M8(t)).getOr(te.fromDom(t)).dom, P8 = (e, t) => Uo(te.fromDom(e), Rq, M8(t)), B8 = (e, t, o) => {
        const r = new Js(e, t), c = o ? r.next.bind(r) : r.prev.bind(r);
        let u = e;
        for (let f = o ? e : c(); f && !Dq(f); f = c())
          Rs(f) && (u = f);
        return u;
      }, $8 = (e, t, o) => {
        const c = Re.fromRangeStart(e).getNode(), u = Mq(c, t, o), f = B8(c, u, !1), b = B8(c, u, !0), v = document.createRange();
        return P8(f, u).fold(() => {
          N8(f) ? v.setStart(f, 0) : v.setStartBefore(f);
        }, (S) => v.setStartBefore(S.dom)), P8(b, u).fold(() => {
          N8(b) ? v.setEnd(b, b.data.length) : v.setEndAfter(b);
        }, (S) => v.setEndAfter(S.dom)), v;
      }, I8 = (e) => {
        const t = $8(e.selection.getRng(), e.getBody(), e.schema);
        e.selection.setRng(E_(t));
      }, Pq = (e) => {
        e.on("mousedown", (t) => {
          t.detail >= 3 && (t.preventDefault(), I8(e));
        });
      };
      var Ay;
      (function(e) {
        e.Before = "before", e.After = "after";
      })(Ay || (Ay = {}));
      const Bq = (e, t) => Math.abs(e.left - t), bS = (e, t) => Math.abs(e.right - t), $q = (e, t) => e >= t.top && e <= t.bottom, Iq = (e, t) => e.top < t.bottom && e.bottom > t.top, F8 = (e, t) => {
        const o = mw(e, t) / Math.min(e.height, t.height);
        return Iq(e, t) && o > 0.5;
      }, Fq = (e, t) => {
        const o = ze(e, (r) => $q(t, r));
        return O1(o).fold(() => [[], e], (r) => {
          const { pass: c, fail: u } = st(e, (f) => F8(f, r));
          return [c, u];
        });
      }, Lq = (e, t) => ({
        node: e.node,
        position: Bq(e, t) < bS(e, t) ? Ay.Before : Ay.After
      }), Hq = (e, t, o) => t > e.left && t < e.right ? 0 : Math.min(Math.abs(e.left - t), Math.abs(e.right - t)), cN = (e, t, o, r) => {
        const c = (R) => Rs(R.node) ? P.some(R) : ht(R.node) ? cN(rs(R.node.childNodes), t, o, !1) : P.none(), u = (R, M, H) => c(M).filter((J) => Math.abs(H(R, t, o) - H(J, t, o)) < 2 && tt(J.node)), f = (R, M) => {
          const H = Tl(R, (J, W) => M(J, t, o) - M(W, t, o));
          return cc(H, c).map((J) => r && !tt(J.node) && H.length > 1 ? u(J, H[1], M).getOr(J) : J);
        }, [b, v] = Fq(WD(e), o), { pass: S, fail: O } = st(v, (R) => R.top < o);
        return f(b, Hq).orThunk(() => f(O, F2)).orThunk(() => f(S, F2));
      }, zq = (e, t, o, r) => {
        const c = (u, f) => {
          const b = (S) => ht(S) && S.classList.contains("mce-drag-container"), v = ze(u.dom.childNodes, bt(b));
          return f.fold(() => cN(v, o, r, !0), (S) => {
            const O = ze(v, (R) => R !== S.dom);
            return cN(O, o, r, !0);
          }).orThunk(() => (Qn(u, e) ? P.none() : Fc(u)).bind((O) => c(O, P.some(u))));
        };
        return c(t, P.none());
      }, e3 = (e, t, o) => {
        const r = te.fromDom(e), c = Pl(r), f = te.fromPoint(c, t, o).filter((b) => Ja(r, b)).getOr(r);
        return zq(r, f, t, o);
      }, lN = (e, t, o) => e3(e, t, o).filter((r) => tb(r.node)).map((r) => Lq(r, t)), iN = (e) => {
        const t = e.getBoundingClientRect(), o = e.ownerDocument, r = o.documentElement, c = o.defaultView;
        return {
          top: t.top + (c?.scrollY ?? 0) - r.clientTop,
          left: t.left + (c?.scrollX ?? 0) - r.clientLeft
        };
      }, Vq = (e) => e.inline ? iN(e.getBody()) : { left: 0, top: 0 }, Uq = (e) => {
        const t = e.getBody();
        return e.inline ? { left: t.scrollLeft, top: t.scrollTop } : { left: 0, top: 0 };
      }, jq = (e) => {
        const t = e.getBody(), o = e.getDoc().documentElement, r = { left: t.scrollLeft, top: t.scrollTop }, c = { left: t.scrollLeft || o.scrollLeft, top: t.scrollTop || o.scrollTop };
        return e.inline ? r : c;
      }, EX = (e, t) => {
        if (t.target.ownerDocument !== e.getDoc()) {
          const o = iN(e.getContentAreaContainer()), r = jq(e);
          return {
            left: t.pageX - o.left + r.left,
            top: t.pageY - o.top + r.top
          };
        }
        return {
          left: t.pageX,
          top: t.pageY
        };
      }, Wq = (e, t, o) => ({
        pageX: o.left - e.left + t.left,
        pageY: o.top - e.top + t.top
      }), Zq = (e, t) => Wq(Vq(e), Uq(e), EX(e, t)), t3 = (e) => ({ target: e, srcElement: e }), n3 = (e, t, o, r) => ({
        ...t,
        dataTransfer: r,
        type: e,
        ...t3(o)
      }), Gq = (e, t, o) => {
        const r = cn("Function not supported on simulated event.");
        return {
          // Event
          bubbles: !0,
          cancelBubble: !1,
          cancelable: !0,
          composed: !1,
          currentTarget: null,
          defaultPrevented: !1,
          eventPhase: 0,
          isTrusted: !0,
          returnValue: !1,
          timeStamp: 0,
          type: e,
          composedPath: r,
          initEvent: r,
          preventDefault: St,
          stopImmediatePropagation: St,
          stopPropagation: St,
          AT_TARGET: window.Event.AT_TARGET,
          BUBBLING_PHASE: window.Event.BUBBLING_PHASE,
          CAPTURING_PHASE: window.Event.CAPTURING_PHASE,
          NONE: window.Event.NONE,
          // UIEvent
          altKey: !1,
          button: 0,
          buttons: 0,
          clientX: 0,
          clientY: 0,
          ctrlKey: !1,
          layerX: 0,
          layerY: 0,
          metaKey: !1,
          movementX: 0,
          movementY: 0,
          offsetX: 0,
          offsetY: 0,
          pageX: 0,
          pageY: 0,
          relatedTarget: null,
          screenX: 0,
          screenY: 0,
          shiftKey: !1,
          x: 0,
          y: 0,
          detail: 0,
          view: null,
          which: 0,
          initUIEvent: r,
          initMouseEvent: r,
          getModifierState: r,
          // DragEvent
          dataTransfer: o,
          ...t3(t)
        };
      }, qq = (e, t) => {
        const o = dZ(e);
        return t === "dragstart" ? (HI(o), xR(o)) : t === "drop" ? (cZ(o), N4(o)) : (lZ(o), SR(o)), o;
      }, Kq = (e, t, o, r) => {
        const c = qq(o, e);
        return Gn(r) ? Gq(e, t, c) : n3(e, r, t, c);
      }, vS = 32, Yq = 100, _y = 8, yS = 16, L8 = Es, Xq = L2(L8, dl), H8 = (e, t, o) => L8(o) && o !== t && e.isEditable(o.parentElement), Qq = (e, t, o) => jt(t) || t === o || e.dom.isChildOf(t, o) ? !1 : e.dom.isEditable(t), TX = (e, t, o, r) => {
        const c = e.dom, u = t.cloneNode(!0);
        c.setStyles(u, { width: o, height: r }), c.setAttrib(u, "data-mce-selected", null);
        const f = c.create("div", {
          class: "mce-drag-container",
          "data-mce-bogus": "all",
          unselectable: "on",
          contenteditable: "false"
        });
        return c.setStyles(f, {
          position: "absolute",
          opacity: 0.5,
          overflow: "hidden",
          border: 0,
          padding: 0,
          margin: 0,
          width: o,
          height: r
        }), c.setStyles(u, {
          margin: 0,
          boxSizing: "border-box"
        }), f.appendChild(u), f;
      }, Jq = (e, t) => {
        e.parentNode !== t && t.appendChild(e);
      }, o3 = (e, t) => (o) => () => {
        const r = e === "left" ? o.scrollX : o.scrollY;
        o.scroll({
          [e]: r + t,
          behavior: "smooth"
        });
      }, z8 = o3("left", -vS), uN = o3("left", vS), s3 = o3("top", -vS), CS = o3("top", vS), V8 = (e, t, o, r, c, u, f, b, v, S, O, R) => {
        let M = 0, H = 0;
        e.style.left = t.pageX + "px", e.style.top = t.pageY + "px", t.pageX + o > c && (M = t.pageX + o - c), t.pageY + r > u && (H = t.pageY + r - u), e.style.width = o - M + "px", e.style.height = r - H + "px";
        const J = v.clientHeight, W = v.clientWidth, Q = f + v.getBoundingClientRect().top, ge = b + v.getBoundingClientRect().left;
        O.on((be) => {
          be.intervalId.clear(), be.dragging && R && (f + _y >= J ? be.intervalId.set(CS(S)) : f - _y <= 0 ? be.intervalId.set(s3(S)) : b + _y >= W ? be.intervalId.set(uN(S)) : b - _y <= 0 ? be.intervalId.set(z8(S)) : Q + yS >= window.innerHeight ? be.intervalId.set(CS(window)) : Q - yS <= 0 ? be.intervalId.set(s3(window)) : ge + yS >= window.innerWidth ? be.intervalId.set(uN(window)) : ge - yS <= 0 && be.intervalId.set(z8(window)));
        });
      }, U8 = (e) => {
        e && e.parentNode && e.parentNode.removeChild(e);
      }, eK = (e, t) => {
        const o = e.getParent(t.parentNode, e.isBlock);
        U8(t), o && o !== e.getRoot() && e.isEmpty(o) && vf(te.fromDom(o));
      }, tK = (e) => e.button === 0, nK = (e, t) => ({
        pageX: t.pageX - e.relX,
        pageY: t.pageY + 5
      }), j8 = (e, t) => (o) => {
        if (tK(o)) {
          const r = _o(t.dom.getParents(o.target), Xq).getOr(null);
          if (X(r) && H8(t.dom, t.getBody(), r)) {
            const c = t.dom.getPos(r), u = t.getBody(), f = t.getDoc().documentElement;
            e.set({
              element: r,
              dataTransfer: vy(),
              dragging: !1,
              screenX: o.screenX,
              screenY: o.screenY,
              maxX: (t.inline ? u.scrollWidth : f.offsetWidth) - 2,
              maxY: (t.inline ? u.scrollHeight : f.offsetHeight) - 2,
              relX: o.pageX - c.x,
              relY: o.pageY - c.y,
              width: r.offsetWidth,
              height: r.offsetHeight,
              ghost: TX(t, r, r.offsetWidth, r.offsetHeight),
              intervalId: Jd(Yq)
            });
          }
        }
      }, oK = (e, t, o) => {
        e._selectionOverrides.hideFakeCaret(), lN(e.getBody(), t, o).fold(() => e.selection.placeCaretAt(t, o), (r) => {
          const c = e._selectionOverrides.showCaret(1, r.node, r.position === Ay.Before, !1);
          c ? e.selection.setRng(c) : e.selection.placeCaretAt(t, o);
        });
      }, Oy = (e, t, o, r, c) => {
        t === "dragstart" && GI(r, e.dom.getOuterHTML(o));
        const u = Kq(t, o, r, c);
        return e.dispatch(t, u);
      }, sK = (e, t) => {
        const o = vt((c, u) => oK(t, c, u), 0);
        t.on("remove", o.cancel);
        const r = e;
        return (c) => e.on((u) => {
          const f = Math.max(Math.abs(c.screenX - u.screenX), Math.abs(c.screenY - u.screenY));
          if (!u.dragging && f > 10) {
            const b = Oy(t, "dragstart", u.element, u.dataTransfer, c);
            if (X(b.dataTransfer) && (u.dataTransfer = b.dataTransfer), b.isDefaultPrevented())
              return;
            u.dragging = !0, t.focus();
          }
          if (u.dragging) {
            const b = c.currentTarget === t.getDoc().documentElement, v = nK(u, Zq(t, c));
            Jq(u.ghost, t.getBody()), V8(u.ghost, v, u.width, u.height, u.maxX, u.maxY, c.clientY, c.clientX, t.getContentAreaContainer(), t.getWin(), r, b), o.throttle(c.clientX, c.clientY);
          }
        });
      }, rK = (e) => {
        const t = e.getSel();
        if (X(t)) {
          const r = t.getRangeAt(0).startContainer;
          return tt(r) ? r.parentNode : r;
        } else
          return null;
      }, dN = (e, t) => (o) => {
        e.on((r) => {
          if (r.intervalId.clear(), r.dragging) {
            if (Qq(t, rK(t.selection), r.element)) {
              const c = t.getDoc().elementFromPoint(o.clientX, o.clientY) ?? t.getBody();
              Oy(t, "drop", c, r.dataTransfer, o).isDefaultPrevented() || t.undoManager.transact(() => {
                eK(t.dom, r.element), ZI(r.dataTransfer).each((f) => t.insertContent(f)), t._selectionOverrides.hideFakeCaret();
              });
            }
            Oy(t, "dragend", t.getBody(), r.dataTransfer, o);
          }
        }), W8(e);
      }, mN = (e, t, o) => {
        e.on((r) => {
          r.intervalId.clear(), r.dragging && o.fold(() => Oy(t, "dragend", r.element, r.dataTransfer), (c) => Oy(t, "dragend", r.element, r.dataTransfer, c));
        }), W8(e);
      }, kX = (e, t) => (o) => mN(e, t, P.some(o)), W8 = (e) => {
        e.on((t) => {
          t.intervalId.clear(), U8(t.ghost);
        }), e.clear();
      }, Z8 = (e) => {
        const t = Mc(), o = lo.DOM, r = document, c = j8(t, e), u = sK(t, e), f = dN(t, e), b = kX(t, e);
        e.on("mousedown", c), e.on("mousemove", u), e.on("mouseup", f), o.bind(r, "mousemove", u), o.bind(r, "mouseup", b), e.on("remove", () => {
          o.unbind(r, "mousemove", u), o.unbind(r, "mouseup", b);
        }), e.on("keydown", (v) => {
          v.keyCode === Et.ESC && mN(t, e, P.none());
        });
      }, aK = (e) => {
        const t = (c) => {
          if (!c.isDefaultPrevented()) {
            const u = c.dataTransfer;
            u && (Lt(u.types, "Files") || u.files.length > 0) && (c.preventDefault(), c.type === "drop" && jT(e, "Dropped file type is not supported"));
          }
        }, o = (c) => {
          LE(e, c.target) && t(c);
        }, r = () => {
          const c = lo.DOM, u = e.dom, f = document, b = e.inline ? e.getBody() : e.getDoc(), v = ["drop", "dragover"];
          xe(v, (S) => {
            c.bind(f, S, o), u.bind(b, S, t);
          }), e.on("remove", () => {
            xe(v, (S) => {
              c.unbind(f, S, o), u.unbind(b, S, t);
            });
          });
        };
        e.on("init", () => {
          $d.setEditorTimeout(e, r, 0);
        });
      }, fN = (e) => {
        Z8(e), Pk(e) && aK(e);
      }, cK = (e) => {
        const t = vt(() => {
          if (!e.removed && e.getBody().contains(document.activeElement)) {
            const o = e.selection.getRng();
            if (o.collapsed) {
              const r = oh(e, o, !1);
              e.selection.setRng(r);
            }
          }
        }, 0);
        e.on("focus", () => {
          t.throttle();
        }), e.on("blur", () => {
          t.cancel();
        });
      }, lK = (e) => {
        e.on("init", () => {
          e.on("focusin", (t) => {
            const o = t.target;
            if (vi(o)) {
              const r = Om(e.getBody(), o), c = Es(r) ? r : o;
              e.selection.getNode() !== c && zf(e, c).each((u) => e.selection.setRng(u));
            }
          });
        });
      }, xS = Es, gN = (e, t) => Om(e.getBody(), t), r3 = (e) => {
        const t = e.selection, o = e.dom, r = e.getBody(), c = An(e, r, o.isBlock, () => Lv(e)), u = "sel-" + o.uniqueId(), f = "data-mce-selected";
        let b;
        const v = (Me) => X(Me) && o.hasClass(Me, "mce-offscreen-selection"), S = (Me) => Me !== r && (xS(Me) || vi(Me)) && o.isChildOf(Me, r) && o.isEditable(Me.parentNode), O = (Me) => {
          Me && t.setRng(Me);
        }, R = (Me, Te, $e, yt = !0) => e.dispatch("ShowCaret", {
          target: Te,
          direction: Me,
          before: $e
        }).isDefaultPrevented() ? null : (yt && t.scrollIntoView(Te, Me === -1), c.show($e, Te)), M = (Me) => {
          Me.hasAttribute("data-mce-caret") && (Qi(Me), t.scrollIntoView(Me));
        }, H = () => {
          e.on("click", (Te) => {
            o.isEditable(Te.target) || (Te.preventDefault(), e.focus());
          }), e.on("blur NewBlock", je), e.on("ResizeWindow FullscreenStateChanged", c.reposition), e.on("tap", (Te) => {
            const $e = Te.target, yt = gN(e, $e);
            xS(yt) ? (Te.preventDefault(), zf(e, yt).each(Be)) : S($e) && zf(e, $e).each(Be);
          }, !0), e.on("mousedown", (Te) => {
            const $e = Te.target;
            if ($e !== r && $e.nodeName !== "HTML" && !o.isChildOf($e, r) || !GV(e, Te.clientX, Te.clientY))
              return;
            je(), Kt();
            const yt = gN(e, $e);
            xS(yt) ? (Te.preventDefault(), zf(e, yt).each(Be)) : lN(r, Te.clientX, Te.clientY).each((Sn) => {
              Te.preventDefault();
              const wn = R(1, Sn.node, Sn.position === Ay.Before, !1);
              O(wn), zc(yt) ? yt.focus() : e.getBody().focus();
            });
          }), e.on("keypress", (Te) => {
            Et.modifierPressed(Te) || xS(t.getNode()) && Te.preventDefault();
          }), e.on("GetSelectionRange", (Te) => {
            let $e = Te.range;
            if (b) {
              if (!b.parentNode) {
                b = null;
                return;
              }
              $e = $e.cloneRange(), $e.selectNode(b), Te.range = $e;
            }
          }), e.on("focusin", (Te) => {
            if (!vi(Te.target) && e.getBody().contains(Te.target) && Te.target !== e.getBody() && !e.dom.isEditable(Te.target.parentNode)) {
              c.isShowing() && c.hide(), Te.target.contains(e.selection.getNode()) || (e.selection.select(Te.target, !0), e.selection.collapse(!0));
              const $e = Be(e.selection.getRng(), !0);
              $e && e.selection.setRng($e);
            }
          }), e.on("SetSelectionRange", (Te) => {
            Te.range = Q(Te.range);
            const $e = Be(Te.range, Te.forward);
            $e && (Te.range = $e);
          });
          const Me = (Te) => ht(Te) && Te.id === "mcepastebin";
          e.on("AfterSetSelectionRange", (Te) => {
            const $e = Te.range, yt = $e.startContainer.parentElement;
            !W($e) && !Me(yt) && Kt(), v(yt) || je();
          }), fN(e), cK(e), lK(e);
        }, J = (Me) => jl(Me) || bl(Me) || yf(Me), W = (Me) => J(Me.startContainer) || J(Me.endContainer), Q = (Me) => {
          const Te = e.schema.getVoidElements(), $e = o.createRng(), yt = Me.startContainer, Sn = Me.startOffset, wn = Me.endContainer, uo = Me.endOffset;
          return kn(Te, yt.nodeName.toLowerCase()) ? Sn === 0 ? $e.setStartBefore(yt) : $e.setStartAfter(yt) : $e.setStart(yt, Sn), kn(Te, wn.nodeName.toLowerCase()) ? uo === 0 ? $e.setEndBefore(wn) : $e.setEndAfter(wn) : $e.setEnd(wn, uo), $e;
        }, ge = (Me, Te) => {
          const $e = te.fromDom(e.getBody()), yt = e.getDoc(), Sn = Zi($e, "#" + u).getOrThunk(() => {
            const Go = te.fromHtml('<div data-mce-bogus="all" class="mce-offscreen-selection"></div>', yt);
            return Ss(Go, "id", u), bo($e, Go), Go;
          }), wn = o.createRng();
          Il(Sn), ll(Sn, [
            te.fromText($s, yt),
            te.fromDom(Te),
            te.fromText($s, yt)
          ]), wn.setStart(Sn.dom.firstChild, 1), wn.setEnd(Sn.dom.lastChild, 0), pc(Sn, {
            top: o.getPos(Me, e.getBody()).y + "px"
          }), cg(Sn);
          const uo = t.getSel();
          return uo && (uo.removeAllRanges(), uo.addRange(wn)), wn;
        }, be = (Me) => {
          const Te = e.getDoc().createElement("div");
          Te.style.width = Me.style.width, Te.style.height = Me.style.height;
          const $e = Me.getAttribute("width");
          $e && Te.setAttribute("width", $e);
          const yt = Me.getAttribute("height");
          return yt && Te.setAttribute("height", yt), Te;
        }, ve = (Me) => {
          const Te = f1(Me) ? be(Me) : Me.cloneNode(!0), $e = e.dispatch("ObjectSelected", { target: Me, targetClone: Te });
          if ($e.isDefaultPrevented())
            return null;
          const yt = ge(Me, $e.targetClone), Sn = te.fromDom(Me);
          return xe(Ne(te.fromDom(e.getBody()), `*[${f}]`), (wn) => {
            Qn(Sn, wn) || sr(wn, f);
          }), o.getAttrib(Me, f) || Me.setAttribute(f, "1"), b = Me, Kt(), yt;
        }, Be = (Me, Te) => {
          if (!Me)
            return null;
          if (Me.collapsed) {
            if (!W(Me)) {
              const wn = Te ? 1 : -1, uo = Rf(wn, r, Me), Go = uo.getNode(!Te);
              if (X(Go)) {
                if (tb(Go))
                  return R(wn, Go, Te ? !uo.isAtEnd() : !1, !1);
                if ($u(Go) && Es(Go.nextSibling)) {
                  const Ps = o.createRng();
                  return Ps.setStart(Go, 0), Ps.setEnd(Go, 0), Ps;
                }
              }
              const ys = uo.getNode(Te);
              if (X(ys)) {
                if (tb(ys))
                  return R(wn, ys, Te ? !1 : !uo.isAtEnd(), !1);
                if ($u(ys) && Es(ys.previousSibling)) {
                  const Ps = o.createRng();
                  return Ps.setStart(ys, 1), Ps.setEnd(ys, 1), Ps;
                }
              }
            }
            return null;
          }
          let $e = Me.startContainer, yt = Me.startOffset;
          const Sn = Me.endOffset;
          if (tt($e) && yt === 0 && xS($e.parentNode) && ($e = $e.parentNode, yt = o.nodeIndex($e), $e = $e.parentNode), !ht($e))
            return null;
          if (Sn === yt + 1 && $e === Me.endContainer) {
            const wn = $e.childNodes[yt];
            if (S(wn))
              return ve(wn);
          }
          return null;
        }, je = () => {
          b && b.removeAttribute(f), Zi(te.fromDom(e.getBody()), "#" + u).each(qo), b = null;
        }, xt = () => {
          c.destroy(), b = null;
        }, Kt = () => {
          c.hide();
        };
        return Bm(e) || H(), {
          showCaret: R,
          showBlockCaretContainer: M,
          hideFakeCaret: Kt,
          destroy: xt
        };
      }, G8 = (e, t) => {
        let o = t;
        for (let r = e.previousSibling; tt(r); r = r.previousSibling)
          o += r.data.length;
        return o;
      }, hN = (e, t, o, r, c) => {
        if (tt(o) && (r < 0 || r > o.data.length))
          return [];
        const u = c && tt(o) ? [G8(o, r)] : [r];
        let f = o;
        for (; f !== t && f.parentNode; )
          u.push(e.nodeIndex(f, c)), f = f.parentNode;
        return f === t ? u.reverse() : [];
      }, pN = (e, t, o, r, c, u, f = !1) => {
        const b = hN(e, t, o, r, f), v = hN(e, t, c, u, f);
        return { start: b, end: v };
      }, q8 = (e, t) => {
        const o = t.slice(), r = o.pop();
        return ns(r) ? Io(o, (u, f) => u.bind((b) => P.from(b.childNodes[f])), P.some(e)).bind((u) => tt(u) && (r < 0 || r > u.data.length) ? P.none() : P.some({ node: u, offset: r })) : P.none();
      }, bN = (e, t) => q8(e, t.start).bind(({ node: o, offset: r }) => q8(e, t.end).map(({ node: c, offset: u }) => {
        const f = document.createRange();
        return f.setStart(o, r), f.setEnd(c, u), f;
      })), iK = (e, t, o, r = !1) => pN(e, t, o.startContainer, o.startOffset, o.endContainer, o.endOffset, r), Dy = (e, t, o) => {
        if (t && e.isEmpty(t) && !o(t)) {
          const r = t.parentNode;
          e.remove(t, tt(t.firstChild) && Th(t.firstChild.data)), Dy(e, r, o);
        }
      }, a3 = (e, t, o, r = !0) => {
        const c = t.startContainer.parentNode, u = t.endContainer.parentNode;
        t.deleteContents(), r && !o(t.startContainer) && (tt(t.startContainer) && t.startContainer.data.length === 0 && e.remove(t.startContainer), tt(t.endContainer) && t.endContainer.data.length === 0 && e.remove(t.endContainer), Dy(e, c, o), c !== u && Dy(e, u, o));
      }, Ry = (e, t) => P.from(e.dom.getParent(t.startContainer, e.dom.isBlock)), vN = (e, t, o) => {
        const r = e.dynamicPatternsLookup({
          text: o,
          block: t
        });
        return {
          ...e,
          blockPatterns: vk(r).concat(e.blockPatterns),
          inlinePatterns: H1(r).concat(e.inlinePatterns)
        };
      }, yN = (e, t, o, r) => {
        const c = e.createRng();
        return c.setStart(t, 0), c.setEnd(o, r), c.toString();
      }, K8 = (e, t) => e.create("span", { "data-mce-type": "bookmark", id: t }), c3 = (e, t) => {
        const o = e.createRng();
        return o.setStartAfter(t.start), o.setEndBefore(t.end), o;
      }, Y8 = (e, t, o) => {
        const r = bN(e.getRoot(), o).getOrDie("Unable to resolve path range"), c = r.startContainer, u = r.endContainer, f = r.endOffset === 0 ? u : u.splitText(r.endOffset), b = r.startOffset === 0 ? c : c.splitText(r.startOffset), v = b.parentNode, S = f.parentNode;
        return {
          prefix: t,
          end: S.insertBefore(K8(e, t + "-end"), f),
          start: v.insertBefore(K8(e, t + "-start"), b)
        };
      }, X8 = (e, t, o) => {
        Dy(e, e.get(t.prefix + "-end"), o), Dy(e, e.get(t.prefix + "-start"), o);
      }, SS = (e) => e.start.length === 0, uK = (e) => (t, o) => {
        const c = t.data.substring(0, o), u = c.lastIndexOf(e.charAt(e.length - 1)), f = c.lastIndexOf(e);
        return f !== -1 ? f + e.length : u !== -1 ? u + 1 : -1;
      }, Q8 = (e, t, o, r) => {
        const c = t.start;
        return MR(e, r.container, r.offset, uK(c), o).bind((f) => {
          const b = o.textContent?.indexOf(c) ?? -1;
          if (b !== -1 && f.offset >= b + c.length) {
            const S = e.createRng();
            return S.setStart(f.container, f.offset - c.length), S.setEnd(f.container, f.offset), P.some(S);
          } else {
            const S = f.offset - c.length;
            return RR(f.container, S, o).map((O) => {
              const R = e.createRng();
              return R.setStart(O.container, O.offset), R.setEnd(f.container, f.offset), R;
            }).filter((O) => (
              // Ensure the range content matches the start
              O.toString() === c
            )).orThunk(() => (
              // No match found, so continue searching
              Q8(e, t, o, Vm(f.container, 0))
            ));
          }
        });
      }, dK = (e, t, o, r, c, u = !1) => {
        if (t.start.length === 0 && !u) {
          const f = e.createRng();
          return f.setStart(o, r), f.setEnd(o, r), P.some(f);
        }
        return OR(o, r, c).bind((f) => Q8(e, t, c, f).bind((v) => {
          if (u) {
            if (v.endContainer === f.container && v.endOffset === f.offset)
              return P.none();
            if (f.offset === 0 && v.endContainer.textContent?.length === v.endOffset)
              return P.none();
          }
          return P.some(v);
        }));
      }, J8 = (e, t, o, r) => {
        const c = e.dom, u = c.getRoot(), f = o.pattern, b = o.position.container, v = o.position.offset;
        return RR(b, v - o.pattern.end.length, t).bind((S) => {
          const O = pN(c, u, S.container, S.offset, b, v, r);
          if (SS(f))
            return P.some({
              matches: [{
                pattern: f,
                startRng: O,
                endRng: O
              }],
              position: S
            });
          {
            const R = l3(e, o.remainingPatterns, S.container, S.offset, t, r), M = R.getOr({ matches: [], position: S }), H = M.position;
            return dK(c, f, H.container, H.offset, t, R.isNone()).map((W) => {
              const Q = iK(c, u, W, r);
              return {
                matches: M.matches.concat([{
                  pattern: f,
                  startRng: Q,
                  endRng: O
                }]),
                position: Vm(W.startContainer, W.startOffset)
              };
            });
          }
        });
      }, l3 = (e, t, o, r, c, u) => {
        const f = e.dom;
        return OR(o, r, f.getRoot()).bind((b) => {
          const v = yN(f, c, o, r);
          for (let S = 0; S < t.length; S++) {
            const O = t[S];
            if (!qr(v, O.end))
              continue;
            const R = t.slice();
            R.splice(S, 1);
            const M = J8(e, c, {
              pattern: O,
              remainingPatterns: R,
              position: b
            }, u);
            if (M.isNone() && r > 0)
              return l3(e, t, o, r - 1, c, u);
            if (M.isSome())
              return M;
          }
          return P.none();
        });
      }, eL = (e, t, o) => {
        e.selection.setRng(o), t.type === "inline-format" ? xe(t.format, (r) => {
          e.formatter.apply(r);
        }) : e.execCommand(t.cmd, !1, t.value);
      }, mK = (e, t, o, r) => {
        const c = c3(e.dom, o);
        a3(e.dom, c, r), eL(e, t, c);
      }, fK = (e, t, o, r, c) => {
        const u = e.dom, f = c3(u, r), b = c3(u, o);
        a3(u, b, c), a3(u, f, c);
        const v = { prefix: o.prefix, start: o.end, end: r.start }, S = c3(u, v);
        eL(e, t, S);
      }, gK = (e, t) => {
        const o = nr("mce_textpattern"), r = qn(t, (c, u) => {
          const f = Y8(e, o + `_end${c.length}`, u.endRng);
          return c.concat([{
            ...u,
            endMarker: f
          }]);
        }, []);
        return qn(r, (c, u) => {
          const f = r.length - c.length - 1, b = SS(u.pattern) ? u.endMarker : Y8(e, o + `_start${f}`, u.startRng);
          return c.concat([{
            ...u,
            startMarker: b
          }]);
        }, []);
      }, hK = (e) => Tl(e, (t, o) => o.end.length - t.end.length), pK = (e, t) => {
        const o = qa(e, (r) => po(t, (c) => r.pattern.start === c.pattern.start && r.pattern.end === c.pattern.end));
        return e.length === t.length ? o ? e : t : e.length > t.length ? e : t;
      }, tL = (e, t, o, r, c, u) => {
        const f = l3(e, c.inlinePatterns, o, r, t, u).fold(() => [], (v) => v.matches), b = l3(e, hK(c.inlinePatterns), o, r, t, u).fold(() => [], (v) => v.matches);
        return pK(f, b);
      }, CN = (e, t) => {
        if (t.length === 0)
          return;
        const o = e.dom, r = e.selection.getBookmark(), c = gK(o, t);
        xe(c, (u) => {
          const f = o.getParent(u.startMarker.start, o.isBlock), b = (v) => v === f;
          SS(u.pattern) ? mK(e, u.pattern, u.endMarker, b) : fK(e, u.pattern, u.startMarker, u.endMarker, b), X8(o, u.endMarker, b), X8(o, u.startMarker, b);
        }), e.selection.moveToBookmark(r);
      }, nL = (e, t, o) => DR(t, 0, t).map((r) => {
        const c = r.container;
        return NR(c, o.start.length, t).each((u) => {
          const f = e.createRng();
          f.setStart(c, 0), f.setEnd(u.container, u.offset), a3(e, f, (b) => b === t);
        }), c;
      }), i3 = (e) => (t, o) => {
        const r = t.dom, c = o.pattern, u = bN(r.getRoot(), o.range).getOrDie("Unable to resolve path range"), f = (b, v) => {
          const S = v.get(b);
          return Ot(S) && js(S).exists((O) => kn(O, "block"));
        };
        return Ry(t, u).each((b) => {
          c.type === "block-format" ? f(c.format, t.formatter) && t.undoManager.transact(() => {
            e(t.dom, b, c), t.formatter.apply(c.format);
          }) : c.type === "block-command" && t.undoManager.transact(() => {
            e(t.dom, b, c), t.execCommand(c.cmd, !1, c.value);
          });
        }), !0;
      }, bK = (e) => Tl(e, (t, o) => o.start.length - t.start.length), oL = (e) => (t, o) => {
        const r = bK(t), c = o.replace($s, " ");
        return _o(r, (u) => e(u, o, c));
      }, sL = (e, t) => (o, r, c, u, f = r.textContent ?? "") => {
        const b = o.dom, v = Ar(o);
        return b.is(r, v) ? e(c.blockPatterns, f).map((S) => t && Je.trim(f).length === S.start.length ? [] : [{
          pattern: S,
          range: pN(b, b.getRoot(), r, 0, r, 0, u)
        }]).getOr([]) : [];
      }, vK = (e) => /^\s[^\s]/.test(e), yK = i3((e, t, o) => {
        nL(e, t, o).each((r) => {
          const c = te.fromDom(r), u = xa(c);
          vK(u) && s1(c, u.slice(1));
        });
      }), u3 = oL((e, t, o) => t.indexOf(e.start) === 0 || o.indexOf(e.start) === 0), CK = sL(u3, !0), xK = (e, t) => {
        const o = e.selection.getRng();
        return Ry(e, o).map((r) => {
          const c = Math.max(0, o.startOffset), u = vN(t, r, r.textContent ?? ""), f = tL(e, r, o.startContainer, c, u, !0), b = CK(e, r, u, !0);
          return { inlineMatches: f, blockMatches: b };
        }).filter(({ inlineMatches: r, blockMatches: c }) => c.length > 0 || r.length > 0);
      }, SK = (e, t) => {
        if (t.length === 0)
          return;
        const o = e.selection.getBookmark();
        xe(t, (r) => yK(e, r)), e.selection.moveToBookmark(o);
      }, wK = i3(nL), EK = oL((e, t, o) => t === e.start || o === e.start), TK = sL(EK, !1), kK = (e, t) => {
        const o = e.selection.getRng();
        return Ry(e, o).map((r) => {
          const c = Math.max(0, o.startOffset), u = yN(e.dom, r, o.startContainer, c), f = vN(t, r, u);
          return TK(e, r, f, !1, u);
        }).filter((r) => r.length > 0);
      }, AK = (e, t) => {
        xe(t, (o) => wK(e, o));
      }, _K = (e, t) => xK(e, t).fold(ye, ({ inlineMatches: o, blockMatches: r }) => (e.undoManager.add(), e.undoManager.extra(() => {
        e.execCommand("mceInsertNewLine");
      }, () => {
        $0(e), CN(e, o), SK(e, r);
        const c = e.selection.getRng(), u = OR(c.startContainer, c.startOffset, e.dom.getRoot());
        e.execCommand("mceInsertNewLine"), u.each((f) => {
          const b = f.container;
          b.data.charAt(f.offset - 1) === Pc && (b.deleteData(f.offset - 1, 1), Dy(e.dom, b.parentNode, (v) => v === e.dom.getRoot()));
        });
      }), !0)), rL = (e, t) => {
        const o = e.selection.getRng();
        Ry(e, o).map((r) => {
          const c = Math.max(0, o.startOffset - 1), u = yN(e.dom, r, o.startContainer, c), f = vN(t, r, u), b = tL(e, r, o.startContainer, c, f, !1);
          b.length > 0 && e.undoManager.transact(() => {
            CN(e, b);
          });
        });
      }, OK = (e, t) => kK(e, t).fold(ye, (o) => (e.undoManager.transact(() => {
        AK(e, o);
      }), !0)), xN = (e, t, o) => {
        for (let r = 0; r < e.length; r++)
          if (o(e[r], t))
            return !0;
        return !1;
      }, DK = (e, t) => xN(e, t, (o, r) => o === r.keyCode && !Et.modifierPressed(r)), RK = (e, t) => xN(e, t, (o, r) => o.charCodeAt(0) === r.charCode), aL = (e) => {
        const t = [",", ".", ";", ":", "!", "?"], o = [32], r = () => yk(aE(e).filter((f) => f.type === "inline-command" || f.type === "block-command" ? e.queryCommandSupported(f.cmd) : !0), Xt(e)), c = () => ap(e);
        e.on("keydown", (f) => {
          if (f.keyCode === 13 && !Et.modifierPressed(f) && e.selection.isCollapsed() && e.selection.isEditable()) {
            const b = z1(r(), "enter");
            (b.inlinePatterns.length > 0 || b.blockPatterns.length > 0 || c()) && _K(e, b) && f.preventDefault();
          }
        }, !0), e.on("keydown", (f) => {
          if (f.keyCode === 32 && e.selection.isCollapsed() && e.selection.isEditable()) {
            const b = z1(r(), "space");
            (b.blockPatterns.length > 0 || c()) && OK(e, b) && f.preventDefault();
          }
        }, !0);
        const u = () => {
          if (e.selection.isCollapsed() && e.selection.isEditable()) {
            const f = z1(r(), "space");
            (f.inlinePatterns.length > 0 || c()) && rL(e, f);
          }
        };
        e.on("keyup", (f) => {
          DK(o, f) && u();
        }), e.on("keypress", (f) => {
          RK(t, f) && $d.setEditorTimeout(e, u);
        });
      }, wS = (e) => {
        aL(e);
      }, NK = (e) => {
        const t = Je.each, o = Et.BACKSPACE, r = Et.DELETE, c = e.dom, u = e.selection, f = e.parser, b = fo.browser, v = b.isFirefox(), S = b.isChromium() || b.isSafari(), O = fo.deviceType.isiPhone() || fo.deviceType.isiPad(), R = fo.os.isMacOS() || fo.os.isiOS(), M = (Le, ut) => {
          try {
            e.getDoc().execCommand(Le, !1, String(ut));
          } catch {
          }
        }, H = (Le) => Le.isDefaultPrevented(), J = () => {
          const Le = ($t) => {
            const to = c.create("body"), Zn = $t.cloneContents();
            return to.appendChild(Zn), u.serializer.serialize(to, { format: "html" });
          }, ut = ($t) => {
            const to = Le($t), Zn = c.createRng();
            Zn.selectNode(e.getBody());
            const Qo = Le(Zn);
            return to === Qo;
          };
          e.on("keydown", ($t) => {
            const to = $t.keyCode;
            if (!H($t) && (to === r || to === o) && e.selection.isEditable()) {
              const Zn = e.selection.isCollapsed(), Qo = e.getBody();
              if (Zn && !on(e.schema, Qo) || !Zn && !ut(e.selection.getRng()))
                return;
              $t.preventDefault(), e.setContent(""), Qo.firstChild && c.isBlock(Qo.firstChild) ? e.selection.setCursorLocation(Qo.firstChild, 0) : e.selection.setCursorLocation(Qo, 0), e.nodeChanged();
            }
          });
        }, W = () => {
          e.shortcuts.add("meta+a", null, "SelectAll");
        }, Q = () => {
          e.inline || c.bind(e.getDoc(), "mousedown mouseup", (Le) => {
            let ut;
            if (Le.target === e.getDoc().documentElement)
              if (ut = u.getRng(), e.getDoc().getSelection()?.anchorNode !== null && e.getBody().focus(), Le.type === "mousedown") {
                if (jl(ut.startContainer))
                  return;
                u.placeCaretAt(Le.clientX, Le.clientY);
              } else
                u.setRng(ut);
          });
        }, ge = () => {
          e.on("keydown", (Le) => {
            if (!H(Le) && Le.keyCode === o) {
              if (!e.getBody().getElementsByTagName("hr").length)
                return;
              if (u.isCollapsed() && u.getRng().startOffset === 0) {
                const ut = u.getNode(), $t = ut.previousSibling;
                if (ut.nodeName === "HR") {
                  c.remove(ut), Le.preventDefault();
                  return;
                }
                $t && $t.nodeName && $t.nodeName.toLowerCase() === "hr" && (c.remove($t), Le.preventDefault());
              }
            }
          });
        }, be = () => {
          Range.prototype.getClientRects || e.on("mousedown", (Le) => {
            if (!H(Le) && Le.target.nodeName === "HTML") {
              const ut = e.getBody();
              ut.blur(), $d.setEditorTimeout(e, () => {
                ut.focus();
              });
            }
          });
        }, ve = () => {
          const Le = bv(e);
          e.on("click", (ut) => {
            const $t = ut.target;
            /^(IMG|HR)$/.test($t.nodeName) && c.isEditable($t) && (ut.preventDefault(), e.selection.select($t), e.nodeChanged()), $t.nodeName === "A" && c.hasClass($t, Le) && $t.childNodes.length === 0 && c.isEditable($t.parentNode) && (ut.preventDefault(), u.select($t));
          });
        }, Be = () => {
          const Le = (ut) => ut.nodeName === "IMG" && e.dom.isEditable(ut);
          e.on("mousedown", (ut) => {
            Xs(P.from(ut.clientX), P.from(ut.clientY), ($t, to) => {
              const Zn = e.getDoc().caretPositionFromPoint($t, to), Qo = Zn?.offsetNode?.childNodes[Zn.offset - (Zn.offset > 0 ? 1 : 0)] || Zn?.offsetNode;
              if (X(Qo) && Le(Qo)) {
                const _i = Qo.getBoundingClientRect();
                ut.preventDefault(), e.hasFocus() || e.focus(), e.selection.select(Qo), ut.clientX < _i.left || ut.clientY < _i.top ? e.selection.collapse(!0) : (ut.clientX > _i.right || ut.clientY > _i.bottom) && e.selection.collapse(!1);
              }
            });
          });
        }, je = () => {
          const Le = () => {
            const $t = c.getAttribs(u.getStart().cloneNode(!1));
            return () => {
              const to = u.getStart();
              to !== e.getBody() && (c.setAttrib(to, "style", null), t($t, (Zn) => {
                to.setAttributeNode(Zn.cloneNode(!0));
              }));
            };
          }, ut = () => !u.isCollapsed() && c.getParent(u.getStart(), c.isBlock) !== c.getParent(u.getEnd(), c.isBlock);
          e.on("keypress", ($t) => {
            let to;
            return !H($t) && ($t.keyCode === 8 || $t.keyCode === 46) && ut() ? (to = Le(), e.getDoc().execCommand("delete", !1), to(), $t.preventDefault(), !1) : !0;
          }), c.bind(e.getDoc(), "cut", ($t) => {
            if (!H($t) && ut()) {
              const to = Le();
              $d.setEditorTimeout(e, () => {
                to();
              });
            }
          });
        }, xt = () => {
          e.on("keydown", (Le) => {
            if (!H(Le) && Le.keyCode === o && u.isCollapsed() && u.getRng().startOffset === 0) {
              const ut = u.getNode().previousSibling;
              if (ut && ut.nodeName && ut.nodeName.toLowerCase() === "table")
                return Le.preventDefault(), !1;
            }
            return !0;
          });
        }, Kt = () => {
          e.on("keydown", (Le) => {
            if (H(Le) || Le.keyCode !== Et.BACKSPACE)
              return;
            let ut = u.getRng();
            const $t = ut.startContainer, to = ut.startOffset, Zn = c.getRoot();
            let Qo = $t;
            if (!(!ut.collapsed || to !== 0)) {
              for (; Qo.parentNode && Qo.parentNode.firstChild === Qo && Qo.parentNode !== Zn; )
                Qo = Qo.parentNode;
              Qo.nodeName === "BLOCKQUOTE" && (e.formatter.toggle("blockquote", void 0, Qo), ut = c.createRng(), ut.setStart($t, 0), ut.setEnd($t, 0), u.setRng(ut));
            }
          });
        }, Me = () => {
          const Le = fr("figcaption");
          e.on("keydown", (ut) => {
            if (ut.keyCode === Et.LEFT || ut.keyCode === Et.RIGHT) {
              const $t = te.fromDom(e.selection.getNode());
              Le($t) && e.selection.isCollapsed() && ec($t).bind((to) => e.selection.getRng().startOffset === 0 && ut.keyCode === Et.LEFT ? rl(to) : e.selection.getRng().endOffset === $t.dom.textContent?.length && ut.keyCode === Et.RIGHT ? tc(to) : P.none()).each((to) => {
                e.selection.setCursorLocation(to.dom, 0);
              });
            }
          });
        }, Te = () => {
          const Le = () => {
            M("StyleWithCSS", !1), M("enableInlineTableEditing", !1), Jw(e) || M("enableObjectResizing", !1);
          };
          q1(e) || e.on("BeforeExecCommand mousedown", Le);
        }, $e = () => {
          const Le = () => {
            t(c.select("a:not([data-mce-block])"), (ut) => {
              let $t = ut.parentNode;
              const to = c.getRoot();
              if ($t?.lastChild === ut) {
                for (; $t && !c.isBlock($t); ) {
                  if ($t.parentNode?.lastChild !== $t || $t === to)
                    return;
                  $t = $t.parentNode;
                }
                c.add($t, "br", { "data-mce-bogus": 1 });
              }
            });
          };
          e.on("SetContent ExecCommand", (ut) => {
            (ut.type === "setcontent" || ut.command === "mceInsertLink") && Le();
          });
        }, yt = () => {
          e.on("init", () => {
            M("DefaultParagraphSeparator", Ar(e));
          });
        }, Sn = (Le) => {
          const ut = Le.getBody(), $t = Le.selection.getRng();
          return $t.startContainer === $t.endContainer && $t.startContainer === ut && $t.startOffset === 0 && $t.endOffset === ut.childNodes.length;
        }, wn = () => {
          e.on("keyup focusin mouseup", (Le) => {
            !Et.modifierPressed(Le) && !Sn(e) && u.normalize();
          }, !0);
        }, uo = () => {
          e.contentStyles.push("img:-moz-broken {-moz-force-broken-image-icon:1;min-width:24px;min-height:24px}");
        }, Go = () => {
          e.inline || e.on("keydown", () => {
            document.activeElement === document.body && e.getWin().focus();
          });
        }, ys = () => {
          e.inline || (e.contentStyles.push("body {min-height: 150px}"), e.on("click", (Le) => {
            let ut;
            Le.target.nodeName === "HTML" && (ut = e.selection.getRng(), e.getBody().focus(), e.selection.setRng(ut), e.selection.normalize(), e.nodeChanged());
          }));
        }, Ps = () => {
          R && e.on("keydown", (Le) => {
            Et.metaKeyPressed(Le) && !Le.shiftKey && (Le.keyCode === 37 || Le.keyCode === 39) && (Le.preventDefault(), e.selection.getSel().modify("move", Le.keyCode === 37 ? "backward" : "forward", "lineboundary"));
          });
        }, Ra = () => {
          e.on("click", (Le) => {
            let ut = Le.target;
            do
              if (ut.tagName === "A") {
                Le.preventDefault();
                return;
              }
            while (ut = ut.parentNode);
          }), e.contentStyles.push(".mce-content-body {-webkit-touch-callout: none}");
        }, Ai = () => {
          e.on("init", () => {
            e.dom.bind(e.getBody(), "submit", (Le) => {
              Le.preventDefault();
            });
          });
        }, At = () => {
          f.addNodeFilter("br", (Le) => {
            let ut = Le.length;
            for (; ut--; )
              Le[ut].attr("class") === "Apple-interchange-newline" && Le[ut].remove();
          });
        }, sn = St, Lo = () => {
          if (!v || e.removed)
            return !1;
          const Le = e.selection.getSel();
          return !Le || !Le.rangeCount || Le.rangeCount === 0;
        }, Ao = () => {
          S && (Q(), ve(), Ai(), W(), O && (Go(), ys(), Ra())), v && (be(), Te(), uo(), Ps());
        }, Ga = () => {
          Kt(), J(), fo.windowsPhone || wn(), S && (Q(), ve(), yt(), Ai(), xt(), At(), O ? (Go(), ys(), Ra()) : W()), v && (Me(), Be(), ge(), be(), je(), Te(), $e(), uo(), Ps(), xt());
        };
        return Bm(e) ? Ao() : Ga(), {
          refreshContentEditable: sn,
          isHidden: Lo
        };
      };
      class SN extends Error {
        url;
        constructor(t, o) {
          super(t), this.url = o;
        }
      }
      const wN = {}, MK = (e, t, o) => new Promise((r, c) => {
        const u = te.fromTag("script");
        ea(u, {
          type: "text/javascript",
          src: e,
          ...o
        });
        const f = () => {
          qo(u);
        };
        ag(u, "load", () => {
          f(), r();
        }), ag(u, "error", () => {
          f(), c(new Error(`Failed to load script url: ${e}`));
        }), bo(Yp(t), u);
      }), cL = async (e, t) => {
        const o = Do.ScriptLoader.getScriptAttributes(e);
        return await MK(e, t, o).catch(() => Promise.reject(new SN(`Failed to load component url: ${e}`, e))), e;
      }, PK = (e) => ic(e, (t, o) => Wo(wN, t).getOrThunk(() => {
        if (jt(window.customElements.get(o))) {
          const r = cL(t, ph());
          return wN[t] = r, r;
        } else
          return Promise.resolve(t);
      }).catch((r) => (delete wN[t], Promise.reject(r)))), lL = (e, t) => {
        const o = Ka(Pa(e));
        return en(o, (r) => cL(r, te.fromDom(t)));
      }, BK = (e) => {
        const t = e.schema.getComponentUrls();
        return e.inline ? PK(t) : lL(t, e.getDoc());
      }, iL = async (e) => {
        const t = BK(e), o = ze(await Promise.allSettled(t), (r) => r.status === "rejected");
        o.length > 0 && xe(o, (r) => {
          if (r.reason instanceof SN) {
            const { url: c } = r.reason;
            XV(e, c);
          }
        });
      }, $K = (e) => {
        iL(e);
      }, EN = lo.DOM, IK = (e, t) => {
        const o = te.fromDom(e.getBody()), r = Xp(Fr(o)), c = te.fromTag("style");
        Ss(c, "type", "text/css"), bo(c, te.fromText(t)), bo(r, c), e.on("remove", () => {
          qo(c);
        });
      }, FK = (e) => e.inline ? e.getElement().nodeName.toLowerCase() : void 0, TN = (e) => Ri(e, (t) => Gn(t) === !1), uL = (e) => {
        const t = e.options.get, o = e.editorUpload.blobCache;
        return TN({
          allow_conditional_comments: t("allow_conditional_comments"),
          allow_html_data_urls: t("allow_html_data_urls"),
          allow_svg_data_urls: t("allow_svg_data_urls"),
          allow_html_in_named_anchor: t("allow_html_in_named_anchor"),
          allow_script_urls: t("allow_script_urls"),
          allow_html_in_comments: t("allow_html_in_comments"),
          allow_mathml_annotation_encodings: t("allow_mathml_annotation_encodings"),
          allow_unsafe_link_target: t("allow_unsafe_link_target"),
          convert_unsafe_embeds: t("convert_unsafe_embeds"),
          convert_fonts_to_spans: t("convert_fonts_to_spans"),
          extended_mathml_attributes: t("extended_mathml_attributes"),
          extended_mathml_elements: t("extended_mathml_elements"),
          fix_list_elements: t("fix_list_elements"),
          font_size_legacy_values: t("font_size_legacy_values"),
          forced_root_block: t("forced_root_block"),
          forced_root_block_attrs: t("forced_root_block_attrs"),
          preserve_cdata: t("preserve_cdata"),
          inline_styles: t("inline_styles"),
          root_name: FK(e),
          sandbox_iframes: t("sandbox_iframes"),
          sandbox_iframes_exclusions: Sm(e),
          sanitize: t("xss_sanitization"),
          validate: !0,
          blob_cache: o,
          document: e.getDoc()
        });
      }, dL = (e) => {
        const t = e.options.get;
        return TN({
          custom_elements: t("custom_elements"),
          extended_valid_elements: t("extended_valid_elements"),
          invalid_elements: t("invalid_elements"),
          invalid_styles: t("invalid_styles"),
          schema: t("schema"),
          valid_children: t("valid_children"),
          valid_classes: t("valid_classes"),
          valid_elements: t("valid_elements"),
          valid_styles: t("valid_styles"),
          verify_html: t("verify_html"),
          padd_empty_block_inline_children: t("format_empty_lines")
        });
      }, LK = (e) => {
        const t = e.options.get;
        return {
          ...uL(e),
          ...dL(e),
          ...TN({
            // SerializerSettings
            remove_trailing_brs: t("remove_trailing_brs"),
            pad_empty_with_br: t("pad_empty_with_br"),
            url_converter: t("url_converter"),
            url_converter_scope: t("url_converter_scope"),
            // Writer settings
            element_format: t("element_format"),
            entities: t("entities"),
            entity_encoding: t("entity_encoding"),
            indent: t("indent"),
            indent_after: t("indent_after"),
            indent_before: t("indent_before")
          })
        };
      }, HK = (e) => {
        const t = Gv(uL(e), e.schema);
        return t.addAttributeFilter("src,href,style,tabindex", (o, r) => {
          const c = e.dom, u = "data-mce-" + r;
          let f = o.length;
          for (; f--; ) {
            const b = o[f];
            let v = b.attr(r);
            if (v && !b.attr(u)) {
              if (v.indexOf("data:") === 0 || v.indexOf("blob:") === 0)
                continue;
              r === "style" ? (v = c.serializeStyle(c.parseStyle(v), b.name), v.length || (v = null), b.attr(u, v), b.attr(r, v)) : r === "tabindex" ? (b.attr(u, v), b.attr(r, null)) : b.attr(u, e.convertURL(v, r, b.name));
            }
          }
        }), t.addNodeFilter("script", (o) => {
          let r = o.length;
          for (; r--; ) {
            const c = o[r], u = c.attr("type") || "no/type";
            u.indexOf("mce-") !== 0 && c.attr("type", "mce-" + u);
          }
        }), EC(e) && t.addNodeFilter("#cdata", (o) => {
          let r = o.length;
          for (; r--; ) {
            const c = o[r];
            c.type = 8, c.name = "#comment", c.value = "[CDATA[" + e.dom.encode(c.value ?? "") + "]]";
          }
        }), t.addNodeFilter("p,h1,h2,h3,h4,h5,h6,div", (o) => {
          let r = o.length;
          const c = e.schema.getNonEmptyElements();
          for (; r--; ) {
            const u = o[r];
            u.isEmpty(c) && u.getAll("br").length === 0 && u.append(new _a("br", 1));
          }
        }), t;
      }, mL = (e) => {
        const t = $k(e);
        t && $d.setEditorTimeout(e, () => {
          let o;
          t === !0 ? o = e : o = e.editorManager.get(t), o && !o.destroyed && (o.focus(), o.selection.scrollIntoView());
        }, 100);
      }, kN = (e) => {
        const t = e.dom.getRoot();
        !e.inline && (!VC(e) || e.selection.getStart(!0) === t) && E(t).each((o) => {
          const r = o.getNode(), c = Vc(r) ? E(r).getOr(o) : o;
          e.selection.setRng(c.toRange());
        });
      }, fL = (e) => {
        e.bindPendingEventDelegates(), e.initialized = !0, Nw(e), e.focus(!0), kN(e), e.nodeChanged({ initial: !0 });
        const t = Bk(e);
        se(t) && t.call(e, e), mL(e), Jg(e) && D6(e, !0);
      }, d3 = (e) => e.inline ? e.ui.styleSheetLoader : e.dom.styleSheetLoader, zK = (e, t, o) => {
        const { pass: r, fail: c } = st(t, (b) => tinymce.Resource.has(Ep(b))), f = [
          ...r.map((b) => {
            const v = tinymce.Resource.get(Ep(b));
            return U(v) ? Promise.resolve(d3(e).loadRawCss(b, v)) : Promise.resolve();
          }),
          d3(e).loadAll(c)
        ];
        return e.inline ? f : f.concat([
          e.ui.styleSheetLoader.loadAll(o)
        ]);
      }, gL = (e) => {
        const t = d3(e), o = hC(e), r = e.contentCSS, c = () => {
          t.unloadAll(r), e.inline || e.ui.styleSheetLoader.unloadAll(o);
        }, u = () => {
          e.removed ? c() : e.on("remove", c);
        };
        if (e.contentStyles.length > 0) {
          let v = "";
          Je.each(e.contentStyles, (S) => {
            v += S + `\r
`;
          }), e.dom.addStyle(v);
        }
        const f = Promise.all(zK(e, r, o)).then(u).catch(u), b = $g(e);
        return b && IK(e, b), f;
      }, VK = (e) => {
        const t = e.getDoc(), o = e.getBody();
        Rw(e), sE(e) || (t.body.spellcheck = !1, EN.setAttrib(o, "spellcheck", "false")), e.quirks = NK(e), So(e);
        const r = kk(e);
        r !== void 0 && (o.dir = r);
        const c = Ik(e);
        c && e.on("BeforeSetContent", (u) => {
          Je.each(c, (f) => {
            u.content = u.content.replace(f, (b) => "<!--mce:protected " + escape(b) + "-->");
          });
        }), e.on("SetContent", () => {
          e.addVisual(e.getBody());
        }), e.on("compositionstart compositionend", (u) => {
          e.composing = u.type === "compositionstart";
        });
      }, hL = (e) => {
        Bm(e) || e.load({ initial: !0, format: "html" }), e.startContent = e.getContent({ format: "raw" });
      }, m3 = (e) => {
        e.removed !== !0 && (hL(e), fL(e));
      }, UK = (e) => {
        let t = !1;
        const o = setTimeout(() => {
          t || e.setProgressState(!0);
        }, 500);
        return () => {
          clearTimeout(o), t = !0, e.setProgressState(!1);
        };
      }, pL = (e) => {
        const t = e.getElement();
        let o = e.getDoc();
        e.inline && (EN.addClass(t, "mce-content-body"), e.contentDocument = o = document, e.contentWindow = window, e.bodyElement = t, e.contentAreaContainer = t);
        const r = e.getBody();
        r.disabled = !0, e.readonly = q1(e), e._editableRoot = pv(e), !ou(e) && e.hasEditableRoot() && (e.inline && EN.getStyle(r, "position", !0) === "static" && (r.style.position = "relative"), r.contentEditable = "true"), r.disabled = !1, e.editorUpload = Ab(e), e.schema = wa(dL(e)), e.dom = lo(o, {
          keep_values: !0,
          // Note: Don't bind here, as the binding is handled via the `url_converter_scope`
          // eslint-disable-next-line @typescript-eslint/unbound-method
          url_converter: e.convertURL,
          url_converter_scope: e,
          update_styles: !0,
          root_element: e.inline ? e.getBody() : null,
          collect: e.inline,
          schema: e.schema,
          contentCssCors: Yw(e),
          referrerPolicy: dv(e),
          crossOrigin: Bg(e),
          onSetAttrib: (f) => {
            e.dispatch("SetAttrib", f);
          }
        }), e.parser = HK(e), e.serializer = EO(LK(e), e), e.selection = SO(e.dom, e.getWin(), e.serializer, e), e.annotator = E5(e), e.formatter = $6(e), e.undoManager = xU(e), e._nodeChangeDispatcher = new YG(e), e._selectionOverrides = r3(e), es(e), UW(e), R8(e), GW(e), Bm(e) || (Pq(e), wS(e));
        const c = VG(e);
        cR(e, c), Gd(e), TU(e), Aq(e, c);
        const u = kV(e);
        VK(e), $K(e), u.fold(() => {
          const f = UK(e);
          gL(e).then(() => {
            m3(e), f();
          });
        }, (f) => {
          e.setProgressState(!0), gL(e).then(() => {
            f().then((b) => {
              e.setProgressState(!1), m3(e), HT(e);
            }, (b) => {
              e.notificationManager.open({ type: "error", text: String(b) }), m3(e), HT(e);
            });
          });
        });
      }, ES = lo.DOM, f3 = (e, t, o, r) => {
        const c = te.fromTag("iframe");
        return r.each((u) => Ss(c, "tabindex", u)), ea(c, o), ea(c, {
          id: e + "_ifr",
          frameBorder: "0",
          allowTransparency: "true",
          ...fo.browser.isFirefox() ? { title: t } : {}
        }), bc(c, "tox-edit-area__iframe"), c;
      }, bL = (e) => {
        let t = uC(e) + "<html><head>";
        dC(e) !== e.editorManager.documentBaseURL && (t += '<base href="' + e.documentBaseURI.getURI() + '" />'), t += '<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />';
        const o = zw(e), r = Vw(e), c = e.translate(vv(e)), u = fo.browser.isFirefox() ? "" : `aria-label="${c}"`;
        return Uw(e) && (t += '<meta http-equiv="Content-Security-Policy" content="' + Uw(e) + '" />'), t += `</head><body id="${o}" class="mce-content-body ${r}" data-id="${e.id}" ${u}><br></body></html>`, t;
      }, vL = (e, t) => {
        const o = vv(e), r = e.translate(o), c = il(te.fromDom(e.getElement()), "tabindex").bind(Jf), u = f3(e.id, r, Hw(e), c).dom;
        u.onload = () => {
          u.onload = null, e.dispatch("load");
        }, e.contentAreaContainer = t.iframeContainer, e.iframeElement = u, e.iframeHTML = bL(e), ES.add(t.iframeContainer, u);
      }, yL = (e) => {
        const t = e.iframeElement, o = () => {
          e.contentDocument = t.contentDocument, pL(e);
        };
        if (J1(e) || fo.browser.isFirefox()) {
          const r = e.getDoc();
          r.open(), r.write(e.iframeHTML), r.close(), o();
        } else {
          const r = ag(te.fromDom(t), "load", () => {
            r.unbind(), o();
          });
          t.srcdoc = e.iframeHTML;
        }
      }, jK = (e, t) => {
        vL(e, t), t.editorContainer && (t.editorContainer.style.display = e.orgDisplay, e.hidden = ES.isHidden(t.editorContainer)), e.getElement().style.display = "none", ES.setAttrib(e.id, "aria-hidden", "true"), e.getElement().style.visibility = e.orgVisibility, yL(e);
      }, CL = lo.DOM, WK = (e, t, o) => {
        const r = wp.get(o), c = wp.urls[o] || e.editorManager.documentBaseURL.replace(/\/$/, "");
        if (o = Je.trim(o), r && Je.inArray(t, o) === -1) {
          if (e.plugins[o])
            return;
          try {
            const u = r(e, c) || {};
            e.plugins[o] = u, se(u.init) && (u.init(e, c), t.push(o));
          } catch (u) {
            QV(e, o, u);
          }
        }
      }, ZK = (e) => {
        const t = (o) => {
          o.keyCode === Et.ESC && !o.defaultPrevented && Lw(e).isDefaultPrevented() && o.preventDefault();
        };
        document.addEventListener("keyup", t), e.inline || e.on("keyup", t), e.on("remove", () => {
          document.removeEventListener("keyup", t), e.inline || e.off("keyup", t);
        });
      }, Gf = (e) => e.replace(/^\-/, ""), xL = (e) => {
        const t = [];
        xe(K1(e), (o) => {
          WK(e, t, Gf(o));
        });
      }, GK = (e) => {
        const t = Je.trim(Z1(e)), o = e.ui.registry.getAll().icons, r = {
          ...UT.get("default").icons,
          ...UT.get(t).icons
        };
        Un(r, (c, u) => {
          kn(o, u) || e.ui.registry.addIcon(u, c);
        });
      }, SL = (e) => {
        const t = Od(e);
        if (U(t)) {
          const o = xb.get(t);
          e.theme = o(e, xb.urls[t]) || {}, se(e.theme.init) && e.theme.init(e, xb.urls[t] || e.editorManager.documentBaseURL.replace(/\/$/, ""));
        } else
          e.theme = {};
      }, qK = (e) => {
        const t = gv(e), o = ny.get(t);
        e.model = o(e, ny.urls[t]);
      }, KK = (e) => {
        zO.init(e);
      }, AN = (e) => {
        const t = e.theme.renderUI;
        return t ? t() : EL(e);
      }, g3 = (e) => {
        const t = e.getElement(), r = Od(e)(e, t);
        return r.editorContainer.nodeType && (r.editorContainer.id = r.editorContainer.id || e.id + "_parent"), r.iframeContainer && r.iframeContainer.nodeType && (r.iframeContainer.id = r.iframeContainer.id || e.id + "_iframecontainer"), r.height = r.iframeHeight ? r.iframeHeight : t.offsetHeight, r;
      }, wL = (e, t) => ({
        editorContainer: e,
        iframeContainer: t,
        api: {}
      }), YK = (e) => {
        const t = CL.create("div");
        return CL.insertAfter(t, e), wL(t, t);
      }, EL = (e) => {
        const t = e.getElement();
        return e.inline ? wL(null) : YK(t);
      }, TL = (e) => {
        const t = e.getElement();
        return e.orgDisplay = t.style.display, U(Od(e)) ? AN(e) : se(Od(e)) ? g3(e) : EL(e);
      }, XK = (e, t) => {
        const o = {
          show: P.from(t.show).getOr(St),
          hide: P.from(t.hide).getOr(St),
          isEnabled: P.from(t.isEnabled).getOr(He),
          setEnabled: (r) => {
            r && (e.mode.get() === "readonly" || Jg(e)) || P.from(t.setEnabled).each((u) => u(r));
          }
        };
        e.ui = { ...e.ui, ...o };
      }, kL = async (e) => {
        e.dispatch("ScriptsLoaded"), GK(e), ZK(e), SL(e), qK(e), KK(e), xL(e);
        const t = await TL(e);
        XK(e, P.from(t.api).getOr({})), e.editorContainer = t.editorContainer, iU(e), e.inline ? pL(e) : jK(e, {
          editorContainer: t.editorContainer,
          iframeContainer: t.iframeContainer
        });
      }, zb = lo.DOM, AL = (e) => e.charAt(0) === "-", QK = (e, t) => {
        const o = Xw(t), r = Qw(t);
        if (!pl.hasCode(o) && o !== "en") {
          const c = ms(r) ? r : `${t.editorManager.baseURL}/langs/${o}.js`;
          e.add(c).catch(() => {
            wb(t, c, o);
          });
        }
      }, JK = (e, t) => {
        const o = Od(e);
        if (U(o) && !AL(o) && !kn(xb.urls, o)) {
          const r = eE(e), c = r ? e.documentBaseURI.toAbsolute(r) : `themes/${o}/theme${t}.js`;
          xb.load(o, c).catch(() => {
            y6(e, c, o);
          });
        }
      }, eY = (e, t) => {
        const o = gv(e);
        if (o !== "plugin" && !kn(ny.urls, o)) {
          const r = Ok(e), c = U(r) ? e.documentBaseURI.toAbsolute(r) : `models/${o}/model${t}.js`;
          ny.load(o, c).catch(() => {
            YV(e, c, o);
          });
        }
      }, _L = (e, t) => {
        zO.load(e, t);
      }, h3 = (e) => P.from(fC(e)).filter(ms).map((t) => ({
        url: t,
        name: P.none()
      })), p3 = (e, t, o) => P.from(t).filter((r) => ms(r) && !UT.has(r)).map((r) => ({
        url: `${e.editorManager.baseURL}/icons/${r}/icons${o}.js`,
        name: P.some(r)
      })), tY = (e, t, o) => {
        const r = p3(t, "default", o), c = h3(t).orThunk(() => p3(t, Z1(t), ""));
        xe(uc([r, c]), (u) => {
          e.add(u.url).catch(() => {
            KV(t, u.url, u.name.getOrUndefined());
          });
        });
      }, OL = (e, t) => {
        const o = (r, c) => {
          r !== "licensekeymanager" && wp.load(r, c).catch(() => {
            v6(e, c, r);
          });
        };
        Un(CC(e), (r, c) => {
          o(c, r), e.options.set("plugins", K1(e).concat(c));
        }), xe(K1(e), (r) => {
          r = Je.trim(r), r && !wp.urls[r] && !AL(r) && o(r, `plugins/${r}/plugin${t}.js`);
        });
      }, DL = (e) => {
        const t = Od(e);
        return !U(t) || X(xb.get(t));
      }, nY = (e) => {
        const t = gv(e);
        return X(ny.get(t));
      }, RL = (e, t) => {
        const o = Do.ScriptLoader, r = () => {
          !e.removed && DL(e) && nY(e) && kL(e);
        };
        JK(e, t), eY(e, t), _L(e, t), QK(o, e), tY(o, e, t), OL(e, t), o.loadQueue().then(r, r);
      }, oY = (e, t) => b2.forElement(e, {
        contentCssCors: yC(t),
        referrerPolicy: dv(t)
      }), sY = (e) => {
        const t = e.id;
        pl.setCode(Xw(e));
        const o = () => {
          zb.unbind(window, "ready", o), e.render();
        };
        if (!zh.Event.domLoaded) {
          zb.bind(window, "ready", o);
          return;
        }
        if (!e.getElement())
          return;
        const r = te.fromDom(e.getElement()), c = Kn(r);
        e.on("remove", () => {
          We(r.dom.attributes, (f) => sr(r, f.name)), ea(r, c);
        }), e.ui.styleSheetLoader = oY(r, e), G1(e) ? e.inline = !0 : (e.orgVisibility = e.getElement().style.visibility, e.getElement().style.visibility = "hidden");
        const u = e.getElement().form || zb.getParent(t, "form");
        u && (e.formElement = u, vC(e) && !pi(e.getElement()) && (zb.insertAfter(zb.create("input", { type: "hidden", name: t }), t), e.hasHiddenInput = !0), e.formEventDelegate = (f) => {
          e.dispatch(f.type, f);
        }, zb.bind(u, "submit reset", e.formEventDelegate), e.on("reset", () => {
          e.resetContent();
        }), Nk(e) && !u.submit.nodeType && !u.submit.length && !u._mceOldSubmit && (u._mceOldSubmit = u.submit, u.submit = () => (e.editorManager.triggerSave(), e.setDirty(!1), u._mceOldSubmit(u)))), e.windowManager = b6(e), e.notificationManager = Bx(e), lE(e) && e.on("GetContent", (f) => {
          f.save && (f.content = zb.encode(f.content));
        }), Mk(e) && e.on("submit", () => {
          e.initialized && e.save();
        }), hv(e) && (e._beforeUnload = () => {
          e.initialized && !e.destroyed && !e.isHidden() && e.save({ format: "raw", no_events: !0, set_dirty: !1 });
        }, e.editorManager.on("BeforeUnload", e._beforeUnload)), e.editorManager.add(e), RL(e, e.suffix);
      }, NL = [
        "#E41B60",
        // Pink
        "#AD1457",
        // Dark Pink
        "#1939EC",
        // Indigo
        "#001CB5",
        // Dark Indigo
        "#648000",
        // Lime
        "#465B00",
        // Dark Lime
        "#006CE7",
        // Blue
        "#0054B4",
        // Dark Blue
        "#00838F",
        // Cyan
        "#006064",
        // Dark Cyan
        "#00866F",
        // Turquoise
        "#004D40",
        // Dark Turquoise
        "#51742F",
        // Green
        "#385021",
        // Dark Green
        "#CF4900",
        // Orange
        "#A84600",
        // Dark Orange
        "#CC0000",
        // Red
        "#6A1B9A",
        // Dark Red
        "#9C27B0",
        // Purple
        "#6A00AB",
        // Dark Purple
        "#3041BA",
        // Navy Blue
        "#0A1877",
        // Dark Navy Blue
        "#774433",
        // Brown
        "#452B24",
        // Dark Brown
        "#607D8B",
        // Blue Gray
        "#455A64"
        // Dark Blue Gray
      ], rY = (e) => Intl.Segmenter ? `${new Intl.Segmenter().segment(e)[Symbol.iterator]().next().value?.segment}` : e.trim()[0], ML = (e, t) => {
        let o = 5381;
        for (let r = 0; r < e.length; r++)
          o = (o << 5) + o + e.charCodeAt(r);
        return (o >>> 0) % (t + 1);
      }, PL = (e) => {
        const t = ML(e ?? "", NL.length - 1);
        return NL[t];
      }, BL = (e, t, o) => {
        const r = o / 2;
        return `<svg height="${o}" width="${o}" xmlns="http://www.w3.org/2000/svg"><circle cx="${r}" cy="${r}" r="${r}" fill="${t}"/><text x="50%" y="50%" text-anchor="middle" dominant-baseline="central" fill="#FFF" font-family="sans-serif" font-size="${r}">` + e + "</text></svg>";
      }, $L = (e, t, o) => "data:image/svg+xml," + encodeURIComponent(BL(e, t, o)), b3 = (e, t = { size: 36 }) => $L(rY(e.name), PL(e.id), t.size), IL = Ac([
        ym("id"),
        Tf("name"),
        Tf("avatar"),
        io("custom")
      ]), _N = (e) => {
        const t = {};
        return Un(e, (o, r) => {
          o.each((c) => {
            t[r] = c;
          });
        }), t;
      }, FL = (e) => {
        if (!Array.isArray(e))
          throw new Error("fetch_users must return an array");
        const t = en(e, (c) => np("Invalid user object", IL, c)), { errors: o, values: r } = Br(t);
        if (o.length > 0) {
          const c = en(o, (u, f) => `User at index ${f}: ${Ad(u)}`);
          console.warn(`User validation errors:
` + c.join(`
`));
        }
        return en(r, (c) => {
          const { id: u, name: f, avatar: b, ...v } = c;
          return {
            id: u,
            name: f.getOr(u),
            avatar: b.getOr(b3({ id: u, name: f.getOr(u) })),
            ..._N(v)
          };
        });
      }, LL = (e) => {
        const t = /* @__PURE__ */ new Map(), o = /* @__PURE__ */ new Map(), r = (S) => P.from(t.get(S)), c = (S, O) => {
          t.set(O, S);
        }, u = (S, O) => P.from(o.get(S)).each(({ reject: R }) => {
          R(O), o.delete(S);
        }), f = (S, O) => P.from(o.get(S)).each(({ resolve: R }) => {
          R(O), o.delete(S);
        }), b = (S) => {
          const O = mE(e);
          if (Array.isArray(S)) {
            if (!O)
              return vu(S, (M) => Promise.resolve({
                id: M,
                name: M,
                avatar: b3({ id: M, name: M })
              }));
          } else return {};
          const R = Ka(ze(S, (M) => !r(M).isSome()));
          return xe(R, (M) => {
            const H = new Promise((J, W) => {
              o.set(M, { resolve: J, reject: W });
            });
            c(H, M);
          }), R.length > 0 && O(R).then(FL).then((M) => {
            const H = new Set(en(M, (J) => J.id));
            xe(M, (J) => f(J.id, J)), xe(R, (J) => {
              H.has(J) || u(J, new Error(`User ${J} not found`));
            });
          }).catch((M) => {
            xe(R, (H) => u(H, M instanceof Error ? M : new Error("Network error")));
          }), Io(S, (M, H) => (M[H] = r(H).getOr(Promise.resolve({
            id: H,
            name: H,
            avatar: b3({ id: H, name: H })
          })), M), {});
        }, v = dE(e);
        return Object.freeze({
          userId: v,
          fetchUsers: b
        });
      }, HL = (e) => LL(e), aY = (e, t) => {
        e._editableRoot !== t && (e._editableRoot = t, Jg(e) || (e.getBody().contentEditable = String(e.hasEditableRoot()), e.nodeChanged()), Fw(e, t));
      }, cY = (e) => e._editableRoot, zL = (e, t) => ({
        sections: ot(e),
        options: ot(t)
      }), ON = Ii().deviceType, DN = ON.isPhone(), VL = ON.isTablet(), Vb = (e) => {
        if (jt(e))
          return [];
        {
          const t = Ot(e) ? e : e.split(/[ ,]/), o = en(t, _s);
          return ze(o, ms);
        }
      }, RN = (e, t) => {
        const o = as(t, (r, c) => Lt(e, c));
        return zL(o.t, o.f);
      }, v3 = (e, t, o = {}) => {
        const r = e.sections(), c = Wo(r, t).getOr({});
        return Je.extend({}, o, c);
      }, y3 = (e, t) => kn(e.sections(), t), UL = (e, t) => y3(e, t) ? e.sections()[t] : {}, jL = (e, t) => ({
        ...{
          table_grid: !1,
          // Table grid relies on hover, which isn't available for touch devices so use the dialog instead
          object_resizing: !1,
          // No nice way to do object resizing at this stage
          resize: !1,
          // Editor resize doesn't make sense on mobile
          toolbar_mode: Wo(e, "toolbar_mode").getOr("scrolling"),
          // Use the default side-scrolling toolbar for tablets/phones
          toolbar_sticky: !1
          // Only enable sticky toolbar on desktop by default
        },
        ...t ? {
          menubar: !1
          // Phones don't have a lot of screen space, so disable the menubar
        } : {}
      }), NN = (e, t) => {
        const o = t.external_plugins ?? {};
        return e && e.external_plugins ? Je.extend({}, e.external_plugins, o) : o;
      }, WL = (e, t) => [
        ...Vb(e),
        ...Vb(t)
      ], ZL = (e, t, o, r) => e && y3(t, "mobile") ? r : o, lY = (e, t, o, r) => {
        const c = Vb(o.forced_plugins), u = Vb(r.plugins), f = UL(t, "mobile"), b = f.plugins ? Vb(f.plugins) : u, v = ZL(e, t, u, b), S = WL(c, v);
        return Je.extend(r, {
          forced_plugins: c,
          plugins: S
        });
      }, GL = (e, t) => e && y3(t, "mobile"), iY = (e, t, o, r, c) => {
        const u = e ? { mobile: jL(c.mobile ?? {}, t) } : {}, f = RN(["mobile"], xu(u, c)), b = Je.extend(
          // Default options
          o,
          // tinymce.overrideOptions options
          r,
          // User options
          f.options(),
          // Sections
          GL(e, f) ? v3(f, "mobile") : {},
          // Forced options
          {
            external_plugins: NN(r, f.options())
          }
        );
        return lY(e, f, r, b);
      }, uY = (e, t) => {
        const o = kl(t);
        return iY(DN || VL, DN, o, e, o);
      }, dY = (e, t) => a6(e, t), qL = (e) => {
        const t = (r, c) => {
          e.formatter.toggle(r, c), e.nodeChanged();
        }, o = (r) => () => {
          xe("left,center,right,justify".split(","), (c) => {
            r !== c && e.formatter.remove("align" + c);
          }), r !== "none" && t("align" + r);
        };
        e.editorCommands.addCommands({
          JustifyLeft: o("left"),
          JustifyCenter: o("center"),
          JustifyRight: o("right"),
          JustifyFull: o("justify"),
          JustifyNone: o("none")
        });
      }, mY = (e) => {
        const t = (o) => () => {
          const r = e.selection, c = r.isCollapsed() ? [e.dom.getParent(r.getNode(), e.dom.isBlock)] : r.getSelectedBlocks();
          return po(c, (u) => X(e.formatter.matchNode(u, o)));
        };
        e.editorCommands.addCommands({
          JustifyLeft: t("alignleft"),
          JustifyCenter: t("aligncenter"),
          JustifyRight: t("alignright"),
          JustifyFull: t("alignjustify")
        }, "state");
      }, KL = (e) => {
        qL(e), mY(e);
      }, C3 = (e) => {
        e.editorCommands.addCommands({
          "Cut,Copy,Paste": (t) => {
            const o = e.getDoc();
            let r;
            try {
              o.execCommand(t);
            } catch {
              r = !0;
            }
            if (t === "paste" && !o.queryCommandEnabled(t) && (r = !0), r || !o.queryCommandSupported(t)) {
              let c = e.translate("Your browser doesn't support direct access to the clipboard. Please use the Ctrl+X/C/V keyboard shortcuts instead.");
              (fo.os.isMacOS() || fo.os.isiOS()) && (c = c.replace(/Ctrl\+/g, "⌘+")), e.notificationManager.open({ text: c, type: "error" });
            }
          }
        });
      }, fY = (e, t, o, r) => {
        const c = te.fromDom(e.getRoot());
        return sx(c, Re.fromRangeStart(t), r) ? o = o.replace(/^ /, "&nbsp;") : o = o.replace(/^&nbsp;/, " "), Dc(c, Re.fromRangeEnd(t), r) ? o = o.replace(/(&nbsp;| )(<br( \/)>)?$/, "&nbsp;") : o = o.replace(/&nbsp;(<br( \/)?>)?$/, " "), o;
      }, YL = (e) => {
        if (typeof e != "string") {
          const t = Je.extend({
            paste: e.paste,
            data: {
              paste: e.paste
            }
          }, e);
          return {
            content: e.content,
            details: t
          };
        }
        return {
          content: e,
          details: {}
        };
      }, gY = (e, t) => {
        const o = e.selection, r = e.dom;
        return /^ | $/.test(t) ? fY(r, o.getRng(), t, e.schema) : t;
      }, TS = (e, t) => {
        if (e.selection.isEditable()) {
          const { content: o, details: r } = YL(t);
          xx(e, { ...r, content: gY(e, o), format: "html", set: !1, selection: !0 }).each((c) => {
            const u = Xg(e, c.content, r);
            W_(e, u, c), e.addVisual();
          });
        }
      }, MN = (e) => {
        e.editorCommands.addCommands({
          mceCleanup: () => {
            const t = e.selection.getBookmark();
            e.setContent(e.getContent()), e.selection.moveToBookmark(t);
          },
          insertImage: (t, o, r) => {
            TS(e, e.dom.createHTML("img", { src: r }));
          },
          insertHorizontalRule: () => {
            e.execCommand("mceInsertContent", !1, "<hr>");
          },
          insertText: (t, o, r) => {
            TS(e, e.dom.encode(r));
          },
          insertHTML: (t, o, r) => {
            TS(e, r);
          },
          mceInsertContent: (t, o, r) => {
            TS(e, r);
          },
          mceSetContent: (t, o, r) => {
            e.setContent(r);
          },
          mceReplaceContent: (t, o, r) => {
            e.execCommand("mceInsertContent", !1, r.replace(/\{\$selection\}/g, e.selection.getContent({ format: "text" })));
          },
          mceNewDocument: () => {
            e.setContent(Hk(e));
          }
        });
      }, hY = {
        "font-size": "size",
        "font-family": "face"
      }, pY = fr("font"), XL = (e, t, o) => {
        const r = (u) => rr(u, e).orThunk(() => pY(u) ? Wo(hY, e).bind((f) => il(u, f)) : P.none()), c = (u) => Qn(te.fromDom(t), u);
        return gi(te.fromDom(o), (u) => r(u), c);
      }, bY = (e) => (
        // 'Font name', Font -> Font name,Font
        e.replace(/[\'\"\\]/g, "").replace(/,\s+/g, ",")
      ), vY = (e, t) => P.from(lo.DOM.getStyle(t, e, !0)), QL = (e) => (t, o) => P.from(o).map(te.fromDom).filter(Is).bind((r) => XL(e, t, r.dom).or(vY(e, r.dom))).getOr(""), yY = QL("font-size"), CY = A(bY, QL("font-family")), JL = (e) => E(e.getBody()).bind((t) => {
        const o = t.container();
        return P.from(tt(o) ? o.parentNode : o);
      }), e7 = (e) => P.from(e.selection.getRng()).bind((t) => {
        const o = e.getBody();
        return t.startContainer === o && t.startOffset === 0 ? P.none() : P.from(e.selection.getStart(!0));
      }), xY = (e, t) => e7(e).orThunk(ue(JL, e)).map(te.fromDom).filter(Is).bind(t), PN = (e, t) => xY(e, No(P.some, t)), t7 = (e, t) => {
        if (/^[0-9.]+$/.test(t)) {
          const o = parseInt(t, 10);
          if (o >= 1 && o <= 7) {
            const r = TC(e), c = kC(e);
            return c.length > 0 ? c[o - 1] || t : r[o - 1] || t;
          } else
            return t;
        } else
          return t;
      }, SY = (e) => {
        const t = e.split(/\s*,\s*/);
        return en(t, (o) => o.indexOf(" ") !== -1 && !(hn(o, '"') || hn(o, "'")) ? `'${o}'` : o).join(",");
      }, n = (e, t) => {
        const o = t7(e, t);
        e.formatter.toggle("fontname", { value: SY(o) }), e.nodeChanged();
      }, s = (e) => PN(e, (t) => CY(e.getBody(), t.dom)).getOr(""), a = (e, t) => {
        e.formatter.toggle("fontsize", { value: t7(e, t) }), e.nodeChanged();
      }, l = (e) => PN(e, (t) => yY(e.getBody(), t.dom)).getOr(""), d = (e) => PN(e, (t) => {
        const o = te.fromDom(e.getBody()), r = gi(t, (u) => rr(u, "line-height"), ue(Qn, o)), c = () => {
          const u = parseFloat(Ls(t, "line-height")), f = parseFloat(Ls(t, "font-size"));
          return String(u / f);
        };
        return r.getOrThunk(c);
      }).getOr(""), g = (e, t) => {
        e.formatter.toggle("lineheight", { value: String(t) }), e.nodeChanged();
      }, h = (e) => {
        const t = (o, r) => {
          e.formatter.toggle(o, r), e.nodeChanged();
        };
        e.editorCommands.addCommands({
          "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (o) => {
            t(o);
          },
          "ForeColor,HiliteColor": (o, r, c) => {
            t(o, { value: c });
          },
          BackColor: (o, r, c) => {
            t("hilitecolor", { value: c });
          },
          FontName: (o, r, c) => {
            n(e, c);
          },
          FontSize: (o, r, c) => {
            a(e, c);
          },
          LineHeight: (o, r, c) => {
            g(e, c);
          },
          Lang: (o, r, c) => {
            t(o, { value: c.code, customValue: c.customCode ?? null });
          },
          RemoveFormat: (o) => {
            e.formatter.remove(o);
          },
          mceBlockQuote: () => {
            t("blockquote");
          },
          FormatBlock: (o, r, c) => {
            t(U(c) ? c : "p");
          },
          mceToggleFormat: (o, r, c) => {
            t(c);
          }
        });
      }, C = (e) => {
        const t = (o) => e.formatter.match(o);
        e.editorCommands.addCommands({
          "Bold,Italic,Underline,Strikethrough,Superscript,Subscript": (o) => t(o),
          mceBlockQuote: () => t("blockquote")
        }, "state"), e.editorCommands.addQueryValueHandler("FontName", () => s(e)), e.editorCommands.addQueryValueHandler("FontSize", () => l(e)), e.editorCommands.addQueryValueHandler("LineHeight", () => d(e));
      }, x = (e) => {
        h(e), C(e);
      }, T = (e) => {
        e.editorCommands.addCommands({
          mceAddUndoLevel: () => {
            e.undoManager.add();
          },
          mceEndUndoLevel: () => {
            e.undoManager.add();
          },
          Undo: () => {
            e.undoManager.undo();
          },
          Redo: () => {
            e.undoManager.redo();
          }
        });
      }, _ = (e) => {
        e.editorCommands.addCommands({
          Indent: () => {
            lI(e);
          },
          Outdent: () => {
            sh(e);
          }
        }), e.editorCommands.addCommands({
          Outdent: () => rI(e),
          Indent: () => HW(e)
        }, "state");
      }, N = (e) => {
        const t = (o, r, c) => {
          if (e.mode.isReadOnly())
            return;
          const u = U(c) ? { href: c } : c, f = e.dom.getParent(e.selection.getNode(), "a");
          Ye(u) && U(u.href) && (u.href = u.href.replace(/ /g, "%20").replace(/&amp;/g, "&"), (!f || !u.href) && e.formatter.remove("link"), u.href && e.formatter.apply("link", u, f));
        };
        e.editorCommands.addCommands({
          unlink: () => {
            if (e.selection.isEditable()) {
              if (e.selection.isCollapsed()) {
                const o = e.dom.getParent(e.selection.getStart(), "a");
                o && e.dom.remove(o, !0);
                return;
              }
              e.formatter.remove("link");
            }
          },
          mceInsertLink: t,
          createLink: t
        });
      }, L = (e, t, o, r) => {
        const c = e.dom, u = (b) => c.isBlock(b) && b.parentElement === o, f = u(t) ? t : c.getParent(r, u, o);
        return P.from(f).map(te.fromDom);
      }, j = (e, t) => {
        if (e.mode.isReadOnly())
          return;
        const o = e.dom, r = e.selection.getRng(), c = t ? e.selection.getStart() : e.selection.getEnd(), u = t ? r.startContainer : r.endContainer, f = iS(o, u);
        if (!f || !f.isContentEditable)
          return;
        const b = t ? ca : cl, v = Ar(e);
        L(e, c, f, u).each((S) => {
          const O = OF(e, u, S.dom, f, !1, v);
          b(S, te.fromDom(O)), e.selection.setCursorLocation(O, 0), e.dispatch("NewBlock", { newBlock: O }), cS(e, "insertParagraph");
        });
      }, Z = (e) => j(e, !0), ne = (e) => j(e, !1), ae = (e) => {
        e.editorCommands.addCommands({
          InsertNewBlockBefore: () => {
            Z(e);
          },
          InsertNewBlockAfter: () => {
            ne(e);
          }
        });
      }, Y = (e) => {
        e.editorCommands.addCommands({
          insertParagraph: () => {
            U4(dS, e);
          },
          mceInsertNewLine: (t, o, r) => {
            ZF(e, r);
          },
          InsertLineBreak: (t, o, r) => {
            U4(zF, e);
          }
        });
      }, le = (e) => {
        e.editorCommands.addCommands({
          mceSelectNodeDepth: (t, o, r) => {
            let c = 0;
            e.dom.getParent(e.selection.getNode(), (u) => ht(u) && c++ === r ? (e.selection.select(u), !1) : !0, e.getBody());
          },
          mceSelectNode: (t, o, r) => {
            e.selection.select(r);
          },
          selectAll: () => {
            const t = e.dom.getParent(e.selection.getStart(), dl);
            if (t) {
              const o = e.dom.createRng();
              o.selectNodeContents(t), e.selection.setRng(o);
            }
          }
        });
      }, pe = (e) => {
        e.editorCommands.addCommands({
          mceRemoveNode: (t, o, r) => {
            const c = r ?? e.selection.getNode();
            if (c !== e.getBody()) {
              const u = e.selection.getBookmark();
              e.dom.remove(c, !0), e.selection.moveToBookmark(u);
            }
          },
          mcePrint: () => {
            e.getWin().print();
          },
          mceFocus: (t, o, r) => {
            M5(e, r === !0);
          },
          mceToggleVisualAid: () => {
            e.hasVisual = !e.hasVisual, e.addVisual();
          }
        });
      }, Ee = (e) => {
        KL(e), C3(e), T(e), le(e), MN(e), N(e), _(e), ae(e), Y(e), x(e), pe(e);
      }, Oe = ["toggleview"], gt = (e) => Lt(Oe, e.toLowerCase());
      class Ue {
        editor;
        commands = { state: {}, exec: {}, value: {} };
        constructor(t) {
          this.editor = t;
        }
        /**
         * Executes a registered command on the current instance. A list of available commands can be found in
         * the tinymce command identifiers documentation.
         *
         * @method execCommand
         * @param {String} command Command name to execute, for example mceLink or Bold.
         * @param {Boolean} ui Specifies if a UI (dialog) should be presented or not.
         * @param {Object/Array/String/Number/Boolean} value Optional command value, this can be anything.
         * @param {Object} args Optional arguments object.
         * @return {Boolean} true or false if the command was supported or not.
         */
        execCommand(t, o = !1, r, c) {
          const u = this.editor, f = t.toLowerCase(), b = c?.skip_focus;
          if (u.removed || (f !== "mcefocus" && (!/^(mceAddUndoLevel|mceEndUndoLevel)$/i.test(f) && !b ? u.focus() : N7(u)), u.dispatch("BeforeExecCommand", { command: t, ui: o, value: r }).isDefaultPrevented()))
            return !1;
          const S = this.commands.exec[f];
          return se(S) ? (S(f, o, r, c), u.dispatch("ExecCommand", { command: t, ui: o, value: r, args: c }), !0) : !1;
        }
        /**
         * Queries the current state for a command. For example: If the current selection is "bold".
         *
         * @method queryCommandState
         * @param {String} command Command to check the state of.
         * @return {Boolean} true/false - For example: If the selected contents is bold or not.
         */
        queryCommandState(t) {
          if (!gt(t) && this.editor.quirks.isHidden() || this.editor.removed)
            return !1;
          const o = t.toLowerCase(), r = this.commands.state[o];
          return se(r) ? r(o) : !1;
        }
        /**
         * Returns a command specific value, for example the current font size.
         *
         * @method queryCommandValue
         * @param {String} command Command to query value from.
         * @return {String} Command value, for example the current font size or an empty string (`""`) if the query command is not found.
         */
        queryCommandValue(t) {
          if (!gt(t) && this.editor.quirks.isHidden() || this.editor.removed)
            return "";
          const o = t.toLowerCase(), r = this.commands.value[o];
          return se(r) ? r(o) : "";
        }
        addCommands(t, o = "exec") {
          const r = this.commands;
          Un(t, (c, u) => {
            xe(u.toLowerCase().split(","), (f) => {
              r[o][f] = c;
            });
          });
        }
        addCommand(t, o, r) {
          const c = t.toLowerCase();
          this.commands.exec[c] = (u, f, b, v) => o.call(r ?? this.editor, f, b, v);
        }
        /**
         * Removes a command from the command collection.
         *
         * @method removeCommand
         * @param {String} command Command name to remove.
         * @param {String} type Optional type to remove, defaults to removing all types. Can be 'exec', 'state', 'value', or omitted for all.
         */
        removeCommand(t, o) {
          const r = t.toLowerCase();
          o ? delete this.commands[o][r] : (delete this.commands.exec[r], delete this.commands.state[r], delete this.commands.value[r]);
        }
        /**
         * Returns true/false if the command is supported or not.
         *
         * @method queryCommandSupported
         * @param {String} command Command that we check support for.
         * @return {Boolean} true/false if the command is supported or not.
         */
        queryCommandSupported(t) {
          const o = t.toLowerCase();
          return !!this.commands.exec[o];
        }
        addQueryStateHandler(t, o, r) {
          this.commands.state[t.toLowerCase()] = () => o.call(r ?? this.editor);
        }
        addQueryValueHandler(t, o, r) {
          this.commands.value[t.toLowerCase()] = () => o.call(r ?? this.editor);
        }
      }
      const Qe = Je.makeMap("focus blur focusin focusout click dblclick mousedown mouseup mousemove mouseover beforepaste paste cut copy selectionchange mouseout mouseenter mouseleave wheel keydown keypress keyup input beforeinput contextmenu dragstart dragend dragover draggesture dragdrop drop drag submit compositionstart compositionend compositionupdate touchstart touchmove touchend touchcancel", " ");
      class Ke {
        /**
         * Returns true/false if the specified event name is a native browser event or not.
         *
         * @method isNative
         * @param {String} name Name to check if it's native.
         * @return {Boolean} true/false if the event is native or not.
         * @static
         */
        static isNative(t) {
          return !!Qe[t.toLowerCase()];
        }
        settings;
        scope;
        toggleEvent;
        bindings = {};
        constructor(t) {
          this.settings = t || {}, this.scope = this.settings.scope || this, this.toggleEvent = this.settings.toggleEvent || ye;
        }
        /**
         * Fires the specified event by name.
         * <br>
         * <em>Marked for removal in TinyMCE 8.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {String} name Name of the event to fire.
         * @param {Object?} args Event arguments.
         * @return {Object} Event args instance passed in.
         * @deprecated Use dispatch() instead
         * @example
         * instance.fire('event', {...});
         */
        fire(t, o) {
          return this.dispatch(t, o);
        }
        /**
         * Dispatches the specified event by name.
         *
         * @method dispatch
         * @param {String} name Name of the event to dispatch
         * @param {Object?} args Event arguments.
         * @return {Object} Event args instance passed in.
         * @example
         * instance.dispatch('event', {...});
         */
        dispatch(t, o) {
          const r = t.toLowerCase(), c = E0(r, o ?? {}, this.scope);
          this.settings.beforeFire && this.settings.beforeFire(c);
          const u = this.bindings[r];
          if (u)
            for (let f = 0, b = u.length; f < b; f++) {
              const v = u[f];
              if (!v.removed) {
                if (v.once && this.off(r, v.func), c.isImmediatePropagationStopped())
                  return c;
                if (v.func.call(this.scope, c) === !1)
                  return c.preventDefault(), c;
              }
            }
          return c;
        }
        /**
         * Binds an event listener to a specific event by name.
         *
         * @method on
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.on('event', (e) => {
         *   // Callback logic
         * });
         */
        on(t, o, r, c) {
          if (o === !1 && (o = ye), o) {
            const u = {
              func: o,
              removed: !1
            };
            c && Je.extend(u, c);
            const f = t.toLowerCase().split(" ");
            let b = f.length;
            for (; b--; ) {
              const v = f[b];
              let S = this.bindings[v];
              S || (S = [], this.toggleEvent(v, !0)), r ? S = [u, ...S] : S = [...S, u], this.bindings[v] = S;
            }
          }
          return this;
        }
        /**
         * Unbinds an event listener to a specific event by name.
         *
         * @method off
         * @param {String?} name Name of the event to unbind.
         * @param {Function?} callback Callback to unbind.
         * @return {Object} Current class instance.
         * @example
         * // Unbind specific callback
         * instance.off('event', handler);
         *
         * // Unbind all listeners by name
         * instance.off('event');
         *
         * // Unbind all events
         * instance.off();
         */
        off(t, o) {
          if (t) {
            const r = t.toLowerCase().split(" ");
            let c = r.length;
            for (; c--; ) {
              const u = r[c];
              let f = this.bindings[u];
              if (!u)
                return Un(this.bindings, (b, v) => {
                  this.toggleEvent(v, !1), delete this.bindings[v];
                }), this;
              if (f) {
                if (!o)
                  f.length = 0;
                else {
                  const b = st(f, (v) => v.func === o);
                  f = b.fail, this.bindings[u] = f, xe(b.pass, (v) => {
                    v.removed = !0;
                  });
                }
                f.length || (this.toggleEvent(t, !1), delete this.bindings[u]);
              }
            }
          } else
            Un(this.bindings, (r, c) => {
              this.toggleEvent(c, !1);
            }), this.bindings = {};
          return this;
        }
        /**
         * Binds an event listener to a specific event by name
         * and automatically unbind the event once the callback fires.
         *
         * @method once
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.once('event', (e) => {
         *   // Callback logic
         * });
         */
        once(t, o, r) {
          return this.on(t, o, r, { once: !0 });
        }
        /**
         * Returns true/false if the dispatcher has a event of the specified name.
         *
         * @method has
         * @param {String} name Name of the event to check for.
         * @return {Boolean} true/false if the event exists or not.
         */
        has(t) {
          t = t.toLowerCase();
          const o = this.bindings[t];
          return !(!o || o.length === 0);
        }
      }
      const Qt = (e) => (e._eventDispatcher || (e._eventDispatcher = new Ke({
        scope: e,
        toggleEvent: (t, o) => {
          Ke.isNative(t) && e.toggleNativeEvent && e.toggleNativeEvent(t, o);
        }
      })), e._eventDispatcher), zt = {
        /**
         * Fires the specified event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         * <br>
         * <em>Deprecated in TinyMCE 6.0 and has been marked for removal in TinyMCE 9.0. Use <code>dispatch</code> instead.</em>
         *
         * @method fire
         * @param {String} name Name of the event to fire.
         * @param {Object?} args Event arguments.
         * @param {Boolean?} bubble True/false if the event is to be bubbled.
         * @return {Object} Event args instance passed in.
         * @deprecated Use dispatch() instead
         * @example
         * instance.fire('event', {...});
         */
        fire(e, t, o) {
          return Sx("fire"), this.dispatch(e, t, o);
        },
        /**
         * Dispatches the specified event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method dispatch
         * @param {String} name Name of the event to dispatch.
         * @param {Object?} args Event arguments.
         * @param {Boolean?} bubble True/false if the event is to be bubbled.
         * @return {Object} Event args instance passed in.
         * @example
         * instance.dispatch('event', {...});
         */
        dispatch(e, t, o) {
          const r = this;
          if (r.removed && e !== "remove" && e !== "detach")
            return E0(e.toLowerCase(), t ?? {}, r);
          const c = Qt(r).dispatch(e, t);
          if (o !== !1 && r.parent) {
            let u = r.parent();
            for (; u && !c.isPropagationStopped(); )
              u.dispatch(e, c, !1), u = u.parent ? u.parent() : void 0;
          }
          return c;
        },
        /**
         * Binds an event listener to a specific event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method on
         * @param {String} name Event name or space separated list of events to bind.
         * @param {Function} callback Callback to be executed when the event occurs.
         * @param {Boolean} prepend Optional flag if the event should be prepended. Use this with care.
         * @return {Object} Current class instance.
         * @example
         * instance.on('event', (e) => {
         *   // Callback logic
         * });
         */
        on(e, t, o) {
          return Qt(this).on(e, t, o);
        },
        /**
         * Unbinds an event listener to a specific event by name. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method off
         * @param {String?} name Name of the event to unbind.
         * @param {Function?} callback Callback to unbind.
         * @return {Object} Current class instance.
         * @example
         * // Unbind specific callback
         * instance.off('event', handler);
         *
         * // Unbind all listeners by name
         * instance.off('event');
         *
         * // Unbind all events
         * instance.off();
         */
        off(e, t) {
          return Qt(this).off(e, t);
        },
        /**
         * Bind the event callback and once it fires the callback is removed. Consult the
         * <a href="https://www.tiny.cloud/docs/tinymce/8/events/">event reference</a> for more details on each event.
         *
         * @method once
         * @param {String} name Name of the event to bind.
         * @param {Function} callback Callback to bind only once.
         * @return {Object} Current class instance.
         */
        once(e, t) {
          return Qt(this).once(e, t);
        },
        /**
         * Returns true/false if the object has a event of the specified name.
         *
         * @method hasEventListeners
         * @param {String} name Name of the event to check for.
         * @return {Boolean} true/false if the event exists or not.
         */
        hasEventListeners(e) {
          return Qt(this).has(e);
        }
      }, jn = lo.DOM;
      let Jt;
      const _n = (e, t) => {
        if (t === "selectionchange")
          return e.getDoc();
        if (!e.inline && /^(?:mouse|touch|click|contextmenu|drop|dragover|dragend)/.test(t))
          return e.getDoc().documentElement;
        const o = fv(e);
        return o ? (e.eventRoot || (e.eventRoot = jn.select(o)[0]), e.eventRoot) : e.getBody();
      }, Ut = (e) => !e.hidden && !Jg(e), Ve = (e, t, o) => {
        Ut(e) ? e.dispatch(t, o) : Jg(e) && sU(e, o);
      }, ct = (e, t) => {
        if (e.delegates || (e.delegates = {}), e.delegates[t] || e.removed)
          return;
        const o = _n(e, t);
        if (fv(e)) {
          if (Jt || (Jt = {}, e.editorManager.on("removeEditor", () => {
            e.editorManager.activeEditor || Jt && (Un(Jt, (c, u) => {
              e.dom.unbind(_n(e, u));
            }), Jt = null);
          })), Jt[t])
            return;
          const r = (c) => {
            const u = c.target, f = e.editorManager.get();
            let b = f.length;
            for (; b--; ) {
              const v = f[b].getBody();
              (v === u || jn.isChildOf(u, v)) && Ve(f[b], t, c);
            }
          };
          Jt[t] = r, jn.bind(o, t, r);
        } else {
          const r = (c) => {
            Ve(e, t, c);
          };
          jn.bind(o, t, r), e.delegates[t] = r;
        }
      }, mn = {
        ...zt,
        /**
         * Bind any pending event delegates. This gets executed after the target body/document is created.
         *
         * @private
         */
        bindPendingEventDelegates() {
          const e = this;
          Je.each(e._pendingNativeEvents, (t) => {
            ct(e, t);
          });
        },
        /**
         * Toggles a native event on/off this is called by the EventDispatcher when
         * the first native event handler is added and when the last native event handler is removed.
         *
         * @private
         */
        toggleNativeEvent(e, t) {
          const o = this;
          e === "focus" || e === "blur" || o.removed || (t ? o.initialized ? ct(o, e) : o._pendingNativeEvents ? o._pendingNativeEvents.push(e) : o._pendingNativeEvents = [e] : o.initialized && o.delegates && (o.dom.unbind(_n(o, e), e, o.delegates[e]), delete o.delegates[e]));
        },
        /**
         * Unbinds all native event handlers that means delegates, custom events bound using the Events API etc.
         *
         * @private
         */
        unbindAllNativeEvents() {
          const e = this, t = e.getBody(), o = e.dom;
          e.delegates && (Un(e.delegates, (r, c) => {
            e.dom.unbind(_n(e, c), c, r);
          }), delete e.delegates), !e.inline && t && o && (t.onload = null, o.unbind(e.getWin()), o.unbind(e.getDoc())), o && (o.unbind(t), o.unbind(e.getContainer()));
        }
      }, Pn = (e) => U(e) ? { value: e.split(/[ ,]/), valid: !0 } : an(e, U) ? { value: e, valid: !0 } : { valid: !1, message: "The value must be a string[] or a comma/space separated string." }, qt = (e) => {
        const t = (() => {
          switch (e) {
            case "array":
              return Ot;
            case "boolean":
              return Yt;
            case "function":
              return se;
            case "number":
              return ns;
            case "object":
              return Ye;
            case "string":
              return U;
            case "string[]":
              return Pn;
            case "object[]":
              return (o) => an(o, Ye);
            case "regexp":
              return (o) => lt(o, RegExp);
            default:
              return He;
          }
        })();
        return (o) => ac(o, t, `The value must be a ${e}.`);
      }, Nn = (e) => U(e.processor), Xo = (e, t) => {
        const o = ti(t.message) ? "" : `. ${t.message}`;
        return e + o;
      }, ko = (e) => e.valid, ac = (e, t, o = "") => {
        const r = t(e);
        return Yt(r) ? r ? { value: e, valid: !0 } : { valid: !1, message: o } : r;
      }, Ms = (e, t, o) => {
        if (!Gn(t)) {
          const r = ac(t, o);
          if (ko(r))
            return r.value;
          console.error(Xo(`Invalid default value passed for the "${e}" option`, r));
        }
      }, Yl = (e, t, o = t) => {
        const r = {}, c = {}, u = (H, J, W) => {
          const Q = ac(J, W);
          return ko(Q) ? (c[H] = Q.value, !0) : (console.warn(Xo(`Invalid value passed for the ${H} option`, Q)), !1);
        }, f = (H, J) => {
          const W = Nn(J) ? qt(J.processor) : J.processor, Q = Ms(H, J.default, W);
          r[H] = {
            ...J,
            default: Q,
            processor: W
          }, Wo(c, H).orThunk(() => Wo(t, H)).each((be) => u(H, be, W));
        }, b = (H) => kn(r, H);
        return {
          register: f,
          isRegistered: b,
          get: (H) => Wo(c, H).orThunk(() => Wo(r, H).map((J) => J.default)).getOrUndefined(),
          set: (H, J) => {
            if (b(H)) {
              const W = r[H];
              return W.immutable ? (console.error(`"${H}" is an immutable option and cannot be updated`), !1) : u(H, J, W.processor);
            } else
              return console.warn(`"${H}" is not a registered option. Ensure the option has been registered before setting a value.`), !1;
          },
          unset: (H) => {
            const J = b(H);
            return J && delete c[H], J;
          },
          isSet: (H) => kn(c, H),
          debug: () => {
            try {
              console.log(JSON.parse(JSON.stringify(o, (H, J) => Yt(J) || ns(J) || U(J) || oe(J) || Ot(J) || On(J) ? J : Object.prototype.toString.call(J))));
            } catch (H) {
              console.error(H);
            }
          }
        };
      }, Da = (e, t) => {
        e.dom.contentEditable = "true";
      }, mu = (e, t) => {
        const o = te.fromDom(e.getBody());
        t ? (e.readonly = !0, e.hasEditableRoot() && Da(o), jO(e)) : (e.readonly = !1, O6(e));
      }, Wa = (e) => e.readonly, nd = (e) => {
        const t = e.undoManager.add();
        X(t) && (e.undoManager.undo(), e.undoManager.reset());
      }, Pp = (e) => po(e, (t) => t.type === "characterData" || t.type === "childList"), qf = (e) => {
        const t = (r) => {
          Wa(e) && Pp(r) && nd(e);
        }, o = new MutationObserver(t);
        e.on("beforeinput paste cut dragend dragover draggesture dragdrop drop drag", (r) => {
          Wa(e) && r.preventDefault();
        }), e.on("BeforeExecCommand", (r) => {
          (r.command === "Undo" || r.command === "Redo") && Wa(e) && r.preventDefault();
        }), e.on("compositionstart", () => {
          Wa(e) && o.observe(e.getBody(), {
            characterData: !0,
            childList: !0,
            subtree: !0
          });
        }), e.on("compositionend", () => {
          if (Wa(e)) {
            const r = o.takeRecords();
            t(r);
          }
          o.disconnect();
        });
      }, Ny = ["design", "readonly"], Kf = (e, t, o, r) => {
        const c = o[t.get()], u = o[r];
        try {
          u.activate();
        } catch (f) {
          console.error(`problem while activating editor mode ${r}:`, f);
          return;
        }
        c.deactivate(), c.editorReadOnly !== u.editorReadOnly && mu(e, u.editorReadOnly), t.set(r), xk(e, r);
      }, kS = (e, t, o, r) => {
        if (!(r === o.get() || e.initialized && Jg(e))) {
          if (!kn(t, r))
            throw new Error(`Editor mode '${r}' is invalid`);
          e.initialized ? Kf(e, o, t, r) : e.on("init", () => Kf(e, o, t, r));
        }
      }, BN = (e, t, o) => {
        if (Lt(Ny, t))
          throw new Error(`Cannot override default mode ${t}`);
        return {
          ...e,
          [t]: {
            ...o,
            deactivate: () => {
              try {
                o.deactivate();
              } catch (r) {
                console.error(`problem while deactivating editor mode ${t}:`, r);
              }
            }
          }
        };
      }, My = (e) => {
        const t = Wt("design"), o = Wt({
          design: {
            activate: St,
            deactivate: St,
            editorReadOnly: !1
          },
          readonly: {
            activate: St,
            deactivate: St,
            editorReadOnly: !0
          }
        });
        return qf(e), rU(e), {
          isReadOnly: () => Wa(e),
          set: (r) => kS(e, o.get(), t, r),
          get: () => t.get(),
          register: (r, c) => {
            o.set(BN(o.get(), r, c));
          }
        };
      }, Py = Je.each, By = Je.explode, n7 = {
        f1: 112,
        f2: 113,
        f3: 114,
        f4: 115,
        f5: 116,
        f6: 117,
        f7: 118,
        f8: 119,
        f9: 120,
        f10: 121,
        f11: 122,
        f12: 123
      }, $N = Je.makeMap("alt,ctrl,shift,meta,access"), wY = (e) => e in $N, IN = (e) => {
        const t = {}, o = fo.os.isMacOS() || fo.os.isiOS();
        Py(By(e.toLowerCase(), "+"), (u) => {
          wY(u) ? t[u] = !0 : /^[0-9]{2,}$/.test(u) ? t.keyCode = parseInt(u, 10) : (t.charCode = u.charCodeAt(0), t.keyCode = n7[u] || u.toUpperCase().charCodeAt(0));
        });
        const r = [t.keyCode];
        let c;
        for (c in $N)
          t[c] ? r.push(c) : t[c] = !1;
        return t.id = r.join(","), t.access && (t.alt = !0, o ? t.ctrl = !0 : t.shift = !0), t.meta && (o ? t.meta = !0 : (t.ctrl = !0, t.meta = !1)), t;
      };
      class $y {
        editor;
        shortcuts = {};
        pendingPatterns = [];
        constructor(t) {
          this.editor = t;
          const o = this;
          t.on("keyup keypress keydown", (r) => {
            (o.hasModifier(r) || o.isFunctionKey(r)) && !r.isDefaultPrevented() && (Py(o.shortcuts, (c) => {
              o.matchShortcut(r, c) && (o.pendingPatterns = c.subpatterns.slice(0), r.type === "keydown" && o.executeShortcutAction(c));
            }), o.matchShortcut(r, o.pendingPatterns[0]) && (o.pendingPatterns.length === 1 && r.type === "keydown" && o.executeShortcutAction(o.pendingPatterns[0]), o.pendingPatterns.shift()));
          });
        }
        /**
         * Adds a keyboard shortcut for some command or function.
         *
         * @method add
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @param {String} desc Text description for the command.
         * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
         * @param {Object} scope Optional scope to execute the function in.
         * @return {Boolean} true/false state if the shortcut was added or not.
         */
        add(t, o, r, c) {
          const u = this, f = u.normalizeCommandFunc(r);
          return Py(By(Je.trim(t)), (b) => {
            const v = u.createShortcut(b, o, f, c);
            u.shortcuts[v.id] = v;
          }), !0;
        }
        /**
         * Remove a keyboard shortcut by pattern.
         *
         * @method remove
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @return {Boolean} true/false state if the shortcut was removed or not.
         */
        remove(t) {
          const o = this.createShortcut(t);
          return this.shortcuts[o.id] ? (delete this.shortcuts[o.id], !0) : !1;
        }
        normalizeCommandFunc(t) {
          const o = this, r = t;
          return typeof r == "string" ? () => {
            o.editor.execCommand(r, !1, null);
          } : Je.isArray(r) ? () => {
            o.editor.execCommand(r[0], r[1], r[2]);
          } : r;
        }
        createShortcut(t, o, r, c) {
          const u = Je.map(By(t, ">"), IN);
          return u[u.length - 1] = Je.extend(u[u.length - 1], {
            func: r,
            scope: c || this.editor
          }), Je.extend(u[0], {
            desc: this.editor.translate(o),
            subpatterns: u.slice(1)
          });
        }
        hasModifier(t) {
          return t.altKey || t.ctrlKey || t.metaKey;
        }
        isFunctionKey(t) {
          return t.type === "keydown" && t.keyCode >= 112 && t.keyCode <= 123;
        }
        matchShortcut(t, o) {
          return !o || o.ctrl !== t.ctrlKey || o.meta !== t.metaKey || o.alt !== t.altKey || o.shift !== t.shiftKey ? !1 : t.keyCode === o.keyCode || t.charCode && t.charCode === o.charCode ? (t.preventDefault(), !0) : !1;
        }
        executeShortcutAction(t) {
          return t.func ? t.func.call(t.scope) : null;
        }
      }
      const Iy = () => {
        const e = zZ();
        return {
          /**
           * Registers a new auto completer component. When a configured string pattern
           * is matched in the content while typing, the autocompleter will be triggered.
           * Emoticons and Charmap use an autocompleter.
           * <br>
           * For information on creating an autocompleter, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/autocompleter/">
           * UI Components - Autocompleter</a>.
           *
           * @method addAutocompleter
           * @param {String} name Unique name identifying this autocomplete configuration.
           * @param {InlineContent.AutocompleterSpec} obj The autocomplete configuration object.
           */
          addAutocompleter: e.addAutocompleter,
          /**
           * Registers a new toolbar button that executes a command when clicked or activated
           * via keyboard navigation controls.
           * <br>
           * For information on creating a basic toolbar button, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-basic-toolbar-button/">
           * UI Components - Types of toolbar buttons: Basic button</a>.
           *
           * @method addButton
           * @param {String} name Unique name identifying the button, this button name will be used in the toolbar configuration to reference the button.
           * @param {Toolbar.ToolbarButtonSpec} obj the button configuration object.
           */
          addButton: e.addButton,
          /**
           * Registers a new contextual form item.
           * Similar to a context menu item, a contextual form is an item with an input
           * form element appearing when a content predicate is matched. An example
           * of a contextual form is the link plugin when the configuration
           * { link_context_toolbar: true } is used. When the cursor is on a link, a
           * contextual input form appears allowing for quick changes to the url field.
           * <br>
           * For information on creating context forms, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/contextform/">
           * UI Components - Context forms</a>.
           *
           * @method addContextForm
           * @param {String} name Unique name identifying the new contextual form item.
           * @param {Toolbar.ContextFormSpec} obj the context form configuration object.
           */
          addContextForm: e.addContextForm,
          /**
           * Registers a new context menu section that only appears when a content predicate is matched,
           * for example, the cursor is inside a table.
           * <br>
           * For information on creating context menus, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/contextmenu/">
           * UI Components - Context Menu</a>.
           *
           * @method addContextMenu
           * @param {String} name Unique name identifying the new context menu.
           * @param {Menu.ContextMenuSpec} obj The context menu configuration object.
           */
          addContextMenu: e.addContextMenu,
          /**
           * Registers a new context toolbar that only appears when a content predicate is matched for example
           * the cursor is on an image element.
           * <br>
           * For information on creating context toolbars, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/contexttoolbar/">
           * UI Components - Context Toolbar</a>.
           *
           * @method addContextToolbar
           * @param {String} name Unique name identifying the new context toolbar.
           * @param {Toolbar.ContextToolbarSpec} obj The context menu configuration object.
           */
          addContextToolbar: e.addContextToolbar,
          /**
           * Registers a new SVG icon. The icon name reference can be configured by any
           * TinyMCE UI components that can display an icon. The icon is only available
           * to the editor instance it was configured for.
           *
           * @method addIcon
           * @param {String} name Unique name identifying the new icon.
           * @param {String} svgData The SVG data string the browser will use to render the SVG icon.
           * @example
           * //To add a simple triangle icon:
           * editor.ui.registry.addIcon('triangleUp', '<svg height="24" width="24"><path d="M12 0 L24 24 L0 24 Z" /></svg>');
           */
          addIcon: e.addIcon,
          /**
           * Registers a new menu button. Adds a toolbar button that opens a menu when
           * clicked. The menu can be populated by items created by addMenuItem,
           * addNestedMenuItem or addToggleMenuItem.
           * <br>
           * For information on creating a toolbar menu button, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-menu-toolbar-button/">
           * UI Components - Types of toolbar buttons: Menu button</a>.
           *
           * @method addMenuButton
           * @param {String} name Unique name identifying the new menu button.
           * @param {Toolbar.ToolbarMenuButtonSpec} obj The menu button configuration object.
           */
          addMenuButton: e.addMenuButton,
          /**
           * Registers a new menu item that executes a command when clicked or activated
           * via keyboard navigation controls.
           * <br>
           * For information on creating a basic menu item, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/creating-custom-menu-items/">
           * UI Components - Custom menu items: Basic menu items</a>.
           *
           * @method addMenuItem
           * @param {String} name Unique name identifying the new menu item.
           * @param {Menu.MenuItemSpec} obj The menu item configuration object.
           */
          addMenuItem: e.addMenuItem,
          /**
           * Registers a new menu item that reveals a submenu when clicked or activated
           * by keyboard navigation controls.The submenu can be populated by items
           * created by addMenuItem, addNestedMenuItem or addToggleMenuItem.
           * <br>
           * For information on creating a nested menu item, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-nested-menu-items/">
           * UI Components - Custom menu items: Nested menu items</a>.
           *
           * @method addNestedMenuItem
           * @param {String} name Unique name identifying the new nested menu item.
           * @param {Menu.NestedMenuItemSpec} obj The nested menu item configuration object.
           */
          addNestedMenuItem: e.addNestedMenuItem,
          /**
           * Registers a new sidebar container.
           * This sidebar container is attached to the right side of the editor and
           * can be toggled open or closed. When registered, a new toolbar toggle
           * button with the same sidebar name is created. Additionally there is a
           * ToggleSidebar command and a 'ToggleSidebar' event that can used to
           * manage the sidebar open/closed state. The tinycomments plugin uses a
           * sidebar for its Ui components.
           * <br>
           * For information on creating a custom sidebar, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/customsidebar/">
           * UI Components - Custom sidebar</a>.
           *
           * @method addSidebar
           * @param {String} name Unique name identifying the new sidebar.
           * @param {Sidebar.SidebarSpec} obj The sidebar configuration object.
           */
          addSidebar: e.addSidebar,
          /**
           * Registers a new split button for the toolbar. The list styles plugin uses
           * a split button to simplify its functionality.
           * <br>
           * For information on creating a split toolbar button, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-split-toolbar-button/">
           * UI Components - Types of toolbar buttons: Split button</a>.
           *
           * @method addSplitButton
           * @param {String} name Unique name identifying the new split button.
           * @param {Toolbar.ToolbarSplitButtonSpec} obj The split button configuration object.
           */
          addSplitButton: e.addSplitButton,
          /**
           * Registers a new toggle button for the toolbar. A toggle buttons state can
           * be set in the configuration.
           * <br>
           * For information on creating a toggle toolbar button, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-toggle-toolbar-button/">
           * UI Components - Types of toolbar buttons: Toggle button</a>.
           *
           * @method addToggleButton
           * @param {String} name Unique name identifying the new split button.
           * @param {Toolbar.ToolbarToggleButtonSpec} obj The toggle button configuration object.
           */
          addToggleButton: e.addToggleButton,
          /**
           * Registers a new group toolbar button for the toolbar. Renders a toolbar button that opens a floating toolbar when
           * clicked.
           * <br>
           * <strong>Note:</strong> Group toolbar buttons can only be used when using the floating toolbar mode.
           * <br>
           * For information on creating a group toolbar button, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-group-toolbar-button/">
           * UI Components - Types of toolbar buttons: Group toolbar button</a>.
           *
           * @method addGroupToolbarButton
           * @param {String} name Unique name identifying the new group toolbar button.
           * @param {Toolbar.GroupToolbarButtonSpec} obj The group toolbar button configuration object.
           */
          addGroupToolbarButton: e.addGroupToolbarButton,
          /**
           * Registers a new menu item that will act like a toggle button,
           * showing a tick in the menu item to represent state.
           * <br>
           * For information on creating a toggle menu item, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-toggle-menu-items/">
           * UI Components - Custom menu items: Toggle menu items</a>.
           *
           * @method addToggleMenuItem
           * @param {String} name Unique name identifying the new menu item.
           * @param {Menu.ToggleMenuItemSpec} obj The menu item configuration object.
           */
          addToggleMenuItem: e.addToggleMenuItem,
          /**
           * Registers a new view container.
           * This view container is hidden (off) by default and attached next to the main view.
           * It can be toggled on or off.
           * When it is on, the main editor view is hidden and the specific view is shown.
           * When it is off, the specific view is hidden and the main view is shown.
           * There is also a ToggleView command.
           * The ToggleView command can toggle the view visibility.
           * The ToggleView command can be queried for its current state.
           * <br>
           * For information on creating a custom view, see:
           * <a href="https://www.tiny.cloud/docs/tinymce/8/custom-view/">
           * UI Components - Custom view</a>.
           *
           * @method addView
           * @param {String} name Unique name identifying the new view.
           * @param {View.ViewSpec} obj The view configuration object.
           */
          addView: e.addView,
          /**
           * Registers a new context configuration in the registry.
           * The registry stores all context configurations.
           * The buttons in editor configuration object can contain a context property.
           * These button specifications can use the registered contexts to determine
           * whether to enable or disable the buttons based on the current context.
           *
           * @method addContext
           * @param {String} name Unique name identifying the new context configuration.
           * @param {Function} pred A predicate function that determines if the context is active
           */
          addContext: e.addContext,
          /* note getAll is an internal method and may not be supported in future revisions */
          getAll: e.getAll
        };
      }, qd = lo.DOM, FN = Je.extend, o7 = Je.each;
      class AS {
        baseUri;
        /**
         * Editor instance id, normally the same as the div/textarea that was replaced.
         *
         * @property id
         * @type String
         */
        id;
        /**
         * A uuid string to uniquely identify an editor across any page.
         *
         * @property editorUid
         * @type String
         */
        editorUid;
        /**
         * Name/Value object containing plugin instances.
         *
         * @property plugins
         * @type Object
         * @example
         * // Execute a method inside a plugin directly
         * tinymce.activeEditor.plugins.someplugin.someMethod();
         */
        plugins = {};
        /**
         * URI object to document configured for the TinyMCE instance.
         *
         * @property documentBaseURI
         * @type tinymce.util.URI
         * @example
         * // Get relative URL from the location of document_base_url
         * tinymce.activeEditor.documentBaseURI.toRelative('/somedir/somefile.htm');
         *
         * // Get absolute URL from the location of document_base_url
         * tinymce.activeEditor.documentBaseURI.toAbsolute('somefile.htm');
         */
        documentBaseURI;
        /**
         * URI object to current document that holds the TinyMCE editor instance.
         *
         * @property baseURI
         * @type tinymce.util.URI
         * @example
         * // Get relative URL from the location of the API
         * tinymce.activeEditor.baseURI.toRelative('/somedir/somefile.htm');
         *
         * // Get absolute URL from the location of the API
         * tinymce.activeEditor.baseURI.toAbsolute('somefile.htm');
         */
        baseURI;
        /**
         * Array with CSS files to load into the iframe.
         *
         * @property contentCSS
         * @type Array
         */
        contentCSS = [];
        /**
         * Array of CSS styles to add to head of document when the editor loads.
         *
         * @property contentStyles
         * @type Array
         */
        contentStyles = [];
        /**
         * Editor ui components
         *
         * @property ui
         * @type tinymce.editor.ui.Ui
         */
        ui;
        /**
         * Editor mode API
         *
         * @property mode
         * @type tinymce.EditorMode
         */
        mode;
        /**
         * Editor options API
         *
         * @property options
         * @type tinymce.EditorOptions
         */
        options;
        /**
         * Editor upload API
         *
         * @property editorUpload
         * @type tinymce.EditorUpload
         */
        editorUpload;
        /**
         * Editor user lookup API
         *
         * @property userLookup
         * @type tinymce.UserLookup
         */
        userLookup;
        shortcuts;
        loadedCSS = {};
        editorCommands;
        suffix;
        editorManager;
        hidden;
        inline;
        hasVisual;
        isNotDirty = !1;
        // Arguments set later, for example by InitContentBody.ts
        // Note that these may technically be undefined up until PreInit (or similar) has fired,
        // however the types are aimed at an initialised editor for ease of use.
        annotator;
        bodyElement;
        bookmark;
        // Note: Intentionally any so as to not expose Optional
        composing = !1;
        container;
        contentAreaContainer;
        contentDocument;
        contentWindow;
        delegates;
        destroyed = !1;
        dom;
        editorContainer;
        eventRoot;
        formatter;
        formElement;
        formEventDelegate;
        hasHiddenInput = !1;
        iframeElement = null;
        iframeHTML;
        initialized = !1;
        notificationManager;
        orgDisplay;
        orgVisibility;
        parser;
        quirks;
        readonly = !1;
        removed = !1;
        schema;
        selection;
        serializer;
        startContent = "";
        targetElm;
        theme;
        model;
        undoManager;
        windowManager;
        licenseKeyManager;
        _beforeUnload;
        _eventDispatcher;
        _nodeChangeDispatcher;
        _pendingNativeEvents = [];
        _selectionOverrides;
        _skinLoaded = !1;
        _editableRoot = !0;
        // EditorObservable patches
        bindPendingEventDelegates;
        toggleNativeEvent;
        unbindAllNativeEvents;
        fire;
        dispatch;
        on;
        off;
        once;
        hasEventListeners;
        /**
         * Constructs a editor instance by id.
         *
         * @constructor
         * @method Editor
         * @param {String} id Unique id for the editor.
         * @param {Object} options Options for the editor.
         * @param {tinymce.EditorManager} editorManager EditorManager instance.
         */
        constructor(t, o, r) {
          this.editorManager = r, FN(this, mn);
          const c = this;
          this.id = t, this.editorUid = Mi(), this.hidden = !1;
          const u = uY(r.defaultOptions, o);
          this.options = Yl(c, u, o), W1(c), this.userLookup = HL(this);
          const f = this.options.get;
          f("deprecation_warnings") && N9(o, u);
          const b = f("suffix");
          b && (r.suffix = b), this.suffix = r.suffix;
          const v = f("base_url");
          v && r._setBaseUrl(v), this.baseUri = r.baseURI;
          const S = dv(c);
          S && (Do.ScriptLoader._setReferrerPolicy(S), lo.DOM.styleSheetLoader._setReferrerPolicy(S)), Do.ScriptLoader._setCrossOrigin((H) => Bg(c)(H, "script")), lo.DOM.styleSheetLoader._setCrossOrigin((H) => Bg(c)(H, "stylesheet"));
          const O = yC(c);
          X(O) && lo.DOM.styleSheetLoader._setContentCssCors(O), Vr.languageLoad = f("language_load"), Vr.baseURL = r.baseURL, this.setDirty(!1), this.documentBaseURI = new zd(dC(c), {
            base_uri: this.baseUri
          }), this.baseURI = this.baseUri, this.inline = G1(c), this.hasVisual = Y1(c), this.shortcuts = new $y(this), this.editorCommands = new Ue(this), Ee(this);
          const R = f("cache_suffix");
          R && (fo.cacheSuffix = R.replace(/^[\?\&]+/, "")), this.ui = {
            registry: Iy(),
            styleSheetLoader: void 0,
            show: St,
            hide: St,
            setEnabled: St,
            isEnabled: He
          }, this.mode = My(c), Object.defineProperty(this, "editorUid", {
            writable: !1,
            configurable: !1,
            enumerable: !0
          }), r.dispatch("SetupEditor", { editor: this });
          const M = Ig(c);
          se(M) && M.call(c, c);
        }
        /**
         * Renders the editor/adds it to the page.
         *
         * @method render
         */
        render() {
          sY(this);
        }
        /**
         * Focuses/activates the editor. This will set this editor as the activeEditor in the tinymce collection
         * it will also place DOM focus inside the editor.
         *
         * @method focus
         * @param {Boolean} skipFocus Skip DOM focus. Just set is as the active editor.
         */
        focus(t) {
          this.execCommand("mceFocus", !1, t);
        }
        /**
         * Returns true/false if the editor has real keyboard focus.
         *
         * @method hasFocus
         * @return {Boolean} Current focus state of the editor.
         */
        hasFocus() {
          return Lv(this);
        }
        /**
         * Translates the specified string by replacing variables with language pack items it will also check if there is
         * a key matching the input.
         *
         * @method translate
         * @param {String} text String to translate by the language pack data.
         * @return {String} Translated string.
         */
        translate(t) {
          return pl.translate(t);
        }
        getParam(t, o, r) {
          const c = this.options;
          return c.isRegistered(t) || (X(r) ? c.register(t, { processor: r, default: o }) : c.register(t, { processor: He, default: o })), !c.isSet(t) && !Gn(o) ? o : c.get(t);
        }
        /**
         * Checks that the plugin is in the editor configuration and can optionally check if the plugin has been loaded.
         *
         * @method hasPlugin
         * @param {String} name The name of the plugin, as specified for the TinyMCE `plugins` option.
         * @param {Boolean} loaded If `true`, will also check that the plugin has been loaded.
         * @return {Boolean} If `loaded` is `true`, returns `true` if the plugin is in the configuration and has been loaded. If `loaded` is `false`, returns `true` if the plugin is in the configuration, regardless of plugin load status.
         * @example
         * // Returns `true` if the Comments plugin is in the editor configuration and has loaded successfully:
         * tinymce.activeEditor.hasPlugin('tinycomments', true);
         * // Returns `true` if the Table plugin is in the editor configuration, regardless of whether or not it loads:
         * tinymce.activeEditor.hasPlugin('table');
         */
        hasPlugin(t, o) {
          return Lt(K1(this), t) ? o ? wp.get(t) !== void 0 : !0 : !1;
        }
        /**
         * Dispatches out a onNodeChange event to all observers. This method should be called when you
         * need to update the UI states or element path etc.
         *
         * @method nodeChanged
         * @param {Object} args Optional args to pass to NodeChange event handlers.
         */
        nodeChanged(t) {
          this._nodeChangeDispatcher.nodeChanged(t);
        }
        addCommand(t, o, r) {
          this.editorCommands.addCommand(t, o, r);
        }
        addQueryStateHandler(t, o, r) {
          this.editorCommands.addQueryStateHandler(t, o, r);
        }
        addQueryValueHandler(t, o, r) {
          this.editorCommands.addQueryValueHandler(t, o, r);
        }
        /**
         * Adds a keyboard shortcut for some command or function.
         *
         * @method addShortcut
         * @param {String} pattern Shortcut pattern. Like for example: ctrl+alt+o.
         * @param {String} desc Text description for the command.
         * @param {String/Function} cmdFunc Command name string or function to execute when the key is pressed.
         * @param {Object} scope Optional scope to execute the function in.
         * @return {Boolean} true/false state if the shortcut was added or not.
         * @example
         * editor.addShortcut('ctrl+a', 'description of the shortcut', () => {});
         * editor.addShortcut('ctrl+alt+a', 'description of the shortcut', () => {});
         * // "meta" maps to Command on Mac and Ctrl on PC
         * editor.addShortcut('meta+a', 'description of the shortcut', () => {});
         * // "access" maps to Control+Option on Mac and shift+alt on PC
         * editor.addShortcut('access+a', 'description of the shortcut', () => {});
         *
         * editor.addShortcut('meta+access+c', 'Opens the code editor dialog.', () => {
         *   editor.execCommand('mceCodeEditor');
         * });
         *
         * editor.addShortcut('meta+shift+32', 'Inserts "Hello, World!" for meta+shift+space', () => {
         *   editor.execCommand('mceInsertContent', false, 'Hello, World!');
         * });
         */
        addShortcut(t, o, r, c) {
          this.shortcuts.add(t, o, r, c);
        }
        /**
         * Executes a registered command on the current instance. A list of available commands can be found in
         * the tinymce command identifiers documentation.
         *
         * @method execCommand
         * @param {String} cmd Command name to execute, for example mceLink or Bold.
         * @param {Boolean} ui Specifies if a UI (dialog) should be presented or not.
         * @param {Object/Array/String/Number/Boolean} value Optional command value, this can be anything.
         * @param {Object} args Optional arguments object.
         * @return {Boolean} true or false if the command was supported or not.
         */
        execCommand(t, o, r, c) {
          return this.editorCommands.execCommand(t, o, r, c);
        }
        /**
         * Returns a command specific state, for example if bold is enabled or not.
         *
         * @method queryCommandState
         * @param {String} cmd Command to query state from.
         * @return {Boolean} Command specific state, for example if bold is enabled or not.
         */
        queryCommandState(t) {
          return this.editorCommands.queryCommandState(t);
        }
        /**
         * Returns a command specific value, for example the current font size.
         *
         * @method queryCommandValue
         * @param {String} cmd Command to query value from.
         * @return {String} Command value, for example the current font size or an empty string (`""`) if the query command is not found.
         */
        queryCommandValue(t) {
          return this.editorCommands.queryCommandValue(t);
        }
        /**
         * Returns true/false if the command is supported or not.
         *
         * @method queryCommandSupported
         * @param {String} cmd Command that we check support for.
         * @return {Boolean} true/false if the command is supported or not.
         */
        queryCommandSupported(t) {
          return this.editorCommands.queryCommandSupported(t);
        }
        /**
         * Shows the editor and hides any textarea/div that the editor is supposed to replace.
         *
         * @method show
         */
        show() {
          const t = this;
          t.hidden && (t.hidden = !1, t.inline ? t.getBody().contentEditable = "true" : (qd.show(t.getContainer()), qd.hide(t.id)), t.load(), t.dispatch("show"));
        }
        /**
         * Hides the editor and shows any textarea/div that the editor is supposed to replace.
         *
         * @method hide
         */
        hide() {
          const t = this;
          t.hidden || (t.save(), t.inline ? (t.getBody().contentEditable = "false", t === t.editorManager.focusedEditor && (t.editorManager.focusedEditor = null)) : (qd.hide(t.getContainer()), qd.setStyle(t.id, "display", t.orgDisplay)), t.hidden = !0, t.dispatch("hide"));
        }
        /**
         * Returns true/false if the editor is hidden or not.
         *
         * @method isHidden
         * @return {Boolean} True/false if the editor is hidden or not.
         */
        isHidden() {
          return this.hidden;
        }
        /**
         * Sets the progress state, this will display a throbber/progess for the editor.
         * This is ideal for asynchronous operations like an AJAX save call.
         *
         * @method setProgressState
         * @param {Boolean} state Boolean state if the progress should be shown or hidden.
         * @param {Number} time Optional time to wait before the progress gets shown.
         * @return {Boolean} Same as the input state.
         * @example
         * // Show progress for the active editor
         * tinymce.activeEditor.setProgressState(true);
         *
         * // Hide progress for the active editor
         * tinymce.activeEditor.setProgressState(false);
         *
         * // Show progress after 3 seconds
         * tinymce.activeEditor.setProgressState(true, 3000);
         */
        setProgressState(t, o) {
          this.dispatch("ProgressState", { state: t, time: o });
        }
        /**
         * Loads contents from the textarea, input or other element that got converted into an editor instance.
         * This method will move the contents from that textarea, input or other element into the editor by using setContent
         * so all events etc that method has will get dispatched as well.
         *
         * @method load
         * @param {Object} args Optional content object, this gets passed around through the whole load process.
         */
        load(t = {}) {
          const o = this, r = o.getElement();
          if (!o.removed && r) {
            const c = {
              ...t,
              load: !0
            }, u = pi(r) ? r.value : r.innerHTML;
            o.setContent(u, c), c.no_events || o.dispatch("LoadContent", {
              ...c,
              element: r
            });
          }
        }
        /**
         * Saves the contents from an editor out to the textarea or div element that got converted into an editor instance.
         * This method will move the HTML contents from the editor into that textarea or div by getContent
         * so all events etc that method has will get dispatched as well.
         *
         * @method save
         * @param {Object} args Optional content object, this gets passed around through the whole save process.
         * @return {String} HTML string that got set into the textarea/div.
         */
        save(t = {}) {
          const o = this;
          let r = o.getElement();
          if (!r || !o.initialized || o.removed)
            return "";
          const c = {
            ...t,
            save: !0,
            element: r
          };
          let u = o.getContent(c);
          const f = { ...c, content: u };
          if (f.no_events || o.dispatch("SaveContent", f), f.format === "raw" && o.dispatch("RawSaveContent", f), u = f.content, pi(r))
            r.value = u;
          else {
            (t.is_removing || !o.inline) && (r.innerHTML = u);
            const b = qd.getParent(o.id, "form");
            b && o7(b.elements, (v) => v.name === o.id ? (v.value = u, !1) : !0);
          }
          return f.element = c.element = r = null, f.set_dirty !== !1 && o.setDirty(!1), u;
        }
        setContent(t, o) {
          TO(this, t, o);
        }
        getContent(t) {
          return VV(this, t);
        }
        /**
         * Inserts content at caret position.
         *
         * @method insertContent
         * @param {String} content Content to insert.
         * @param {Object} args Optional args to pass to insert call.
         */
        insertContent(t, o) {
          o && (t = FN({ content: t }, o)), this.execCommand("mceInsertContent", !1, t);
        }
        /**
         * Resets the editors content, undo/redo history and dirty state. If `initialContent` isn't specified, then
         * the editor is reset back to the initial start content.
         *
         * @method resetContent
         * @param {String} initialContent An optional string to use as the initial content of the editor.
         */
        resetContent(t) {
          t === void 0 ? TO(this, this.startContent, { initial: !0, format: "raw" }) : TO(this, t, { initial: !0 }), this.undoManager.reset(), this.setDirty(!1), this.nodeChanged();
        }
        /**
         * Returns true/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
         *
         * The dirty state is automatically set to `true` when the user modifies editor content after initialization or the
         * last `editor.save()` call. This includes changes made using undo or redo.
         *
         * @method isDirty
         * @return {Boolean} True/false if the editor is dirty or not. It will get dirty if the user has made modifications to the contents.
         * @example
         * if (tinymce.activeEditor.isDirty()) {
         *   alert("You must save your contents.");
         * }
         */
        isDirty() {
          return !this.isNotDirty;
        }
        /**
         * Explicitly sets the dirty state. This will fire the dirty event if the editor dirty state is changed from false to true
         * by invoking this method.
         *
         * @method setDirty
         * @param {Boolean} state True/false if the editor is considered dirty.
         * @example
         * const ajaxSave = () => {
         *   const editor = tinymce.get('elm1');
         *
         *   // Save contents using some XHR call
         *   alert(editor.getContent());
         *
         *   editor.setDirty(false); // Force not dirty state
         * }
         */
        setDirty(t) {
          const o = !this.isNotDirty;
          this.isNotDirty = !t, t && t !== o && this.dispatch("dirty");
        }
        /**
         * Returns the container element of the editor. The container element includes
         * all the elements added to the page for the editor. Such as UI, iframe, etc.
         *
         * @method getContainer
         * @return {Element} HTML DOM element for the editor container.
         */
        getContainer() {
          const t = this;
          return t.container || (t.container = t.editorContainer || qd.get(t.id + "_parent")), t.container;
        }
        /**
         * Returns the content area container element of the editor. This element
         * holds the iframe or the editable element.
         *
         * @method getContentAreaContainer
         * @return {Element} HTML DOM element for the editor area container.
         */
        getContentAreaContainer() {
          return this.contentAreaContainer;
        }
        /**
         * Returns the target element/textarea that got replaced with a TinyMCE editor instance.
         *
         * @method getElement
         * @return {Element} HTML DOM element for the replaced element.
         */
        getElement() {
          return this.targetElm || (this.targetElm = qd.get(this.id)), this.targetElm;
        }
        /**
         * Returns the iframes window object.
         *
         * @method getWin
         * @return {Window} Iframe DOM window object.
         */
        getWin() {
          const t = this;
          if (!t.contentWindow) {
            const o = t.iframeElement;
            o && (t.contentWindow = o.contentWindow);
          }
          return t.contentWindow;
        }
        /**
         * Returns the iframes document object.
         *
         * @method getDoc
         * @return {Document} Iframe DOM document object.
         */
        getDoc() {
          const t = this;
          if (!t.contentDocument) {
            const o = t.getWin();
            o && (t.contentDocument = o.document);
          }
          return t.contentDocument;
        }
        /**
         * Returns the root element of the editable area.
         * For a non-inline iframe-based editor, returns the iframe's body element.
         *
         * @method getBody
         * @return {Element} The root element of the editable area.
         */
        getBody() {
          const t = this.getDoc();
          return this.bodyElement ?? t?.body ?? null;
        }
        /**
         * URL converter function this gets executed each time a user adds an img, a or
         * any other element that has a URL in it. This will be called both by the DOM and HTML
         * manipulation functions.
         *
         * @method convertURL
         * @param {String} url URL to convert.
         * @param {String} name Attribute name src, href etc.
         * @param {String/HTMLElement} elm Tag name or HTML DOM element depending on HTML or DOM insert.
         * @return {String} Converted URL string.
         */
        convertURL(t, o, r) {
          const c = this, u = c.options.get, f = Dd(c);
          if (se(f))
            return f.call(c, t, r, !0, o);
          if (!u("convert_urls") || r === "link" || Ye(r) && r.nodeName === "LINK" || t.indexOf("file:") === 0 || t.length === 0)
            return t;
          const b = new zd(t);
          return b.protocol !== "http" && b.protocol !== "https" && b.protocol !== "" ? t : u("relative_urls") ? c.documentBaseURI.toRelative(t) : (t = c.documentBaseURI.toAbsolute(t, u("remove_script_host")), t);
        }
        /**
         * Adds visual aids for tables, anchors, etc so they can be more easily edited inside the editor.
         *
         * @method addVisual
         * @param {Element} elm Optional root element to loop though to find tables, etc that needs the visual aid.
         */
        addVisual(t) {
          dY(this, t);
        }
        /**
         * Changes the editable state of the editor's root element.
         *
         * @method setEditableRoot
         * @param {Boolean} state State to set true for editable and false for non-editable.
         */
        setEditableRoot(t) {
          aY(this, t);
        }
        /**
         * Returns the current editable state of the editor's root element.
         *
         * @method hasEditableRoot
         * @return {Boolean} True if the root element is editable, false if it is not editable.
         */
        hasEditableRoot() {
          return cY(this);
        }
        /**
         * Removes the editor from the dom and tinymce collection.
         *
         * @method remove
         */
        remove() {
          AO(this);
        }
        /**
         * Destroys the editor instance by removing all events, element references or other resources
         * that could leak memory. This method will be called automatically when the page is unloaded
         * but you can also call it directly if you know what you are doing.
         *
         * @method destroy
         * @param {Boolean} automatic Optional state if the destroy is an automatic destroy or user called one.
         */
        destroy(t) {
          p6(this, t);
        }
        /**
         * Uploads all data uri/blob uri images in the editor contents to server.
         *
         * @method uploadImages
         * @return {Promise} Promise instance with images and status for each image.
         */
        uploadImages() {
          return this.editorUpload.uploadImages();
        }
        // Internal functions
        _scanForImages() {
          return this.editorUpload.scanForImages();
        }
      }
      const Bp = lo.DOM, _S = Je.each;
      let OS = !1, Ub, aa = [];
      const ch = (e) => {
        const t = e.type;
        _S(Um.get(), (o) => {
          switch (t) {
            case "scroll":
              o.dispatch("ScrollWindow", e);
              break;
            case "resize":
              o.dispatch("ResizeWindow", e);
              break;
          }
        });
      }, x3 = (e) => {
        if (e !== OS) {
          const t = lo.DOM;
          e ? (t.bind(window, "resize", ch), t.bind(window, "scroll", ch)) : (t.unbind(window, "resize", ch), t.unbind(window, "scroll", ch)), OS = e;
        }
      }, S3 = (e) => {
        const t = aa;
        return aa = ze(aa, (o) => e !== o), Um.activeEditor === e && (Um.activeEditor = aa.length > 0 ? aa[0] : null), Um.focusedEditor === e && (Um.focusedEditor = null), t.length !== aa.length;
      }, EY = (e) => {
        e && e.initialized && !(e.getContainer() || e.getBody()).parentNode && (S3(e), e.unbindAllNativeEvents(), e.destroy(!0), e.removed = !0);
      }, w3 = document.compatMode !== "CSS1Compat", Um = {
        ...zt,
        baseURI: null,
        baseURL: null,
        /**
         * Object containing the options that will be passed by default to the <code>init</code> method upon each initialization of an editor. These defaults will be shallow merged with other options passed to <code>init</code>.
         *
         * @property defaultOptions
         * @type Object
         */
        defaultOptions: {},
        documentBaseURL: null,
        suffix: null,
        /**
         * A uuid string to anonymously identify the page tinymce is loaded in
         *
         * @property pageUid
         * @type String
         */
        pageUid: Mi(),
        /**
         * Major version of TinyMCE build.
         *
         * @property majorVersion
         * @type String
         */
        majorVersion: "8",
        /**
         * Minor version of TinyMCE build.
         *
         * @property minorVersion
         * @type String
         */
        minorVersion: "3.2",
        /**
         * Release date of TinyMCE build.
         *
         * @property releaseDate
         * @type String
         */
        releaseDate: "2026-01-14",
        /**
         * Collection of language pack data.
         *
         * @property i18n
         * @type Object
         */
        i18n: pl,
        /**
         * Currently active editor instance.
         *
         * @property activeEditor
         * @type tinymce.Editor
         * @example
         * tinyMCE.activeEditor.selection.getContent();
         * tinymce.EditorManager.activeEditor.selection.getContent();
         */
        activeEditor: null,
        focusedEditor: null,
        setup() {
          const e = this;
          let t = "", o = "", r = zd.getDocumentBaseUrl(document.location);
          /^[^:]+:\/\/\/?[^\/]+\//.test(r) && (r = r.replace(/[\?#].*$/, "").replace(/[\/\\][^\/]+$/, ""), /[\/\\]$/.test(r) || (r += "/"));
          const c = window.tinymce || window.tinyMCEPreInit;
          if (c)
            t = c.base || c.baseURL, o = c.suffix;
          else {
            const u = document.getElementsByTagName("script");
            for (let f = 0; f < u.length; f++) {
              const b = u[f].src || "";
              if (b === "")
                continue;
              const v = b.substring(b.lastIndexOf("/"));
              if (/tinymce(\.full|\.jquery|)(\.min|\.dev|)\.js/.test(b)) {
                v.indexOf(".min") !== -1 && (o = ".min"), t = b.substring(0, b.lastIndexOf("/"));
                break;
              }
            }
            if (!t && document.currentScript) {
              const f = document.currentScript.src;
              f.indexOf(".min") !== -1 && (o = ".min"), t = f.substring(0, f.lastIndexOf("/"));
            }
          }
          e.baseURL = new zd(r).toAbsolute(t), e.documentBaseURL = r, e.baseURI = new zd(e.baseURL), e.suffix = o, O5(e), xe(["majorVersion", "minorVersion", "releaseDate", "pageUid", "_addLicenseKeyManager"], (u) => Object.defineProperty(e, u, {
            writable: !1,
            configurable: !1,
            enumerable: !0
          }));
        },
        /**
         * Overrides the default options for editor instances. The <code>overrideDefaults</code> method replaces the <code>defaultOptions</code>, including any set by a previous call to the <code>overrideDefaults</code> method.
         * <br /><br />
         * When using the Tiny Cloud, some of these defaults are required for the cloud-based editor to function.
         * <br /><br />
         * Therefore, when using <code>overrideDefaults</code> with the cloud-based editor, any newly integrated options must be combined with the options in <code>tinymce.defaultOptions</code>.
         *
         * @method overrideDefaults
         * @param {Object} defaultOptions Default options object.
         * @example
         * const customOptions = {
         *   toolbar_sticky: true
         * };
         *
         * tinymce.overrideDefaults({
         *   ...tinymce.defaultOptions,
         *   ...customOptions
         * });
         */
        overrideDefaults(e) {
          const t = e.base_url;
          t && this._setBaseUrl(t);
          const o = e.suffix;
          o && (this.suffix = o), this.defaultOptions = e;
          const r = e.plugin_base_urls;
          r !== void 0 && Un(r, (c, u) => {
            Vr.PluginManager.urls[u] = c;
          });
        },
        /**
         * Initializes a set of editors. This method will create editors based on various settings.
         * <br /><br />
         * For information on basic usage of <code>init</code>, see: <a href="https://www.tiny.cloud/docs/tinymce/8/basic-setup/">Basic setup</a>.
         *
         * @method init
         * @param {Object} options Options object to be passed to each editor instance.
         * @return {Promise} Promise that gets resolved with an array of editors when all editor instances are initialized.
         * @example
         * // Initializes a editor using the longer method
         * tinymce.EditorManager.init({
         *    some_settings : 'some value'
         * });
         *
         * // Initializes a editor instance using the shorter version and with a promise
         * tinymce.init({
         *   some_settings : 'some value'
         * }).then((editors) => {
         *   ...
         * });
         */
        init(e) {
          const t = this;
          let o;
          const r = Je.makeMap("area base basefont br col frame hr img input isindex link meta param embed source wbr track colgroup option table tbody tfoot thead tr th td script noscript style textarea video audio iframe object menu", " "), c = (O, R) => O.inline && R.tagName.toLowerCase() in r, u = (O) => {
            let R = O.id;
            return R || (R = Wo(O, "name").filter((M) => !Bp.get(M)).getOrThunk(Bp.uniqueId), O.setAttribute("id", R)), R;
          }, f = (O) => {
            const R = e[O];
            if (R)
              return R.apply(t, []);
          }, b = (O) => fo.browser.isIE() || fo.browser.isEdge() ? (WT("TinyMCE does not support the browser you are using. For a list of supported browsers please see: https://www.tiny.cloud/docs/tinymce/8/support/#supportedwebbrowsers"), []) : w3 ? (WT("Failed to initialize the editor as the document is not in standards mode. TinyMCE requires standards mode."), []) : U(O.selector) ? Bp.select(O.selector) : X(O.target) ? [O.target] : [];
          let v = (O) => {
            o = O;
          };
          const S = () => {
            let O = 0;
            const R = [];
            let M;
            const H = (J, W, Q) => {
              const ge = new AS(J, W, t);
              R.push(ge), ge.on("init", () => {
                ++O === M.length && v(R);
              }), ge.targetElm = ge.targetElm || Q, ge.render();
            };
            Bp.unbind(window, "ready", S), f("onpageload"), M = Ka(b(e)), Je.each(M, (J) => {
              EY(t.get(J.id));
            }), M = Je.grep(M, (J) => !t.get(J.id)), M.length === 0 ? v([]) : _S(M, (J) => {
              c(e, J) ? WT("Could not initialize inline editor on invalid inline target element", J) : H(u(J), e, J);
            });
          };
          return Bp.bind(window, "ready", S), new Promise((O) => {
            o ? O(o) : v = (R) => {
              O(R);
            };
          });
        },
        /**
         * Returns an editor instance for a given id.
         *
         * @method get
         * @param {String/Number} id The id or index of the editor instance to return.
         * @return {tinymce.Editor/Array} Editor instance or an array of editor instances.
         * @example
         * // Adds an onclick event to an editor by id
         * tinymce.get('mytextbox').on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         *
         * // Adds an onclick event to an editor by index
         * tinymce.get(0).on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         *
         * // Adds an onclick event to an editor by id (longer version)
         * tinymce.EditorManager.get('mytextbox').on('click', (e) => {
         *   ed.windowManager.alert('Hello world!');
         * });
         */
        get(e) {
          return arguments.length === 0 ? aa.slice(0) : U(e) ? _o(aa, (t) => t.id === e).getOr(null) : ns(e) && aa[e] ? aa[e] : null;
        },
        /**
         * Adds an editor instance to the editor collection. This will also set it as the active editor.
         *
         * @method add
         * @param {tinymce.Editor} editor Editor instance to add to the collection.
         * @return {tinymce.Editor} The same instance that got passed in.
         */
        add(e) {
          const t = this, o = t.get(e.id);
          return o === e || (o === null && aa.push(e), x3(!0), t.activeEditor = e, t.dispatch("AddEditor", { editor: e }), Ub || (Ub = (r) => {
            const c = t.dispatch("BeforeUnload");
            if (c.returnValue)
              return r.preventDefault(), r.returnValue = c.returnValue, c.returnValue;
          }, window.addEventListener("beforeunload", Ub))), e;
        },
        /**
         * Creates an editor instance and adds it to the EditorManager collection.
         *
         * @method createEditor
         * @param {String} id Instance id to use for editor.
         * @param {Object} options Editor instance options.
         * @return {tinymce.Editor} Editor instance that got created.
         */
        createEditor(e, t) {
          return this.add(new AS(e, t, this));
        },
        /**
         * Removes a editor or editors form page.
         *
         * @example
         * // Remove all editors bound to divs
         * tinymce.remove('div');
         *
         * // Remove all editors bound to textareas
         * tinymce.remove('textarea');
         *
         * // Remove all editors
         * tinymce.remove();
         *
         * // Remove specific instance by id
         * tinymce.remove('#id');
         *
         * @method remove
         * @param {tinymce.Editor/String/Object} [selector] CSS selector or editor instance to remove.
         * @return {tinymce.Editor} The editor that got passed in will be return if it was found otherwise null.
         */
        remove(e) {
          const t = this;
          let o;
          if (!e) {
            for (let r = aa.length - 1; r >= 0; r--)
              t.remove(aa[r]);
            return;
          }
          if (U(e)) {
            _S(Bp.select(e), (r) => {
              o = t.get(r.id), o && t.remove(o);
            });
            return;
          }
          return o = e, oe(t.get(o.id)) ? null : (S3(o) && t.dispatch("RemoveEditor", { editor: o }), aa.length === 0 && window.removeEventListener("beforeunload", Ub), o.remove(), x3(aa.length > 0), o);
        },
        /**
         * Executes a specific command on the currently active editor.
         *
         * @method execCommand
         * @param {String} cmd Command to perform for example Bold.
         * @param {Boolean} ui Optional boolean state if a UI should be presented for the command or not.
         * @param {Object/String/Number/Boolean} value Optional value parameter like for example an URL to a link.
         * @return {Boolean} true/false if the command was executed or not.
         */
        execCommand(e, t, o) {
          const r = this, c = Ye(o) ? o.id ?? o.index : o;
          switch (e) {
            case "mceAddEditor": {
              if (!r.get(c)) {
                const u = o.options;
                new AS(c, u, r).render();
              }
              return !0;
            }
            case "mceRemoveEditor": {
              const u = r.get(c);
              return u && u.remove(), !0;
            }
            case "mceToggleEditor": {
              const u = r.get(c);
              return u ? (u.isHidden() ? u.show() : u.hide(), !0) : (r.execCommand("mceAddEditor", !1, o), !0);
            }
          }
          return r.activeEditor ? r.activeEditor.execCommand(e, t, o) : !1;
        },
        /**
         * Calls the save method on all editor instances in the collection. This can be useful when a form is to be submitted.
         *
         * @method triggerSave
         * @example
         * // Saves all contents
         * tinyMCE.triggerSave();
         */
        triggerSave: () => {
          _S(aa, (e) => {
            e.save();
          });
        },
        /**
         * Adds a language pack, this gets called by the loaded language files like en.js.
         *
         * @method addI18n
         * @param {String} code Optional language code.
         * @param {Object} items Name/value object with translations.
         */
        addI18n: (e, t) => {
          pl.add(e, t);
        },
        /**
         * Translates the specified string using the language pack items.
         *
         * @method translate
         * @param {String/Array/Object} text String to translate
         * @return {String} Translated string.
         */
        translate: (e) => pl.translate(e),
        /**
         * Sets the active editor instance and fires the deactivate/activate events.
         *
         * @method setActive
         * @param {tinymce.Editor} editor Editor instance to set as the active instance.
         */
        setActive(e) {
          const t = this.activeEditor;
          this.activeEditor !== e && (t && t.dispatch("deactivate", { relatedTarget: e }), e.dispatch("activate", { relatedTarget: t })), this.activeEditor = e;
        },
        _setBaseUrl(e) {
          this.baseURL = new zd(this.documentBaseURL).toAbsolute(e.replace(/\/+$/, "")), this.baseURI = new zd(this.baseURL);
        },
        _addLicenseKeyManager: (e) => zO.add(e)
      };
      Um.setup();
      const DS = (() => {
        const e = Mc(), t = (u) => ({
          items: u,
          types: Vt(u),
          getType: (f) => Wo(u, f).getOrUndefined()
        }), o = (u) => {
          e.set(u);
        }, r = () => e.get().getOrUndefined(), c = e.clear;
        return {
          FakeClipboardItem: t,
          write: o,
          read: r,
          clear: c
        };
      })(), s7 = Math.min, Fy = Math.max, Za = Math.round, jb = (e, t, o) => {
        let r = t.x, c = t.y;
        const u = e.w, f = e.h, b = t.w, v = t.h, S = (o || "").split("");
        return S[0] === "b" && (c += v), S[1] === "r" && (r += b), S[0] === "c" && (c += Za(v / 2)), S[1] === "c" && (r += Za(b / 2)), S[3] === "b" && (c -= f), S[4] === "r" && (r -= u), S[3] === "c" && (c -= Za(f / 2)), S[4] === "c" && (r -= Za(u / 2)), Wb(r, c, u, f);
      }, TY = (e, t, o, r) => {
        for (let c = 0; c < r.length; c++) {
          const u = jb(e, t, r[c]);
          if (u.x >= o.x && u.x + u.w <= o.w + o.x && u.y >= o.y && u.y + u.h <= o.h + o.y)
            return r[c];
        }
        return null;
      }, r7 = (e, t, o) => Wb(e.x - t, e.y - o, e.w + t * 2, e.h + o * 2), LN = (e, t) => {
        const o = Fy(e.x, t.x), r = Fy(e.y, t.y), c = s7(e.x + e.w, t.x + t.w), u = s7(e.y + e.h, t.y + t.h);
        return c - o < 0 || u - r < 0 ? null : Wb(o, r, c - o, u - r);
      }, a7 = (e, t, o) => {
        let r = e.x, c = e.y, u = e.x + e.w, f = e.y + e.h;
        const b = t.x + t.w, v = t.y + t.h, S = Fy(0, t.x - r), O = Fy(0, t.y - c), R = Fy(0, u - b), M = Fy(0, f - v);
        return r += S, c += O, o && (u += S, f += O, r -= R, c -= M), u -= R, f -= M, Wb(r, c, u - r, f - c);
      }, Wb = (e, t, o, r) => ({ x: e, y: t, w: o, h: r }), Yf = {
        inflate: r7,
        relativePosition: jb,
        findBestRelativePosition: TY,
        intersect: LN,
        clamp: a7,
        create: Wb,
        fromClientRect: (e) => Wb(e.left, e.top, e.width, e.height)
      }, Ly = (e, t, o = 1e3) => {
        let r = !1, c = null;
        const u = (S) => (...O) => {
          r || (r = !0, c !== null && (window.clearTimeout(c), c = null), S.apply(null, O));
        }, f = u(e), b = u(t);
        return {
          start: (...S) => {
            !r && c === null && (c = window.setTimeout(() => b.apply(null, S), o));
          },
          resolve: f,
          reject: b
        };
      }, c7 = (() => {
        const e = {}, t = {}, o = {};
        return {
          load: (v, S) => {
            const O = `Script at URL "${S}" failed to load`, R = `Script at URL "${S}" did not call \`tinymce.Resource.add('${v}', data)\` within 1 second`;
            if (e[v] !== void 0)
              return e[v];
            {
              const M = new Promise((H, J) => {
                const W = Ly(H, J);
                t[v] = W.resolve, Do.ScriptLoader.loadScript(S).then(() => W.start(R), () => W.reject(O));
              });
              return e[v] = M, M;
            }
          },
          add: (v, S) => {
            t[v] !== void 0 && (t[v](S), delete t[v]), e[v] = Promise.resolve(S), o[v] = S;
          },
          has: (v) => v in o,
          get: (v) => o[v],
          unload: (v) => {
            delete e[v], delete o[v];
          }
        };
      })(), HN = () => (() => {
        let e = {}, t = [];
        const o = {
          getItem: (r) => {
            const c = e[r];
            return c || null;
          },
          setItem: (r, c) => {
            t.push(r), e[r] = String(c);
          },
          key: (r) => t[r],
          removeItem: (r) => {
            t = t.filter((c) => c === r), delete e[r];
          },
          clear: () => {
            t = [], e = {};
          },
          length: 0
        };
        return Object.defineProperty(o, "length", {
          get: () => t.length,
          configurable: !1,
          enumerable: !1
        }), o;
      })();
      let Hy;
      try {
        const e = "__storage_test__";
        Hy = window.localStorage, Hy.setItem(e, e), Hy.removeItem(e);
      } catch {
        Hy = HN();
      }
      var lh = Hy;
      const l7 = {
        geom: {
          Rect: Yf
        },
        util: {
          Delay: $d,
          Tools: Je,
          VK: Et,
          URI: zd,
          EventDispatcher: Ke,
          Observable: zt,
          I18n: pl,
          LocalStorage: lh,
          ImageUploader: M6
        },
        dom: {
          EventUtils: zh,
          TreeWalker: Js,
          TextSeeker: wd,
          DOMUtils: lo,
          ScriptLoader: Do,
          RangeUtils: _m,
          Serializer: EO,
          StyleSheetLoader: Nh,
          ControlSelection: Z7,
          BookmarkManager: Iv,
          Selection: SO,
          Event: zh.Event
        },
        html: {
          Styles: fm,
          Entities: gl,
          Node: _a,
          Schema: wa,
          DomParser: Gv,
          Writer: DA,
          Serializer: mp
        },
        Env: fo,
        AddOnManager: Vr,
        Annotator: E5,
        Formatter: $6,
        UndoManager: xU,
        EditorCommands: Ue,
        WindowManager: b6,
        NotificationManager: Bx,
        EditorObservable: mn,
        Shortcuts: $y,
        Editor: AS,
        FocusManager: A5,
        EditorManager: Um,
        // Global instances
        DOM: lo.DOM,
        ScriptLoader: Do.ScriptLoader,
        PluginManager: wp,
        ThemeManager: xb,
        ModelManager: ny,
        IconManager: UT,
        Resource: c7,
        FakeClipboard: DS,
        // Global utility functions
        trim: Je.trim,
        isArray: Je.isArray,
        is: Je.is,
        toArray: Je.toArray,
        makeMap: Je.makeMap,
        each: Je.each,
        map: Je.map,
        grep: Je.grep,
        inArray: Je.inArray,
        extend: Je.extend,
        walk: Je.walk,
        resolve: Je.resolve,
        explode: Je.explode,
        _addCacheSuffix: Je._addCacheSuffix
      }, zN = Je.extend(Um, l7), i7 = (e) => {
        try {
          V.exports = e;
        } catch {
        }
      };
      ((e) => {
        window.tinymce = e, window.tinyMCE = e;
      })(zN), i7(zN);
    })();
  }(NY)), NY.exports;
}
dJ();
var KX = {}, YX = {}, XX;
function mJ() {
  return XX || (XX = 1, tinymce.IconManager.add("default", {
    icons: {
      "accessibility-check": '<svg width="24" height="24"><path d="M12 2a2 2 0 0 1 2 2 2 2 0 0 1-2 2 2 2 0 0 1-2-2c0-1.1.9-2 2-2Zm8 7h-5v12c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5c0-.6-.4-1-1-1a1 1 0 0 0-1 1v5c0 .6-.4 1-1 1a1 1 0 0 1-1-1V9H4a1 1 0 1 1 0-2h16c.6 0 1 .4 1 1s-.4 1-1 1Z" fill-rule="nonzero"/></svg>',
      "accordion-toggle": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M12 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 15c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1h-6a1 1 0 0 1-1-1Z"/><path opacity=".2" fill-rule="evenodd" clip-rule="evenodd" d="M4 19c0-.6.4-1 1-1h6c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1-1-1Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M12.3 7.3a1 1 0 0 1 1.4 0L16 9.6l2.3-2.3a1 1 0 1 1 1.4 1.4L16 12.4l-3.7-3.7a1 1 0 0 1 0-1.4ZM4.3 11.7a1 1 0 0 1 0-1.4L6.6 8 4.3 5.7a1 1 0 0 1 1.4-1.4L9.4 8l-3.7 3.7a1 1 0 0 1-1.4 0Z"/></svg>',
      accordion: '<svg width="24" height="24"><rect x="12" y="7" width="10" height="2" rx="1"/><rect x="12" y="11" width="10" height="2" rx="1"/><rect x="12" y="15" width="6" height="2" rx="1"/><path fill-rule="evenodd" clip-rule="evenodd" d="M2.3 7.3a1 1 0 0 1 1.4 0L6 9.6l2.3-2.3a1 1 0 0 1 1.4 1.4L6 12.4 2.3 8.7a1 1 0 0 1 0-1.4Z"/></svg>',
      "action-next": '<svg width="24" height="24"><path fill-rule="nonzero" d="M5.7 7.3a1 1 0 0 0-1.4 1.4l7.7 7.7 7.7-7.7a1 1 0 1 0-1.4-1.4L12 13.6 5.7 7.3Z"/></svg>',
      "action-prev": '<svg width="24" height="24"><path fill-rule="nonzero" d="M18.3 15.7a1 1 0 0 0 1.4-1.4L12 6.6l-7.7 7.7a1 1 0 0 0 1.4 1.4L12 9.4l6.3 6.3Z"/></svg>',
      "add-file": '<svg height="24" width="24"><path d="M2 7h2V4h3V2H4a2 2 0 0 0-2 2zm20 0h-2V4h-3V2h3a2 2 0 0 1 2 2zm0 2h-2v6h2zm0 8h-2v3h-3v2h3a2 2 0 0 0 2-2zM2 9h2v6H2zm0 8h2v3h3v2H4a2 2 0 0 1-2-2zm7 5v-2h6v2zm6-20v2H9V2zM6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M2 7h2V4h3V2H4a2 2 0 0 0-2 2zm20 0h-2V4h-3V2h3a2 2 0 0 1 2 2zm0 2h-2v6h2zm0 8h-2v3h-3v2h3a2 2 0 0 0 2-2zM2 9h2v6H2zm0 8h2v3h3v2H4a2 2 0 0 1-2-2zm7 5v-2h6v2zm6-20v2H9V2zM6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/><path d="M6 17h12l-4-5-3 3.8-2-2.6z"/></svg>',
      addtag: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 5a2 2 0 0 1 1.6.8L21 12l-4.4 6.2a2 2 0 0 1-1.6.8h-3v-2h3l3.5-5L15 7H5v3H3V7c0-1.1.9-2 2-2h10Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M6 12a1 1 0 0 0-1 1v2H3a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2H7v-2c0-.6-.4-1-1-1Z"/></svg>',
      adjustments: '<svg width="24" height="24"><path d="M16 11a3 3 0 1 1 2.8-4H21v2h-2.2a3 3 0 0 1-2.8 2Zm0-2a1 1 0 1 1 0-2 1 1 0 0 1 0 2ZM3 9h8V7H3v2Zm5 10a3 3 0 1 0-2.8-4H3v2h2.2A3 3 0 0 0 8 19Zm0-2a1 1 0 1 0 0-2 1 1 0 0 0 0 2Zm13 0h-8v-2h8v2Z"/></svg>',
      "ai-prompt": '<svg width="24" height="24"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M15 6.7a1 1 0 0 0-1.4 0l-9.9 10a1 1 0 0 0 0 1.3l2.1 2.1c.4.4 1 .4 1.4 0l10-9.9c.3-.3.3-1 0-1.4l-2.2-2Zm1.4 2.8-2-2-3 2.7 2.2 2.2 2.8-2.9Z"/><path d="m18.5 7.3-.7-1.5-1.5-.8 1.5-.7.7-1.5.7 1.5 1.5.7-1.5.8-.7 1.5ZM18.5 16.5l-.7-1.6-1.5-.7 1.5-.7.7-1.6.7 1.6 1.5.7-1.5.7-.7 1.6ZM9.7 7.3 9 5.8 7.5 5 9 4.3l.7-1.5.7 1.5L12 5l-1.5.8-.7 1.5Z"/></g><defs><clipPath id="a"><path d="M0 0h24v24H0z"/></clipPath></defs></svg>',
      ai: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M5 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3h14a3 3 0 0 0 3-3V6a3 3 0 0 0-3-3H5Zm6.8 11.5.5 1.2a68.3 68.3 0 0 0 .7 1.1l.4.1c.3 0 .5 0 .7-.3.2-.1.3-.3.3-.6l-.3-1-2.6-6.2a20.4 20.4 0 0 0-.5-1.3l-.5-.4-.7-.2c-.2 0-.5 0-.6.2-.2 0-.4.2-.5.4l-.3.6-.3.7L5.7 15l-.2.6-.1.4c0 .3 0 .5.3.7l.6.2c.3 0 .5 0 .7-.2l.4-1 .5-1.2h3.9ZM9.8 9l1.5 4h-3l1.5-4Zm5.6-.9v7.6c0 .4 0 .7.2 1l.7.2c.3 0 .6 0 .8-.3l.2-.9V8.1c0-.4 0-.7-.2-.9a1 1 0 0 0-.8-.3c-.2 0-.5.1-.7.3l-.2 1Z"/></svg>',
      "align-center": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm3 4h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm-3-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "align-justify": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0 4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "align-left": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 4h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Zm0-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "align-none": '<svg width="24" height="24"><path d="M14.2 5 13 7H5a1 1 0 1 1 0-2h9.2Zm4 0h.8a1 1 0 0 1 0 2h-2l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h6.8Zm4 0H19a1 1 0 0 1 0 2h-4.4l1.2-2Zm-6.4 4-1.2 2H5a1 1 0 0 1 0-2h4.4Zm4 0H19a1 1 0 0 1 0 2h-6.8l1.2-2ZM7 17l-1.2 2H5a1 1 0 0 1 0-2h2Zm4 0h8a1 1 0 0 1 0 2H9.8l1.2-2Zm5.2-13.5 1.3.7-9.7 16.3-1.3-.7 9.7-16.3Z" fill-rule="evenodd"/></svg>',
      "align-right": '<svg width="24" height="24"><path d="M5 5h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2Zm6 4h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 8h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-6-4h14c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "alt-text": '<svg width="24" height="24"><path d="M3 20a2 2 0 0 1-1.4-.6A2 2 0 0 1 1 18V6c0-.6.2-1 .6-1.4A2 2 0 0 1 3 4h18c.6 0 1 .2 1.4.6.4.4.6.9.6 1.4v12c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6H3Zm0-2h18V6H3v12Zm1.5-3H6v-1.5h1.5V15H9v-5a1 1 0 0 0-.3-.7A1 1 0 0 0 8 9H5.5a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v5ZM6 12v-1.5h1.5V12H6Z"/><path d="M11 15V9h1.3v4.5h2V15H11Zm5.8-4.5V15h1.4v-4.5h1.3V9h-4v1.5h1.3Z"/></svg>',
      "arrow-left": '<svg width="24" height="24"><path d="m5.6 13 12 6a1 1 0 0 0 1.4-1V6a1 1 0 0 0-1.4-.9l-12 6a1 1 0 0 0 0 1.8Z" fill-rule="evenodd"/></svg>',
      "arrow-right": '<svg width="24" height="24"><path d="m18.5 13-12 6A1 1 0 0 1 5 18V6a1 1 0 0 1 1.4-.9l12 6a1 1 0 0 1 0 1.8Z" fill-rule="evenodd"/></svg>',
      "auto-image-enhancement": '<svg width="24" height="24"><path d="M7.7 10.6a5.8 5.8 0 0 0 5.7 5.7A5.8 5.8 0 0 0 7.7 22 5.8 5.8 0 0 0 2 16.3a5.8 5.8 0 0 0 5.7-5.7ZM15.5 2c.3 3 3.3 6 6.5 6.4-3.2.5-6.2 3.4-6.5 6.5-.3-3.4-3-6-6.4-6.5 3.3-.5 6.1-3 6.4-6.4Z"/></svg>',
      blur: '<svg width="24" height="24"><path d="M19.3 9.3a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7A1 1 0 0 0 20 9a1 1 0 0 0-.7.3Zm-16 0a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3A1 1 0 0 0 5 10a1 1 0 0 0-.3-.7A1 1 0 0 0 4 9a1 1 0 0 0-.7.3Zm16 6a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3Zm-16 0a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3A1 1 0 0 0 5 16a1 1 0 0 0-.3-.7A1 1 0 0 0 4 15a1 1 0 0 0-.7.3Zm5-11A1 1 0 0 0 8 5a1 1 0 0 0 1 1c.3 0 .5-.1.7-.3A1 1 0 0 0 10 5a1 1 0 0 0-.3-.7A1 1 0 0 0 9 4a1 1 0 0 0-.7.3Zm6 0a1 1 0 0 0-.3.7 1 1 0 0 0 1 1c.3 0 .5-.1.7-.3A1 1 0 0 0 16 5a1 1 0 0 0-.3-.7A1 1 0 0 0 15 4a1 1 0 0 0-.7.3Zm-6 16a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7A1 1 0 0 0 9 20a1 1 0 0 0-.7.3Zm6 0a1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3s.5-.1.7-.3a1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3ZM7.6 8.6A2 2 0 0 0 7 10c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 9 8a2 2 0 0 0-1.4.6Zm0 6A2 2 0 0 0 7 16c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 9 14a2 2 0 0 0-1.4.6Zm6-6A2 2 0 0 0 13 10c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 15 8a2 2 0 0 0-1.4.6Zm0 6A2 2 0 0 0 13 16c0 .6.2 1 .6 1.4.4.4.8.6 1.4.6s1-.2 1.4-.6c.4-.4.6-.8.6-1.4s-.2-1-.6-1.4A2 2 0 0 0 15 14a2 2 0 0 0-1.4.6Z"/></svg>',
      bold: '<svg width="24" height="24"><path d="M7.8 19c-.3 0-.5 0-.6-.2l-.2-.5V5.7c0-.2 0-.4.2-.5l.6-.2h5c1.5 0 2.7.3 3.5 1 .7.6 1.1 1.4 1.1 2.5a3 3 0 0 1-.6 1.9c-.4.6-1 1-1.6 1.2.4.1.9.3 1.3.6s.8.7 1 1.2c.4.4.5 1 .5 1.6 0 1.3-.4 2.3-1.3 3-.8.7-2.1 1-3.8 1H7.8Zm5-8.3c.6 0 1.2-.1 1.6-.5.4-.3.6-.7.6-1.3 0-1.1-.8-1.7-2.3-1.7H9.3v3.5h3.4Zm.5 6c.7 0 1.3-.1 1.7-.4.4-.4.6-.9.6-1.5s-.2-1-.7-1.4c-.4-.3-1-.4-2-.4H9.4v3.8h4Z" fill-rule="evenodd"/></svg>',
      bookmark: '<svg width="24" height="24"><path d="M6 4v17l6-4 6 4V4c0-.6-.4-1-1-1H7a1 1 0 0 0-1 1Z" fill-rule="nonzero"/></svg>',
      "border-style": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="2" x="3" y="6" rx="1"/><rect width="2.8" height="2" x="3" y="16" rx="1"/><rect width="2.8" height="2" x="6.8" y="16" rx="1"/><rect width="2.8" height="2" x="10.6" y="16" rx="1"/><rect width="2.8" height="2" x="14.4" y="16" rx="1"/><rect width="2.8" height="2" x="18.2" y="16" rx="1"/><rect width="8" height="2" x="3" y="11" rx="1"/><rect width="8" height="2" x="13" y="11" rx="1"/></g></svg>',
      "border-width": '<svg width="24" height="24"><g fill-rule="evenodd"><rect width="18" height="5" x="3" y="5" rx="1"/><rect width="18" height="3.5" x="3" y="11.5" rx="1"/><rect width="18" height="2" x="3" y="17" rx="1"/></g></svg>',
      box: '<svg width="24" height="24"><path d="M3.8 7a1 1 0 0 0-.7.6l-.1 3V13.8a3.5 3.5 0 0 0 4 2.7c.8-.2 1.4-.5 2-1l.3-.3.3.2c.7.7 1.4 1 2.4 1.1 1.2 0 2.4-.6 3-1.6.9-1.2.8-2.8 0-4a3.7 3.7 0 0 0-2-1.2c-.4-.1-1.2-.1-1.6 0a3.4 3.4 0 0 0-1.7 1l-.3.2-.2-.1c-.4-.5-1.2-1-2-1.1-.6-.2-1.5 0-2 .2H5V9c0-1.3 0-1.3-.3-1.6a1 1 0 0 0-1-.3Zm12 2.6c-.3.2-.5.4-.6.8v.6l.9 1 .7 1v.1l-.8 1-.7 1a1 1 0 0 0 0 .7 1 1 0 0 0 1.3.6c.2 0 .3-.2 1-1l.5-.7.6.8.7.8c.4.3 1 .3 1.3 0l.2-.3a1 1 0 0 0 0-.8l-.8-1.2-.7-1a26 26 0 0 0 1.5-2 .8.8 0 0 0 .1-.4c0-.4-.1-.7-.5-.9H20c-.4 0-.5 0-1.2.8l-.7.8-.6-.7-.7-.9a1 1 0 0 0-1 0Zm-9 2 .4.1c.3.1.6.5.7.8l.1.6v.6c-.6 1-2 1.2-2.7.3-.3-.3-.3-.5-.3-1v-.5c.3-.5.7-.8 1.1-1a1.5 1.5 0 0 1 .7 0Zm5.7 0c.4 0 .8.4 1 .8l.2.6-.1.7c-.5.9-1.6 1.1-2.4.6a1.4 1.4 0 0 1-.6-1.1 1.4 1.4 0 0 1 .5-1.2 1.5 1.5 0 0 1 1.4-.4Z"/></svg>',
      brightness: '<svg width="24" height="24"><path d="M12.7 18.3a1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v1a1 1 0 0 0 .3.7 1 1 0 0 0 .7.3 1 1 0 0 0 .7-.3 1 1 0 0 0 .3-.7v-1a1 1 0 0 0-.3-.7ZM11.3 5.7a1 1 0 0 0 .7.3 1 1 0 0 0 .7-.3A1 1 0 0 0 13 5V4a1 1 0 0 0-.3-.7A1 1 0 0 0 12 3a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v1a1 1 0 0 0 .3.7Zm9.4 5.6a1 1 0 0 0-.7-.3h-1a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 .3.7 1 1 0 0 0 .7.3h1a1 1 0 0 0 .7-.3 1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.7Zm-15 1.4A1 1 0 0 0 6 12a1 1 0 0 0-.3-.7A1 1 0 0 0 5 11H4a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 .3.7 1 1 0 0 0 .7.3h1a1 1 0 0 0 .7-.3Zm13 4.6-.7-.8a1 1 0 0 0-.8-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 .3.8l.7.7a1 1 0 0 0 .7.3 1 1 0 0 0 .8-.3 1 1 0 0 0 .3-.8 1 1 0 0 0-.3-.7ZM5.3 6.7l.7.8a1 1 0 0 0 .8.3 1 1 0 0 0 .7-.3 1 1 0 0 0 .3-.7 1 1 0 0 0-.3-.8l-.7-.7A1 1 0 0 0 6 5a1 1 0 0 0-.8.3 1 1 0 0 0-.3.8 1 1 0 0 0 .3.6Zm12 1a1 1 0 0 0 .7-.2l.7-.7A1 1 0 0 0 19 6a1 1 0 0 0-.3-.8 1 1 0 0 0-.8-.3 1 1 0 0 0-.7.3l-.7.7a1 1 0 0 0-.3.8 1 1 0 0 0 .3.7 1 1 0 0 0 .7.2ZM6.7 16.4a1 1 0 0 0-.8.2l-.7.7a1 1 0 0 0-.3.7 1 1 0 0 0 .3.8 1 1 0 0 0 .8.3 1 1 0 0 0 .7-.3l.7-.7a1 1 0 0 0 .3-.8 1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3Z"/><path fill-rule="evenodd" d="M13.6 8.3A4 4 0 0 0 12 8a4 4 0 0 0-1.6.3A4 4 0 0 0 9 9.5a4 4 0 0 0-.6 1A4 4 0 0 0 8 12c0 .6.1 1 .3 1.6a4 4 0 0 0 2.1 2 4 4 0 0 0 1.6.4 4 4 0 0 0 1.6-.3 4 4 0 0 0 2-2.1A4 4 0 0 0 16 12a4 4 0 0 0-.3-1.6 4 4 0 0 0-2.1-2ZM14 12a2 2 0 1 1-4 0 2 2 0 0 1 4 0Z"/></svg>',
      browse: '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-4v-2h4V8H5v10h4v2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9.4-2.3 2.3a1 1 0 1 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 0 1-1.4 1.4L13 13.4V20a1 1 0 0 1-2 0v-6.6Z" fill-rule="nonzero"/></svg>',
      camera: '<svg height="24" width="24"><g clip-rule="evenodd" fill-rule="evenodd"><path d="M10 5.4a1 1 0 0 1 .8-.4h4.4a1 1 0 0 1 .8.4l1.2 1.8h2.3A2.5 2.5 0 0 1 22 9.6v8a2.5 2.5 0 0 1-2.5 2.5h-13A2.5 2.5 0 0 1 4 17.6v-8a2.5 2.5 0 0 1 2.5-2.4h2.3zM11.4 7l-1.2 1.7a1 1 0 0 1-.8.5h-3a.5.5 0 0 0-.4.4v8a.5.5 0 0 0 .5.5h13a.5.5 0 0 0 .5-.5v-8a.5.5 0 0 0-.5-.4h-2.9a1 1 0 0 1-.8-.5L14.6 7z"/><path d="M13 11.4a2 2 0 1 0 0 3.8 2 2 0 0 0 0-3.8zm-4 1.9a4 4 0 1 1 8 0 4 4 0 0 1-8 0z"/></g></svg>',
      cancel: '<svg width="24" height="24"><path d="M12 4.6a7.4 7.4 0 1 1 0 14.8 7.4 7.4 0 0 1 0-14.8ZM12 3a9 9 0 1 0 0 18 9 9 0 0 0 0-18Zm0 8L14.8 8l1 1.1-2.7 2.8 2.7 2.7-1.1 1.1-2.7-2.7-2.7 2.7-1-1.1 2.6-2.7-2.7-2.7 1-1.1 2.8 2.7Z" fill-rule="nonzero"/></svg>',
      caption: '<svg height="24" width="24"><path d="M6 16h8v-2H6zm10 0h2v-2h-2zM4 20a2 2 0 0 1-1.5-.6A2 2 0 0 1 2 18V6c0-.6.2-1 .6-1.4A2 2 0 0 1 4 4h16c.6 0 1 .2 1.4.6.4.4.6.9.6 1.4v12c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6zm0-2h16V6H4z"/></svg>',
      "cell-background-color": '<svg width="24" height="24"><path d="m15.7 2 1.6 1.6-2.7 2.6 5.9 5.8c.7.7.7 1.7 0 2.4l-6.3 6.1a1.7 1.7 0 0 1-2.4 0l-6.3-6.1c-.7-.7-.7-1.7 0-2.4L15.7 2ZM18 12l-4.5-4L9 12h9ZM4 16s2 2.4 2 3.8C6 21 5.1 22 4 22s-2-1-2-2.2C2 18.4 4 16 4 16Z"/></svg>',
      "cell-border-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M5 13v5h2v2H5a2 2 0 0 1-2-2v-5h2zm8-7V4h6a2 2 0 0 1 2 2h-8z" opacity=".2"/><path fill-rule="nonzero" d="M13 4v2H5v7H3V6c0-1.1.9-2 2-2h8zm-2.6 14.1.1-.1.1.1.2.3.2.2.2.2c.4.6.8 1.2.8 1.7 0 .8-.7 1.5-1.5 1.5S9 21.3 9 20.5c0-.5.4-1.1.8-1.7l.2-.2.2-.2.2-.3z"/><path d="m13 11-2 2H5v-2h6V6h2z"/><path fill-rule="nonzero" d="m18.4 8 1 1-1.8 1.9 4 4c.5.4.5 1.1 0 1.6l-4.3 4.2a1.2 1.2 0 0 1-1.6 0l-4.4-4.2c-.4-.5-.4-1.2 0-1.7l7-6.8Zm1.6 7-3-3-3 3h6Z"/></g></svg>',
      "change-case": '<svg width="24" height="24"><path d="M18.4 18.2v-.6c-.5.8-1.3 1.2-2.4 1.2-2.2 0-3.3-1.6-3.3-4.8 0-3.1 1-4.7 3.3-4.7 1.1 0 1.8.3 2.4 1.1v-.6c0-.5.4-.8.8-.8s.8.3.8.8v8.4c0 .5-.4.8-.8.8a.8.8 0 0 1-.8-.8zm-2-7.4c-1.3 0-1.8.9-1.8 3.2 0 2.4.5 3.3 1.7 3.3 1.3 0 1.8-.9 1.8-3.2 0-2.4-.5-3.3-1.7-3.3zM10 15.7H5.5l-.8 2.6a1 1 0 0 1-1 .7h-.2a.7.7 0 0 1-.7-1l4-12a1 1 0 0 1 2 0l4 12a.7.7 0 0 1-.8 1h-.2a1 1 0 0 1-1-.7l-.8-2.6zm-.3-1.5-2-6.5-1.9 6.5h3.9z" fill-rule="evenodd"/></svg>',
      "character-count": '<svg width="24" height="24"><path d="M4 11.5h16v1H4v-1Zm4.8-6.8V10H7.7V5.8h-1v-1h2ZM11 8.3V9h2v1h-3V7.7l2-1v-.9h-2v-1h3v2.4l-2 1Zm6.3-3.4V10h-3.1V9h2.1V8h-2.1V6.8h2.1v-1h-2.1v-1h3.1ZM5.8 16.4c0-.5.2-.8.5-1 .2-.2.6-.3 1.2-.3l.8.1c.2 0 .4.2.5.3l.4.4v2.8l.2.3H8.2V18.7l-.6.3H7c-.4 0-.7 0-1-.2a1 1 0 0 1-.3-.9c0-.3 0-.6.3-.8.3-.2.7-.4 1.2-.4l.6-.2h.3v-.2l-.1-.2a.8.8 0 0 0-.5-.1 1 1 0 0 0-.4 0l-.3.4h-1Zm2.3.8h-.2l-.2.1-.4.1a1 1 0 0 0-.4.2l-.2.2.1.3.5.1h.4l.4-.4v-.6Zm2-3.4h1.2v1.7l.5-.3h.5c.5 0 .9.1 1.2.5.3.4.5.8.5 1.4 0 .6-.2 1.1-.5 1.5-.3.4-.7.6-1.3.6l-.6-.1-.4-.4v.4h-1.1v-5.4Zm1.1 3.3c0 .3 0 .6.2.8a.7.7 0 0 0 1.2 0l.2-.8c0-.4 0-.6-.2-.8a.7.7 0 0 0-.6-.3l-.6.3-.2.8Zm6.1-.5c0-.2 0-.3-.2-.4a.8.8 0 0 0-.5-.2c-.3 0-.5.1-.6.3l-.2.9c0 .3 0 .6.2.8.1.2.3.3.6.3.2 0 .4 0 .5-.2l.2-.4h1.1c0 .5-.3.8-.6 1.1a2 2 0 0 1-1.3.4c-.5 0-1-.2-1.3-.6a2 2 0 0 1-.5-1.4c0-.6.1-1.1.5-1.5.3-.4.8-.5 1.4-.5.5 0 1 0 1.2.3.4.3.5.7.5 1.2h-1v-.1Z" fill-rule="evenodd"/></svg>',
      "checklist-rtl": '<svg width="24" height="24"><path d="M5 17h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2zm14.2 11c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L18 8c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8z" fill-rule="evenodd"/></svg>',
      checklist: '<svg width="24" height="24"><path d="M11 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2h-8a1 1 0 0 1 0-2ZM7.2 16c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 20c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 14c-.2.3-.7.4-1 0l-1.3-1.3a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Zm0-6c.2-.4.6-.5.9-.3.3.2.4.6.2 1L6 8c-.2.3-.7.4-1 0L3.8 6.9a.7.7 0 0 1 0-1c.3-.2.7-.2 1 0l.7.9 1.7-2.8Z" fill-rule="evenodd"/></svg>',
      "checkmark-filled": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 2a10 10 0 1 1 0 20 10 10 0 0 1 0-20Zm4.8 5a1 1 0 0 0-1.4.3l-5.4 8-2-2.1a1 1 0 1 0-1.5 1.4l3 3a1 1 0 0 0 1.5-.2l6-9a1 1 0 0 0-.2-1.4Z"/></svg>',
      checkmark: '<svg width="24" height="24"><path d="M18.2 5.4a1 1 0 0 1 1.6 1.2l-8 12a1 1 0 0 1-1.5.1l-5-5a1 1 0 1 1 1.4-1.4l4.1 4.1 7.4-11Z" fill-rule="nonzero"/></svg>',
      "chevron-down": '<svg width="10" height="10"><path d="M8.7 2.2c.3-.3.8-.3 1 0 .4.4.4.9 0 1.2L5.7 7.8c-.3.3-.9.3-1.2 0L.2 3.4a.8.8 0 0 1 0-1.2c.3-.3.8-.3 1.1 0L5 6l3.7-3.8Z" fill-rule="nonzero"/></svg>',
      "chevron-left": '<svg width="10" height="10"><path d="M7.8 1.3 4 5l3.8 3.7c.3.3.3.8 0 1-.4.4-.9.4-1.2 0L2.2 5.7a.8.8 0 0 1 0-1.2L6.6.2C7 0 7.4 0 7.8.2c.3.3.3.8 0 1.1Z" fill-rule="nonzero"/></svg>',
      "chevron-right": '<svg width="10" height="10"><path d="M2.2 1.3a.8.8 0 0 1 0-1c.4-.4.9-.4 1.2 0l4.4 4.1c.3.4.3.9 0 1.2L3.4 9.8c-.3.3-.8.3-1.2 0a.8.8 0 0 1 0-1.1L6 5 2.2 1.3Z" fill-rule="nonzero"/></svg>',
      "chevron-up": '<svg width="10" height="10"><path d="M8.7 7.8 5 4 1.3 7.8c-.3.3-.8.3-1 0a.8.8 0 0 1 0-1.2l4.1-4.4c.3-.3.9-.3 1.2 0l4.2 4.4c.3.3.3.9 0 1.2-.3.3-.8.3-1.1 0Z" fill-rule="nonzero"/></svg>',
      "close-filled": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 2a10 10 0 1 1 0 20 10 10 0 0 1 0-20Zm4.7 5.3a1 1 0 0 0-1.3 0L12 10.6 8.6 7.3a1 1 0 0 0-1.3 1.3l3.3 3.4-3.3 3.4a1 1 0 0 0 1.3 1.3l3.4-3.3 3.4 3.3a1 1 0 0 0 1.3-1.3L13.4 12l3.3-3.4a1 1 0 0 0 0-1.3Z"/></svg>',
      close: '<svg width="24" height="24"><path d="M17.3 8.2 13.4 12l3.9 3.8a1 1 0 0 1-1.5 1.5L12 13.4l-3.8 3.9a1 1 0 0 1-1.5-1.5l3.9-3.8-3.9-3.8a1 1 0 0 1 1.5-1.5l3.8 3.9 3.8-3.9a1 1 0 0 1 1.5 1.5Z" fill-rule="evenodd"/></svg>',
      "code-sample": '<svg width="24" height="26"><path d="M7.1 11a2.8 2.8 0 0 1-.8 2 2.8 2.8 0 0 1 .8 2v1.7c0 .3.1.6.4.8.2.3.5.4.8.4.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.7 0-1.4-.3-2-.8-.5-.6-.8-1.3-.8-2V15c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4v-.8c0-.2.2-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V9.3c0-.7.3-1.4.8-2 .6-.5 1.3-.8 2-.8.3 0 .4.2.4.4v.8c0 .2-.1.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8V11Zm9.8 0V9.3c0-.3-.1-.6-.4-.8-.2-.3-.5-.4-.8-.4a.4.4 0 0 1-.4-.4V7c0-.2.1-.4.4-.4.7 0 1.4.3 2 .8.5.6.8 1.3.8 2V11c0 .3.1.6.4.8.2.3.5.4.8.4.2 0 .4.2.4.4v.8c0 .2-.2.4-.4.4-.3 0-.6.1-.8.4-.3.2-.4.5-.4.8v1.7c0 .7-.3 1.4-.8 2-.6.5-1.3.8-2 .8a.4.4 0 0 1-.4-.4v-.8c0-.2.1-.4.4-.4.3 0 .6-.1.8-.4.3-.2.4-.5.4-.8V15a2.8 2.8 0 0 1 .8-2 2.8 2.8 0 0 1-.8-2Zm-3.3-.4c0 .4-.1.8-.5 1.1-.3.3-.7.5-1.1.5-.4 0-.8-.2-1.1-.5-.4-.3-.5-.7-.5-1.1 0-.5.1-.9.5-1.2.3-.3.7-.4 1.1-.4.4 0 .8.1 1.1.4.4.3.5.7.5 1.2ZM12 13c.4 0 .8.1 1.1.5.4.3.5.7.5 1.1 0 1-.1 1.6-.5 2a3 3 0 0 1-1.1 1c-.4.3-.8.4-1.1.4a.5.5 0 0 1-.5-.5V17a3 3 0 0 0 1-.2l.6-.6c-.6 0-1-.2-1.3-.5-.2-.3-.3-.7-.3-1 0-.5.1-1 .5-1.2.3-.4.7-.5 1.1-.5Z" fill-rule="evenodd"/></svg>',
      "color-levels": '<svg width="24" height="24"><path d="M17.5 11.4A9 9 0 0 1 18 14c0 .5 0 1-.2 1.4 0 .4-.3.9-.5 1.3a6.2 6.2 0 0 1-3.7 3 5.7 5.7 0 0 1-3.2 0A5.9 5.9 0 0 1 7.6 18a6.2 6.2 0 0 1-1.4-2.6 6.7 6.7 0 0 1 0-2.8c0-.4.1-.9.3-1.3a13.6 13.6 0 0 1 2.3-4A20 20 0 0 1 12 4a26.4 26.4 0 0 1 3.2 3.4 18.2 18.2 0 0 1 2.3 4Zm-2 4.5c.4-.7.5-1.4.5-2a7.3 7.3 0 0 0-1-3.2c.2.6.2 1.2.2 1.9a4.5 4.5 0 0 1-1.3 3 5.3 5.3 0 0 1-2.3 1.5 4.9 4.9 0 0 1-2 .1 4.3 4.3 0 0 0 2.4.8 4 4 0 0 0 2-.6 4 4 0 0 0 1.5-1.5Z" fill-rule="evenodd"/></svg>',
      "color-picker": '<svg width="24" height="24"><path d="M12 3a9 9 0 0 0 0 18 1.5 1.5 0 0 0 1.1-2.5c-.2-.3-.4-.6-.4-1 0-.8.7-1.5 1.5-1.5H16a5 5 0 0 0 5-5c0-4.4-4-8-9-8Zm-5.5 9a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3-4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm5 0a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Zm3 4a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3Z" fill-rule="nonzero"/></svg>',
      "color-swatch-remove-color": '<svg width="24" height="24" class="color-swatch-remove-color"><path stroke="#000" stroke-width="2" d="M21 3 3 21" fill-rule="evenodd"/></svg>',
      "color-swatch": '<svg width="24" height="24"><rect x="3" y="3" width="18" height="18" rx="1" fill-rule="evenodd"/></svg>',
      "comment-add": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/><path d="M13 10h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 0v-2H9a1 1 0 0 1 0-2h2V8a1 1 0 0 1 2 0v2Z"/></g></svg>',
      comment: '<svg width="24" height="24"><path fill-rule="nonzero" d="m9 19 3-2h7c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H5a1 1 0 0 0-1 1v10c0 .6.4 1 1 1h4v2Zm-2 4v-4H5a3 3 0 0 1-3-3V6a3 3 0 0 1 3-3h14a3 3 0 0 1 3 3v10a3 3 0 0 1-3 3h-6.4L7 23Z"/></svg>',
      contrast: '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 0 1 19.4 9c.4 1 .6 2 .6 3.1s-.2 2.1-.6 3.1a8 8 0 0 1-1.7 2.6 8 8 0 0 1-2.6 1.7 7.8 7.8 0 0 1-3.1.6 7.8 7.8 0 0 1-3.1-.6 8 8 0 0 1-2.6-1.7A8 8 0 0 1 4.6 15 7.8 7.8 0 0 1 4 12c0-1.1.2-2.1.6-3.1a8 8 0 0 1 1.7-2.6A8 8 0 0 1 9 4.6 7.8 7.8 0 0 1 12 4Zm-6 8a6 6 0 0 0 1.8 4.2 6 6 0 0 0 1.9 1.3 5.8 5.8 0 0 0 2.3.5V6c-.8 0-1.6.2-2.3.5a6 6 0 0 0-2 1.3 6 6 0 0 0-1.2 1.9A5.8 5.8 0 0 0 6 12Z"/></svg>',
      copy: '<svg width="24" height="24"><path d="M16 3H6a2 2 0 0 0-2 2v11h2V5h10V3Zm1 4a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7Zm0 12V9h-7v10h7Z" fill-rule="nonzero"/></svg>',
      crop: '<svg width="24" height="24"><path d="M17 8v7h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v2c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-2H7V9H5a1 1 0 1 1 0-2h2V5c0-.6.4-1 1-1s1 .4 1 1v2h7l3-3 1 1-3 3ZM9 9v5l5-5H9Zm1 6h5v-5l-5 5Z" fill-rule="evenodd"/></svg>',
      "cut-column": '<svg width="24" height="24"><path fill-rule="evenodd" d="M7.2 4.5c.9 0 1.6.4 2.2 1A3.7 3.7 0 0 1 10.5 8v.5l1 1 4-4 1-.5a3.3 3.3 0 0 1 2 0c.4 0 .7.3 1 .5L17 8h4v13h-6V10l-1.5 1.5.5.5v4l-2.5-2.5-1 1v.5c0 .4 0 .8-.3 1.2-.2.5-.4.9-.8 1.2-.6.7-1.3 1-2.2 1-.8.2-1.5 0-2-.6l-.5-.8-.2-1c0-.4 0-.8.3-1.2A3.9 3.9 0 0 1 7 12.7c.5-.2 1-.3 1.5-.2l1-1-1-1c-.5 0-1 0-1.5-.2-.5-.1-1-.4-1.4-.9-.4-.3-.6-.7-.8-1.2L4.5 7c0-.4 0-.7.2-1 0-.3.3-.6.5-.8.5-.5 1.2-.8 2-.7Zm12.3 5h-3v10h3v-10ZM8 13.8h-.3l-.4.2a2.8 2.8 0 0 0-.7.4v.1a2.8 2.8 0 0 0-.6.8l-.1.4v.7l.2.5.5.2h.7a2.6 2.6 0 0 0 .8-.3 2.4 2.4 0 0 0 .7-.7 2.5 2.5 0 0 0 .3-.8 1.5 1.5 0 0 0 0-.8 1 1 0 0 0-.2-.4 1 1 0 0 0-.5-.2H8Zm3.5-3.7c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4ZM7 5.8h-.4a1 1 0 0 0-.5.3 1 1 0 0 0-.2.5v.7a2.5 2.5 0 0 0 .3.8l.2.3h.1l.4.4.4.2.4.1h.7L9 9l.2-.4a1.6 1.6 0 0 0 0-.8 2.6 2.6 0 0 0-.3-.8A2.5 2.5 0 0 0 7.7 6l-.4-.1H7Z"/></svg>',
      "cut-row": '<svg width="24" height="24"><path fill-rule="evenodd" d="M22 3v5H9l3 3 2-2h4l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8.7.6 1 1.3 1 2.2.2.8 0 1.5-.6 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l2 2V3h14ZM8.5 15.3h-.3a2.6 2.6 0 0 0-.8.4 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3L9 18V18l.4-.4.2-.4.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2h-.5Zm7 0H15a1 1 0 0 0-.4.3 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4a2.8 2.8 0 0 0 .5.7h.1a2.8 2.8 0 0 0 .8.6l.4.1h.7l.5-.2.2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3h-.3ZM12 11.6c-.4 0-.7.1-1 .4-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4Zm8.5-7.1h-11v2h11v-2Z"/></svg>',
      cut: '<svg width="24" height="24"><path d="M18 15c.6.7 1 1.4 1 2.3 0 .8-.2 1.5-.7 2l-.8.5-1 .2c-.4 0-.8 0-1.2-.3a3.9 3.9 0 0 1-2.1-2.2c-.2-.5-.3-1-.2-1.5l-1-1-1 1c0 .5 0 1-.2 1.5-.1.5-.4 1-.9 1.4-.3.4-.7.6-1.2.8l-1.2.3c-.4 0-.7 0-1-.2-.3 0-.6-.3-.8-.5-.5-.5-.8-1.2-.7-2 0-.9.4-1.6 1-2.2A3.7 3.7 0 0 1 8.6 14H9l1-1-4-4-.5-1a3.3 3.3 0 0 1 0-2c0-.4.3-.7.5-1l6 6 6-6 .5 1a3.3 3.3 0 0 1 0 2c0 .4-.3.7-.5 1l-4 4 1 1h.5c.4 0 .8 0 1.2.3.5.2.9.4 1.2.8Zm-8.5 2.2.1-.4v-.7a1 1 0 0 0-.2-.5 1 1 0 0 0-.4-.2 1.6 1.6 0 0 0-.8 0 2.6 2.6 0 0 0-.8.3 2.5 2.5 0 0 0-.9 1.1l-.1.4v.7l.2.5.5.2h.7a2.5 2.5 0 0 0 .8-.3 2.8 2.8 0 0 0 1-1Zm2.5-2.8c.4 0 .7-.1 1-.4.3-.3.4-.6.4-1s-.1-.7-.4-1c-.3-.3-.6-.4-1-.4s-.7.1-1 .4c-.3.3-.4.6-.4 1s.1.7.4 1c.3.3.6.4 1 .4Zm5.4 4 .2-.5v-.7a2.6 2.6 0 0 0-.3-.8 2.4 2.4 0 0 0-.7-.7 2.5 2.5 0 0 0-.8-.3 1.5 1.5 0 0 0-.8 0 1 1 0 0 0-.4.2 1 1 0 0 0-.2.5 1.5 1.5 0 0 0 0 .7v.4l.3.4.3.4a2.8 2.8 0 0 0 .8.5l.4.1h.7l.5-.2Z" fill-rule="evenodd"/></svg>',
      "document-gear-properties": '<svg height="24" width="24"><path d="M17.3 14.5a7.1 7.1 0 0 1 1.2.6l1.5-.5 1 1.8-1.2 1V18.7l1.2 1-1 1.6-1.5-.4a4.5 4.5 0 0 1-.6.3 7.1 7.1 0 0 1-.6.3L17 23h-2l-.3-1.5a7.4 7.4 0 0 1-.6-.3 4.5 4.5 0 0 1-.6-.3l-1.5.5-1-1.8 1.2-1a3.9 3.9 0 0 1 0-.6v-.7l-1.2-1 1-1.6 1.5.4a4.5 4.5 0 0 1 1.2-.6L15 13h2zM16 16a2 2 0 0 0-1.5.6A1.9 1.9 0 0 0 14 18c0 .6.2 1 .6 1.4s1 .6 1.5.6 1-.2 1.5-.6.6-.8.6-1.4-.2-1-.6-1.4A2 2 0 0 0 16 16z" fill-rule="evenodd"/><path d="M19 7.6V12h-2V9h-4V5H7v14h3v2H7a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h7.4z"/></svg>',
      "document-properties": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
      drag: '<svg width="24" height="24"><path d="M13 5h2v2h-2V5Zm0 4h2v2h-2V9ZM9 9h2v2H9V9Zm4 4h2v2h-2v-2Zm-4 0h2v2H9v-2Zm0 4h2v2H9v-2Zm4 0h2v2h-2v-2ZM9 5h2v2H9V5Z" fill-rule="evenodd"/></svg>',
      dropbox: '<svg height="24" width="24"><path clip-rule="evenodd" d="m6.4 9.3-3-2a1 1 0 0 1 0-1.6l4-2.5a1 1 0 0 1 1 0L12 5.5l3.6-2.3a1 1 0 0 1 1 0l4 2.5a1 1 0 0 1 0 1.7l-3 1.9 3 1.9a1 1 0 0 1 0 1.6l-2.9 1.9V16c0 .3-.1.6-.4.8l-4.5 3a1 1 0 0 1-1.2 0l-4.4-3a1 1 0 0 1-.5-.9v-1l-3.2-2.2a1 1 0 0 1 0-1.6zm3 0L12 7.5l2.6 1.8L12 11zM8.9 15v.4l3.3 2.3 3.4-2.3v-.2L12 13l-3.1 2zm-1-10-2 1.4 2 1.3 2-1.3zm8.2 0-2 1.4 2 1.3 2-1.3zm-2 6.9 2-1.3 2 1.3-2 1.3-2-1.3zm-8.3 0 2-1.3L10 12l-2 1.3-2-1.3z" fill-rule="evenodd"/></svg>',
      "duplicate-column": '<svg width="24" height="24"><path d="M17 6v16h-7V6h7Zm-2 2h-3v12h3V8Zm-2-6v2H8v15H6V2h7Z"/></svg>',
      "duplicate-row": '<svg width="24" height="24"><path d="M22 11v7H6v-7h16Zm-2 2H8v3h12v-3Zm-1-6v2H4v5H2V7h17Z"/></svg>',
      duplicate: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M16 3v2H6v11H4V5c0-1.1.9-2 2-2h10Zm3 8h-2V9h-7v10h9a2 2 0 0 1-2 2h-7a2 2 0 0 1-2-2V9c0-1.2.9-2 2-2h7a2 2 0 0 1 2 2v2Z"/><path d="M17 14h1a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1h-1a1 1 0 0 1 0-2h1v-1a1 1 0 0 1 2 0v1Z"/></g></svg>',
      "edit-block": '<svg width="24" height="24"><path fill-rule="nonzero" d="m19.8 8.8-9.4 9.4c-.2.2-.5.4-.9.4l-5.4 1.2 1.2-5.4.5-.8 9.4-9.4c.7-.7 1.8-.7 2.5 0l2.1 2.1c.7.7.7 1.8 0 2.5Zm-2-.2 1-.9v-.3l-2.2-2.2a.3.3 0 0 0-.3 0l-1 1L18 8.5Zm-1 1-2.5-2.4-6 6 2.5 2.5 6-6Zm-7 7.1-2.6-2.4-.3.3-.1.2-.7 3 3.1-.6h.1l.4-.5Z"/></svg>',
      "edit-image": '<svg width="24" height="24"><path d="M18 16h2V7a2 2 0 0 0-2-2H7v2h11v9ZM6 17h15a1 1 0 0 1 0 2h-1v1a1 1 0 0 1-2 0v-1H6a2 2 0 0 1-2-2V7H3a1 1 0 1 1 0-2h1V4a1 1 0 1 1 2 0v13Zm3-5.3 1.3 2 3-4.7 3.7 6H7l2-3.3Z" fill-rule="nonzero"/></svg>',
      "embed-page": '<svg width="24" height="24"><path d="M19 6V5H5v14h2A13 13 0 0 1 19 6Zm0 1.4c-.8.8-1.6 2.4-2.2 4.6H19V7.4Zm0 5.6h-2.4c-.4 1.8-.6 3.8-.6 6h3v-6Zm-4 6c0-2.2.2-4.2.6-6H13c-.7 1.8-1.1 3.8-1.1 6h3Zm-4 0c0-2.2.4-4.2 1-6H9.6A12 12 0 0 0 8 19h3ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm11.8 9c.4-1.9 1-3.4 1.8-4.5a9.2 9.2 0 0 0-4 4.5h2.2Zm-3.4 0a12 12 0 0 1 2.8-4 12 12 0 0 0-5 4h2.2Z" fill-rule="nonzero"/></svg>',
      embed: '<svg width="24" height="24"><path d="M4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm1 2v14h14V5H5Zm4.8 2.6 5.6 4a.5.5 0 0 1 0 .8l-5.6 4A.5.5 0 0 1 9 16V8a.5.5 0 0 1 .8-.4Z" fill-rule="nonzero"/></svg>',
      emoji: '<svg width="24" height="24"><path d="M9 11c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm6 0c.6 0 1-.4 1-1s-.4-1-1-1a1 1 0 0 0-1 1c0 .6.4 1 1 1Zm-3 5.5c2.1 0 4-1.5 4.4-3.5H7.6c.5 2 2.3 3.5 4.4 3.5ZM12 4a8 8 0 1 0 0 16 8 8 0 0 0 0-16Zm0 14.5a6.5 6.5 0 1 1 0-13 6.5 6.5 0 0 1 0 13Z" fill-rule="nonzero"/></svg>',
      evernote: '<svg width="24" height="24"><path fill-rule="evenodd" d="m9.5 3-.3.1-2.6 2.6C3.8 8.5 4 8.2 4 8.7c0 1.3.3 3 .6 4.3.5 2 1.1 3.2 2 3.7l1.2.3c1 .2 1.5.2 2.2.2 1.3 0 1.7 0 2.2-.4.3-.2.3-.4.4-1a38.4 38.4 0 0 1 .3-.4l.3.1 1.8.1h1.6v-1.8H14l-.1-.2a6.8 6.8 0 0 1-.5-1c-.2-.4-.3-.6-.5-.7a.8.8 0 0 0-.5-.1.9.9 0 0 0-.8.5l-.4 1.6-.3 1.5H9.4l-2-.3a1 1 0 0 1-.1-.2A10.1 10.1 0 0 1 6 9.7v-.2h4l.5-.5V5H12c.4.2.7.7.8 1.1a1 1 0 0 0 .2.6c.2.2.3.2 1 .3 1.2 0 2 .2 2.5.6.4.2.8.7 1 1.2.3 1.2.5 4 .3 6.4 0 1.8-.4 3.4-.8 4h-.7a8 8 0 0 1-.8 0c-.2 0-.3-.3-.2-.5a.5.5 0 0 1 .4-.3h.9v-1.8H16c-.7 0-.9 0-1.2.2-.9.4-1.4 1.2-1.4 2.1l.1.4.1.2a1 1 0 0 1 .1.2c.3.7.8 1.2 1.4 1.3l1.2.1h1.2a2 2 0 0 0 1-.8 9 9 0 0 0 1.1-4.3c.2-3 0-6.3-.4-7.7A4.3 4.3 0 0 0 16 5.3a7 7 0 0 0-1.3-.2 7.2 7.2 0 0 1-.4 0 5.5 5.5 0 0 1 0-.3c-.2-.5-.6-1-1.2-1.4a3 3 0 0 0-.5-.2c-.4-.2-.5-.2-1.8-.2a26.5 26.5 0 0 0-1.3 0Zm-.8 4v.7H7.2l.7-.8.8-.7v.7Zm7 3.5c-.4 0-.7.5-.9 1v.7h.3c.7 0 1.1.2 1.5.6l.3.2.3-.6V11a1 1 0 0 0-.6-.4 2 2 0 0 0-.8 0Z" clip-rule="evenodd"/></svg>',
      "export-pdf": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H7v3H5V5c0-1.1.9-2 2-2Z"/><path d="M2.6 15.2v-1.9h1c.6 0 1-.2 1.4-.5.3-.3.5-.7.5-1.2s-.2-.9-.5-1.2a2 2 0 0 0-1.3-.4H1v5.2h1.6Zm.4-3h-.4v-1.1h.5l.6.1.2.5c0 .1 0 .3-.2.4l-.7.1Zm5.7 3 1-.1c.3 0 .5-.2.7-.4l.5-.8c.2-.3.2-.7.2-1.3v-1l-.5-.8c-.2-.3-.4-.5-.7-.6L8.7 10H6.3v5.2h2.4Zm-.4-1.1H8v-3h.4c.5 0 .8.2 1 .4l.2 1.1-.1 1-.3.3-.8.2Zm5.3 1.2V13h2v-1h-2v-1H16V10h-4v5.2h1.6Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
      "export-word": '<svg width="24" height="24"><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V17h-2V9h-4V5H5c0-1.1.9-2 2-2ZM15 17a1 1 0 1 0-2 0v3.1l-1.4-1a1 1 0 1 0-1.2 1.7l3.6 2.4 3.6-2.4a1 1 0 0 0-1.2-1.6l-1.4 1V17Z"/></svg>',
      export: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M14.4 3 18 7v1h-5V5H7v14h9a1 1 0 0 1 2 0c0 1-.8 2-1.9 2H7c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2h7.5Z"/><path d="M18.1 12c.5 0 .9.4.9 1 0 .5-.3 1-.8 1h-7.3c-.5 0-.9-.4-.9-1 0-.5.3-1 .8-1h7.3Z"/><path d="M16.4 9.2a1 1 0 0 1 1.4.2l2.4 3.6-2.4 3.6a1 1 0 0 1-1.7-1v-.2l1.7-2.4-1.6-2.4a1 1 0 0 1 .2-1.4Z"/></g></svg>',
      exposure: '<svg width="24" height="24"><path d="M5 21a2 2 0 0 1-1.4-.6A2 2 0 0 1 3 19V5c0-.6.2-1 .6-1.4A2 2 0 0 1 5 3h14c.6 0 1 .2 1.4.6.4.4.6.8.6 1.4v14c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6H5Zm0-2h14V5L5 19Zm9.5-1v-2h-2v-1.5h2v-2H16v2h2V16h-2v2h-1.5ZM6 8.5h5V7H6v1.5Z"/></svg>',
      fb: '<svg width="24" height="24"><path fill-rule="evenodd" d="M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-11 6.7V14H8.1v-2.5h2v-1C10 8.2 11.5 7 12.8 7H16v2.5h-2.4c-.8 0-1 .7-1 1.3v.7h3.2l-1 2.5h-2v5a7 7 0 1 0-2.8-.2Z" clip-rule="evenodd"/></svg>',
      feedback: '<svg width="24" height="24"><path fill-rule="evenodd" d="M16 6c1 0 2 1 2 2v5c0 1-1 2-2 2h-3l-4 3v-3H8c-1 0-2-1-2-2V8c0-1 1-2 2-2h8Zm-7 5v1h4v-1H9Zm0-2v1h6V9H9Z"/></svg>',
      fill: '<svg width="24" height="26"><path d="m16.6 12-9-9-1.4 1.4 2.4 2.4-5.2 5.1c-.5.6-.5 1.6 0 2.2L9 19.6a1.5 1.5 0 0 0 2.2 0l5.5-5.5c.5-.6.5-1.6 0-2.2ZM5.2 13 10 8.2l4.8 4.8H5.2ZM19 14.5s-2 2.2-2 3.5c0 1.1.9 2 2 2a2 2 0 0 0 2-2c0-1.3-2-3.5-2-3.5Z" fill-rule="nonzero"/></svg>',
      flickr: '<svg width="24" height="24"><path d="M8.2 15.3c1.7 0 3.1-1.4 3.1-3.1A3.2 3.2 0 0 0 8.1 9 3.2 3.2 0 0 0 5 12.2c0 1.7 1.4 3 3.2 3Zm7.6 0c1.7 0 3.2-1.4 3.2-3.1a3.2 3.2 0 0 0-6.3 0c0 1.7 1.4 3 3.1 3Z"/></svg>',
      "flip-horizontally": '<svg width="24" height="24"><path d="M14 19h2v-2h-2v2Zm4-8h2V9h-2v2ZM4 7v10c0 1.1.9 2 2 2h3v-2H6V7h3V5H6a2 2 0 0 0-2 2Zm14-2v2h2a2 2 0 0 0-2-2Zm-7 16h2V3h-2v18Zm7-6h2v-2h-2v2Zm-4-8h2V5h-2v2Zm4 12a2 2 0 0 0 2-2h-2v2Z" fill-rule="nonzero"/></svg>',
      "flip-vertically": '<svg width="24" height="24"><path d="M5 14v2h2v-2H5Zm8 4v2h2v-2h-2Zm4-14H7a2 2 0 0 0-2 2v3h2V6h10v3h2V6a2 2 0 0 0-2-2Zm2 14h-2v2a2 2 0 0 0 2-2ZM3 11v2h18v-2H3Zm6 7v2h2v-2H9Zm8-4v2h2v-2h-2ZM5 18c0 1.1.9 2 2 2v-2H5Z" fill-rule="nonzero"/></svg>',
      folder: '<svg width="24" height="24"><path fill-rule="evenodd" d="M5.6 6a.6.6 0 0 0-.6.6v11.2a.6.6 0 0 0 .6.6h12.8a.6.6 0 0 0 .6-.6V9a.6.6 0 0 0-.6-.6h-7.2a1 1 0 0 1-.8-.4L9 6H5.6ZM3.8 4.8A2.6 2.6 0 0 1 5.6 4h4a1 1 0 0 1 .8.4l1.3 2h6.7A2.6 2.6 0 0 1 21 9v8.8a2.6 2.6 0 0 1-2.6 2.6H5.6A2.6 2.6 0 0 1 3 17.8V6.6c0-.7.3-1.4.8-1.8Z" clip-rule="evenodd"/></svg>',
      footnote: '<svg width="24" height="24"><path d="M19 13c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h14Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M19 4v6h-1V5h-1.5V4h2.6Z"/><path d="M12 18c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 1 1 0-2h7ZM14 8c.6 0 1 .4 1 1s-.4 1-1 1H5a1 1 0 0 1 0-2h9Z"/></svg>',
      "format-code": '<svg width="24" height="24"><path d="m10 22 2-7H6l9-13h2l-2 8h7L12 22h-2ZM6 2h7l-1.4 2H6V2Zm4.2 4H4v2h4.8l1.4-2Zm-2.7 4H2v2h4l1.5-2Z"/></svg>',
      "format-painter": '<svg width="24" height="24"><path d="M18 5V4c0-.5-.4-1-1-1H5a1 1 0 0 0-1 1v4c0 .6.5 1 1 1h12c.6 0 1-.4 1-1V7h1v4H9v9c0 .6.4 1 1 1h2c.6 0 1-.4 1-1v-7h8V5h-3Z" fill-rule="nonzero"/></svg>',
      format: '<svg width="24" height="24"><path fill-rule="evenodd" d="M17 5a1 1 0 0 1 0 2h-4v11a1 1 0 0 1-2 0V7H7a1 1 0 1 1 0-2h10Z"/></svg>',
      fullscreen: '<svg width="24" height="24"><path d="m15.3 10-1.2-1.3 2.9-3h-2.3a.9.9 0 1 1 0-1.7H19c.5 0 .9.4.9.9v4.4a.9.9 0 1 1-1.8 0V7l-2.9 3Zm0 4 3 3v-2.3a.9.9 0 1 1 1.7 0V19c0 .5-.4.9-.9.9h-4.4a.9.9 0 1 1 0-1.8H17l-3-2.9 1.3-1.2ZM10 15.4l-2.9 3h2.3a.9.9 0 1 1 0 1.7H5a.9.9 0 0 1-.9-.9v-4.4a.9.9 0 1 1 1.8 0V17l2.9-3 1.2 1.3ZM8.7 10 5.7 7v2.3a.9.9 0 0 1-1.7 0V5c0-.5.4-.9.9-.9h4.4a.9.9 0 0 1 0 1.8H7l3 2.9-1.3 1.2Z" fill-rule="nonzero"/></svg>',
      gallery: '<svg width="24" height="24"><path fill-rule="nonzero" d="m5 15.7 2.3-2.2c.3-.3.7-.3 1 0L11 16l5.1-5c.3-.4.8-.4 1 0l2 1.9V8H5v7.7ZM5 18V19h3l1.8-1.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 6h16c.6 0 1 .4 1 1v13c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V7c0-.6.4-1 1-1Zm6 7a2 2 0 1 1 0-4 2 2 0 0 1 0 4ZM4.5 4h15a.5.5 0 1 1 0 1h-15a.5.5 0 0 1 0-1Zm2-2h11a.5.5 0 1 1 0 1h-11a.5.5 0 0 1 0-1Z"/></svg>',
      gamma: '<svg height="24" width="24"><path d="M11.5 16.3a.7.7 0 1 0 1.4 0V14l2.7-6a.7.7 0 1 0-1.2-.6l-2.2 5-2.3-4.9C9.6 7 8.7 7 8 7.2v1.1c.8-.2.9 0 1.2 1l2.3 4.7z"/><path d="M4 3h16a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H4a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm1 2h14v14H5z" fill-rule="evenodd"/></svg>',
      "google-drive": '<svg height="24" width="24"><path clip-rule="evenodd" d="M8.7 4.5a1 1 0 0 1 .9-.5h4.8a1 1 0 0 1 .9.5l5.6 9.7a1 1 0 0 1 0 1l-2.4 4.2a1 1 0 0 1-.9.5H6.4a1 1 0 0 1-.9-.5l-2.4-4.2a1 1 0 0 1 0-1zM10.2 6l-4.5 7.7h2.5L12.7 6h-2.5zm4.2 1 4.4 7.7-1.2 2.2-4.4-7.7zM12 11.2l-1.5 2.5h3zm2.6 4.5H5.7L7 17.9h8.9l-1.3-2.2z" fill-rule="evenodd"/></svg>',
      "google-photos": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12.4 3c-.8 0-1.4.7-1.4 1.4v3.2a5 5 0 0 0-8 4c0 .8.6 1.4 1.4 1.4h3.2a5 5 0 0 0-1 3 5 5 0 0 0 5 5c.8 0 1.4-.6 1.4-1.4v-3.2a5 5 0 0 0 8-4c0-.8-.7-1.4-1.4-1.4h-3.2a5 5 0 0 0-4-8Zm.6 8V5a3 3 0 0 1 2.4 3 3 3 0 0 1-2.4 3Zm-2 0H5a3 3 0 0 1 3-2.4 3 3 0 0 1 3 2.4Zm2 2a3 3 0 0 0 3 2.4 3 3 0 0 0 3-2.4h-6Zm-4.4 3a3 3 0 0 1 2.4-3v6a3 3 0 0 1-2.4-3Z" clip-rule="evenodd"/></svg>',
      grayscale: '<svg height="24" width="24"><path d="M3 5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2zm12.4 0H19v3.6zm-2.8 0h-2.2l8.6 8.6v-2.2zm-5 0H5l14 14v-2.6z" fill-rule="evenodd"/></svg>',
      help: '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M12 5.5a6.5 6.5 0 0 0-6 9 6.3 6.3 0 0 0 1.4 2l1 1a6.3 6.3 0 0 0 3.6 1 6.5 6.5 0 0 0 6-9 6.3 6.3 0 0 0-1.4-2l-1-1a6.3 6.3 0 0 0-3.6-1ZM12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Z"/><path d="M9.6 9.7a.7.7 0 0 1-.7-.8c0-1.1 1.5-1.8 3.2-1.8 1.8 0 3.2.8 3.2 2.4 0 1.4-.4 2.1-1.5 2.8-.2 0-.3.1-.3.2a2 2 0 0 0-.8.8.8.8 0 0 1-1.4-.6c.3-.7.8-1 1.3-1.5l.4-.2c.7-.4.8-.6.8-1.5 0-.5-.6-.9-1.7-.9-.5 0-1 .1-1.4.3-.2 0-.3.1-.3.2v-.2c0 .4-.4.8-.8.8Z" fill-rule="nonzero"/><circle cx="12" cy="16" r="1"/></g></svg>',
      "highlight-bg-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-highlight-bg-color__color" d="M3 18h18v3H3z"/><path fill-rule="nonzero" d="M7.7 16.7H3l3.3-3.3-.7-.8L10.2 8l4 4.1-4 4.2c-.2.2-.6.2-.8 0l-.6-.7-1.1 1.1zm5-7.5L11 7.4l3-2.9a2 2 0 0 1 2.6 0L18 6c.7.7.7 2 0 2.7l-2.9 2.9-1.8-1.8-.5-.6"/></g></svg>',
      home: '<svg width="24" height="24"><path fill-rule="nonzero" d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>',
      "horizontal-rule": '<svg width="24" height="24"><path d="M4 11h16v2H4z" fill-rule="evenodd"/></svg>',
      huddle: '<svg height="24" width="24"><path d="M10.3 5.6V8h.8v-2l3.5 2 4.3-2.5L14.6 3l-4.3 2.6zM14.6 8v5.2l4.3-2.6V5.6L14.6 8zM6 13.3v2.5h.9v-2l3.4 2 4.3-2.5-4.3-2.6zm4.3 2.6V21l4.3-2.6v-5.1l-4.3 2.6z"/></svg>',
      "image-decorative": '<svg width="24" height="24"><path d="M12 10c.3 0 .5-.1.7-.3A1 1 0 0 0 13 9a1 1 0 0 0-.3-.7A1 1 0 0 0 12 8a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7 1 1 0 0 0 1 1Zm0 6a3 3 0 0 1-1.8-.5A3 3 0 0 1 9.1 14a2 2 0 0 0-.2 0 3 3 0 0 1-2.5-1 3 3 0 0 1-.9-2.2A3 3 0 0 1 6.2 9a3.4 3.4 0 0 1-.5-1 3 3 0 0 1-.2-1 3 3 0 0 1 1-2.2A3 3 0 0 1 8.8 4H9a3 3 0 0 1 1.1-1.4A3 3 0 0 1 12 2a3 3 0 0 1 1.8.5c.5.4.9.9 1.1 1.5h.2a3 3 0 0 1 2.5.8 3 3 0 0 1 .9 2.3c0 .3 0 .7-.2 1a2.8 2.8 0 0 1-.5.9l.5 1 .2 1a3 3 0 0 1-1 2.2 3 3 0 0 1-2.4.9 1.8 1.8 0 0 0-.2 0 3 3 0 0 1-1.1 1.4 3 3 0 0 1-1.8.5Zm0 7a8.7 8.7 0 0 1 .7-3.5 9.2 9.2 0 0 1 2-2.8 9.2 9.2 0 0 1 2.8-2A8.6 8.6 0 0 1 21 14a8.6 8.6 0 0 1-.7 3.5 9.2 9.2 0 0 1-2 2.8 9.2 9.2 0 0 1-2.8 2 8.6 8.6 0 0 1-3.5.7Zm2.5-2.5a6.8 6.8 0 0 0 2.4-1.5 6.8 6.8 0 0 0 1.7-2.6c-1 .4-1.8 1-2.6 1.7a6.8 6.8 0 0 0-1.5 2.4ZM12 23a8.6 8.6 0 0 0-.7-3.5 9.2 9.2 0 0 0-2-2.9 9.2 9.2 0 0 0-2.8-1.9A8.6 8.6 0 0 0 3 14a8.7 8.7 0 0 0 .7 3.5 9.2 9.2 0 0 0 2 2.9 9.2 9.2 0 0 0 2.8 1.9 8.6 8.6 0 0 0 3.5.7Zm-2.5-2.5A6.8 6.8 0 0 1 7.2 19a6.8 6.8 0 0 1-1.6-2.6c.9.4 1.7 1 2.5 1.7a6.8 6.8 0 0 1 1.6 2.4Zm5.9-8.4c.3 0 .5-.1.8-.4.2-.2.3-.5.3-.8 0-.2 0-.4-.2-.6a1.3 1.3 0 0 0-.5-.4l-.8-.4a3 3 0 0 1-.2.5 3.8 3.8 0 0 1-.2.5 2.5 2.5 0 0 1-.3.4 4 4 0 0 1-.4.4l.8.6a.8.8 0 0 0 .3.1h.4ZM15 8.5l.8-.4.5-.4.2-.6a1.1 1.1 0 0 0-.3-.8 1 1 0 0 0-.8-.4 1.1 1.1 0 0 0-.7.2l-.8.6.4.4.3.4a3.9 3.9 0 0 1 .4 1Zm-4-2.3a2.7 2.7 0 0 1 1-.2 2.7 2.7 0 0 1 1 .2l.2-1.1c0-.3-.1-.6-.4-.8A1.2 1.2 0 0 0 12 4c-.3 0-.6.1-.8.3-.3.2-.4.5-.3.8v1.1Zm1 7.8c.3 0 .6-.1.8-.3.3-.2.4-.5.3-.8v-1.1a2.7 2.7 0 0 1-1.1.2 2.7 2.7 0 0 1-1-.2l-.2 1.1c0 .3.1.6.4.8.2.2.5.3.8.3ZM9 8.5a3 3 0 0 1 .4-1l.3-.4.4-.4-.8-.6A.9.9 0 0 0 9 6a1.2 1.2 0 0 0-.3 0c-.4 0-.6 0-.9.3a1.1 1.1 0 0 0-.3.8c0 .2 0 .4.2.6l.5.4.9.4Zm-.3 3.6H9l.3-.2.8-.6a5.5 5.5 0 0 1-.4-.4 2.1 2.1 0 0 1-.3-.4 3.8 3.8 0 0 1-.2-.5 3 3 0 0 1-.1-.5l-1 .4-.4.4a1.1 1.1 0 0 0-.2.6c0 .3.2.6.4.8.2.2.4.4.7.4Z"/></svg>',
      "image-enhancements": '<svg height="24" width="24"><path d="M5.3 21a2 2 0 0 1-1.5-.6 2 2 0 0 1-.6-1.4V5c0-.6.2-1 .6-1.4A2 2 0 0 1 5.2 3H13v2H5.2v14h14v-8h2v8c0 .6-.1 1-.5 1.4a2 2 0 0 1-1.4.6z"/><path d="M11 9a4 4 0 0 0 4 4 4 4 0 0 0-4 4 4 4 0 0 0-4-4 4 4 0 0 0 4-4zm5.5-6c.2 2.1 2.2 4.1 4.5 4.5-2.3.4-4.3 2.4-4.5 4.5A5.2 5.2 0 0 0 12 7.5 5.2 5.2 0 0 0 16.5 3z"/></svg>',
      "image-options": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
      image: '<svg width="24" height="24"><path d="m5 15.7 3.3-3.2c.3-.3.7-.3 1 0L12 15l4.1-4c.3-.4.8-.4 1 0l2 1.9V5H5v10.7ZM5 18V19h3l2.8-2.9-2-2L5 17.9Zm14-3-2.5-2.4-6.4 6.5H19v-4ZM4 3h16c.6 0 1 .4 1 1v16c0 .6-.4 1-1 1H4a1 1 0 0 1-1-1V4c0-.6.4-1 1-1Zm6 8a2 2 0 1 0 0-4 2 2 0 0 0 0 4Z" fill-rule="nonzero"/></svg>',
      "import-word": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M7 3h7.4L19 7.6V15h-2V9h-4V5H5c0-1.1.9-2 2-2Z"/><path d="M9.5 7A1.5 1.5 0 0 1 11 8.4v7.1A1.5 1.5 0 0 1 9.6 17H2.5A1.5 1.5 0 0 1 1 15.6V8.5A1.5 1.5 0 0 1 2.4 7h7.1Zm-1 2.8-1 2.6-1-2.5v-.1a.6.6 0 0 0-1 0l-.1.1-.9 2.5-1-2.5v-.1a.6.6 0 0 0-1 .4v.1l1.5 4v.1a.6.6 0 0 0 1 0v-.1l1-2.5.9 2.5v.1a.6.6 0 0 0 1 0H8l1.6-4v-.2a.6.6 0 0 0-1.1-.4Z"/><path fill-rule="evenodd" clip-rule="evenodd" d="M11.4 18.2a1 1 0 0 0 1.2 1.6l1.4-1V22a1 1 0 1 0 2 0v-3.1l1.4 1a1 1 0 0 0 1.2-1.7L15 15.8l-3.6 2.4Z"/></svg>',
      indent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm-2.6-3.8L6.2 12l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
      info: '<svg width="24" height="24"><path d="M12 4a7.8 7.8 0 0 1 5.7 2.3A8 8 0 1 1 12 4Zm-1 3v2h2V7h-2Zm3 10v-1h-1v-5h-3v1h1v4h-1v1h4Z" fill-rule="evenodd"/></svg>',
      "insert-character": '<svg width="24" height="24"><path d="M15 18h4l1-2v4h-6v-3.3l1.4-1a6 6 0 0 0 1.8-2.9 6.3 6.3 0 0 0-.1-4.1 5.8 5.8 0 0 0-3-3.2c-.6-.3-1.3-.5-2.1-.5a5.1 5.1 0 0 0-3.9 1.8 6.3 6.3 0 0 0-1.3 6 6.2 6.2 0 0 0 1.8 3l1.4.9V20H4v-4l1 2h4v-.5l-2-1L5.4 15A6.5 6.5 0 0 1 4 11c0-1 .2-1.9.6-2.7A7 7 0 0 1 6.3 6C7.1 5.4 8 5 9 4.5c1-.3 2-.5 3.1-.5a8.8 8.8 0 0 1 5.7 2 7 7 0 0 1 1.7 2.3 6 6 0 0 1 .2 4.8c-.2.7-.6 1.3-1 1.9a7.6 7.6 0 0 1-3.6 2.5v.5Z" fill-rule="evenodd"/></svg>',
      "insert-time": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M12 19a7 7 0 1 0 0-14 7 7 0 0 0 0 14Zm0 2a9 9 0 1 1 0-18 9 9 0 0 1 0 18Z"/><path d="M16 12h-3V7c0-.6-.4-1-1-1a1 1 0 0 0-1 1v7h5c.6 0 1-.4 1-1s-.4-1-1-1Z"/></g></svg>',
      instagram: '<svg height="24" width="24"><path clip-rule="evenodd" d="M10.1 9a4 4 0 1 1 4.4 6.6A4 4 0 0 1 10.1 9zm2.2 1.3a2 2 0 1 0 0 4 2 2 0 0 0 0-4z" fill-rule="evenodd"/><path d="M16 9.3a1.3 1.3 0 1 0 0-2.6 1.3 1.3 0 0 0 0 2.6z"/><path clip-rule="evenodd" d="M3 6a3 3 0 0 1 3-3h12a3 3 0 0 1 3 3v12a3 3 0 0 1-3 3H6a3 3 0 0 1-3-3zm3-1a1 1 0 0 0-1 1v12a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1V6a1 1 0 0 0-1-1z" fill-rule="evenodd"/></svg>',
      invert: '<svg height="24" width="24"><path d="M5 4 3.6 5.4l3.9 4C6.6 10.7 6 12.3 6 14a6 6 0 0 0 10.3 4.2l1.9 1.8 1.4-1.4z" fill-rule="evenodd"/><path d="M13.4 8.4c.9 1 1.6 2.1 2 3.2l2.6 2.6V14c0-5-6-10-6-10s-1 .8-2.1 2l1.4 1.5.7-.7 1.4 1.6z"/></svg>',
      italic: '<svg width="24" height="24"><path d="m16.7 4.7-.1.9h-.3c-.6 0-1 0-1.4.3-.3.3-.4.6-.5 1.1l-2.1 9.8v.6c0 .5.4.8 1.4.8h.2l-.2.8H8l.2-.8h.2c1.1 0 1.8-.5 2-1.5l2-9.8.1-.5c0-.6-.4-.8-1.4-.8h-.3l.2-.9h5.8Z" fill-rule="evenodd"/></svg>',
      language: '<svg width="24" height="24"><path d="M12 3a9 9 0 1 1 0 18 9 9 0 0 1 0-18Zm4.3 13.3c-.5 1-1.2 2-2 2.9a7.5 7.5 0 0 0 3.2-2.1l-.2-.2a6 6 0 0 0-1-.6Zm-8.6 0c-.5.2-.9.5-1.2.8.9 1 2 1.7 3.2 2a10 10 0 0 1-2-2.8Zm3.6-.8c-.8 0-1.6.1-2.2.3.5 1 1.2 1.9 2.1 2.7Zm1.5 0v3c.9-.8 1.6-1.7 2.1-2.7-.6-.2-1.4-.3-2.1-.3Zm-6-2.7H4.5c.2 1 .5 2.1 1 3h.3l1.3-1a10 10 0 0 1-.3-2Zm12.7 0h-2.3c0 .7-.1 1.4-.3 2l1.6 1.1c.5-1 .9-2 1-3.1Zm-3.8 0h-3V14c1 0 2 .1 2.7.4.2-.5.3-1 .3-1.6Zm-4.4 0h-3l.3 1.6c.8-.3 1.7-.4 2.7-.4v-1.3Zm-5.5-5c-.7 1-1.1 2.2-1.3 3.5h2.3c0-1 .2-1.8.5-2.6l-1.5-1Zm2.9 1.4v.1c-.2.6-.4 1.3-.4 2h3V9.4c-1 0-1.8-.1-2.6-.3Zm6.6 0h-.1l-2.4.3v1.8h3l-.5-2.1Zm3-1.4-.3.1-1.3.8c.3.8.5 1.6.5 2.6h2.3a7.5 7.5 0 0 0-1.3-3.5Zm-9 0 2 .2V5.5a9 9 0 0 0-2 2.2Zm3.5-2.3V8c.6 0 1.3 0 1.9-.2a9 9 0 0 0-2-2.3Zm-3-.7h-.1c-1.1.4-2.1 1-3 1.8l1.2.7a10 10 0 0 1 1.9-2.5Zm4.4 0 .1.1a10 10 0 0 1 1.8 2.4l1.1-.7a7.5 7.5 0 0 0-3-1.8Z"/></svg>',
      "line-height": '<svg width="24" height="24"><path d="M21 5a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zm0 4a1 1 0 0 1 .1 2H13a1 1 0 0 1-.1-2H21zM7 3.6l3.7 3.7a1 1 0 0 1-1.3 1.5h-.1L8 7.3v9.2l1.3-1.3a1 1 0 0 1 1.3 0h.1c.4.4.4 1 0 1.3v.1L7 20.4l-3.7-3.7a1 1 0 0 1 1.3-1.5h.1L6 16.7V7.4L4.7 8.7a1 1 0 0 1-1.3 0h-.1a1 1 0 0 1 0-1.3v-.1L7 3.6z"/></svg>',
      line: '<svg width="24" height="24"><path d="m15 9-8 8H4v-3l8-8 3 3Zm1-1-3-3 1-1h1c-.2 0 0 0 0 0l2 2s0 .2 0 0v1l-1 1ZM4 18h16v2H4v-2Z" fill-rule="evenodd"/></svg>',
      link: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2-2a2 2 0 1 0-2.6-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2Z" fill-rule="nonzero"/></svg>',
      "list-bull-circle": '<svg height="48" width="48"><path d="M8 14a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM8 24a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0zM8 34a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0z" fill-rule="evenodd"/><path d="M18 12h22v4H18zm0 10h22v4H18zm0 10h22v4H18z" opacity=".2"/></svg>',
      "list-bull-default": '<svg height="48" width="48"><path d="M14 14a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/><path d="M12 24a3 3 0 1 0 6 0 3 3 0 0 0-6 0zm5 0a2 2 0 1 1-4 0 2 2 0 0 1 4 0z" fill-rule="evenodd"/><path d="M16 31h6v6h-6z"/><path d="M16 31h6v6h-6z"/><path d="M18 12h22v4H18zm4 10h18v4H22zm4 10h14v4H26z" opacity=".2"/></svg>',
      "list-bull-disc": '<svg height="48" width="48"><path d="M14 14a3 3 0 1 1-6 0 3 3 0 0 1 6 0zm0 10a3 3 0 1 1-6 0 3 3 0 0 1 6 0zm0 10a3 3 0 1 1-6 0 3 3 0 0 1 6 0z"/><path d="M18 12h22v4H18zm0 10h22v4H18zm0 10h22v4H18z" opacity=".2"/></svg>',
      "list-bull-square": '<svg height="48" width="48"><path d="M8 21h6v6H8zm0 10h6v6H8zm0-20h6v6H8z"/><path d="M18 12h22v4H18zm0 10h22v4H18zm0 10h22v4H18z" opacity=".2"/></svg>',
      "list-num-default-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 17v-4.8h-.1l-1.5 1v-1.1l1.6-1.1h1.2v6zM33.3 17.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm1.7 5.7c0-1.2 1-2 2.2-2 1.3 0 2.1.8 2.1 1.8 0 .7-.3 1.2-1.3 2.2l-1.2 1v.2h2.6v1h-4.3v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H35zm-1.7 4.3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7zm3.2 7.3v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H35c0-1.1 1-1.8 2.2-1.8 1.2 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.7.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .6 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7zm-3.3 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7z"/></g></svg>',
      "list-num-default": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10 17v-4.8l-1.5 1v-1.1l1.6-1h1.2V17h-1.2Zm3.6.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-5 5.7c0-1.2.8-2 2.1-2s2.1.8 2.1 1.8c0 .7-.3 1.2-1.4 2.2l-1.1 1v.2h2.6v1H8.6v-.9l2-1.9c.8-.8 1-1.1 1-1.5 0-.5-.4-.8-1-.8-.5 0-.9.3-.9.9H8.5Zm6.3 4.3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM10 34.4v-1h.7c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7s-1 .3-1 .8H8.6c0-1.1 1-1.8 2.2-1.8 1.3 0 2.1.6 2.1 1.6 0 .7-.4 1.2-1 1.3v.1c.8.1 1.3.7 1.3 1.4 0 1-1 1.9-2.4 1.9-1.3 0-2.2-.8-2.3-2h1.2c0 .6.5 1 1.1 1 .7 0 1-.4 1-1 0-.5-.3-.8-1-.8h-.7Zm4.7 2.7c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Z"/></g></svg>',
      "list-num-lower-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M36.5 16c-.9 0-1.5-.5-1.5-1.3s.6-1.3 1.8-1.4h1v-.4c0-.4-.2-.6-.7-.6-.4 0-.7.1-.8.4h-1.1c0-.8.8-1.4 2-1.4S39 12 39 13V16h-1.2v-.6c-.3.4-.8.7-1.4.7Zm.4-.8c.6 0 1-.4 1-.9V14h-1c-.5.1-.7.3-.7.6 0 .4.3.6.7.6ZM33.1 16.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7ZM37.7 26c-.7 0-1.2-.2-1.5-.7v.7H35v-6.3h1.2v2.5c.3-.5.8-.9 1.5-.9 1.1 0 1.8 1 1.8 2.4 0 1.5-.7 2.4-1.8 2.4Zm-.5-3.6c-.6 0-1 .5-1 1.3s.4 1.4 1 1.4c.7 0 1-.6 1-1.4 0-.8-.3-1.3-1-1.3ZM33.2 26.1c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7zm6 7h-1c-.1-.5-.4-.8-1-.8s-1 .5-1 1.4c0 1 .4 1.4 1 1.4.5 0 .9-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7zm-6.1 3c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7z"/></g></svg>',
      "list-num-lower-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.3 15.2c.5 0 1-.4 1-.9V14h-1c-.5.1-.8.3-.8.6 0 .4.3.6.8.6Zm-.4.9c-1 0-1.5-.6-1.5-1.4 0-.8.6-1.3 1.7-1.4h1.1v-.4c0-.4-.2-.6-.7-.6-.5 0-.8.1-.9.4h-1c0-.8.8-1.4 2-1.4 1.1 0 1.8.6 1.8 1.6V16h-1.1v-.6h-.1c-.2.4-.7.7-1.3.7Zm4.6 0c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-3.2 10c-.6 0-1.2-.3-1.4-.8v.7H8.5v-6.3H10v2.5c.3-.5.8-.9 1.4-.9 1.2 0 1.9 1 1.9 2.4 0 1.5-.7 2.4-1.9 2.4Zm-.4-3.7c-.7 0-1 .5-1 1.3s.3 1.4 1 1.4c.6 0 1-.6 1-1.4 0-.8-.4-1.3-1-1.3Zm4 3.7c-.5 0-.7-.3-.7-.7 0-.4.2-.7.7-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-2.2 7h-1.2c0-.5-.4-.8-.9-.8-.6 0-1 .5-1 1.4 0 1 .4 1.4 1 1.4.5 0 .8-.2 1-.7h1c0 1-.8 1.7-2 1.7-1.4 0-2.2-.9-2.2-2.4s.8-2.4 2.2-2.4c1.2 0 2 .7 2 1.7Zm1.8 3c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-lower-greek-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M37.4 16c-1.2 0-2-.8-2-2.3 0-1.5.8-2.4 2-2.4.6 0 1 .4 1.3 1v-.9H40v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1-.7h-.2c-.2.4-.7.8-1.3.8Zm.3-1c.6 0 1-.5 1-1.3s-.4-1.3-1-1.3-1 .5-1 1.3.4 1.4 1 1.4ZM33.3 16.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM36 21.9c0-1.5.8-2.3 2.1-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.9 1.3.9.3 1.3.8 1.3 1.7 0 1.2-.7 1.9-1.8 1.9-.6 0-1.1-.3-1.4-.8v2.2H36V22Zm1.8 1.2v-1h.3c.5 0 .9-.2.9-.7 0-.5-.3-.8-.9-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1 1.3s1-.4 1-1-.4-1-1.2-1h-.3ZM33.3 26.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7ZM37.1 34.6 34.8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.2.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1ZM33.3 36.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-lower-greek": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M10.5 15c.7 0 1-.5 1-1.3s-.3-1.3-1-1.3c-.5 0-.9.5-.9 1.3s.4 1.4 1 1.4Zm-.3 1c-1.1 0-1.8-.8-1.8-2.3 0-1.5.7-2.4 1.8-2.4.7 0 1.1.4 1.3 1h.1v-.9h1.2v3.2c0 .4.1.5.4.5h.2v.9h-.6c-.6 0-1-.2-1.1-.7h-.1c-.2.4-.7.8-1.4.8Zm5 .1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.7-.7.5 0 .8.3.8.7 0 .4-.3.7-.8.7Zm-4.9 7v-1h.3c.6 0 1-.2 1-.7 0-.5-.4-.8-1-.8-.5 0-.8.3-.8 1v2.2c0 .8.4 1.3 1.1 1.3.6 0 1-.4 1-1s-.5-1-1.3-1h-.3ZM8.6 22c0-1.5.7-2.3 2-2.3 1.2 0 2 .6 2 1.6 0 .6-.3 1-.8 1.3.8.3 1.3.8 1.3 1.7 0 1.2-.8 1.9-1.9 1.9-.6 0-1.1-.3-1.3-.8v2.2H8.5V22Zm6.2 4.2c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm-4.5 8.5L8 30h1.4l1.7 3.5 1.7-3.5h1.1l-2.2 4.6v.1c.5.8.7 1.4.7 1.8 0 .4-.1.8-.4 1-.2.2-.6.3-1 .3-.9 0-1.3-.4-1.3-1.2 0-.5.2-1 .5-1.7l.1-.2Zm.7 1a2 2 0 0 0-.4.9c0 .3.1.4.4.4.3 0 .4-.1.4-.4 0-.2-.1-.6-.4-1Zm4.5.5c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-lower-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M32.9 16v-1.2h-1.3V16H33Zm0 10v-1.2h-1.3V26H33Zm0 10v-1.2h-1.3V36H33Z"/><path fill-rule="nonzero" d="M36 21h-1.5v5H36zM36 31h-1.5v5H36zM39 21h-1.5v5H39zM39 31h-1.5v5H39zM42 31h-1.5v5H42zM36 11h-1.5v5H36zM36 19h-1.5v1H36zM36 29h-1.5v1H36zM39 19h-1.5v1H39zM39 29h-1.5v1H39zM42 29h-1.5v1H42zM36 9h-1.5v1H36z"/></g></svg>',
      "list-num-lower-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 16v-1.2h1.3V16H15Zm0 10v-1.2h1.3V26H15Zm0 10v-1.2h1.3V36H15Z"/><path fill-rule="nonzero" d="M12 21h1.5v5H12zM12 31h1.5v5H12zM9 21h1.5v5H9zM9 31h1.5v5H9zM6 31h1.5v5H6zM12 11h1.5v5H12zM12 19h1.5v1H12zM12 29h1.5v1H12zM9 19h1.5v1H9zM9 29h1.5v1H9zM6 29h1.5v1H6zM12 9h1.5v1H12z"/></g></svg>',
      "list-num-upper-alpha-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="m39.3 17-.5-1.4h-2l-.5 1.4H35l2-6h1.6l2 6h-1.3Zm-1.6-4.7-.7 2.3h1.6l-.8-2.3ZM33.4 17c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7Zm4.7 9.9h-2.7v-6H38c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7Zm-1.4-5v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4h1.1c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9h-1.1V26ZM33 27.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm4.9 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm-4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-upper-alpha": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="m12.6 17-.5-1.4h-2L9.5 17H8.3l2-6H12l2 6h-1.3ZM11 12.3l-.7 2.3h1.6l-.8-2.3Zm4.7 4.8c-.4 0-.7-.3-.7-.7 0-.4.3-.7.7-.7.5 0 .7.3.7.7 0 .4-.2.7-.7.7ZM11.4 27H8.7v-6h2.6c1.2 0 1.9.6 1.9 1.5 0 .6-.5 1.2-1 1.3.7.1 1.3.7 1.3 1.5 0 1-.8 1.7-2 1.7ZM10 22v1.5h1c.6 0 1-.3 1-.8 0-.4-.4-.7-1-.7h-1Zm0 4H11c.7 0 1.1-.3 1.1-.8 0-.6-.4-.9-1.1-.9H10V26Zm5.4 1.1c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Zm-4.1 10c-1.8 0-2.8-1.1-2.8-3.1s1-3.1 2.8-3.1c1.4 0 2.5.9 2.6 2.2h-1.3c0-.7-.6-1.1-1.3-1.1-1 0-1.6.7-1.6 2s.6 2 1.6 2c.7 0 1.2-.4 1.4-1h1.2c-.1 1.3-1.2 2.2-2.6 2.2Zm4.5 0c-.5 0-.8-.3-.8-.7 0-.4.3-.7.8-.7.4 0 .7.3.7.7 0 .4-.3.7-.7.7Z"/></g></svg>',
      "list-num-upper-roman-rtl": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M8 12h22v4H8zM8 22h22v4H8zM8 32h22v4H8z"/><path d="M31.6 17v-1.2H33V17h-1.3Zm0 10v-1.2H33V27h-1.3Zm0 10v-1.2H33V37h-1.3Z"/><path fill-rule="nonzero" d="M34.5 20H36v7h-1.5zM34.5 30H36v7h-1.5zM37.5 20H39v7h-1.5zM37.5 30H39v7h-1.5zM40.5 30H42v7h-1.5zM34.5 10H36v7h-1.5z"/></g></svg>',
      "list-num-upper-roman": '<svg width="48" height="48"><g fill-rule="evenodd"><path opacity=".2" d="M18 12h22v4H18zM18 22h22v4H18zM18 32h22v4H18z"/><path d="M15.1 17v-1.2h1.3V17H15Zm0 10v-1.2h1.3V27H15Zm0 10v-1.2h1.3V37H15Z"/><path fill-rule="nonzero" d="M12 20h1.5v7H12zM12 30h1.5v7H12zM9 20h1.5v7H9zM9 30h1.5v7H9zM6 30h1.5v7H6zM12 10h1.5v7H12z"/></g></svg>',
      lock: '<svg width="24" height="24"><path d="M16.3 11c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H8V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h.3ZM10 8v3h4V8a1 1 0 0 0-.3-.7A1 1 0 0 0 13 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7Z" fill-rule="evenodd"/></svg>',
      ltr: '<svg width="24" height="24"><path d="M11 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 7.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L11 5ZM4.4 16.2 6.2 15l-1.8-1.2a1 1 0 0 1 1.2-1.6l3 2a1 1 0 0 1 0 1.6l-3 2a1 1 0 1 1-1.2-1.6Z" fill-rule="evenodd"/></svg>',
      "math-equation": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 4.8c.1-.5.5-.8 1-.8h10a1 1 0 1 1 0 2h-9.2L8.3 19.2a1 1 0 0 1-1.7.4l-3.4-4.2a1 1 0 0 1 1.6-1.2l2 2.5L9 4.8Zm9.7 5.5c.4.4.4 1 0 1.4L17 13.5l1.8 1.8a1 1 0 1 1-1.4 1.4L15.5 15l-1.8 1.8a1 1 0 0 1-1.4-1.4l1.8-1.8-1.8-1.8a1 1 0 0 1 1.4-1.4l1.8 1.8 1.8-1.8a1 1 0 0 1 1.4 0Z"/></svg>',
      mentions: '<svg height="24" width="24"><path d="M12 21a8.8 8.8 0 0 1-3.5-.7 9 9 0 0 1-2.9-2 9 9 0 0 1-1.9-2.8A8.8 8.8 0 0 1 3 12c0-1.3.2-2.4.7-3.5a9 9 0 0 1 4.8-4.8A8.8 8.8 0 0 1 12 3c1.3 0 2.4.2 3.5.7a9.1 9.1 0 0 1 4.8 4.8A8.7 8.7 0 0 1 21 12v1.4a3 3 0 0 1-.9 2.2 3 3 0 0 1-2.2.9c-.5 0-1-.1-1.5-.4a3.8 3.8 0 0 1-1.1-1 4.8 4.8 0 0 1-1.5 1 4.3 4.3 0 0 1-1.8.4c-1.2 0-2.3-.4-3.2-1.3-.9-.9-1.3-2-1.3-3.2s.4-2.3 1.3-3.2c.9-.9 2-1.3 3.2-1.3s2.3.4 3.2 1.3c.9.9 1.3 2 1.3 3.2v1.4c0 .4.1.7.4 1 .3.3.6.4 1 .4s.7-.1 1-.4c.3-.3.4-.6.4-1V12c0-2-.7-3.8-2.1-5.2S14 4.7 12 4.7s-3.8.7-5.2 2.1S4.7 10 4.7 12s.7 3.8 2.1 5.2 3.2 2.1 5.2 2.1h4.5V21zm0-6.2c.8 0 1.4-.3 2-.8a2.7 2.7 0 0 0 .8-2c0-.8-.3-1.4-.8-2a2.7 2.7 0 0 0-2-.8c-.8 0-1.4.3-2 .8a2.7 2.7 0 0 0-.8 2c0 .8.3 1.4.8 2a2.7 2.7 0 0 0 2 .8z"/></svg>',
      minus: '<svg width="24" height="24"><path d="M19 11a1 1 0 0 1 .1 2H5a1 1 0 0 1-.1-2H19Z"/></svg>',
      "more-drawer": '<svg width="24" height="24"><path d="M6 10a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm12 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Zm-6 0a2 2 0 0 0-2 2c0 1.1.9 2 2 2a2 2 0 0 0 2-2 2 2 0 0 0-2-2Z" fill-rule="nonzero"/></svg>',
      "new-document": '<svg width="24" height="24"><path d="M14.4 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V7.6L14.4 3ZM17 19H7V5h6v4h4v10Z" fill-rule="nonzero"/></svg>',
      "new-tab": '<svg width="24" height="24"><path d="m15 13 2-2v8H5V7h8l-2 2H7v8h8v-4Zm4-8v5.5l-2-2-5.6 5.5H10v-1.4L15.5 7l-2-2H19Z" fill-rule="evenodd"/></svg>',
      "non-breaking": '<svg width="24" height="24"><path d="M11 11H8a1 1 0 1 1 0-2h3V6c0-.6.4-1 1-1s1 .4 1 1v3h3c.6 0 1 .4 1 1s-.4 1-1 1h-3v3c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-3Zm10 4v5H3v-5c0-.6.4-1 1-1s1 .4 1 1v3h14v-3c0-.6.4-1 1-1s1 .4 1 1Z" fill-rule="evenodd"/></svg>',
      notice: '<svg width="24" height="24"><path d="M15.5 4 20 8.5v7L15.5 20h-7L4 15.5v-7L8.5 4h7ZM13 17v-2h-2v2h2Zm0-4V7h-2v6h2Z" fill-rule="evenodd" clip-rule="evenodd"/></svg>',
      onedrive: '<svg height="24" width="24"><path d="M4 13.7h1zm16 .7h-1zm-11.7-4A4.4 4.4 0 0 1 12.1 8V6a6.4 6.4 0 0 0-5.6 3.4l1.8 1zM12.1 8c2 0 3.6 1.4 4 2.8l2-.5A6.3 6.3 0 0 0 12 6v2zm8.1 6.8-9.8-5.5-1 1.8 9.8 5.5 1-1.8zm-9.8-5.5A5 5 0 0 0 3 13.7h2A3 3 0 0 1 9.5 11l1-1.8zM3 13.7a5 5 0 0 0 1 2.8l1.5-1.1a3 3 0 0 1-.5-1.7zm15.8 1.6a2.3 2.3 0 0 1-2 1.4v2a4.3 4.3 0 0 0 3.9-2.6zm-2 1.4H8v2h8.7zm-8.8 0a3 3 0 0 1-2.5-1.3L4 16.5a5 5 0 0 0 4 2.2v-2zm12.7-.6c.2-.6.3-1.1.3-1.7h-2c0 .3 0 .6-.2.9zm.3-1.7c0-3-3.1-5.1-6-4l.8 1.9a2.3 2.3 0 0 1 3.2 2h2zm-6-4L4.4 15l.8 1.9 10.7-4.6-.7-1.8z"/></svg>',
      "ordered-list-rtl": '<svg width="24" height="24"><path d="M6 17h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 0 1 0-2Zm0-6h8a1 1 0 0 1 0 2H6a1 1 0 1 1 0-2Zm13-1v3.5a.5.5 0 1 1-1 0V5h-.5a.5.5 0 1 1 0-1H19Zm-1 8.8.2.2h1.3a.5.5 0 1 1 0 1h-1.6a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2h-1.3a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3Zm2 4.2v2c0 .6-.4 1-1 1h-1.5a.5.5 0 0 1 0-1h1.2a.3.3 0 1 0 0-.6h-1.3a.4.4 0 1 1 0-.8h1.3a.3.3 0 0 0 0-.6h-1.2a.5.5 0 1 1 0-1H19c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
      "ordered-list": '<svg width="24" height="24"><path d="M10 17h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0-6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 1 1 0-2ZM6 4v3.5c0 .3-.2.5-.5.5a.5.5 0 0 1-.5-.5V5h-.5a.5.5 0 0 1 0-1H6Zm-1 8.8.2.2h1.3c.3 0 .5.2.5.5s-.2.5-.5.5H4.9a1 1 0 0 1-.9-1V13c0-.4.3-.8.6-1l1.2-.4.2-.3a.2.2 0 0 0-.2-.2H4.5a.5.5 0 0 1-.5-.5c0-.3.2-.5.5-.5h1.6c.5 0 .9.4.9 1v.1c0 .4-.3.8-.6 1l-1.2.4-.2.3ZM7 17v2c0 .6-.4 1-1 1H4.5a.5.5 0 0 1 0-1h1.2c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.4a.4.4 0 1 1 0-.8h1.3c.2 0 .3-.1.3-.3 0-.2-.1-.3-.3-.3H4.5a.5.5 0 1 1 0-1H6c.6 0 1 .4 1 1Z" fill-rule="evenodd"/></svg>',
      orientation: '<svg width="24" height="24"><path d="M7.3 6.4 1 13l6.4 6.5 6.5-6.5-6.5-6.5ZM3.7 13l3.6-3.7L11 13l-3.7 3.7-3.6-3.7ZM12 6l2.8 2.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0L9.2 5.7a.8.8 0 0 1 0-1.2L13.6.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L12 4h1a9 9 0 1 1-4.3 16.9l1.5-1.5A7 7 0 1 0 13 6h-1Z" fill-rule="nonzero"/></svg>',
      outdent: '<svg width="24" height="24"><path d="M7 5h12c.6 0 1 .4 1 1s-.4 1-1 1H7a1 1 0 1 1 0-2Zm5 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm0 4h7c.6 0 1 .4 1 1s-.4 1-1 1h-7a1 1 0 0 1 0-2Zm-5 4h12a1 1 0 0 1 0 2H7a1 1 0 0 1 0-2Zm1.6-3.8a1 1 0 0 1-1.2 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 0 1 1.2 1.6L6.8 12l1.8 1.2Z" fill-rule="evenodd"/></svg>',
      "page-break": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M5 11c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h1c.6 0 1 .4 1 1s-.4 1-1 1h-1a1 1 0 0 1 0-2Zm4 0c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2ZM7 3v5h10V3c0-.6.4-1 1-1s1 .4 1 1v7H5V3c0-.6.4-1 1-1s1 .4 1 1ZM6 22a1 1 0 0 1-1-1v-7h14v7c0 .6-.4 1-1 1a1 1 0 0 1-1-1v-5H7v5c0 .6-.4 1-1 1Z"/></g></svg>',
      paragraph: '<svg width="24" height="24"><path fill-rule="evenodd" d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z"/></svg>',
      "paste-column-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h7v2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm8 7v12h-6V8h6Zm-1.5 1.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-column-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V18c0 1-.8 2-1.9 2H11v-2h7V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v2H4V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm-2 7v12H4V8h6ZM8.5 9.5h-3v9h3v-9ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-row-after": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V11h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h14c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 11v5H8v-5h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-row-before": '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 1a3 3 0 0 1 2.8 2H18c1 0 2 .8 2 1.9V7h-2V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h12v-4h2v4c0 1-.8 2-1.9 2H6c-1 0-2-.8-2-1.9V5c0-1 .8-2 1.9-2H9.2A3 3 0 0 1 12 1Zm10 7v5H8V8h14Zm-1.5 1.5h-11v2h11v-2ZM12 3a1 1 0 1 0 0 2 1 1 0 0 0 0-2Z"/></svg>',
      "paste-text": '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Zm0 9h6v2h-.5l-.5-1h-1v4h.8v1h-3.6v-1h.8v-4h-1l-.5 1H12v-2Z" fill-rule="nonzero"/></svg>',
      paste: '<svg width="24" height="24"><path d="M18 9V5h-2v1c0 .6-.4 1-1 1H9a1 1 0 0 1-1-1V5H6v13h3V9h9ZM9 20H6a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2h3.2A3 3 0 0 1 12 1a3 3 0 0 1 2.8 2H18a2 2 0 0 1 2 2v4h1v12H9v-1Zm1.5-9.5v9h9v-9h-9ZM12 3a1 1 0 0 0-1 1c0 .5.4 1 1 1s1-.5 1-1-.4-1-1-1Z" fill-rule="nonzero"/></svg>',
      "permanent-pen": '<svg width="24" height="24"><path d="M10.5 17.5 8 20H3v-3l3.5-3.5a2 2 0 0 1 0-3L14 3l1 1-7.3 7.3a1 1 0 0 0 0 1.4l3.6 3.6c.4.4 1 .4 1.4 0L20 9l1 1-7.6 7.6a2 2 0 0 1-2.8 0l-.1-.1Z" fill-rule="nonzero"/></svg>',
      "photo-filter": '<svg height="24" width="24"><path d="M4.4 21c-.3 0-.6-.2-.9-.5-.3-.3-.4-.6-.5-.9L19.6 3c.3 0 .6.3.9.5l.5.9zM3 14.7v-2.8L11.9 3h2.8zM3 7V5c0-.6.2-1 .6-1.4A2 2 0 0 1 5 3h2zm14 14 4-4v2c0 .6-.2 1-.6 1.4a2 2 0 0 1-1.4.6zm-7.7 0L21 9.3v2.8L12 21z"/></svg>',
      plus: '<svg width="24" height="24"><path d="M12 4c.5 0 1 .4 1 .9V11h6a1 1 0 0 1 .1 2H13v6a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H11V5c0-.6.4-1 1-1Z"/></svg>',
      preferences: '<svg width="24" height="24"><path d="m20.1 13.5-1.9.2a5.8 5.8 0 0 1-.6 1.5l1.2 1.5c.4.4.3 1 0 1.4l-.7.7a1 1 0 0 1-1.4 0l-1.5-1.2a6.2 6.2 0 0 1-1.5.6l-.2 1.9c0 .5-.5.9-1 .9h-1a1 1 0 0 1-1-.9l-.2-1.9a5.8 5.8 0 0 1-1.5-.6l-1.5 1.2a1 1 0 0 1-1.4 0l-.7-.7a1 1 0 0 1 0-1.4l1.2-1.5a6.2 6.2 0 0 1-.6-1.5l-1.9-.2a1 1 0 0 1-.9-1v-1c0-.5.4-1 .9-1l1.9-.2a5.8 5.8 0 0 1 .6-1.5L5.2 7.3a1 1 0 0 1 0-1.4l.7-.7a1 1 0 0 1 1.4 0l1.5 1.2a6.2 6.2 0 0 1 1.5-.6l.2-1.9c0-.5.5-.9 1-.9h1c.5 0 1 .4 1 .9l.2 1.9a5.8 5.8 0 0 1 1.5.6l1.5-1.2a1 1 0 0 1 1.4 0l.7.7c.3.4.4 1 0 1.4l-1.2 1.5a6.2 6.2 0 0 1 .6 1.5l1.9.2c.5 0 .9.5.9 1v1c0 .5-.4 1-.9 1ZM12 15a3 3 0 1 0 0-6 3 3 0 0 0 0 6Z" fill-rule="evenodd"/></svg>',
      preview: '<svg width="24" height="24"><path d="M3.5 12.5c.5.8 1.1 1.6 1.8 2.3 2 2 4.2 3.2 6.7 3.2s4.7-1.2 6.7-3.2a16.2 16.2 0 0 0 2.1-2.8 15.7 15.7 0 0 0-2.1-2.8c-2-2-4.2-3.2-6.7-3.2a9.3 9.3 0 0 0-6.7 3.2A16.2 16.2 0 0 0 3.2 12c0 .2.2.3.3.5Zm-2.4-1 .7-1.2L4 7.8C6.2 5.4 8.9 4 12 4c3 0 5.8 1.4 8.1 3.8a18.2 18.2 0 0 1 2.8 3.7v1l-.7 1.2-2.1 2.5c-2.3 2.4-5 3.8-8.1 3.8-3 0-5.8-1.4-8.1-3.8a18.2 18.2 0 0 1-2.8-3.7 1 1 0 0 1 0-1Zm12-3.3a2 2 0 1 0 2.7 2.6 4 4 0 1 1-2.6-2.6Z" fill-rule="nonzero"/></svg>',
      print: '<svg width="24" height="24"><path d="M18 8H6a3 3 0 0 0-3 3v6h2v3h14v-3h2v-6a3 3 0 0 0-3-3Zm-1 10H7v-4h10v4Zm.5-5c-.8 0-1.5-.7-1.5-1.5s.7-1.5 1.5-1.5 1.5.7 1.5 1.5-.7 1.5-1.5 1.5Zm.5-8H6v2h12V5Z" fill-rule="nonzero"/></svg>',
      quote: '<svg width="24" height="24"><path d="M7.5 17h.9c.4 0 .7-.2.9-.6L11 13V8c0-.6-.4-1-1-1H6a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Zm8 0h.9c.4 0 .7-.2.9-.6L19 13V8c0-.6-.4-1-1-1h-4a1 1 0 0 0-1 1v4c0 .6.4 1 1 1h2l-1.3 2.7a1 1 0 0 0 .8 1.3Z" fill-rule="nonzero"/></svg>',
      redo: '<svg width="24" height="24"><path d="M17.6 10H12c-2.8 0-4.4 1.4-4.9 3.5-.4 2 .3 4 1.4 4.6a1 1 0 1 1-1 1.8c-2-1.2-2.9-4.1-2.3-6.8.6-3 3-5.1 6.8-5.1h5.6l-3.3-3.3a1 1 0 1 1 1.4-1.4l5 5a1 1 0 0 1 0 1.4l-5 5a1 1 0 0 1-1.4-1.4l3.3-3.3Z" fill-rule="nonzero"/></svg>',
      reload: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="m5 22.1-1.2-4.7v-.2a1 1 0 0 1 1-1l5 .4a1 1 0 1 1-.2 2l-2.2-.2a7.8 7.8 0 0 0 8.4.2 7.5 7.5 0 0 0 3.5-6.4 1 1 0 1 1 2 0 9.5 9.5 0 0 1-4.5 8 9.9 9.9 0 0 1-10.2 0l.4 1.4a1 1 0 1 1-2 .5ZM13.6 7.4c0-.5.5-1 1-.9l2.8.2a8 8 0 0 0-9.5-1 7.5 7.5 0 0 0-3.6 7 1 1 0 0 1-2 0 9.5 9.5 0 0 1 4.5-8.6 10 10 0 0 1 10.9.3l-.3-1a1 1 0 0 1 2-.5l1.1 4.8a1 1 0 0 1-1 1.2l-5-.4a1 1 0 0 1-.9-1Z"/></g></svg>',
      "remove-formatting": '<svg width="24" height="24"><path d="M13.2 6a1 1 0 0 1 0 .2l-2.6 10a1 1 0 0 1-1 .8h-.2a.8.8 0 0 1-.8-1l2.6-10H8a1 1 0 1 1 0-2h9a1 1 0 0 1 0 2h-3.8ZM5 18h7a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Zm13 1.5L16.5 18 15 19.5a.7.7 0 0 1-1-1l1.5-1.5-1.5-1.5a.7.7 0 0 1 1-1l1.5 1.5 1.5-1.5a.7.7 0 0 1 1 1L17.5 17l1.5 1.5a.7.7 0 0 1-1 1Z" fill-rule="evenodd"/></svg>',
      remove: '<svg width="24" height="24"><path d="M16 7h3a1 1 0 0 1 0 2h-1v9a3 3 0 0 1-3 3H9a3 3 0 0 1-3-3V9H5a1 1 0 1 1 0-2h3V6a3 3 0 0 1 3-3h2a3 3 0 0 1 3 3v1Zm-2 0V6c0-.6-.4-1-1-1h-2a1 1 0 0 0-1 1v1h4Zm2 2H8v9c0 .6.4 1 1 1h6c.6 0 1-.4 1-1V9Zm-7 3a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Zm4 0a1 1 0 0 1 2 0v4a1 1 0 0 1-2 0v-4Z" fill-rule="nonzero"/></svg>',
      "resize-handle": '<svg width="10" height="10"><g fill-rule="nonzero"><path d="M8.1 1.1A.5.5 0 1 1 9 2l-7 7A.5.5 0 1 1 1 8l7-7ZM8.1 5.1A.5.5 0 1 1 9 6l-3 3A.5.5 0 1 1 5 8l3-3Z"/></g></svg>',
      resize: '<svg width="24" height="24"><path d="M4 5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h6c.3 0 .5.1.7.3.2.2.3.4.3.7 0 .3-.1.5-.3.7a1 1 0 0 1-.7.3H7.4L18 16.6V13c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3.3 0 .5.1.7.3.2.2.3.4.3.7v6c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-6a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3.6L6 7.4V11c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3 1 1 0 0 1-.7-.3A1 1 0 0 1 4 11V5Z" fill-rule="evenodd"/></svg>',
      "restore-draft": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
      "revert-changes": '<svg height="24" width="24"><path d="m8.9 18.8.4 3.2H13v-2h-2v-2.6a4.6 4.6 0 0 1-1.6-.6 5.9 5.9 0 0 1-1.3-1l-2.5 1-1-1.7 2.2-1.6a4 4 0 0 1-.2-.7 5.9 5.9 0 0 1 0-.8v-.8l.2-.8-2.2-1.6 1-1.7 2.5 1a6 6 0 0 1 1.2-.9l1.4-.6.4-2.6h2l.3 2.6A5.6 5.6 0 0 1 16 8.2l2.5-1 1 1.6-2.2 1.7.2.7v.8a5 5 0 0 1 0 1h2a2.6 2.6 0 0 0 0-.5V11.3l2.6-2-2.8-4.7-3 1.3a8.2 8.2 0 0 0-.5-.4 3.8 3.8 0 0 0-.6-.3L14.8 2H9.3l-.4 3.2a5 5 0 0 0-1.2.7l-3-1.3L2 9.4l2.6 2V12.6l-2.6 2 2.7 4.7 3-1.3a8 8 0 0 0 1.2.7z"/><path d="m14.5 20.3 2.1-2-2.1-2.2 1.4-1.4 2.1 2.1 2.1-2 1.4 1.3-2 2.1 2 2.1-1.4 1.4-2.1-2-2.1 2zM12 14a2 2 0 1 0 0-4 2 2 0 0 0 0 4z"/></svg>',
      "revision-history": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M17 13c0 .6-.4 1-1 1h-4V8c0-.6.4-1 1-1s1 .4 1 1v4h2c.6 0 1 .4 1 1Z"/><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></g></svg>',
      "rotate-left": '<svg width="24" height="24"><path d="M4.7 10H9a1 1 0 0 1 0 2H3a1 1 0 0 1-1-1V5a1 1 0 1 1 2 0v3l2.5-2.4a9.2 9.2 0 0 1 10.8-1.5A9 9 0 0 1 13.4 21c-2.4.1-4.7-.7-6.5-2.2a1 1 0 1 1 1.3-1.5 7.2 7.2 0 0 0 11.6-3.7 7 7 0 0 0-3.5-7.7A7.2 7.2 0 0 0 8 7L4.7 10Z" fill-rule="nonzero"/></svg>',
      "rotate-right": '<svg width="24" height="24"><path d="M20 8V5a1 1 0 0 1 2 0v6c0 .6-.4 1-1 1h-6a1 1 0 0 1 0-2h4.3L16 7A7.2 7.2 0 0 0 7.7 6a7 7 0 0 0 3 13.1c1.9.1 3.7-.5 5-1.7a1 1 0 0 1 1.4 1.5A9.2 9.2 0 0 1 2.2 14c-.9-3.9 1-8 4.5-9.9 3.5-1.9 8-1.3 10.8 1.5L20 8Z" fill-rule="nonzero"/></svg>',
      rtl: '<svg width="24" height="24"><path d="M8 5h8v2h-2v12h-2V7h-2v12H8v-7c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 4.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L8 5Zm12 11.2a1 1 0 1 1-1 1.6l-3-2a1 1 0 0 1 0-1.6l3-2a1 1 0 1 1 1 1.6L18.4 15l1.8 1.2Z" fill-rule="evenodd"/></svg>',
      saturation: '<svg width="24" height="24"><path fill-rule="evenodd" d="M12 20.5a6 6 0 1 1-5.9-10.2 6 6 0 1 1 11.8 0A6 6 0 1 1 12 20.5Zm-1.1-7.7a6 6 0 0 0-.2.3 4.3 4.3 0 0 1-2-1.3c.9.1 1.6.5 2.2 1Zm2.4.3a6 6 0 0 0-.2-.3 4.3 4.3 0 0 1 2.2-1 4.3 4.3 0 0 1-2 1.3ZM12.2 15a6.3 6.3 0 0 1-.4 0 4.3 4.3 0 0 0 .2 2.5 4.3 4.3 0 0 0 .2-2.5Zm.9 4.2a6 6 0 0 0 .8-4.5 6 6 0 0 0 3.4-2.8 4.3 4.3 0 0 1-1.3 8.4 4.3 4.3 0 0 1-2.9-1.1Zm-2.2 0a4.3 4.3 0 1 1-4.2-7.3 6 6 0 0 0 3.4 2.8 6 6 0 0 0 .8 4.5Zm-3-9.2a4.3 4.3 0 1 1 8.3 0 6 6 0 0 0-4.2 1.5A6 6 0 0 0 7.8 10Z"/></svg>',
      save: '<svg width="24" height="24"><path d="M5 16h14a2 2 0 0 1 2 2v2a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-2c0-1.1.9-2 2-2Zm0 2v2h14v-2H5Zm10 0h2v2h-2v-2Zm-4-6.4L8.7 9.3a1 1 0 1 0-1.4 1.4l4 4c.4.4 1 .4 1.4 0l4-4a1 1 0 1 0-1.4-1.4L13 11.6V4a1 1 0 0 0-2 0v7.6Z" fill-rule="nonzero"/></svg>',
      search: '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Z" fill-rule="nonzero"/></svg>',
      "select-all": '<svg width="24" height="24"><path d="M3 5h2V3a2 2 0 0 0-2 2Zm0 8h2v-2H3v2Zm4 8h2v-2H7v2ZM3 9h2V7H3v2Zm10-6h-2v2h2V3Zm6 0v2h2a2 2 0 0 0-2-2ZM5 21v-2H3c0 1.1.9 2 2 2Zm-2-4h2v-2H3v2ZM9 3H7v2h2V3Zm2 18h2v-2h-2v2Zm8-8h2v-2h-2v2Zm0 8a2 2 0 0 0 2-2h-2v2Zm0-12h2V7h-2v2Zm0 8h2v-2h-2v2Zm-4 4h2v-2h-2v2Zm0-16h2V3h-2v2ZM7 17h10V7H7v10Zm2-8h6v6H9V9Z" fill-rule="nonzero"/></svg>',
      selected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm3.6 10.9L7 12.3a.7.7 0 0 0-1 1L9.6 17 18 8.6a.7.7 0 0 0 0-1 .7.7 0 0 0-1 0l-7.4 7.3Z"/></svg>',
      send: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="m13.3 22 7-18.3-18.3 7L9 15l4.3 7ZM18 6.8l-.7-.7L9.4 14l.7.7L18 6.8Z"/></svg>',
      settings: '<svg width="24" height="24"><path d="M11 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V8H5a1 1 0 1 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.5V6ZM8 8h2V6H8v2Zm9 2.8v.2h2c.6 0 1 .4 1 1s-.4 1-1 1h-2v.3c0 .2 0 .3-.2.5l-.6.2h-2.4c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V13H5a1 1 0 0 1 0-2h8v-.3c0-.2 0-.3.2-.5l.6-.2h2.4c.3 0 .4 0 .6.2l.2.6ZM14 13h2v-2h-2v2Zm-3 2.8v.2h8c.6 0 1 .4 1 1s-.4 1-1 1h-8v.3c0 .2 0 .3-.2.5l-.6.2H7.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6V18H5a1 1 0 0 1 0-2h2v-.3c0-.2 0-.3.2-.5l.5-.2h2.5c.3 0 .4 0 .6.2l.2.6ZM8 18h2v-2H8v2Z" fill-rule="evenodd"/></svg>',
      sharpen: '<svg width="24" height="24"><path fill-rule="evenodd" d="m16 6 4 4-8 9-8-9 4-4h8Zm-4 10.2 5.5-6.2-.1-.1H12v-.3h5.1l-.2-.2H12V9h4.6l-.2-.2H12v-.3h4.1l-.2-.2H12V8h3.6l-.2-.2H8.7L6.5 10l.1.1H12v.3H6.9l.2.2H12v.3H7.3l.2.2H12v.3H7.7l.3.2h4v.3H8.2l.2.2H12v.3H8.6l.3.2H12v.3H9l.3.2H12v.3H9.5l.2.2H12v.3h-2l.2.2H12v.3h-1.6l.2.2H12v.3h-1.1l.2.2h.9v.3h-.7l.2.2h.5v.3h-.3l.3.2Z"/></svg>',
      sourcecode: '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M9.8 15.7c.3.3.3.8 0 1-.3.4-.9.4-1.2 0l-4.4-4.1a.8.8 0 0 1 0-1.2l4.4-4.2c.3-.3.9-.3 1.2 0 .3.3.3.8 0 1.1L6 12l3.8 3.7ZM14.2 15.7c-.3.3-.3.8 0 1 .4.4.9.4 1.2 0l4.4-4.1c.3-.3.3-.9 0-1.2l-4.4-4.2a.8.8 0 0 0-1.2 0c-.3.3-.3.8 0 1.1L18 12l-3.8 3.7Z"/></g></svg>',
      "spell-check": '<svg width="24" height="24"><path d="M6 8v3H5V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h2c.3 0 .5.1.7.3.2.2.3.4.3.7v6H8V8H6Zm0-3v2h2V5H6Zm13 0h-3v5h3v1h-3a1 1 0 0 1-.7-.3 1 1 0 0 1-.3-.7V5c0-.3.1-.5.3-.7.2-.2.4-.3.7-.3h3v1Zm-5 1.5-.1.7c-.1.2-.3.3-.6.3.3 0 .5.1.6.3l.1.7V10c0 .3-.1.5-.3.7a1 1 0 0 1-.7.3h-3V4h3c.3 0 .5.1.7.3.2.2.3.4.3.7v1.5ZM13 10V8h-2v2h2Zm0-3V5h-2v2h2Zm3 5 1 1-6.5 7L7 15.5l1.3-1 2.2 2.2L16 12Z" fill-rule="evenodd"/></svg>',
      "strike-through": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M15.6 8.5c-.5-.7-1-1.1-1.3-1.3-.6-.4-1.3-.6-2-.6-2.7 0-2.8 1.7-2.8 2.1 0 1.6 1.8 2 3.2 2.3 4.4.9 4.6 2.8 4.6 3.9 0 1.4-.7 4.1-5 4.1A6.2 6.2 0 0 1 7 16.4l1.5-1.1c.4.6 1.6 2 3.7 2 1.6 0 2.5-.4 3-1.2.4-.8.3-2-.8-2.6-.7-.4-1.6-.7-2.9-1-1-.2-3.9-.8-3.9-3.6C7.6 6 10.3 5 12.4 5c2.9 0 4.2 1.6 4.7 2.4l-1.5 1.1Z"/><path d="M5 11h14a1 1 0 0 1 0 2H5a1 1 0 0 1 0-2Z" fill-rule="nonzero"/></g></svg>',
      subscript: '<svg width="24" height="24"><path d="m10.4 10 4.6 4.6-1.4 1.4L9 11.4 4.4 16 3 14.6 7.6 10 3 5.4 4.4 4 9 8.6 13.6 4 15 5.4 10.4 10ZM21 19h-5v-1l1-.8 1.7-1.6c.3-.4.5-.8.5-1.2 0-.3 0-.6-.2-.7-.2-.2-.5-.3-.9-.3a2 2 0 0 0-.8.2l-.7.3-.4-1.1 1-.6 1.2-.2c.8 0 1.4.3 1.8.7.4.4.6.9.6 1.5s-.2 1.1-.5 1.6a8 8 0 0 1-1.3 1.3l-.6.6h2.6V19Z" fill-rule="nonzero"/></svg>',
      "suggestededits-badge": '<svg height="24" width="24"><path d="M11 3H7a2 2 0 0 0-2 2v14c0 1.1.9 2 2 2h10a2 2 0 0 0 2-2V9.7a6 6 0 0 1-2 .3v9H7V5h4a6 6 0 0 1 0-2z"/><path d="M15 13v-2h-4v2zm-3 2H9v2h3zm-1-8H9v2h2zm4 10v-2h-2v2z"/><path d="M21 4a4 4 0 1 1-8 0 4 4 0 0 1 8 0z" class="tox-icon--badge"/></svg>',
      suggestededits: '<svg width="24" height="24"><path d="M7 3h7.4L19 7.6V19a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V5c0-1.1.9-2 2-2Zm0 16h10V9h-3V5H7v14Z" clip-rule="evenodd"/><path d="M9 7h2v2H9V7Zm2 4h4v2h-4v-2Zm-2 4h3v2H9v-2Z"/><path d="M9 7h2v2H9V7Zm4 8h2v2h-2v-2Z"/></svg>',
      superscript: '<svg width="24" height="24"><path d="M15 9.4 10.4 14l4.6 4.6-1.4 1.4L9 15.4 4.4 20 3 18.6 7.6 14 3 9.4 4.4 8 9 12.6 13.6 8 15 9.4Zm5.9 1.6h-5v-1l1-.8 1.7-1.6c.3-.5.5-.9.5-1.3 0-.3 0-.5-.2-.7-.2-.2-.5-.3-.9-.3l-.8.2-.7.4-.4-1.2c.2-.2.5-.4 1-.5.3-.2.8-.2 1.2-.2.8 0 1.4.2 1.8.6.4.4.6 1 .6 1.6 0 .5-.2 1-.5 1.5l-1.3 1.4-.6.5h2.6V11Z" fill-rule="nonzero"/></svg>',
      "table-caption": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="12" height="2" x="3" y="4" rx="1"/><path d="M19 8a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-8c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></g></svg>',
      "table-cell-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M13 4v9H3V6c0-1.1.9-2 2-2h8Zm-2 2H5v5h6V6Z"/><path fill-rule="nonzero" d="M13 4h6a2 2 0 0 1 2 2v7h-8v-2h6V6h-6V4Z" opacity=".2"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/><path fill-rule="nonzero" d="M3 13v5c0 1.1.9 2 2 2h8v-7h-2v5H5v-5H3Z" opacity=".2"/></g></svg>',
      "table-cell-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8 0h-6v5h6v-5Zm-8-7H5v5h6V6Z"/></svg>',
      "table-cell-select-all": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z" opacity=".2"/></g></svg>',
      "table-cell-select-inner": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v12h14V6Z" opacity=".2"/><path d="M13 6v5h6v2h-6v5h-2v-5H5v-2h6V6h2Z"/></g></svg>',
      "table-classes": '<svg width="24" height="24"><g fill-rule="evenodd"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v7h-8v7H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 9H5v5h6v-5Zm8-7h-6v5h6V6Zm-8 0H5v5h6V6Z"/><path d="m18 20-2.6 1.6.7-3-2.4-2 3.1-.2 1.2-2.9 1.2 2.9 3.1.2-2.4 2 .7 3z"/></g></svg>',
      "table-delete-column": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-4 4h-2V6h-2v2H9V6H5v12h4v-2h2v2h2v-2h2v2h4V6h-4v2Zm.3.5 1 1.2-3 2.3 3 2.3-1 1.2L12 13l-3.3 2.6-1-1.2 3-2.3-3-2.3 1-1.2L12 11l3.3-2.5Z"/></svg>',
      "table-delete-row": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 2H5v3h2.5v2H5v2h2.5v2H5v3h14v-3h-2.5v-2H19v-2h-2.5V9H19V6Zm-4.7 1.8 1.2 1L13 12l2.6 3.3-1.2 1-2.3-3-2.3 3-1.2-1L11 12 8.5 8.7l1.2-1 2.3 3 2.3-3Z"/></svg>',
      "table-delete-table": '<svg width="24" height="24"><g fill-rule="nonzero"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 6v12h14V6H5Z"/><path d="m14.4 8.6 1.1 1-2.4 2.4 2.4 2.4-1.1 1.1-2.4-2.4-2.4 2.4-1-1.1 2.3-2.4-2.3-2.4 1-1 2.4 2.3z"/></g></svg>',
      "table-insert-column-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M20 4c.6 0 1 .4 1 1v2a1 1 0 0 1-2 0V6h-8v12h8v-1a1 1 0 0 1 2 0v2c0 .5-.4 1-.9 1H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h15ZM9 13H5v5h4v-5Zm7-5c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H17v2a1 1 0 0 1-2 .1V13h-2a1 1 0 0 1-.1-2H15V9c0-.6.4-1 1-1ZM9 6H5v5h4V6Z"/></svg>',
      "table-insert-column-before": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a1 1 0 0 1-1-1v-2a1 1 0 0 1 2 0v1h8V6H5v1a1 1 0 1 1-2 0V5c0-.6.4-1 1-1h15Zm0 9h-4v5h4v-5ZM8 8c.5 0 1 .4 1 .9V11h2a1 1 0 0 1 .1 2H9v2a1 1 0 0 1-2 .1V13H5a1 1 0 0 1-.1-2H7V9c0-.6.4-1 1-1Zm11-2h-4v5h4V6Z"/></svg>',
      "table-insert-row-above": '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4a1 1 0 1 1 0 2H5v6h14V6h-1a1 1 0 0 1 0-2h2c.6 0 1 .4 1 1v13a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5c0-.6.4-1 1-1h2Zm5 10H5v4h6v-4Zm8 0h-6v4h6v-4ZM12 3c.5 0 1 .4 1 .9V6h2a1 1 0 0 1 0 2h-2v2a1 1 0 0 1-2 .1V8H9a1 1 0 0 1 0-2h2V4c0-.6.4-1 1-1Z"/></svg>',
      "table-insert-row-after": '<svg width="24" height="24"><path fill-rule="nonzero" d="M12 13c.5 0 1 .4 1 .9V16h2a1 1 0 0 1 .1 2H13v2a1 1 0 0 1-2 .1V18H9a1 1 0 0 1-.1-2H11v-2c0-.6.4-1 1-1Zm6 7a1 1 0 0 1 0-2h1v-6H5v6h1a1 1 0 0 1 0 2H4a1 1 0 0 1-1-1V6c0-1.1.9-2 2-2h14a2 2 0 0 1 2 2v13c0 .5-.4 1-.9 1H18ZM11 6H5v4h6V6Zm8 0h-6v4h6V6Z"/></svg>',
      "table-left-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm0 9h-4v5h4v-5Zm-6 0H9v5h4v-5Zm0-7H9v5h4V6Zm6 0h-4v5h4V6Z"/></svg>',
      "table-merge-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15.5V18h3v-2.5H5Zm14-5h-9V18h9v-7.5ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Zm-8 7.5h3v-3H5v3Z"/></svg>',
      "table-row-numbering-rtl": '<svg width="24" height="24"><path d="M6 4a2 2 0 0 0-2 2v13c0 1.1.9 2 2 2h12a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2H6Zm0 12h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 11h8v3H6v-3Zm11 0c.6 0 1 .4 1 1v1a1 1 0 0 1-2 0v-1c0-.6.4-1 1-1ZM6 6h8v3H6V6Zm11 0c.6 0 1 .4 1 1v1a1 1 0 1 1-2 0V7c0-.6.4-1 1-1Z"/></svg>',
      "table-row-numbering": '<svg width="24" height="24"><path d="M18 4a2 2 0 0 1 2 2v13a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h12Zm0 12h-8v3h8v-3ZM7 16a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8v-3ZM7 11a1 1 0 0 0-1 1v1a1 1 0 0 0 2 0v-1c0-.6-.4-1-1-1Zm11-5h-8v3h8V6ZM7 6a1 1 0 0 0-1 1v1a1 1 0 1 0 2 0V7c0-.6-.4-1-1-1Z"/></svg>',
      "table-row-properties": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 15v3h6v-3H5Zm14 0h-6v3h6v-3Zm0-9h-6v3h6V6ZM5 9h6V6H5v3Z"/></svg>',
      "table-split-cells": '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM8 15.5H5V18h3v-2.5Zm11-5h-9V18h9v-7.5Zm-2.5 1 1 1-2 2 2 2-1 1-2-2-2 2-1-1 2-2-2-2 1-1 2 2 2-2Zm-8.5-1H5v3h3v-3ZM19 6h-4v2.5h4V6ZM8 6H5v2.5h3V6Zm5 0h-3v2.5h3V6Z"/></svg>',
      "table-top-header": '<svg width="24" height="24"><path d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14Zm-8 11H5v3h6v-3Zm8 0h-6v3h6v-3Zm0-5h-6v3h6v-3ZM5 13h6v-3H5v3Z"/></svg>',
      table: '<svg width="24" height="24"><path fill-rule="nonzero" d="M19 4a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2h14ZM5 14v4h6v-4H5Zm14 0h-6v4h6v-4Zm0-6h-6v4h6V8ZM5 12h6V8H5v4Z"/></svg>',
      "template-add": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M9 12v4H5a2 2 0 0 0-2 2v3h9.3a6 6 0 0 1-.3-2H5v-1h7a6 6 0 0 1 .8-2H11v-5l-.8-.6a3 3 0 1 1 3.6 0l-.8.6v4.7a6 6 0 0 1 2-1.9V12a5 5 0 1 0-6 0Z"/><path d="M18 15c.5 0 1 .4 1 .9V18h2a1 1 0 0 1 .1 2H19v2a1 1 0 0 1-2 .1V20h-2a1 1 0 0 1-.1-2H17v-2c0-.6.4-1 1-1Z"/></svg>',
      template: '<svg width="24" height="24"><path d="M19 19v-1H5v1h14ZM9 16v-4a5 5 0 1 1 6 0v4h4a2 2 0 0 1 2 2v3H3v-3c0-1.1.9-2 2-2h4Zm4 0v-5l.8-.6a3 3 0 1 0-3.6 0l.8.6v5h2Z" fill-rule="nonzero"/></svg>',
      "temporary-placeholder": '<svg width="24" height="24"><g fill-rule="evenodd"><path d="M9 7.6V6h2.5V4.5a.5.5 0 1 1 1 0V6H15v1.6a8 8 0 1 1-6 0Zm-2.6 5.3a.5.5 0 0 0 .3.6c.3 0 .6 0 .6-.3l.1-.2a5 5 0 0 1 3.3-2.8c.3-.1.4-.4.4-.6-.1-.3-.4-.5-.6-.4a6 6 0 0 0-4.1 3.7Z"/><circle cx="14" cy="4" r="1"/><circle cx="12" cy="2" r="1"/><circle cx="10" cy="4" r="1"/></g></svg>',
      "text-color": '<svg width="24" height="24"><g fill-rule="evenodd"><path class="tox-icon-text-color__color" d="M3 18h18v3H3z"/><path d="M8.7 16h-.8a.5.5 0 0 1-.5-.6l2.7-9c.1-.3.3-.4.5-.4h2.8c.2 0 .4.1.5.4l2.7 9a.5.5 0 0 1-.5.6h-.8a.5.5 0 0 1-.4-.4l-.7-2.2c0-.3-.3-.4-.5-.4h-3.4c-.2 0-.4.1-.5.4l-.7 2.2c0 .3-.2.4-.4.4Zm2.6-7.6-.6 2a.5.5 0 0 0 .5.6h1.6a.5.5 0 0 0 .5-.6l-.6-2c0-.3-.3-.4-.5-.4h-.4c-.2 0-.4.1-.5.4Z"/></g></svg>',
      "text-size-decrease": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM14 12a1 1 0 1 0 0 2h6a1 1 0 1 0 0-2h-6Z"/></svg>',
      "text-size-increase": '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M14 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H4a1 1 0 0 1 0-2h10ZM17 9a1 1 0 0 0-1 1v2h-2a1 1 0 1 0 0 2h2v2a1 1 0 1 0 2 0v-2h2a1 1 0 1 0 0-2h-2v-2c0-.6-.4-1-1-1Z"/></svg>',
      toc: '<svg width="24" height="24"><path d="M5 5c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 1 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h11c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Zm0-4c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 1 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm-3 8c.6 0 1 .4 1 1s-.4 1-1 1a1 1 0 0 1 0-2Zm3 0h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      "transform-image": '<svg height="24" width="24"><path d="M3 21v-6h2V9H3V3h6v2h6V3h6v6h-2v6h2v6h-6v-2H9v2zm6-4h6v-2h2V9h-2V7H9v2H7v6h2zM5 7h2V5H5zm12 0h2V5h-2zm0 12h2v-2h-2zM5 19h2v-2H5z"/></svg>',
      translate: '<svg width="24" height="24"><path d="m12.7 14.3-.3.7-.4.7-2.2-2.2-3.1 3c-.3.4-.8.4-1 0a.7.7 0 0 1 0-1l3.1-3A12.4 12.4 0 0 1 6.7 9H8a10.1 10.1 0 0 0 1.7 2.4c.5-.5 1-1.1 1.4-1.8l.9-2H4.7a.7.7 0 1 1 0-1.5h4.4v-.7c0-.4.3-.8.7-.8.4 0 .7.4.7.8v.7H15c.4 0 .8.3.8.7 0 .4-.4.8-.8.8h-1.4a12.3 12.3 0 0 1-1 2.4 13.5 13.5 0 0 1-1.7 2.3l1.9 1.8Zm4.3-3 2.7 7.3a.5.5 0 0 1-.4.7 1 1 0 0 1-1-.7l-.6-1.5h-3.4l-.6 1.5a1 1 0 0 1-1 .7.5.5 0 0 1-.4-.7l2.7-7.4a1 1 0 0 1 2 0Zm-2.2 4.4h2.4L16 12.5l-1.2 3.2Z" fill-rule="evenodd"/></svg>',
      typography: '<svg width="24" height="24"><path fill-rule="evenodd" clip-rule="evenodd" d="M17 5a1 1 0 1 1 0 2h-4v11a1 1 0 1 1-2 0V7H7a1 1 0 0 1 0-2h10Z"/><path d="m17.5 14 .8-1.7 1.7-.8-1.7-.8-.8-1.7-.8 1.7-1.7.8 1.7.8.8 1.7ZM7 14l1 2 2 1-2 1-1 2-1-2-2-1 2-1 1-2Z"/></svg>',
      underline: '<svg width="24" height="24"><path d="M16 5c.6 0 1 .4 1 1v5.5a4 4 0 0 1-.4 1.8l-1 1.4a5.3 5.3 0 0 1-5.5 1 5 5 0 0 1-1.6-1c-.5-.4-.8-.9-1.1-1.4a4 4 0 0 1-.4-1.8V6c0-.6.4-1 1-1s1 .4 1 1v5.5c0 .3 0 .6.2 1l.6.7a3.3 3.3 0 0 0 2.2.8 3.4 3.4 0 0 0 2.2-.8c.3-.2.4-.5.6-.8l.2-.9V6c0-.6.4-1 1-1ZM8 17h8c.6 0 1 .4 1 1s-.4 1-1 1H8a1 1 0 0 1 0-2Z" fill-rule="evenodd"/></svg>',
      undo: '<svg width="24" height="24"><path d="M6.4 8H12c3.7 0 6.2 2 6.8 5.1.6 2.7-.4 5.6-2.3 6.8a1 1 0 0 1-1-1.8c1.1-.6 1.8-2.7 1.4-4.6-.5-2.1-2.1-3.5-4.9-3.5H6.4l3.3 3.3a1 1 0 1 1-1.4 1.4l-5-5a1 1 0 0 1 0-1.4l5-5a1 1 0 0 1 1.4 1.4L6.4 8Z" fill-rule="nonzero"/></svg>',
      unlink: '<svg width="24" height="24"><path d="M6.2 12.3a1 1 0 0 1 1.4 1.4l-2 2a2 2 0 1 0 2.6 2.8l4.8-4.8a1 1 0 0 0 0-1.4 1 1 0 1 1 1.4-1.3 2.9 2.9 0 0 1 0 4L9.6 20a3.9 3.9 0 0 1-5.5-5.5l2-2Zm11.6-.6a1 1 0 0 1-1.4-1.4l2.1-2a2 2 0 1 0-2.7-2.8L11 10.3a1 1 0 0 0 0 1.4A1 1 0 1 1 9.6 13a2.9 2.9 0 0 1 0-4L14.4 4a3.9 3.9 0 0 1 5.5 5.5l-2 2ZM7.6 6.3a.8.8 0 0 1-1 1.1L3.3 4.2a.7.7 0 1 1 1-1l3.2 3.1ZM5.1 8.6a.8.8 0 0 1 0 1.5H3a.8.8 0 0 1 0-1.5H5Zm5-3.5a.8.8 0 0 1-1.5 0V3a.8.8 0 0 1 1.5 0V5Zm6 11.8a.8.8 0 0 1 1-1l3.2 3.2a.8.8 0 0 1-1 1L16 17Zm-2.2 2a.8.8 0 0 1 1.5 0V21a.8.8 0 0 1-1.5 0V19Zm5-3.5a.7.7 0 1 1 0-1.5H21a.8.8 0 0 1 0 1.5H19Z" fill-rule="nonzero"/></svg>',
      unlock: '<svg width="24" height="24"><path d="M16 5c.8 0 1.5.3 2.1.9.6.6.9 1.3.9 2.1v3h-2V8a1 1 0 0 0-.3-.7A1 1 0 0 0 16 7h-2a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v3h.3c.2 0 .3 0 .5.2l.2.6v7.4c0 .3 0 .4-.2.6l-.6.2H4.8c-.3 0-.4 0-.6-.2a.7.7 0 0 1-.2-.6v-7.4c0-.3 0-.4.2-.6l.5-.2H11V8c0-.8.3-1.5.9-2.1.6-.6 1.3-.9 2.1-.9h2Z" fill-rule="evenodd"/></svg>',
      "unordered-list": '<svg width="24" height="24"><path d="M11 5h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2Zm0 6h8c.6 0 1 .4 1 1s-.4 1-1 1h-8a1 1 0 0 1 0-2ZM4.5 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Zm0 6c0-.4.1-.8.4-1 .3-.4.7-.5 1.1-.5.4 0 .8.1 1 .4.4.3.5.7.5 1.1 0 .4-.1.8-.4 1-.3.4-.7.5-1.1.5-.4 0-.8-.1-1-.4-.4-.3-.5-.7-.5-1.1Z" fill-rule="evenodd"/></svg>',
      unselected: '<svg width="24" height="24"><path fill-rule="nonzero" d="M6 4h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6c0-1.1.9-2 2-2Zm0 1a1 1 0 0 0-1 1v12c0 .6.4 1 1 1h12c.6 0 1-.4 1-1V6c0-.6-.4-1-1-1H6Z"/></svg>',
      "upload-from-device": '<svg width="24" height="25"><path d="M11 19a1 1 0 1 0 2 0v-3.2l1.5 1a1 1 0 1 0 1-1.7L12 12.8l-3.5 2.3a1 1 0 0 0 1 1.7l1.5-1V19Z"/><path d="M9.6 4c.3 0 .6.2.8.5l1.3 2h6.7c.7 0 1.4.2 1.8.7.5.5.8 1.2.8 1.9v8.3c0 .7-.3 1.3-.8 1.8a2.6 2.6 0 0 1-1.8.8H16v-2h2.4a.6.6 0 0 0 .4-.2.6.6 0 0 0 .2-.4V9a.6.6 0 0 0-.2-.5.6.6 0 0 0-.4-.1h-7.2a1 1 0 0 1-.8-.5L9 6H5.6a.6.6 0 0 0-.4.2.6.6 0 0 0-.2.4v10.8c0 .1 0 .3.2.4a.6.6 0 0 0 .4.2H8v2H5.6a2.6 2.6 0 0 1-1.8-.8 2.7 2.7 0 0 1-.8-1.8V6.6c0-.7.3-1.3.8-1.8A2.6 2.6 0 0 1 5.6 4h4Z"/></svg>',
      "upload-from-link": '<svg height="25" width="24"><path d="M11.5 11.8a1 1 0 0 1 1.9-.5 5 5 0 0 1-1.3 4.8l-2.4 2.3A4 4 0 1 1 4 13L5 12a1 1 0 0 1 1.4 1.4l-.7.8A2 2 0 1 0 8.3 17l2.4-2.4a3 3 0 0 0 .8-2.8z"/><path d="M10.1 11.8a1 1 0 0 1-2 .5 5 5 0 0 1 1.4-4.8L12 5.1a4 4 0 0 1 5.5 5.6l-.7.8a1 1 0 0 1-1.5-1.4l.8-.8a2 2 0 1 0-2.7-2.7l-2.4 2.3a3 3 0 0 0-.8 3zm5.7 7.2a1 1 0 1 0 2 0v-3l1.4 1.1a1 1 0 0 0 1.2-1.5l-3.6-2.9-3.6 2.9a1 1 0 0 0 1.2 1.5l1.4-1z"/></svg>',
      upload: '<svg width="24" height="24"><path d="M18 19v-2a1 1 0 0 1 2 0v3c0 .6-.4 1-1 1H5a1 1 0 0 1-1-1v-3a1 1 0 0 1 2 0v2h12ZM11 6.4 8.7 8.7a1 1 0 0 1-1.4-1.4l4-4a1 1 0 0 1 1.4 0l4 4a1 1 0 1 1-1.4 1.4L13 6.4V16a1 1 0 0 1-2 0V6.4Z" fill-rule="nonzero"/></svg>',
      user: '<svg width="24" height="24"><path d="M12 24a12 12 0 1 1 0-24 12 12 0 0 1 0 24Zm-8.7-5.3a11 11 0 0 0 17.4 0C19.4 16.3 14.6 15 12 15c-2.6 0-7.4 1.3-8.7 3.7ZM12 13c2.2 0 4-2 4-4.5S14.2 4 12 4 8 6 8 8.5 9.8 13 12 13Z" fill-rule="nonzero"/></svg>',
      "vertical-align": '<svg width="24" height="24"><g fill-rule="nonzero"><rect width="18" height="2" x="3" y="11" rx="1"/><path d="M12 2c.6 0 1 .4 1 1v4l2-1.3a1 1 0 0 1 1.2 1.5l-.1.1-4.1 3-4-3a1 1 0 0 1 1-1.7l2 1.5V3c0-.6.4-1 1-1zm0 11.8 4 2.9a1 1 0 0 1-1 1.7l-2-1.5V21c0 .5-.4 1-.9 1H12a1 1 0 0 1-1-1v-4l-2 1.3a1 1 0 0 1-1.2-.1l-.1-.1a1 1 0 0 1 .1-1.3l.1-.1 4.1-3z"/></g></svg>',
      vibrance: '<svg height="24" width="24"><path d="M12 20 22 4H2zm2.6-8 1.3-2H8l1.3 2h5.2zm-1.2 2h-2.8l1.4 2.2zm5-8L17 8H7L5.6 6h12.8z" fill-rule="evenodd"/></svg>',
      visualblocks: '<svg width="24" height="24"><path d="M9 19v2H7v-2h2Zm-4 0v2a2 2 0 0 1-2-2h2Zm8 0v2h-2v-2h2Zm8 0a2 2 0 0 1-2 2v-2h2Zm-4 0v2h-2v-2h2ZM15 7a1 1 0 0 1 0 2v7a1 1 0 0 1-2 0V9h-1v7a1 1 0 0 1-2 0v-4a2.5 2.5 0 0 1-.2-5H15ZM5 15v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 11v2H3v-2h2Zm16 0v2h-2v-2h2ZM5 7v2H3V7h2Zm16 0v2h-2V7h2ZM5 3v2H3c0-1.1.9-2 2-2Zm8 0v2h-2V3h2Zm6 0a2 2 0 0 1 2 2h-2V3ZM9 3v2H7V3h2Zm8 0v2h-2V3h2Z" fill-rule="evenodd"/></svg>',
      visualchars: '<svg width="24" height="24"><path d="M10 5h7a1 1 0 0 1 0 2h-1v11a1 1 0 0 1-2 0V7h-2v11a1 1 0 0 1-2 0v-6c-.5 0-1 0-1.4-.3A3.4 3.4 0 0 1 6.8 10a3.3 3.3 0 0 1 0-2.8 3.4 3.4 0 0 1 1.8-1.8L10 5Z" fill-rule="evenodd"/></svg>',
      vk: '<svg width="24" height="24"><path fill-rule="evenodd" d="M14.8 17.4a2 2 0 0 1-1.3.7 8 8 0 0 1-7.7-3.6c-1.4-2-2.2-4.4-2.6-5.7L3 8.6A2 2 0 0 1 5 6h2.5c.4 0 .8.1 1.2.4A2 2 0 0 1 9.8 6h3.5a2 2 0 0 1 1.4.6 2 2 0 0 1 1.5-.6h2.4a2 2 0 0 1 2 2.5c-.5 1.5-1.2 2.6-1.8 3.6a12.5 12.5 0 0 1 2 3.2A2 2 0 0 1 19 18h-2.6a2 2 0 0 1-1.3-.5 6.9 6.9 0 0 1-.3-.2Zm.5-2.5-1.2-1a3 3 0 0 0-.8-.2v2.4h-1.7a5.6 5.6 0 0 1-.3 0c-3-.7-4.7-3.7-5.6-6.1A38.1 38.1 0 0 1 5 8.1V8h2.5a80.5 80.5 0 0 1 1.2 2.5c.6 1.2 1.2 2 2 2.1V9l-.9-1h3.5v4.1a5 5 0 0 0 .4-.3c.7-.7 1.2-1.4 1.6-2.2l.2-.3.7-1.3h2.4a8.5 8.5 0 0 1-.8 2l-1.3 2-.3.3a10.5 10.5 0 0 1 2.8 3.8h-2.6l-.8-.9a20.6 20.6 0 0 0-.3-.3Z" clip-rule="evenodd"/></svg>',
      warmth: '<svg height="24" width="24"><path d="M12 21.1c-1.4 0-2.6-.5-3.6-1.5s-1.5-2.1-1.5-3.5c0-.8.2-1.6.6-2.2A5 5 0 0 1 8.9 12v-6c0-.8.3-1.5 1-2.1a2.9 2.9 0 0 1 2-.9c.9 0 1.6.3 2.2.9.5.6.8 1.3.8 2.1v6a5 5 0 0 1 1.5 1.8A4.9 4.9 0 0 1 17 16c0 1.4-.5 2.6-1.4 3.5s-2.2 1.5-3.6 1.5zm-3-5h6c0-.5-.2-1-.4-1.4a3 3 0 0 0-.9-1l-.8-.6v-7a1 1 0 0 0-.3-.7A1 1 0 0 0 12 5a1 1 0 0 0-.7.3 1 1 0 0 0-.3.7v7l-.8.6a2.9 2.9 0 0 0-.9 1 3 3 0 0 0-.3 1.4z"/></svg>',
      warning: '<svg width="24" height="24"><path d="M19.8 18.3c.2.5.3.9 0 1.2-.1.3-.5.5-1 .5H5.2c-.5 0-.9-.2-1-.5-.3-.3-.2-.7 0-1.2L11 4.7l.5-.5.5-.2c.2 0 .3 0 .5.2.2 0 .3.3.5.5l6.8 13.6ZM12 18c.3 0 .5-.1.7-.3.2-.2.3-.4.3-.7a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7c0 .3.1.5.3.7.2.2.4.3.7.3Zm.7-3 .3-4a1 1 0 0 0-.3-.7 1 1 0 0 0-.7-.3 1 1 0 0 0-.7.3 1 1 0 0 0-.3.7l.3 4h1.4Z" fill-rule="evenodd"/></svg>',
      "zoom-in": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-1-9a1 1 0 0 1 2 0v6a1 1 0 0 1-2 0V8Zm-2 4a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>',
      "zoom-out": '<svg width="24" height="24"><path d="M16 17.3a8 8 0 1 1 1.4-1.4l4.3 4.4a1 1 0 0 1-1.4 1.4l-4.4-4.3Zm-5-.3a6 6 0 1 0 0-12 6 6 0 0 0 0 12Zm-3-5a1 1 0 0 1 0-2h6a1 1 0 0 1 0 2H8Z" fill-rule="nonzero"/></svg>'
    }
  })), YX;
}
var QX;
function fJ() {
  return QX || (QX = 1, mJ()), KX;
}
fJ();
var JX = {}, eQ = {}, tQ;
function gJ() {
  return tQ || (tQ = 1, function() {
    const V = Object.getPrototypeOf, me = (n, s, a) => a(n, s.prototype) ? !0 : n.constructor?.name === s.name, pt = (n) => {
      const s = typeof n;
      return n === null ? "null" : s === "object" && Array.isArray(n) ? "array" : s === "object" && me(n, String, (a, l) => l.isPrototypeOf(a)) ? "string" : s;
    }, rt = (n) => (s) => pt(s) === n, Nt = (n) => (s) => typeof s === n, mt = (n) => (s) => n === s, nn = (n, s) => et(n) && me(n, s, (a, l) => V(a) === l), De = rt("string"), et = rt("object"), Tt = (n) => nn(n, Object), $n = rt("array"), Mt = mt(null), vn = Nt("boolean"), Cn = mt(void 0), pn = (n) => n == null, un = (n) => !pn(n), Xe = Nt("function"), In = Nt("number"), lt = (n, s) => {
      if ($n(n)) {
        for (let a = 0, l = n.length; a < l; ++a)
          if (!s(n[a]))
            return !1;
        return !0;
      }
      return !1;
    }, U = () => {
    }, Ye = (n) => () => n(), On = (n, s) => (...a) => n(s.apply(null, a)), Ot = (n, s) => (a) => n(s(a)), oe = (n) => () => n, Yt = (n) => n, Gn = (n, s) => n === s;
    function jt(n, ...s) {
      return (...a) => {
        const l = s.concat(a);
        return n.apply(null, l);
      };
    }
    const X = (n) => (s) => !n(s), se = (n) => () => {
      throw new Error(n);
    }, ns = (n) => n(), an = oe(!1), St = oe(!0);
    class A {
      tag;
      value;
      // Sneaky optimisation: every instance of Optional.none is identical, so just
      // reuse the same object
      static singletonNone = new A(!1);
      // The internal representation has a `tag` and a `value`, but both are
      // private: able to be console.logged, but not able to be accessed by code
      constructor(s, a) {
        this.tag = s, this.value = a;
      }
      // --- Identities ---
      /**
       * Creates a new `Optional<T>` that **does** contain a value.
       */
      static some(s) {
        return new A(!0, s);
      }
      /**
       * Create a new `Optional<T>` that **does not** contain a value. `T` can be
       * any type because we don't actually have a `T`.
       */
      static none() {
        return A.singletonNone;
      }
      /**
       * Perform a transform on an `Optional` type. Regardless of whether this
       * `Optional` contains a value or not, `fold` will return a value of type `U`.
       * If this `Optional` does not contain a value, the `U` will be created by
       * calling `onNone`. If this `Optional` does contain a value, the `U` will be
       * created by calling `onSome`.
       *
       * For the FP enthusiasts in the room, this function:
       * 1. Could be used to implement all of the functions below
       * 2. Forms a catamorphism
       */
      fold(s, a) {
        return this.tag ? a(this.value) : s();
      }
      /**
       * Determine if this `Optional` object contains a value.
       */
      isSome() {
        return this.tag;
      }
      /**
       * Determine if this `Optional` object **does not** contain a value.
       */
      isNone() {
        return !this.tag;
      }
      // --- Functor (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value. If
       * you provide a function to turn a T into a U, this is the function you use
       * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
       * a value then the output will also contain a value (that value being the
       * output of `mapper(this.value)`), and if this **does not** contain a value
       * then neither will the output.
       */
      map(s) {
        return this.tag ? A.some(s(this.value)) : A.none();
      }
      // --- Monad (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value.
       * Unlike `map`, here the transform itself also returns an `Optional`.
       */
      bind(s) {
        return this.tag ? s(this.value) : A.none();
      }
      // --- Traversable (name stolen from Haskell / maths) ---
      /**
       * For a given predicate, this function finds out if there **exists** a value
       * inside this `Optional` object that meets the predicate. In practice, this
       * means that for `Optional`s that do not contain a value it returns false (as
       * no predicate-meeting value exists).
       */
      exists(s) {
        return this.tag && s(this.value);
      }
      /**
       * For a given predicate, this function finds out if **all** the values inside
       * this `Optional` object meet the predicate. In practice, this means that
       * for `Optional`s that do not contain a value it returns true (as all 0
       * objects do meet the predicate).
       */
      forall(s) {
        return !this.tag || s(this.value);
      }
      filter(s) {
        return !this.tag || s(this.value) ? this : A.none();
      }
      // --- Getters ---
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.
       */
      getOr(s) {
        return this.tag ? this.value : s;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.  Unlike `getOr`, in this method the `replacement` object is also
       * `Optional` - meaning that this method will always return an `Optional`.
       */
      or(s) {
        return this.tag ? this : s;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value. Unlike `getOr`, in this method the `replacement` value is
       * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
       * pass a function which (if called) will **return** the `value` you want to
       * use.
       */
      getOrThunk(s) {
        return this.tag ? this.value : s();
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided Optional object does not contain a
       * value.
       *
       * Unlike `or`, in this method the `replacement` value is "thunked" - that is
       * to say that you don't pass a value to `orThunk`, you pass a function which
       * (if called) will **return** the `value` you want to use.
       *
       * Unlike `getOrThunk`, in this method the `replacement` value is also
       * `Optional`, meaning that this method will always return an `Optional`.
       */
      orThunk(s) {
        return this.tag ? this : s();
      }
      /**
       * Get the value out of the inside of the `Optional` object, throwing an
       * exception if the provided `Optional` object does not contain a value.
       *
       * WARNING:
       * You should only be using this function if you know that the `Optional`
       * object **is not** empty (otherwise you're throwing exceptions in production
       * code, which is bad).
       *
       * In tests this is more acceptable.
       *
       * Prefer other methods to this, such as `.each`.
       */
      getOrDie(s) {
        if (this.tag)
          return this.value;
        throw new Error(s ?? "Called getOrDie on None");
      }
      // --- Interop with null and undefined ---
      /**
       * Creates an `Optional` value from a nullable (or undefined-able) input.
       * Null, or undefined, is converted to `None`, and anything else is converted
       * to `Some`.
       */
      static from(s) {
        return un(s) ? A.some(s) : A.none();
      }
      /**
       * Converts an `Optional` to a nullable type, by getting the value if it
       * exists, or returning `null` if it does not.
       */
      getOrNull() {
        return this.tag ? this.value : null;
      }
      /**
       * Converts an `Optional` to an undefined-able type, by getting the value if
       * it exists, or returning `undefined` if it does not.
       */
      getOrUndefined() {
        return this.value;
      }
      // --- Utilities ---
      /**
       * If the `Optional` contains a value, perform an action on that value.
       * Unlike the rest of the methods on this type, `.each` has side-effects. If
       * you want to transform an `Optional<T>` **into** something, then this is not
       * the method for you. If you want to use an `Optional<T>` to **do**
       * something, then this is the method for you - provided you're okay with not
       * doing anything in the case where the `Optional` doesn't have a value inside
       * it. If you're not sure whether your use-case fits into transforming
       * **into** something or **doing** something, check whether it has a return
       * value. If it does, you should be performing a transform.
       */
      each(s) {
        this.tag && s(this.value);
      }
      /**
       * Turn the `Optional` object into an array that contains all of the values
       * stored inside the `Optional`. In practice, this means the output will have
       * either 0 or 1 elements.
       */
      toArray() {
        return this.tag ? [this.value] : [];
      }
      /**
       * Turn the `Optional` object into a string for debugging or printing. Not
       * recommended for production code, but good for debugging. Also note that
       * these days an `Optional` object can be logged to the console directly, and
       * its inner value (if it exists) will be visible.
       */
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    const No = Array.prototype.slice, ot = Array.prototype.indexOf, jo = Array.prototype.push, he = (n, s) => ot.call(n, s), ue = (n, s) => {
      const a = he(n, s);
      return a === -1 ? A.none() : A.some(a);
    }, bt = (n, s) => he(n, s) > -1, cn = (n, s) => {
      for (let a = 0, l = n.length; a < l; a++) {
        const d = n[a];
        if (s(d, a))
          return !0;
      }
      return !1;
    }, fn = (n, s) => {
      const a = [];
      for (let l = 0; l < n; l++)
        a.push(s(l));
      return a;
    }, Fn = (n, s) => {
      const a = [];
      for (let l = 0; l < n.length; l += s) {
        const d = No.call(n, l, l + s);
        a.push(d);
      }
      return a;
    }, ye = (n, s) => {
      const a = n.length, l = new Array(a);
      for (let d = 0; d < a; d++) {
        const g = n[d];
        l[d] = s(g, d);
      }
      return l;
    }, He = (n, s) => {
      for (let a = 0, l = n.length; a < l; a++) {
        const d = n[a];
        s(d, a);
      }
    }, P = (n, s) => {
      for (let a = n.length - 1; a >= 0; a--) {
        const l = n[a];
        s(l, a);
      }
    }, ro = (n, s) => {
      const a = [], l = [];
      for (let d = 0, g = n.length; d < g; d++) {
        const h = n[d];
        (s(h, d) ? a : l).push(h);
      }
      return { pass: a, fail: l };
    }, Ln = (n, s) => {
      const a = [];
      for (let l = 0, d = n.length; l < d; l++) {
        const g = n[l];
        s(g, l) && a.push(g);
      }
      return a;
    }, oo = (n, s, a) => (P(n, (l, d) => {
      a = s(a, l, d);
    }), a), ao = (n, s, a) => (He(n, (l, d) => {
      a = s(a, l, d);
    }), a), ur = (n, s, a) => {
      for (let l = 0, d = n.length; l < d; l++) {
        const g = n[l];
        if (s(g, l))
          return A.some(g);
        if (a(g, l))
          break;
      }
      return A.none();
    }, Lt = (n, s) => ur(n, s, an), po = (n, s) => {
      for (let a = 0, l = n.length; a < l; a++) {
        const d = n[a];
        if (s(d, a))
          return A.some(a);
      }
      return A.none();
    }, en = (n) => {
      const s = [];
      for (let a = 0, l = n.length; a < l; ++a) {
        if (!$n(n[a]))
          throw new Error("Arr.flatten item " + a + " was not an array, input: " + n);
        jo.apply(s, n[a]);
      }
      return s;
    }, xe = (n, s) => en(ye(n, s)), We = (n, s) => {
      for (let a = 0, l = n.length; a < l; ++a) {
        const d = n[a];
        if (s(d, a) !== !0)
          return !1;
      }
      return !0;
    }, st = (n) => {
      const s = No.call(n, 0);
      return s.reverse(), s;
    }, ze = (n, s) => Ln(n, (a) => !bt(s, a)), no = (n, s) => {
      const a = {};
      for (let l = 0, d = n.length; l < d; l++) {
        const g = n[l];
        a[String(g)] = s(g, l);
      }
      return a;
    }, qn = (n) => [n], Io = (n, s) => {
      const a = No.call(n, 0);
      return a.sort(s), a;
    }, Jc = (n, s) => s >= 0 && s < n.length ? A.some(n[s]) : A.none(), _o = (n) => Jc(n, 0), Ql = (n) => Jc(n, n.length - 1), jm = Xe(Array.from) ? Array.from : (n) => No.call(n), ga = (n, s) => {
      for (let a = 0; a < n.length; a++) {
        const l = s(n[a], a);
        if (l.isSome())
          return l;
      }
      return A.none();
    }, xo = Object.keys, qa = Object.hasOwnProperty, ds = (n, s) => {
      const a = xo(n);
      for (let l = 0, d = a.length; l < d; l++) {
        const g = a[l], h = n[g];
        s(h, g);
      }
    }, Bs = (n, s) => vu(n, (a, l) => ({
      k: l,
      v: s(a, l)
    })), vu = (n, s) => {
      const a = {};
      return ds(n, (l, d) => {
        const g = s(l, d);
        a[g.k] = g.v;
      }), a;
    }, Tl = (n) => (s, a) => {
      n[a] = s;
    }, Gr = (n, s, a, l) => {
      ds(n, (d, g) => {
        (s(d, g) ? a : l)(d, g);
      });
    }, js = (n, s) => {
      const a = {}, l = {};
      return Gr(n, s, Tl(a), Tl(l)), { t: a, f: l };
    }, dr = (n, s) => {
      const a = {};
      return Gr(n, s, Tl(a), U), a;
    }, rs = (n, s) => {
      const a = [];
      return ds(n, (l, d) => {
        a.push(s(l, d));
      }), a;
    }, cc = (n, s) => {
      const a = xo(n);
      for (let l = 0, d = a.length; l < d; l++) {
        const g = a[l], h = n[g];
        if (s(h, g, n))
          return A.some(h);
      }
      return A.none();
    }, Ka = (n) => rs(n, Yt), Vt = (n, s) => mo(n, s) ? A.from(n[s]) : A.none(), mo = (n, s) => qa.call(n, s), Un = (n, s) => mo(n, s) && n[s] !== void 0 && n[s] !== null, Ma = {
      generate: (n) => {
        if (!$n(n))
          throw new Error("cases must be an array");
        if (n.length === 0)
          throw new Error("there must be at least one case");
        const s = [], a = {};
        return He(n, (l, d) => {
          const g = xo(l);
          if (g.length !== 1)
            throw new Error("one and only one name per case");
          const h = g[0], C = l[h];
          if (a[h] !== void 0)
            throw new Error("duplicate key detected:" + h);
          if (h === "cata")
            throw new Error("cannot have a case named cata (sorry)");
          if (!$n(C))
            throw new Error("case arguments must be an array");
          s.push(h), a[h] = (...x) => {
            const T = x.length;
            if (T !== C.length)
              throw new Error("Wrong number of arguments to case " + h + ". Expected " + C.length + " (" + C + "), got " + T);
            return {
              fold: (...N) => {
                if (N.length !== n.length)
                  throw new Error("Wrong number of arguments to fold. Expected " + n.length + ", got " + N.length);
                return N[d].apply(null, x);
              },
              match: (N) => {
                const L = xo(N);
                if (s.length !== L.length)
                  throw new Error("Wrong number of arguments to match. Expected: " + s.join(",") + `
Actual: ` + L.join(","));
                if (!We(s, (Z) => bt(L, Z)))
                  throw new Error("Not all branches were specified when using match. Specified: " + L.join(", ") + `
Required: ` + s.join(", "));
                return N[h].apply(null, x);
              },
              // NOTE: Only for debugging.
              log: (N) => {
                console.log(N, {
                  constructors: s,
                  constructor: h,
                  params: x
                });
              }
            };
          };
        }), a;
      }
    }, Pt = (n) => {
      let s = n;
      return {
        get: () => s,
        set: (d) => {
          s = d;
        }
      };
    }, Di = (n) => {
      let s = A.none(), a = [];
      const l = (T) => Di((_) => {
        d((N) => {
          _(T(N));
        });
      }), d = (T) => {
        h() ? x(T) : a.push(T);
      }, g = (T) => {
        h() || (s = A.some(T), C(a), a = []);
      }, h = () => s.isSome(), C = (T) => {
        He(T, x);
      }, x = (T) => {
        s.each((_) => {
          setTimeout(() => {
            T(_);
          }, 0);
        });
      };
      return n(g), {
        get: d,
        map: l,
        isReady: h
      };
    }, Ri = {
      nu: Di,
      pure: (n) => Di((s) => {
        s(n);
      })
    }, ic = (n) => {
      setTimeout(() => {
        throw n;
      }, 0);
    }, Pa = (n) => {
      const s = (x) => {
        n().then(x, ic);
      };
      return {
        map: (x) => Pa(() => n().then(x)),
        bind: (x) => Pa(() => n().then((T) => x(T).toPromise())),
        anonBind: (x) => Pa(() => n().then(() => x.toPromise())),
        toLazy: () => Ri.nu(s),
        toCached: () => {
          let x = null;
          return Pa(() => (x === null && (x = n()), x));
        },
        toPromise: n,
        get: s
      };
    }, Zo = {
      nu: (n) => Pa(() => new Promise(n)),
      pure: (n) => Pa(() => Promise.resolve(n))
    }, rd = (n) => {
      const s = (g) => g(n), a = oe(n), l = () => d, d = {
        // Debug info
        tag: !0,
        inner: n,
        // Actual Result methods
        fold: (g, h) => h(n),
        isValue: St,
        isError: an,
        map: (g) => Wt.value(g(n)),
        mapError: l,
        bind: s,
        exists: s,
        forall: s,
        getOr: a,
        or: l,
        getOrThunk: a,
        orThunk: l,
        getOrDie: a,
        each: (g) => {
          g(n);
        },
        toOptional: () => A.some(n)
      };
      return d;
    }, yu = (n) => {
      const s = () => a, a = {
        // Debug info
        tag: !1,
        inner: n,
        // Actual Result methods
        fold: (l, d) => l(n),
        isValue: an,
        isError: St,
        map: s,
        mapError: (l) => Wt.error(l(n)),
        bind: s,
        exists: an,
        forall: St,
        getOr: Yt,
        or: Yt,
        getOrThunk: ns,
        orThunk: ns,
        getOrDie: se(String(n)),
        each: U,
        toOptional: A.none
      };
      return a;
    }, Wt = {
      value: rd,
      error: yu,
      fromOption: (n, s) => n.fold(() => yu(s), rd)
    }, Ba = (n) => ({
      ...n,
      toCached: () => Ba(n.toCached()),
      bindFuture: (x) => Ba(n.bind((T) => T.fold((_) => Zo.pure(Wt.error(_)), (_) => x(_)))),
      bindResult: (x) => Ba(n.map((T) => T.bind(x))),
      mapResult: (x) => Ba(n.map((T) => T.map(x))),
      mapError: (x) => Ba(n.map((T) => T.mapError(x))),
      foldResult: (x, T) => n.map((_) => _.fold(x, T)),
      withTimeout: (x, T) => Ba(Zo.nu((_) => {
        let N = !1;
        const L = setTimeout(() => {
          N = !0, _(Wt.error(T()));
        }, x);
        n.get((j) => {
          N || (clearTimeout(L), _(j));
        });
      }))
    }), Or = (n) => Ba(Zo.nu(n)), Wm = (n) => Ba(Zo.pure(Wt.value(n))), ad = {
      nu: Or,
      wrap: Ba,
      pure: Wm,
      value: Wm,
      error: (n) => Ba(Zo.pure(Wt.error(n))),
      fromResult: (n) => Ba(Zo.pure(n)),
      fromFuture: (n) => Ba(n.map(Wt.value)),
      fromPromise: (n) => Or((s) => {
        n.then((a) => {
          s(Wt.value(a));
        }, (a) => {
          s(Wt.error(a));
        });
      })
    }, Jl = typeof window < "u" ? window : Function("return this;")(), Nc = (n, s, a, l) => {
      const d = n + s;
      return d > l ? a : d < a ? l : d;
    }, nr = (n, s, a) => Math.min(Math.max(n, s), a), Mi = () => window.crypto.getRandomValues(new Uint32Array(1))[0] / 4294967295;
    let Cu = 0;
    const Ct = (n) => {
      const a = (/* @__PURE__ */ new Date()).getTime(), l = Math.floor(Mi() * 1e9);
      return Cu++, n + "_" + l + Cu + String(a);
    }, Ya = (n, s) => s, xu = (n, s) => Tt(n) && Tt(s) ? Ho(n, s) : s, kl = (n) => (...s) => {
      if (s.length === 0)
        throw new Error("Can't merge zero objects");
      const a = {};
      for (let l = 0; l < s.length; l++) {
        const d = s[l];
        for (const g in d)
          mo(d, g) && (a[g] = n(a[g], d[g]));
      }
      return a;
    }, Ho = kl(xu), cd = kl(Ya), uc = (n, s, a = Gn) => n.exists((l) => a(l, s)), Xs = (n, s, a = Gn) => $a(n, s, a).getOr(n.isNone() && s.isNone()), Al = (n) => {
      const s = [], a = (l) => {
        s.push(l);
      };
      for (let l = 0; l < n.length; l++)
        n[l].each(a);
      return s;
    }, ld = (n) => {
      const s = [];
      for (let a = 0; a < n.length; a++) {
        const l = n[a];
        if (l.isSome())
          s.push(l.getOrDie());
        else
          return A.none();
      }
      return A.some(s);
    }, $a = (n, s, a) => n.isSome() && s.isSome() ? A.some(a(n.getOrDie(), s.getOrDie())) : A.none(), Pr = (n, s, a, l) => n.isSome() && s.isSome() && a.isSome() ? A.some(l(n.getOrDie(), s.getOrDie(), a.getOrDie())) : A.none(), tl = (n, s) => n != null ? A.some(s(n)) : A.none(), Br = (n, s) => n ? A.some(s) : A.none(), mh = (n) => n.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"), Jd = (n, s) => {
      let a = s ?? Jl;
      for (let l = 0; l < n.length && a !== void 0 && a !== null; ++l)
        a = a[n[l]];
      return a;
    }, Mc = (n, s) => {
      const a = n.split(".");
      return Jd(a, s);
    };
    Ma.generate([
      { bothErrors: ["error1", "error2"] },
      { firstError: ["error1", "value2"] },
      { secondError: ["value1", "error2"] },
      { bothValues: ["value1", "value2"] }
    ]);
    const _l = (n) => {
      const s = [], a = [];
      return He(n, (l) => {
        l.fold((d) => {
          s.push(d);
        }, (d) => {
          a.push(d);
        });
      }), { errors: s, values: a };
    }, ei = (n) => {
      const s = Pt(A.none()), a = () => s.get().each(n);
      return {
        clear: () => {
          a(), s.set(A.none());
        },
        isSet: () => s.get().isSome(),
        get: () => s.get(),
        set: (C) => {
          a(), s.set(A.some(C));
        }
      };
    }, Zm = () => ei((n) => n.destroy()), As = () => ei((n) => n.unbind()), hn = () => {
      const n = ei(U);
      return {
        ...n,
        on: (a) => n.get().each(a)
      };
    }, qr = (n, s) => n + s, Kr = (n, s) => n.substring(s), _s = (n, s, a) => s === "" || n.length >= s.length && n.substr(a, a + s.length) === s, em = (n, s) => ti(n, s) ? Kr(n, s.length) : n, Pi = (n, s) => nl(n, s) ? n : qr(n, s), ms = (n, s, a = 0, l) => {
      const d = n.indexOf(s, a);
      return d !== -1 ? Cn(l) ? !0 : d + s.length <= l : !1;
    }, ti = (n, s) => _s(n, s, 0), nl = (n, s) => _s(n, s, n.length - s.length), vt = ((n) => (s) => s.replace(n, ""))(/^\s+|\s+$/g), ni = (n) => n.length > 0, ha = (n) => !ni(n), Pc = (n) => {
      const s = parseFloat(n);
      return isNaN(s) ? A.none() : A.some(s);
    }, $s = (n, s) => {
      let a = null, l = null;
      return {
        cancel: () => {
          Mt(a) || (clearTimeout(a), a = null, l = null);
        },
        throttle: (...h) => {
          l = h, Mt(a) && (a = setTimeout(() => {
            const C = l;
            a = null, l = null, n.apply(null, C);
          }, s));
        }
      };
    }, eg = (n, s) => {
      let a = null;
      return {
        cancel: () => {
          Mt(a) || (clearTimeout(a), a = null);
        },
        throttle: (...g) => {
          Mt(a) && (a = setTimeout(() => {
            a = null, n.apply(null, g);
          }, s));
        }
      };
    }, Xa = (n, s) => {
      let a = null;
      const l = () => {
        Mt(a) || (clearTimeout(a), a = null);
      };
      return {
        cancel: l,
        throttle: (...g) => {
          l(), a = setTimeout(() => {
            a = null, n.apply(null, g);
          }, s);
        }
      };
    }, Bc = (n) => {
      let s = !1, a;
      return (...l) => (s || (s = !0, a = n.apply(null, l)), a);
    }, Gm = "\uFEFF", tg = " ", oi = (n, s) => {
      const l = (s || document).createElement("div");
      if (l.innerHTML = n, !l.hasChildNodes() || l.childNodes.length > 1) {
        const d = "HTML does not have a single root node";
        throw console.error(d, n), new Error(d);
      }
      return si(l.childNodes[0]);
    }, ng = (n, s) => {
      const l = (s || document).createElement(n);
      return si(l);
    }, Su = (n, s) => {
      const l = (s || document).createTextNode(n);
      return si(l);
    }, si = (n) => {
      if (n == null)
        throw new Error("Node cannot be null or undefined");
      return {
        dom: n
      };
    }, at = {
      fromHtml: oi,
      fromTag: ng,
      fromText: Su,
      fromDom: si,
      fromPoint: (n, s, a) => A.from(n.dom.elementFromPoint(s, a)).map(si)
    }, Bi = (n, s) => {
      s.fold((a) => {
        n.setStartBefore(a.dom);
      }, (a, l) => {
        n.setStart(a.dom, l);
      }, (a) => {
        n.setStartAfter(a.dom);
      });
    }, tm = (n, s) => {
      s.fold((a) => {
        n.setEndBefore(a.dom);
      }, (a, l) => {
        n.setEnd(a.dom, l);
      }, (a) => {
        n.setEndAfter(a.dom);
      });
    }, ol = (n, s, a) => {
      const l = n.document.createRange();
      return Bi(l, s), tm(l, a), l;
    }, dc = (n, s, a, l, d) => {
      const g = n.document.createRange();
      return g.setStart(s.dom, a), g.setEnd(l.dom, d), g;
    }, id = (n) => ({
      left: n.left,
      top: n.top,
      right: n.right,
      bottom: n.bottom,
      width: n.width,
      height: n.height
    }), pa = (n) => {
      const s = n.getClientRects(), a = s.length > 0 ? s[0] : n.getBoundingClientRect();
      return a.width > 0 || a.height > 0 ? A.some(a).map(id) : A.none();
    }, Ol = (n) => {
      const s = n.getBoundingClientRect();
      return s.width > 0 || s.height > 0 ? A.some(s).map(id) : A.none();
    }, $i = Ma.generate([
      { ltr: ["start", "soffset", "finish", "foffset"] },
      { rtl: ["start", "soffset", "finish", "foffset"] }
    ]), ri = (n, s, a) => s(at.fromDom(a.startContainer), a.startOffset, at.fromDom(a.endContainer), a.endOffset), zo = (n, s) => s.match({
      domRange: (a) => ({
        ltr: oe(a),
        rtl: A.none
      }),
      relative: (a, l) => ({
        ltr: Bc(() => ol(n, a, l)),
        rtl: Bc(() => A.some(ol(n, l, a)))
      }),
      exact: (a, l, d, g) => ({
        ltr: Bc(() => dc(n, a, l, d, g)),
        rtl: Bc(() => A.some(dc(n, d, g, a, l)))
      })
    }), ud = (n, s) => {
      const a = s.ltr();
      return a.collapsed ? s.rtl().filter((d) => d.collapsed === !1).map((d) => (
        // We need to use "reversed" here, because the original only has one point (collapsed)
        $i.rtl(at.fromDom(d.endContainer), d.endOffset, at.fromDom(d.startContainer), d.startOffset)
      )).getOrThunk(() => ri(n, $i.ltr, a)) : ri(n, $i.ltr, a);
    }, B = (n, s) => {
      const a = zo(n, s);
      return ud(n, a);
    }, G = (n, s) => B(n, s).match({
      ltr: (l, d, g, h) => {
        const C = n.document.createRange();
        return C.setStart(l.dom, d), C.setEnd(g.dom, h), C;
      },
      rtl: (l, d, g, h) => {
        const C = n.document.createRange();
        return C.setStart(g.dom, h), C.setEnd(l.dom, d), C;
      }
    });
    $i.ltr, $i.rtl;
    const re = 9, Pe = 11, Ht = 1, Jn = 3, Vo = (n, s) => {
      const a = n.dom;
      if (a.nodeType !== Ht)
        return !1;
      {
        const l = a;
        if (l.matches !== void 0)
          return l.matches(s);
        if (l.msMatchesSelector !== void 0)
          return l.msMatchesSelector(s);
        if (l.webkitMatchesSelector !== void 0)
          return l.webkitMatchesSelector(s);
        if (l.mozMatchesSelector !== void 0)
          return l.mozMatchesSelector(s);
        throw new Error("Browser lacks native selectors");
      }
    }, Sr = (n) => (
      // Only elements, documents and shadow roots support querySelector
      // shadow root element type is DOCUMENT_FRAGMENT
      n.nodeType !== Ht && n.nodeType !== re && n.nodeType !== Pe || // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
      n.childElementCount === 0
    ), Yr = (n, s) => {
      const a = s === void 0 ? document : s.dom;
      return Sr(a) ? [] : ye(a.querySelectorAll(n), at.fromDom);
    }, Qa = (n, s) => {
      const a = s === void 0 ? document : s.dom;
      return Sr(a) ? A.none() : A.from(a.querySelector(n)).map(at.fromDom);
    }, I = (n, s) => n.dom === s.dom, ee = (n, s) => {
      const a = n.dom, l = s.dom;
      return a === l ? !1 : a.contains(l);
    }, fe = (n, s, a, l) => {
      const d = n.isiOS() && /ipad/i.test(a) === !0, g = n.isiOS() && !d, h = n.isiOS() || n.isAndroid(), C = h || l("(pointer:coarse)"), x = d || !g && h && l("(min-device-width:768px)"), T = g || h && !x, _ = s.isSafari() && n.isiOS() && /safari/i.test(a) === !1, N = !T && !x && !_;
      return {
        isiPad: oe(d),
        isiPhone: oe(g),
        isTablet: oe(x),
        isPhone: oe(T),
        isTouch: oe(C),
        isAndroid: n.isAndroid,
        isiOS: n.isiOS,
        isWebView: oe(_),
        isDesktop: oe(N)
      };
    }, _e = (n, s) => {
      for (let a = 0; a < n.length; a++) {
        const l = n[a];
        if (l.test(s))
          return l;
      }
    }, it = (n, s) => {
      const a = _e(n, s);
      if (!a)
        return { major: 0, minor: 0 };
      const l = (d) => Number(s.replace(a, "$" + d));
      return wo(l(1), l(2));
    }, It = (n, s) => {
      const a = String(s).toLowerCase();
      return n.length === 0 ? Mn() : it(n, a);
    }, Mn = () => wo(0, 0), wo = (n, s) => ({ major: n, minor: s }), co = {
      nu: wo,
      detect: It,
      unknown: Mn
    }, ba = (n, s) => ga(s.brands, (a) => {
      const l = a.brand.toLowerCase();
      return Lt(n, (d) => l === d.brand?.toLowerCase()).map((d) => ({
        current: d.name,
        version: co.nu(parseInt(a.version, 10), 0)
      }));
    }), Ws = (n, s) => {
      const a = String(s).toLowerCase();
      return Lt(n, (l) => l.search(a));
    }, Eu = (n, s) => Ws(n, s).map((a) => {
      const l = co.detect(a.versionRegexes, s);
      return {
        current: a.name,
        version: l
      };
    }), qm = (n, s) => Ws(n, s).map((a) => {
      const l = co.detect(a.versionRegexes, s);
      return {
        current: a.name,
        version: l
      };
    }), nm = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, Dl = (n) => (s) => ms(s, n), Yb = [
      // This is legacy Edge
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (n) => ms(n, "edge/") && ms(n, "chrome") && ms(n, "safari") && ms(n, "applewebkit")
      },
      // This is Google Chrome and Chromium Edge
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, nm],
        search: (n) => ms(n, "chrome") && !ms(n, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: (n) => ms(n, "msie") || ms(n, "trident")
      },
      // INVESTIGATE: Is this still the Opera user agent?
      {
        name: "Opera",
        versionRegexes: [nm, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search: Dl("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: Dl("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [nm, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search: (n) => (ms(n, "safari") || ms(n, "mobile/")) && ms(n, "applewebkit")
      }
    ], Xb = [
      {
        name: "Windows",
        search: Dl("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (n) => ms(n, "iphone") || ms(n, "ipad"),
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Android",
        search: Dl("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: Dl("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: Dl("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: Dl("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: Dl("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: Dl("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], Fp = {
      browsers: oe(Yb),
      oses: oe(Xb)
    }, Rl = "Edge", Qb = "Chromium", Jb = "IE", jy = "Opera", Ii = "Firefox", Wy = "Safari", Zy = () => Lp({
      current: void 0,
      version: co.unknown()
    }), Lp = (n) => {
      const s = n.current, a = n.version, l = (d) => () => s === d;
      return {
        current: s,
        version: a,
        isEdge: l(Rl),
        isChromium: l(Qb),
        // NOTE: isIe just looks too weird
        isIE: l(Jb),
        isOpera: l(jy),
        isFirefox: l(Ii),
        isSafari: l(Wy)
      };
    }, Hp = {
      unknown: Zy,
      nu: Lp
    }, NS = "Windows", Gy = "iOS", zp = "Android", Fi = "Linux", sl = "macOS", om = "Solaris", qy = "FreeBSD", fo = "ChromeOS", Ky = () => fh({
      current: void 0,
      version: co.unknown()
    }), fh = (n) => {
      const s = n.current, a = n.version, l = (d) => () => s === d;
      return {
        current: s,
        version: a,
        isWindows: l(NS),
        // TODO: Fix capitalisation
        isiOS: l(Gy),
        isAndroid: l(zp),
        isMacOS: l(sl),
        isLinux: l(Fi),
        isSolaris: l(om),
        isFreeBSD: l(qy),
        isChromeOS: l(fo)
      };
    }, Qs = {
      unknown: Ky,
      nu: fh
    }, Vp = {
      detect: (n, s, a) => {
        const l = Fp.browsers(), d = Fp.oses(), g = s.bind((x) => ba(l, x)).orThunk(() => Eu(l, n)).fold(Hp.unknown, Hp.nu), h = qm(d, n).fold(Qs.unknown, Qs.nu), C = fe(h, g, n, a);
        return {
          browser: g,
          os: h,
          deviceType: C
        };
      }
    }, PS = (n) => window.matchMedia(n).matches;
    let e0 = Bc(() => Vp.detect(window.navigator.userAgent, A.from(window.navigator.userAgentData), PS));
    const Zs = () => e0(), sm = (n, s) => Mc(n, s), Yy = (n, s) => {
      const a = sm(n, s);
      if (a == null)
        throw new Error(n + " not available on this browser");
      return a;
    }, Je = Object.getPrototypeOf, $c = (n) => Yy("HTMLElement", n), og = (n) => {
      const s = Mc("ownerDocument.defaultView", n);
      return et(n) && ($c(s).prototype.isPrototypeOf(n) || /^HTML\w*Element$/.test(Je(n).constructor.name));
    }, Nl = (n) => n.dom.nodeName.toLowerCase(), Km = (n) => n.dom.nodeType, Up = (n) => (s) => Km(s) === n, te = (n) => mc(n) && og(n.dom), mc = Up(Ht), dd = Up(Jn), jp = Up(re), Ym = Up(Pe), va = (n) => (s) => mc(s) && Nl(s) === n, fc = (n) => at.fromDom(n.dom.ownerDocument), Wp = (n) => jp(n) ? n : fc(n), Zp = (n) => at.fromDom(Wp(n).dom.documentElement), sg = (n) => at.fromDom(Wp(n).dom.defaultView), gc = (n) => A.from(n.dom.parentNode).map(at.fromDom), Gp = (n) => gc(n), Li = (n) => A.from(n.dom.parentElement).map(at.fromDom), rg = (n, s) => {
      const a = Xe(s) ? s : an;
      let l = n.dom;
      const d = [];
      for (; l.parentNode !== null && l.parentNode !== void 0; ) {
        const g = l.parentNode, h = at.fromDom(g);
        if (d.push(h), a(h) === !0)
          break;
        l = g;
      }
      return d;
    }, qp = (n) => A.from(n.dom.offsetParent).map(at.fromDom), Ic = (n) => A.from(n.dom.previousSibling).map(at.fromDom), Kp = (n) => A.from(n.dom.nextSibling).map(at.fromDom), ai = (n) => ye(n.dom.childNodes, at.fromDom), md = (n, s) => {
      const a = n.dom.childNodes;
      return A.from(a[s]).map(at.fromDom);
    }, Qn = (n) => md(n, 0), Ja = (n, s) => ({
      element: n,
      offset: s
    }), Xm = (n, s) => {
      const a = ai(n);
      return a.length > 0 && s < a.length ? Ja(a[s], 0) : Ja(n, s);
    }, t0 = (n, s, a, l) => {
      const g = fc(n).dom.createRange();
      return g.setStart(n.dom, s), g.setEnd(a.dom, l), g;
    }, Hn = (n, s, a, l) => {
      const d = t0(n, s, a, l), g = I(n, a) && s === l;
      return d.collapsed && !g;
    }, Tu = (n) => Ym(n) && un(n.dom.host), mr = (n) => at.fromDom(n.dom.getRootNode()), ci = (n) => (
      // Can't use SugarBody.body without causing a circular module reference (since SugarBody.inBody uses SugarShadowDom)
      Tu(n) ? n : at.fromDom(Wp(n).dom.body)
    ), li = (n) => Is(n).isSome(), Is = (n) => {
      const s = mr(n);
      return Tu(s) ? A.some(s) : A.none();
    }, Eo = (n) => at.fromDom(n.dom.host), Xy = (n) => {
      if (un(n.target)) {
        const s = at.fromDom(n.target);
        if (mc(s) && Qy(s) && n.composed && n.composedPath) {
          const a = n.composedPath();
          if (a)
            return _o(a);
        }
      }
      return A.from(n.target);
    }, Qy = (n) => un(n.dom.shadowRoot), fr = (n, s, a, l, d, g, h) => ({
      target: n,
      x: s,
      y: a,
      stop: l,
      prevent: d,
      kill: g,
      raw: h
    }), Ml = (n) => {
      const s = at.fromDom(Xy(n).getOr(n.target)), a = () => n.stopPropagation(), l = () => n.preventDefault(), d = On(l, a);
      return fr(s, n.clientX, n.clientY, a, l, d, n);
    }, Pl = (n, s) => (a) => {
      n(a) && s(Ml(a));
    }, gr = (n, s, a, l, d) => {
      const g = Pl(a, l);
      return n.dom.addEventListener(s, g, d), {
        unbind: jt(Fc, n, s, g, d)
      };
    }, ii = (n, s, a, l) => gr(n, s, a, l, !1), ec = (n, s, a, l) => gr(n, s, a, l, !0), Fc = (n, s, a, l) => {
      n.dom.removeEventListener(s, a, l);
    }, ya = St, Oo = (n, s, a) => ii(n, s, ya, a), rl = (n, s, a) => ec(n, s, ya, a), tc = Ml, Xr = () => at.fromDom(document), $r = (n, s = !1) => n.dom.focus({ preventScroll: s }), Os = (n) => n.dom.blur(), Bl = (n) => {
      const s = mr(n).dom;
      return n.dom === s.activeElement;
    }, Ir = (n = Xr()) => A.from(n.dom.activeElement).map(at.fromDom), or = (n) => Ir(mr(n)).filter((s) => n.dom.contains(s.dom)), fd = (n, s) => {
      gc(n).each((l) => {
        l.dom.insertBefore(s.dom, n.dom);
      });
    }, Yp = (n, s) => {
      Kp(n).fold(() => {
        gc(n).each((d) => {
          Fr(d, s);
        });
      }, (l) => {
        fd(l, s);
      });
    }, gh = (n, s) => {
      Qn(n).fold(() => {
        Fr(n, s);
      }, (l) => {
        n.dom.insertBefore(s.dom, l.dom);
      });
    }, Fr = (n, s) => {
      n.dom.appendChild(s.dom);
    }, Xp = (n, s, a) => {
      md(n, a).fold(() => {
        Fr(n, s);
      }, (l) => {
        fd(l, s);
      });
    }, n0 = (n, s) => {
      He(s, (a) => {
        Fr(n, a);
      });
    }, rm = (n, s, a) => {
      if (De(a) || vn(a) || In(a))
        n.setAttribute(s, a + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", s, ":: Value ", a, ":: Element ", n), new Error("Attribute value was not simple");
    }, ln = (n, s, a) => {
      rm(n.dom, s, a);
    }, Qp = (n, s) => {
      const a = n.dom;
      ds(s, (l, d) => {
        rm(a, d, l);
      });
    }, Dr = (n, s) => {
      const a = n.dom.getAttribute(s);
      return a === null ? void 0 : a;
    }, Qr = (n, s) => A.from(Dr(n, s)), Jr = (n, s) => {
      const a = n.dom;
      return a && a.hasAttribute ? a.hasAttribute(s) : !1;
    }, fs = (n, s) => {
      n.dom.removeAttribute(s);
    }, gd = (n) => ao(n.dom.attributes, (s, a) => (s[a.name] = a.value, s), {}), hh = (n) => {
      n.dom.textContent = "", He(ai(n), (s) => {
        al(s);
      });
    }, al = (n) => {
      const s = n.dom;
      s.parentNode !== null && s.parentNode.removeChild(s);
    }, ui = (n, s) => at.fromDom(n.dom.cloneNode(s)), ag = (n) => ui(n, !1), ph = (n) => ui(n, !0), cg = (n, s) => {
      const l = (s || document).createElement("div");
      return l.innerHTML = n, ai(at.fromDom(l));
    }, Hi = (n) => n.dom.innerHTML, $l = (n, s) => {
      const l = fc(n).dom, d = at.fromDom(l.createDocumentFragment()), g = cg(s, l);
      n0(d, g), hh(n), Fr(n, d);
    }, Jp = (n) => {
      const s = at.fromTag("div"), a = at.fromDom(n.dom.cloneNode(!0));
      return Fr(s, a), Hi(s);
    }, ca = (n) => {
      if (Tu(n))
        return "#shadow-root";
      {
        const s = ag(n);
        return Jp(s);
      }
    }, cl = (n) => new Promise((s, a) => {
      const l = () => {
        g(), s(n);
      }, d = [
        Oo(n, "load", l),
        Oo(n, "error", () => {
          g(), a("Unable to load data from image: " + n.dom.src);
        })
      ], g = () => He(d, (h) => h.unbind());
      n.dom.complete && l();
    }), zi = (n) => n.style !== void 0 && Xe(n.style.getPropertyValue), bo = (n) => {
      const s = dd(n) ? n.dom.parentNode : n.dom;
      if (s == null || s.ownerDocument === null)
        return !1;
      const a = s.ownerDocument;
      return Is(at.fromDom(s)).fold(() => a.body.contains(s), Ot(bo, Eo));
    }, Lc = () => o0(at.fromDom(document)), o0 = (n) => {
      const s = n.dom.body;
      if (s == null)
        throw new Error("Body is not available yet");
      return at.fromDom(s);
    }, lg = (n, s, a) => {
      if (!De(a))
        throw console.error("Invalid call to CSS.set. Property ", s, ":: Value ", a, ":: Element ", n), new Error("CSS value must be a string: " + a);
      zi(n) && n.style.setProperty(s, a);
    }, ll = (n, s) => {
      zi(n) && n.style.removeProperty(s);
    }, gn = (n, s, a) => {
      const l = n.dom;
      lg(l, s, a);
    }, Ss = (n, s) => {
      const a = n.dom;
      ds(s, (l, d) => {
        lg(a, d, l);
      });
    }, ea = (n, s) => {
      const a = n.dom;
      ds(s, (l, d) => {
        l.fold(() => {
          ll(a, d);
        }, (g) => {
          lg(a, d, g);
        });
      });
    }, gs = (n, s) => {
      const a = n.dom, d = window.getComputedStyle(a).getPropertyValue(s);
      return d === "" && !bo(n) ? il(a, s) : d;
    }, il = (n, s) => zi(n) ? n.style.getPropertyValue(s) : "", Cs = (n, s) => {
      const a = n.dom, l = il(a, s);
      return A.from(l).filter((d) => d.length > 0);
    }, sr = (n) => {
      const s = {}, a = n.dom;
      if (zi(a))
        for (let l = 0; l < a.style.length; l++) {
          const d = a.style.item(l);
          s[d] = a.style[d];
        }
      return s;
    }, Qm = (n, s, a) => {
      const l = at.fromTag(n);
      return gn(l, s, a), Cs(l, s).isSome();
    }, Kn = (n, s) => {
      const a = n.dom;
      ll(a, s), uc(Qr(n, "style").map(vt), "") && fs(n, "style");
    }, Il = (n) => n.dom.offsetWidth, qo = (n, s) => {
      const a = (C, x) => {
        if (!In(x) && !x.match(/^[0-9]+$/))
          throw new Error(n + ".set accepts only positive integer values. Value was " + x);
        const T = C.dom;
        zi(T) && (T.style[n] = x + "px");
      }, l = (C) => {
        const x = s(C);
        if (x <= 0 || x === null) {
          const T = gs(C, n);
          return parseFloat(T) || 0;
        }
        return x;
      }, d = l, g = (C, x) => ao(x, (T, _) => {
        const N = gs(C, _), L = N === void 0 ? 0 : parseInt(N, 10);
        return isNaN(L) ? T : T + L;
      }, 0);
      return {
        set: a,
        get: l,
        getOuter: d,
        aggregate: g,
        max: (C, x, T) => {
          const _ = g(C, T);
          return x > _ ? x - _ : 0;
        }
      };
    }, hc = qo("height", (n) => {
      const s = n.dom;
      return bo(n) ? s.getBoundingClientRect().height : s.offsetHeight;
    }), hr = (n) => hc.get(n), pr = (n) => hc.getOuter(n), Vi = (n, s) => {
      const a = ["margin-top", "border-top-width", "padding-top", "padding-bottom", "border-bottom-width", "margin-bottom"], l = hc.max(n, s, a);
      gn(n, "max-height", l + "px");
    }, Jm = (n) => n.offsetWidth <= 0 && n.offsetHeight <= 0, ku = (n) => !Jm(n.dom), hd = qo("width", (n) => {
      const s = n.dom;
      return bo(n) ? s.getBoundingClientRect().width : s.offsetWidth;
    }), pd = (n, s) => hd.set(n, s), la = (n) => hd.get(n), Au = (n) => hd.getOuter(n), Jy = (n, s) => {
      const a = ["margin-left", "border-left-width", "padding-left", "padding-right", "border-right-width", "margin-right"], l = hd.max(n, s, a);
      gn(n, "max-width", l + "px");
    }, bd = (n, s) => ({
      left: n,
      top: s,
      translate: (l, d) => bd(n + l, s + d)
    }), Mo = bd, e1 = (n) => {
      const s = n.getBoundingClientRect();
      return Mo(s.left, s.top);
    }, ef = (n, s) => n !== void 0 ? n : s !== void 0 ? s : 0, Ca = (n) => {
      const s = n.dom.ownerDocument, a = s.body, l = s.defaultView, d = s.documentElement;
      if (a === n.dom)
        return Mo(a.offsetLeft, a.offsetTop);
      const g = ef(l?.pageYOffset, d.scrollTop), h = ef(l?.pageXOffset, d.scrollLeft), C = ef(d.clientTop, a.clientTop), x = ef(d.clientLeft, a.clientLeft);
      return pc(n).translate(h - x, g - C);
    }, pc = (n) => {
      const s = n.dom, l = s.ownerDocument.body;
      return l === s ? Mo(l.offsetLeft, l.offsetTop) : bo(n) ? e1(s) : Mo(0, 0);
    }, Ls = (n) => {
      const s = n !== void 0 ? n.dom : document, a = s.body.scrollLeft || s.documentElement.scrollLeft, l = s.body.scrollTop || s.documentElement.scrollTop;
      return Mo(a, l);
    }, _u = (n, s, a) => {
      const d = (a !== void 0 ? a.dom : document).defaultView;
      d && d.scrollTo(n, s);
    }, tf = ((n, s) => {
      const a = (g) => {
        if (!n(g))
          throw new Error("Can only get " + s + " value of a " + s + " node");
        return l(g).getOr("");
      }, l = (g) => n(g) ? A.from(g.dom.nodeValue) : A.none();
      return {
        get: a,
        getOption: l,
        set: (g, h) => {
          if (!n(g))
            throw new Error("Can only set raw " + s + " value of a " + s + " node");
          g.dom.nodeValue = h;
        }
      };
    })(dd, "text"), bh = (n) => tf.get(n), t1 = (n, s) => (a) => BS(a) === "rtl" ? s : n, BS = (n) => gs(n, "direction") === "rtl" ? "rtl" : "ltr", di = (n, s) => {
      const a = Dr(n, s);
      return a === void 0 || a === "" ? [] : a.split(" ");
    }, e2 = (n, s, a) => {
      const d = di(n, s).concat([a]);
      return ln(n, s, d.join(" ")), !0;
    }, n1 = (n, s, a) => {
      const l = Ln(di(n, s), (d) => d !== a);
      return l.length > 0 ? ln(n, s, l.join(" ")) : fs(n, s), !1;
    };
    var mi = (n, s, a, l, d) => n(a, l) ? A.some(a) : Xe(d) && d(a) ? A.none() : s(a, l, d);
    const s0 = (n, s, a) => {
      let l = n.dom;
      const d = Xe(a) ? a : an;
      for (; l.parentNode; ) {
        l = l.parentNode;
        const g = at.fromDom(l);
        if (s(g))
          return A.some(g);
        if (d(g))
          break;
      }
      return A.none();
    }, nf = (n, s, a) => mi((d, g) => g(d), s0, n, s, a), ig = (n, s) => {
      const a = n.dom;
      return a.parentNode ? ug(at.fromDom(a.parentNode), (l) => !I(n, l) && s(l)) : A.none();
    }, ug = (n, s) => {
      const a = (d) => s(at.fromDom(d));
      return Lt(n.dom.childNodes, a).map(at.fromDom);
    }, o1 = (n, s) => {
      const a = (l) => {
        for (let d = 0; d < l.childNodes.length; d++) {
          const g = at.fromDom(l.childNodes[d]);
          if (s(g))
            return A.some(g);
          const h = a(l.childNodes[d]);
          if (h.isSome())
            return h;
        }
        return A.none();
      };
      return a(n.dom);
    }, r0 = (n) => Qa(n), Fl = (n, s, a) => s0(n, (l) => Vo(l, s), a), t2 = (n, s) => ig(n, (a) => Vo(a, s)), vd = (n, s) => ug(n, (a) => Vo(a, s)), Po = (n, s) => Qa(s, n), xa = (n, s, a) => mi((d, g) => Vo(d, g), Fl, n, s, a), Ui = (n, s) => {
      n.dom.checked = s;
    }, s1 = (n) => n.dom.checked, yd = (n) => n.dom.classList !== void 0, r1 = (n) => di(n, "class"), a0 = (n, s) => e2(n, "class", s), ji = (n, s) => n1(n, "class", s), Wi = (n, s) => bt(r1(n), s) ? ji(n, s) : a0(n, s), Uo = (n, s) => {
      yd(n) ? n.dom.classList.add(s) : a0(n, s);
    }, c0 = (n) => {
      (yd(n) ? n.dom.classList : r1(n)).length === 0 && fs(n, "class");
    }, Ds = (n, s) => {
      yd(n) ? n.dom.classList.remove(s) : ji(n, s), c0(n);
    }, of = (n, s) => {
      const a = yd(n) ? n.dom.classList.toggle(s) : Wi(n, s);
      return c0(n), a;
    }, ar = (n, s) => yd(n) && n.dom.classList.contains(s), Zi = (n, s) => {
      He(s, (a) => {
        Uo(n, a);
      });
    }, ia = (n, s) => {
      He(s, (a) => {
        Ds(n, a);
      });
    }, Ou = (n, s) => {
      He(s, (a) => {
        of(n, a);
      });
    }, vh = (n, s) => We(s, (a) => ar(n, a)), a1 = (n) => {
      const s = n.dom.classList, a = new Array(s.length);
      for (let l = 0; l < s.length; l++) {
        const d = s.item(l);
        d !== null && (a[l] = d);
      }
      return a;
    }, c1 = (n) => yd(n) ? a1(n) : r1(n), n2 = (n) => n.dom.textContent, bc = (n) => n.dom.value, fi = (n, s) => {
      if (s === void 0)
        throw new Error("Value.set was undefined");
      n.dom.value = s;
    }, cr = (n, s, a) => Ln(rg(n, a), s), Lr = (n, s) => Yr(s, n), yh = (n, s, a) => nf(n, s, a).isSome(), dg = (n, s, a) => xa(n, s, a).isSome(), Ch = (n) => Xe(n) ? n : an, l0 = (n, s, a) => {
      let l = n.dom;
      const d = Ch(a);
      for (; l.parentNode; ) {
        l = l.parentNode;
        const g = at.fromDom(l), h = s(g);
        if (h.isSome())
          return h;
        if (d(g))
          break;
      }
      return A.none();
    }, Ll = (n, s, a) => {
      const l = s(n), d = Ch(a);
      return l.orThunk(() => d(n) ? A.none() : l0(n, s, d));
    }, w = {
      create: (n, s, a, l) => ({
        start: n,
        soffset: s,
        finish: a,
        foffset: l
      })
    }, k = Ma.generate([
      { before: ["element"] },
      { on: ["element", "offset"] },
      { after: ["element"] }
    ]), F = (n, s, a, l) => n.fold(s, a, l), q = (n) => n.fold(Yt, Yt, Yt), de = k.before, Ne = k.on, ft = k.after, Zt = {
      before: de,
      on: Ne,
      after: ft,
      cata: F,
      getStart: q
    }, Dn = Ma.generate([
      { domRange: ["rng"] },
      { relative: ["startSitu", "finishSitu"] },
      { exact: ["start", "soffset", "finish", "foffset"] }
    ]), Vn = (n) => Dn.exact(n.start, n.soffset, n.finish, n.foffset), ss = (n) => n.match({
      domRange: (s) => at.fromDom(s.startContainer),
      relative: (s, a) => Zt.getStart(s),
      exact: (s, a, l, d) => s
    }), ws = Dn.domRange, lr = Dn.relative, Hc = Dn.exact, gi = (n) => {
      const s = ss(n);
      return sg(s);
    }, Du = w.create, Hl = {
      domRange: ws,
      relative: lr,
      exact: Hc,
      exactFromRange: Vn,
      getWin: gi,
      range: Du
    }, l1 = (n) => A.from(n.getSelection()), sf = (n) => {
      if (n.rangeCount > 0) {
        const s = n.getRangeAt(0), a = n.getRangeAt(n.rangeCount - 1);
        return A.some(w.create(at.fromDom(s.startContainer), s.startOffset, at.fromDom(a.endContainer), a.endOffset));
      } else
        return A.none();
    }, mg = (n) => {
      if (n.anchorNode === null || n.focusNode === null)
        return sf(n);
      {
        const s = at.fromDom(n.anchorNode), a = at.fromDom(n.focusNode);
        return Hn(s, n.anchorOffset, a, n.focusOffset) ? A.some(w.create(s, n.anchorOffset, a, n.focusOffset)) : sf(n);
      }
    }, fg = (n) => (
      // We want to retrieve the selection as it is.
      l1(n).filter((s) => s.rangeCount > 0).bind(mg)
    ), gg = (n, s) => {
      const a = G(n, s);
      return pa(a);
    }, rf = (n, s) => {
      const a = G(n, s);
      return Ol(a);
    }, xh = {
      // we don't really support all of these different ways to express a length
      unsupportedLength: [
        "em",
        "ex",
        "cap",
        "ch",
        "ic",
        "rem",
        "lh",
        "rlh",
        "vw",
        "vh",
        "vi",
        "vb",
        "vmin",
        "vmax",
        "cm",
        "mm",
        "Q",
        "in",
        "pc",
        "pt",
        "px"
      ],
      // these are the length values we do support
      fixed: ["px", "pt"],
      relative: ["%"],
      empty: [""]
    }, o2 = (() => {
      const n = "[0-9]+", a = "[eE]" + ("[+-]?" + n), l = "\\.", d = (C) => `(?:${C})?`, h = `[+-]?(?:${[
        "Infinity",
        n + l + d(n) + d(a),
        l + n + d(a),
        n + d(a)
      ].join("|")})`;
      return new RegExp(`^(${h})(.*)$`);
    })(), s2 = (n, s) => cn(s, (a) => cn(xh[a], (l) => n === l)), vo = (n, s) => A.from(o2.exec(n)).bind((l) => {
      const d = Number(l[1]), g = l[2];
      return s2(g, s) ? A.some({
        value: d,
        unit: g
      }) : A.none();
    }), Hs = (n, s) => vo(n, s).map(({ value: a, unit: l }) => a + l), Gs = (n) => {
      const s = n === void 0 ? window : n;
      return Zs().browser.isFirefox() ? A.none() : A.from(s.visualViewport);
    }, Sa = (n, s, a, l) => ({
      x: n,
      y: s,
      width: a,
      height: l,
      right: n + a,
      bottom: s + l
    }), Sh = (n) => {
      const s = n === void 0 ? window : n, a = s.document, l = Ls(at.fromDom(a));
      return Gs(s).fold(() => {
        const d = s.document.documentElement, g = d.clientWidth, h = d.clientHeight;
        return Sa(l.left, l.top, g, h);
      }, (d) => (
        // iOS doesn't update the pageTop/pageLeft when element.scrollIntoView() is called, so we need to fallback to the
        // scroll position which will always be less than the page top/left values when page top/left are accurate/correct.
        Sa(Math.max(d.pageLeft, l.left), Math.max(d.pageTop, l.top), d.width, d.height)
      ));
    }, hg = (n, s) => n.view(s).fold(oe([]), (l) => {
      const d = n.owner(l), g = hg(n, d);
      return [l].concat(g);
    }), wh = (n, s) => {
      const a = s.owner(n), l = hg(s, a);
      return A.some(l);
    };
    var am = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      view: (n) => (n.dom === document ? A.none() : A.from(n.dom.defaultView?.frameElement)).map(at.fromDom),
      owner: (n) => fc(n)
    });
    const i1 = (n) => {
      const s = Xr(), a = Ls(s);
      return wh(n, am).fold(jt(Ca, n), (d) => {
        const g = pc(n), h = oo(d, (C, x) => {
          const T = pc(x);
          return {
            left: C.left + T.left,
            top: C.top + T.top
          };
        }, { left: 0, top: 0 });
        return Mo(h.left + g.left + a.left, h.top + g.top + a.top);
      });
    }, af = (n, s, a) => ({
      point: n,
      width: s,
      height: a
    }), M3 = (n, s, a, l) => ({
      x: n,
      y: s,
      width: a,
      height: l
    }), Rr = (n, s, a, l) => ({
      x: n,
      y: s,
      width: a,
      height: l,
      right: n + a,
      bottom: s + l
    }), wr = (n) => {
      const s = Ca(n), a = Au(n), l = pr(n);
      return Rr(s.left, s.top, a, l);
    }, cf = (n) => {
      const s = i1(n), a = Au(n), l = pr(n);
      return Rr(s.left, s.top, a, l);
    }, cm = (n, s) => {
      const a = Math.max(n.x, s.x), l = Math.max(n.y, s.y), d = Math.min(n.right, s.right), g = Math.min(n.bottom, s.bottom), h = d - a, C = g - l;
      return Rr(a, l, h, C);
    }, r2 = (n, s) => ao(s, (a, l) => cm(a, l), n), Ia = () => Sh(window), a2 = (n, s) => I(n.element, s.event.target), lf = (n) => (uc(Cs(n, "position"), "fixed") ? A.none() : qp(n)).orThunk(() => {
      const l = at.fromTag("span");
      return gc(n).bind((d) => {
        Fr(d, l);
        const g = qp(l);
        return al(l), g;
      });
    }), i0 = (n) => lf(n).map(Ca).getOrThunk(() => Mo(0, 0)), zl = (n, s) => {
      const a = A.from(Dr(n, "id")).getOrThunk(() => {
        const l = Ct("aria");
        return ln(s, "id", l), l;
      });
      ln(n, "aria-describedby", a);
    }, c2 = (n) => {
      fs(n, "aria-describedby");
    };
    var ul;
    (function(n) {
      n[n.Error = 0] = "Error", n[n.Value = 1] = "Value";
    })(ul || (ul = {}));
    const Js = (n, s, a) => n.stype === ul.Error ? s(n.serror) : a(n.svalue), u0 = (n) => {
      const s = [], a = [];
      return He(n, (l) => {
        Js(l, (d) => a.push(d), (d) => s.push(d));
      }), { values: s, errors: a };
    }, Th = (n, s) => n.stype === ul.Error ? { stype: ul.Error, serror: s(n.serror) } : n, FS = (n, s) => n.stype === ul.Value ? { stype: ul.Value, svalue: s(n.svalue) } : n, l2 = (n, s) => n.stype === ul.Value ? s(n.svalue) : n, LS = (n, s) => n.stype === ul.Error ? s(n.serror) : n, HS = (n) => ({ stype: ul.Value, svalue: n }), d0 = (n) => ({ stype: ul.Error, serror: n }), ht = {
      fromResult: (n) => n.fold(d0, HS),
      toResult: (n) => Js(n, Wt.error, Wt.value),
      svalue: HS,
      partition: u0,
      serror: d0,
      bind: l2,
      bindError: LS,
      map: FS,
      mapError: Th,
      fold: Js
    }, zc = (n) => et(n) && xo(n).length > 100 ? " removed due to size" : JSON.stringify(n, null, 2), P3 = (n) => {
      const s = n.length > 10 ? n.slice(0, 10).concat([
        {
          path: [],
          getErrorInfo: oe("... (only showing first ten failures)")
        }
      ]) : n;
      return ye(s, (a) => "Failed path: (" + a.path.join(" > ") + `)
` + a.getErrorInfo());
    }, vc = (n, s) => ht.serror([{
      path: n,
      // This is lazy so that it isn't calculated unnecessarily
      getErrorInfo: s
    }]), hi = (n, s, a) => vc(n, () => 'Could not find valid *required* value for "' + s + '" in ' + zc(a)), f0 = (n, s) => vc(n, () => 'Choice schema did not contain choice key: "' + s + '"'), B3 = (n, s, a) => vc(n, () => 'The chosen schema: "' + a + '" did not exist in branches: ' + zc(s)), uf = (n, s) => vc(n, () => "There are unsupported fields: [" + s.join(", ") + "] specified"), $3 = (n, s) => vc(n, oe(s)), Vc = (n) => {
      const s = (l, d) => ht.bindError(n(d), (g) => $3(l, g)), a = oe("val");
      return {
        extract: s,
        toString: a
      };
    }, zS = Vc(ht.svalue), pi = oe(zS), tt = (n, s) => Vc((a) => {
      const l = typeof a;
      return n(a) ? ht.svalue(a) : ht.serror(`Expected type: ${s} but got: ${l}`);
    }), i2 = tt(In, "number"), Hr = tt(De, "string"), zn = tt(vn, "boolean"), lm = tt(Xe, "function"), Ah = (n) => {
      if (Object(n) !== n)
        return !0;
      switch ({}.toString.call(n).slice(8, -1)) {
        // Class
        case "Boolean":
        case "Number":
        case "String":
        case "Date":
        case "RegExp":
        case "Blob":
        case "FileList":
        case "ImageData":
        case "ImageBitmap":
        case "ArrayBuffer":
          return !0;
        case "Array":
        case "Object":
          return Object.keys(n).every((s) => Ah(n[s]));
        default:
          return !1;
      }
    }, zs = Vc((n) => Ah(n) ? ht.svalue(n) : ht.serror("Expected value to be acceptable for sending via postMessage")), bi = () => ({ tag: "required", process: {} }), u1 = (n) => ({ tag: "defaultedThunk", process: n }), dl = (n) => u1(oe(n)), Es = () => ({ tag: "option", process: {} }), im = (n) => ({ tag: "mergeWithThunk", process: n }), _h = (n) => im(oe(n)), u2 = (n, s, a, l) => ({ tag: "field", key: n, newKey: s, presence: a, prop: l }), d2 = (n, s) => ({ tag: "custom", newKey: n, instantiator: s }), vi = (n, s, a) => {
      switch (n.tag) {
        case "field":
          return s(n.key, n.newKey, n.presence, n.prop);
        case "custom":
          return a(n.newKey, n.instantiator);
      }
    }, d1 = (n, s) => ht.svalue(Ho(s, cd.apply(void 0, n))), m1 = (n) => On(ht.serror, en)(n), f1 = {
      consolidateObj: (n, s) => {
        const a = ht.partition(n);
        return a.errors.length > 0 ? m1(a.errors) : d1(a.values, s);
      },
      consolidateArr: (n) => {
        const s = ht.partition(n);
        return s.errors.length > 0 ? m1(s.errors) : ht.svalue(s.values);
      }
    }, f2 = (n, s, a, l) => (
      // In required mode, if it is undefined, it is an error.
      Vt(s, a).fold(() => hi(n, a, s), l)
    ), g0 = (n, s, a, l) => {
      const d = Vt(n, s).getOrThunk(() => a(n));
      return l(d);
    }, F3 = (n, s, a) => a(Vt(n, s)), L3 = (n, s, a, l) => {
      const d = Vt(n, s).map((g) => g === !0 ? a(n) : g);
      return l(d);
    }, g2 = (n, s, a, l, d) => {
      const g = (C) => d.extract(s.concat([l]), C), h = (C) => C.fold(() => ht.svalue(A.none()), (x) => {
        const T = d.extract(s.concat([l]), x);
        return ht.map(T, A.some);
      });
      switch (n.tag) {
        case "required":
          return f2(s, a, l, g);
        case "defaultedThunk":
          return g0(a, l, n.process, g);
        case "option":
          return F3(a, l, h);
        case "defaultedOptionThunk":
          return L3(a, l, n.process, h);
        case "mergeWithThunk":
          return g0(a, l, oe({}), (C) => {
            const x = Ho(n.process(a), C);
            return g(x);
          });
      }
    }, H3 = (n, s, a) => {
      const l = {}, d = [];
      for (const g of a)
        vi(g, (h, C, x, T) => {
          const _ = g2(x, n, s, h, T);
          ht.fold(_, (N) => {
            d.push(...N);
          }, (N) => {
            l[C] = N;
          });
        }, (h, C) => {
          l[h] = C(s);
        });
      return d.length > 0 ? ht.serror(d) : ht.svalue(l);
    }, g1 = (n) => ({
      extract: (l, d) => n().extract(l, d),
      toString: () => n().toString()
    }), e5 = (n) => xo(dr(n, un)), ml = (n) => {
      const s = on(n), a = oo(n, (d, g) => vi(g, (h) => Ho(d, { [h]: !0 }), oe(d)), {});
      return {
        extract: (d, g) => {
          const h = vn(g) ? [] : e5(g), C = Ln(h, (x) => !Un(a, x));
          return C.length === 0 ? s.extract(d, g) : uf(d, C);
        },
        toString: s.toString
      };
    }, on = (n) => ({
      extract: (l, d) => H3(l, d, n),
      toString: () => `obj{
` + ye(n, (d) => vi(d, (g, h, C, x) => g + " -> " + x.toString(), (g, h) => "state(" + g + ")")).join(`
`) + "}"
    }), er = (n) => ({
      extract: (l, d) => {
        const g = ye(d, (h, C) => n.extract(l.concat(["[" + C + "]"]), h));
        return f1.consolidateArr(g);
      },
      toString: () => "array(" + n.toString() + ")"
    }), Oh = (n, s) => {
      const a = s !== void 0 ? s : Yt;
      return {
        extract: (g, h) => {
          const C = [];
          for (const x of n) {
            const T = x.extract(g, h);
            if (T.stype === ul.Value)
              return {
                stype: ul.Value,
                svalue: a(T.svalue)
              };
            C.push(T);
          }
          return f1.consolidateArr(C);
        },
        toString: () => "oneOf(" + ye(n, (g) => g.toString()).join(", ") + ")"
      };
    }, VS = (n, s) => {
      const a = (g, h) => er(Vc(n)).extract(g, h);
      return {
        extract: (g, h) => {
          const C = xo(h), x = a(g, C);
          return ht.bind(x, (T) => {
            const _ = ye(T, (N) => u2(N, N, bi(), s));
            return on(_).extract(g, h);
          });
        },
        toString: () => "setOf(" + s.toString() + ")"
      };
    }, pg = (n, s) => {
      const a = Bc(s);
      return {
        extract: (g, h) => a().extract(g, h),
        toString: () => a().toString()
      };
    }, Dh = On(er, on), h2 = (n, s, a, l) => Vt(a, l).fold(() => B3(n, a, l), (g) => g.extract(n.concat(["branch: " + l]), s)), bg = (n, s) => ({
      extract: (d, g) => Vt(g, n).fold(() => f0(d, n), (C) => h2(d, g, s, C)),
      toString: () => "chooseOn(" + n + "). Possible values: " + xo(s)
    }), US = () => er(zS), Cd = (n) => Vc((s) => n(s).fold(ht.serror, ht.svalue)), jS = (n, s) => VS((a) => ht.fromResult(n(a)), s), p2 = (n, s, a) => {
      const l = s.extract([n], a);
      return ht.mapError(l, (d) => ({ input: a, errors: d }));
    }, Fs = (n, s, a) => ht.toResult(p2(n, s, a)), yi = (n) => n.fold((s) => {
      throw new Error(Rh(s));
    }, Yt), yc = (n, s, a) => yi(Fs(n, s, a)), Rh = (n) => `Errors: 
` + P3(n.errors).join(`
`) + `

Input object: ` + zc(n.input), Cc = (n, s) => bg(n, Bs(s, on)), vg = (n, s) => pg(n, s), ta = u2, xc = d2, h0 = (n) => Cd((s) => bt(n, s) ? Wt.value(s) : Wt.error(`Unsupported value: "${s}", choose one of "${n.join(", ")}".`)), Ze = (n) => ta(n, n, bi(), pi()), Uc = (n, s) => ta(n, n, bi(), s), h1 = (n) => Uc(n, i2), qs = (n) => Uc(n, Hr), Gi = (n, s) => ta(n, n, bi(), h0(s)), fl = (n) => Uc(n, lm), z3 = (n, s) => ta(n, n, Es(), Vc((a) => ht.serror("The field: " + n + " is forbidden. " + s))), xd = (n, s) => ta(n, n, bi(), on(s)), WS = (n, s) => ta(n, n, bi(), Dh(s)), jc = (n, s) => ta(n, n, bi(), er(s)), Fo = (n) => ta(n, n, Es(), pi()), Ru = (n, s) => ta(n, n, Es(), s), Nh = (n) => Ru(n, i2), Ks = (n) => Ru(n, Hr), b2 = (n, s) => Ru(n, h0(s)), v2 = (n) => Ru(n, zn), qi = (n) => Ru(n, lm), p0 = (n, s) => Ru(n, er(s)), Wc = (n, s) => Ru(n, on(s)), V3 = (n, s) => Ru(n, ml(s)), we = (n, s) => ta(n, n, dl(s), pi()), Vl = (n, s, a) => ta(n, n, dl(s), a), p1 = (n, s) => Vl(n, s, i2), Vs = (n, s) => Vl(n, s, Hr), Sc = (n, s, a) => Vl(n, s, h0(a)), zr = (n, s) => Vl(n, s, zn), cs = (n, s) => Vl(n, s, lm), ZS = (n, s) => Vl(n, s, zs), df = (n, s, a) => Vl(n, s, er(a)), mf = (n, s, a) => Vl(n, s, on(a)), Mh = (n, s) => {
      const a = {};
      return ds(n, (l, d) => {
        bt(s, d) || (a[d] = l);
      }), a;
    }, b1 = (n, s) => ({ [n]: s }), y2 = (n) => {
      const s = {};
      return He(n, (a) => {
        s[a.key] = a.value;
      }), s;
    }, C2 = (n, s) => Mh(n, s), ff = (n, s) => b1(n, s), Ph = (n) => y2(n), GS = (n, s) => n.length === 0 ? Wt.value(s) : Wt.value(
      Ho(s, cd.apply(void 0, n))
      // Merger.deepMerge.apply(undefined, [ base ].concat(values))
    ), x2 = (n) => Wt.error(en(n)), U3 = (n, s) => {
      const a = _l(n);
      return a.errors.length > 0 ? x2(a.errors) : GS(a.values, s);
    }, Fa = oe, gl = Fa("touchstart"), ir = Fa("touchmove"), gf = Fa("touchend"), v1 = Fa("touchcancel"), Zc = Fa("mousedown"), Bh = Fa("mousemove"), Nr = Fa("mouseout"), b0 = Fa("mouseup"), Ul = Fa("mouseover"), Ki = Fa("focusin"), S2 = Fa("focusout"), na = Fa("keydown"), $h = Fa("keyup"), Nu = Fa("input"), yg = Fa("change"), Cg = Fa("click"), j3 = Fa("transitioncancel"), v0 = Fa("transitionend"), um = Fa("transitionstart"), y1 = Fa("selectstart"), ls = (n) => oe("alloy." + n), qS = { tap: ls("tap") }, dm = ls("focus"), Ih = ls("blur.post"), y0 = ls("paste.post"), mm = ls("receive"), wa = ls("execute"), xg = ls("focus.item"), Fh = qS.tap, C0 = ls("longpress"), x0 = ls("sandbox.close"), S0 = ls("typeahead.cancel"), C1 = ls("system.init"), KS = ls("system.touchmove"), w2 = ls("system.touchend"), E2 = ls("system.scroll"), Lh = ls("system.resize"), Mu = ls("system.attached"), Ci = ls("system.detached"), fm = ls("system.dismissRequested"), YS = ls("system.repositionRequested"), w0 = ls("focusmanager.shifted"), T2 = ls("slotcontainer.visibility"), XS = ls("system.external.element.scroll"), k2 = ls("change.tab"), E0 = ls("dismiss.tab"), T0 = ls("highlight"), k0 = ls("dehighlight"), Pu = (n) => ca(n), x1 = "unknown";
    var Hh;
    (function(n) {
      n[n.STOP = 0] = "STOP", n[n.NORMAL = 1] = "NORMAL", n[n.LOGGING = 2] = "LOGGING";
    })(Hh || (Hh = {}));
    const Sg = Pt({}), QS = (n, s) => {
      const a = [], l = (/* @__PURE__ */ new Date()).getTime();
      return {
        logEventCut: (d, g, h) => {
          a.push({ outcome: "cut", target: g, purpose: h });
        },
        logEventStopped: (d, g, h) => {
          a.push({ outcome: "stopped", target: g, purpose: h });
        },
        logNoParent: (d, g, h) => {
          a.push({ outcome: "no-parent", target: g, purpose: h });
        },
        logEventNoHandlers: (d, g) => {
          a.push({ outcome: "no-handlers-left", target: g });
        },
        logEventResponse: (d, g, h) => {
          a.push({ outcome: "response", purpose: h, target: g });
        },
        write: () => {
          const d = (/* @__PURE__ */ new Date()).getTime();
          bt(["mousemove", "mouseover", "mouseout", C1()], n) || console.log(n, {
            event: n,
            time: d - l,
            target: s.dom,
            sequence: ye(a, (g) => bt(["cut", "stopped", "response"], g.outcome) ? "{" + g.purpose + "} " + g.outcome + " at (" + Pu(g.target) + ")" : g.outcome)
          });
        }
      };
    }, zh = (n, s, a) => {
      switch (Vt(Sg.get(), n).orThunk(() => {
        const d = xo(Sg.get());
        return ga(d, (g) => n.indexOf(g) > -1 ? A.some(Sg.get()[g]) : A.none());
      }).getOr(Hh.NORMAL)) {
        case Hh.NORMAL:
          return a(A0());
        case Hh.LOGGING: {
          const d = QS(n, s), g = a(d);
          return d.write(), g;
        }
        case Hh.STOP:
          return !0;
      }
    }, wc = [
      "alloy/data/Fields",
      "alloy/debugging/Debugging"
    ], W3 = () => {
      const n = new Error();
      if (n.stack !== void 0) {
        const s = n.stack.split(`
`);
        return Lt(s, (a) => a.indexOf("alloy") > 0 && !cn(wc, (l) => a.indexOf(l) > -1)).getOr(x1);
      } else
        return x1;
    }, A2 = {
      logEventCut: U,
      logEventStopped: U,
      logNoParent: U,
      logEventNoHandlers: U,
      logEventResponse: U,
      write: U
    }, _2 = (n, s, a) => zh(n, s, a), A0 = oe(A2), JS = oe([
      Ze("menu"),
      Ze("selectedMenu")
    ]), wg = oe([
      Ze("item"),
      Ze("selectedItem")
    ]);
    oe(on(wg().concat(JS())));
    const ew = oe(on(wg())), S1 = xd("initSize", [
      Ze("numColumns"),
      Ze("numRows")
    ]), O2 = () => Uc("markers", ew()), tw = () => xd("markers", [
      Ze("backgroundMenu")
    ].concat(JS()).concat(wg())), lo = (n) => xd("markers", ye(n, Ze)), _0 = (n, s, a) => (W3(), ta(
      s,
      s,
      a,
      // Apply some wrapping to their supplied function
      Cd((l) => Wt.value((...d) => l.apply(void 0, d)))
    )), yo = (n) => _0("onHandler", n, dl(U)), hl = (n) => _0("onKeyboardHandler", n, dl(A.none)), hf = (n) => _0("onHandler", n, bi()), w1 = (n) => _0("onKeyboardHandler", n, bi()), Do = (n, s) => xc(n, oe(s)), nw = (n) => xc(n, Yt), ow = oe(S1), Z3 = (n, s, a) => {
      const l = a.toString(), d = l.indexOf(")") + 1, g = l.indexOf("("), h = l.substring(g + 1, d - 1).split(/,\s*/);
      return n.toFunctionAnnotation = () => ({
        name: s,
        parameters: Eg(h.slice(0, 1).concat(h.slice(3)))
      }), n;
    }, Eg = (n) => ye(n, (s) => nl(s, "/*") ? s.substring(0, s.length - 2) : s), E1 = (n, s) => {
      const a = n.toString(), l = a.indexOf(")") + 1, d = a.indexOf("("), g = a.substring(d + 1, l - 1).split(/,\s*/);
      return n.toFunctionAnnotation = () => ({
        name: s,
        parameters: Eg(g)
      }), n;
    }, sw = (n, s) => {
      const a = s.toString(), l = a.indexOf(")") + 1, d = a.indexOf("("), g = a.substring(d + 1, l - 1).split(/,\s*/);
      return n.toFunctionAnnotation = () => ({
        name: "OVERRIDE",
        parameters: Eg(g.slice(1))
      }), n;
    }, G3 = (n, s) => {
      let a = null;
      return {
        cancel: () => {
          a !== null && (clearTimeout(a), a = null);
        },
        schedule: (...g) => {
          a = setTimeout(() => {
            n.apply(null, g), a = null;
          }, s);
        }
      };
    }, q3 = 5, rw = 400, aw = (n) => {
      const s = n.raw;
      return s.touches === void 0 || s.touches.length !== 1 ? A.none() : A.some(s.touches[0]);
    }, K3 = (n, s) => {
      const a = Math.abs(n.clientX - s.x), l = Math.abs(n.clientY - s.y);
      return a > q3 || l > q3;
    }, Y3 = (n) => {
      const s = hn(), a = Pt(!1), l = G3((T) => {
        n.triggerEvent(C0(), T), a.set(!0);
      }, rw), d = (T) => (aw(T).each((_) => {
        l.cancel();
        const N = {
          x: _.clientX,
          y: _.clientY,
          target: T.target
        };
        l.schedule(T), a.set(!1), s.set(N);
      }), A.none()), g = (T) => (l.cancel(), aw(T).each((_) => {
        s.on((N) => {
          K3(_, N) && s.clear();
        });
      }), A.none()), h = (T) => {
        l.cancel();
        const _ = (N) => I(N.target, T.target);
        return s.get().filter(_).map((N) => a.get() ? (T.prevent(), !1) : n.triggerEvent(Fh(), T));
      }, C = Ph([
        { key: gl(), value: d },
        { key: ir(), value: g },
        { key: gf(), value: h }
      ]);
      return {
        fireIfReady: (T, _) => Vt(C, _).bind((N) => N(T))
      };
    };
    var Tg;
    (function(n) {
      n.OnFocusMode = "onFocus", n.OnEnterOrSpaceMode = "onEnterOrSpace", n.OnApiMode = "onApi";
    })(Tg || (Tg = {}));
    const pl = "placeholder", Vr = Ma.generate([
      { single: ["required", "valueThunk"] },
      { multiple: ["required", "valueThunks"] }
    ]), pf = (n) => mo(n, "uiType"), Yi = (n, s, a, l) => n.exists((d) => d !== a.owner) ? Vr.single(!0, oe(a)) : Vt(l, a.name).fold(() => {
      throw new Error("Unknown placeholder component: " + a.name + `
Known: [` + xo(l) + `]
Namespace: ` + n.getOr("none") + `
Spec: ` + JSON.stringify(a, null, 2));
    }, (d) => (
      // Must return a single/multiple type
      d.replace()
    )), Sd = (n, s, a, l) => pf(a) && a.uiType === pl ? Yi(n, s, a, l) : Vr.single(!1, oe(a)), Vh = (n, s, a, l) => Sd(n, s, a, l).fold((g, h) => {
      const C = pf(a) ? h(s, a.config, a.validated) : h(s), x = Vt(C, "components").getOr([]), T = xe(x, (_) => Vh(n, s, _, l));
      return [
        {
          ...C,
          components: T
        }
      ];
    }, (g, h) => {
      if (pf(a)) {
        const C = h(s, a.config, a.validated);
        return a.validated.preprocess.getOr(Yt)(C);
      } else
        return h(s);
    }), Uh = (n, s, a, l) => xe(a, (d) => Vh(n, s, d, l)), O0 = (n, s) => {
      let a = !1;
      const l = () => a, d = () => {
        if (a)
          throw new Error("Trying to use the same placeholder more than once: " + n);
        return a = !0, s;
      }, g = () => s.fold((h, C) => h, (h, C) => h);
      return {
        name: oe(n),
        required: g,
        used: l,
        replace: d
      };
    }, X3 = (n, s, a, l) => {
      const d = Bs(l, (h, C) => O0(C, h)), g = Uh(n, s, a, d);
      return ds(d, (h) => {
        if (h.used() === !1 && h.required())
          throw new Error("Placeholder: " + h.name() + ` was not found in components list
Namespace: ` + n.getOr("none") + `
Components: ` + JSON.stringify(s.components, null, 2));
      }), g;
    }, D0 = Vr.single, D2 = Vr.multiple, R2 = oe(pl), T1 = Ma.generate([
      { required: ["data"] },
      { external: ["data"] },
      { optional: ["data"] },
      { group: ["data"] }
    ]), gm = we("factory", { sketch: Yt }), R0 = we("schema", []), k1 = Ze("name"), N0 = ta("pname", "pname", u1((n) => "<alloy." + Ct(n.name) + ">"), pi()), cw = xc("schema", () => [
      Fo("preprocess")
    ]), wd = we("defaults", oe({})), M0 = we("overrides", oe({})), lw = on([
      gm,
      R0,
      k1,
      N0,
      wd,
      M0
    ]), Q3 = on([
      gm,
      R0,
      k1,
      wd,
      M0
    ]), J3 = on([
      gm,
      R0,
      k1,
      N0,
      wd,
      M0
    ]), iw = on([
      gm,
      cw,
      k1,
      Ze("unit"),
      N0,
      wd,
      M0
    ]), N2 = (n) => n.fold(A.some, A.none, A.some, A.some), Ed = (n) => {
      const s = (a) => a.name;
      return n.fold(s, s, s, s);
    }, uw = (n) => n.fold(Yt, Yt, Yt, Yt), Xi = (n, s) => (a) => {
      const l = yc("Converting part type", s, a);
      return n(l);
    }, nc = Xi(T1.required, lw), xi = Xi(T1.external, Q3), Ec = Xi(T1.optional, J3), P0 = Xi(T1.group, iw), kg = oe("entirety");
    var B0 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      required: nc,
      external: xi,
      optional: Ec,
      group: P0,
      asNamedPart: N2,
      name: Ed,
      asCommon: uw,
      original: kg
    });
    const M2 = (n, s, a, l) => (
      // Extremely confusing names and types :(
      Ho(s.defaults(n, a, l), a, { uid: n.partUids[s.name] }, s.overrides(n, a, l))
    ), ek = (n, s, a) => {
      const l = {}, d = {};
      return He(a, (g) => {
        g.fold(
          // Internal
          (h) => {
            l[h.pname] = D0(!0, (C, x, T) => h.factory.sketch(M2(C, h, x, T)));
          },
          // External
          (h) => {
            const C = s.parts[h.name];
            d[h.name] = oe(
              h.factory.sketch(M2(s, h, C[kg()]), C)
              // This is missing partValidated
            );
          },
          // Optional
          (h) => {
            l[h.pname] = D0(!1, (C, x, T) => h.factory.sketch(M2(C, h, x, T)));
          },
          // Group
          (h) => {
            l[h.pname] = D2(!0, (C, x, T) => {
              const _ = C[h.name];
              return ye(_, (N) => (
                // Group multiples do not take the uid because there is more than one.
                h.factory.sketch(Ho(h.defaults(C, N, T), N, h.overrides(C, N)))
              ));
            });
          }
        );
      }), {
        internals: oe(l),
        externals: oe(d)
      };
    }, bf = (n, s) => {
      const a = {};
      return He(s, (l) => {
        N2(l).each((d) => {
          const g = vf(n, d.pname);
          a[d.name] = (h) => {
            const C = yc("Part: " + d.name + " in " + n, on(d.schema), h);
            return {
              ...g,
              config: h,
              validated: C
            };
          };
        });
      }), a;
    }, vf = (n, s) => ({
      uiType: R2(),
      owner: n,
      name: s
    }), P2 = (n, s, a) => ({
      uiType: R2(),
      owner: n,
      name: s,
      config: a,
      validated: {}
    }), Ur = (n) => (
      // This actually has to change. It needs to return the schemas for things that will
      // not appear in the components list, which is only externals
      xe(n, (s) => s.fold(A.none, A.some, A.none, A.none).map((a) => xd(a.name, a.schema.concat([
        nw(kg())
      ]))).toArray())
    ), A1 = (n) => ye(n, Ed), Gc = (n, s, a) => ek(n, s, a), $0 = (n, s, a) => X3(A.some(n), s, s.components, a), Jo = (n, s, a) => {
      const l = s.partUids[a];
      return n.getSystem().getByUid(l).toOptional();
    }, Bu = (n, s, a) => Jo(n, s, a).getOrDie("Could not find part: " + a), hm = (n, s, a) => {
      const l = {}, d = s.partUids, g = n.getSystem();
      return He(a, (h) => {
        l[h] = oe(g.getByUid(d[h]));
      }), l;
    }, $u = (n, s) => {
      const a = n.getSystem();
      return Bs(s.partUids, (l, d) => oe(a.getByUid(l)));
    }, jl = (n) => xo(n.partUids), I0 = (n, s, a) => {
      const l = {}, d = s.partUids, g = n.getSystem();
      return He(a, (h) => {
        l[h] = oe(g.getByUid(d[h]).getOrDie());
      }), l;
    }, dw = (n, s) => {
      const a = A1(s);
      return Ph(ye(a, (l) => ({ key: l, value: n + "-" + l })));
    }, pm = (n) => ta("partUids", "partUids", im((s) => dw(s.uid, n)), pi());
    var Ag = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      generate: bf,
      generateOne: P2,
      schemas: Ur,
      names: A1,
      substitutes: Gc,
      components: $0,
      defaultUids: dw,
      defaultUidsSchema: pm,
      getAllParts: $u,
      getAllPartNames: jl,
      getPart: Jo,
      getPartOrDie: Bu,
      getParts: hm,
      getPartsOrDie: I0
    });
    const B2 = [
      "valignCentre",
      "alignLeft",
      "alignRight",
      "alignCentre",
      "top",
      "bottom",
      "left",
      "right",
      "inset"
    ], bl = (n, s, a, l = 1) => {
      const d = n * l, g = s * l, h = (x) => Vt(a, x).getOr([]), C = (x, T, _) => {
        const N = ze(B2, _);
        return {
          offset: Mo(x, T),
          classesOn: xe(_, h),
          classesOff: xe(N, h)
        };
      };
      return {
        southeast: () => C(-n, s, ["top", "alignLeft"]),
        southwest: () => C(n, s, ["top", "alignRight"]),
        south: () => C(-n / 2, s, ["top", "alignCentre"]),
        northeast: () => C(-n, -s, ["bottom", "alignLeft"]),
        northwest: () => C(n, -s, ["bottom", "alignRight"]),
        north: () => C(-n / 2, -s, ["bottom", "alignCentre"]),
        east: () => C(n, -s / 2, ["valignCentre", "left"]),
        west: () => C(-n, -s / 2, ["valignCentre", "right"]),
        insetNortheast: () => C(d, g, ["top", "alignLeft", "inset"]),
        insetNorthwest: () => C(-d, g, ["top", "alignRight", "inset"]),
        insetNorth: () => C(-d / 2, g, ["top", "alignCentre", "inset"]),
        insetSoutheast: () => C(d, -g, ["bottom", "alignLeft", "inset"]),
        insetSouthwest: () => C(-d, -g, ["bottom", "alignRight", "inset"]),
        insetSouth: () => C(-d / 2, -g, ["bottom", "alignCentre", "inset"]),
        insetEast: () => C(-d, -g / 2, ["valignCentre", "right", "inset"]),
        insetWest: () => C(d, -g / 2, ["valignCentre", "left", "inset"])
      };
    }, yf = () => bl(0, 0, {}), Ea = (n, s, a, l, d, g, h, C = !1) => ({
      x: n,
      y: s,
      bubble: a,
      direction: l,
      placement: d,
      restriction: g,
      label: `${h}-${d}`,
      alwaysFit: C
    }), Qi = Ma.generate([
      { southeast: [] },
      { southwest: [] },
      { northeast: [] },
      { northwest: [] },
      { south: [] },
      { north: [] },
      { east: [] },
      { west: [] }
    ]), F0 = (n, s, a, l, d, g, h, C, x) => n.fold(s, a, l, d, g, h, C, x), _g = (n, s, a, l) => n.fold(s, s, l, l, s, l, a, a), Cf = (n, s, a, l) => n.fold(s, l, s, l, a, a, s, l), _1 = Qi.southeast, $2 = Qi.southwest, L0 = Qi.northeast, Og = Qi.northwest, xf = Qi.south, I2 = Qi.north, O1 = Qi.east, F2 = Qi.west, mw = (n, s) => {
      switch (s) {
        case 1:
          return n.x;
        case 0:
          return n.x + n.width;
        case 2:
          return n.y;
        case 3:
          return n.y + n.height;
      }
    }, jr = (n, s) => no(["left", "right", "top", "bottom"], (a) => Vt(s, a).map((l) => mw(n, l))), Sf = (n, s, a) => {
      const l = (x, T) => s[x].map((_) => {
        const N = x === "top" || x === "bottom", L = N ? a.top : a.left, Z = (x === "left" || x === "top" ? Math.max : Math.min)(_, T) + L;
        return N ? nr(Z, n.y, n.bottom) : nr(Z, n.x, n.right);
      }).getOr(T), d = l("left", n.x), g = l("top", n.y), h = l("right", n.right), C = l("bottom", n.bottom);
      return Rr(d, g, h - d, C - g);
    }, wf = "layout", fw = (n) => n.x, H0 = (n, s) => n.x + n.width / 2 - s.width / 2, L2 = (n, s) => n.x + n.width - s.width, D1 = (n, s) => n.y - s.height, z0 = (n) => n.y + n.height, gw = (n, s) => n.y + n.height / 2 - s.height / 2, tk = (n) => n.x + n.width, R1 = (n, s) => n.x - s.width, Mr = (n, s, a) => Ea(fw(n), z0(n), a.southeast(), _1(), "southeast", jr(n, {
      left: 1,
      top: 3
      /* AnchorBoxBounds.BottomEdge */
    }), wf), Er = (n, s, a) => Ea(L2(n, s), z0(n), a.southwest(), $2(), "southwest", jr(n, {
      right: 0,
      top: 3
      /* AnchorBoxBounds.BottomEdge */
    }), wf), Ta = (n, s, a) => Ea(fw(n), D1(n, s), a.northeast(), L0(), "northeast", jr(n, {
      left: 1,
      bottom: 2
      /* AnchorBoxBounds.TopEdge */
    }), wf), ua = (n, s, a) => Ea(L2(n, s), D1(n, s), a.northwest(), Og(), "northwest", jr(n, {
      right: 0,
      bottom: 2
      /* AnchorBoxBounds.TopEdge */
    }), wf), Rs = (n, s, a) => Ea(H0(n, s), D1(n, s), a.north(), I2(), "north", jr(n, {
      bottom: 2
      /* AnchorBoxBounds.TopEdge */
    }), wf), Tr = (n, s, a) => Ea(H0(n, s), z0(n), a.south(), xf(), "south", jr(n, {
      top: 3
      /* AnchorBoxBounds.BottomEdge */
    }), wf), jh = (n, s, a) => Ea(tk(n), gw(n, s), a.east(), O1(), "east", jr(n, {
      left: 0
      /* AnchorBoxBounds.RightEdge */
    }), wf), H2 = (n, s, a) => Ea(R1(n, s), gw(n, s), a.west(), F2(), "west", jr(n, {
      right: 1
      /* AnchorBoxBounds.LeftEdge */
    }), wf), z2 = () => [Mr, Er, Ta, ua, Tr, Rs, jh, H2], hw = () => [Er, Mr, ua, Ta, Tr, Rs, jh, H2], V0 = () => [Ta, ua, Mr, Er, Rs, Tr], V2 = () => [ua, Ta, Er, Mr, Rs, Tr], U2 = () => [Mr, Er, Ta, ua, Tr, Rs], U0 = () => [Er, Mr, ua, Ta, Tr, Rs], j2 = "data-alloy-placement", Wh = (n, s) => {
      ln(n, j2, s);
    }, pw = (n) => Qr(n, j2), N1 = (n) => fs(n, j2), Iu = "layout-inset", j0 = (n) => n.x, M1 = (n, s) => n.x + n.width / 2 - s.width / 2, Zh = (n, s) => n.x + n.width - s.width, Dg = (n) => n.y, P1 = (n, s) => n.y + n.height - s.height, W0 = (n, s) => n.y + n.height / 2 - s.height / 2, B1 = (n, s, a) => Ea(Zh(n, s), P1(n, s), a.insetSouthwest(), Og(), "southwest", jr(n, {
      right: 0,
      bottom: 3
      /* AnchorBoxBounds.BottomEdge */
    }), Iu), Z0 = (n, s, a) => Ea(j0(n), P1(n, s), a.insetSoutheast(), L0(), "southeast", jr(n, {
      left: 1,
      bottom: 3
      /* AnchorBoxBounds.BottomEdge */
    }), Iu), Rg = (n, s, a) => Ea(Zh(n, s), Dg(n), a.insetNorthwest(), $2(), "northwest", jr(n, {
      right: 0,
      top: 2
      /* AnchorBoxBounds.TopEdge */
    }), Iu), Tc = (n, s, a) => Ea(j0(n), Dg(n), a.insetNortheast(), _1(), "northeast", jr(n, {
      left: 1,
      top: 2
      /* AnchorBoxBounds.TopEdge */
    }), Iu), La = (n, s, a) => Ea(M1(n, s), Dg(n), a.insetNorth(), xf(), "north", jr(n, {
      top: 2
      /* AnchorBoxBounds.TopEdge */
    }), Iu), Gh = (n, s, a) => Ea(M1(n, s), P1(n, s), a.insetSouth(), I2(), "south", jr(n, {
      bottom: 3
      /* AnchorBoxBounds.BottomEdge */
    }), Iu), Re = (n, s, a) => Ea(Zh(n, s), W0(n, s), a.insetEast(), F2(), "east", jr(n, {
      right: 0
      /* AnchorBoxBounds.RightEdge */
    }), Iu), $1 = (n, s, a) => Ea(j0(n), W0(n, s), a.insetWest(), O1(), "west", jr(n, {
      left: 1
      /* AnchorBoxBounds.LeftEdge */
    }), Iu), nk = (n) => {
      switch (n) {
        case "north":
          return La;
        case "northeast":
          return Tc;
        case "northwest":
          return Rg;
        case "south":
          return Gh;
        case "southeast":
          return Z0;
        case "southwest":
          return B1;
        case "east":
          return Re;
        case "west":
          return $1;
      }
    }, kc = (n, s, a, l, d) => pw(l).map(nk).getOr(La)(n, s, a, l, d), qh = (n) => {
      switch (n) {
        case "north":
          return Gh;
        case "northeast":
          return Z0;
        case "northwest":
          return B1;
        case "south":
          return La;
        case "southeast":
          return Tc;
        case "southwest":
          return Rg;
        case "east":
          return $1;
        case "west":
          return Re;
      }
    }, Fu = (n, s, a, l, d) => pw(l).map(qh).getOr(La)(n, s, a, l, d), W2 = (n, s) => {
      Vi(n, Math.floor(s));
    }, Z2 = oe((n, s) => {
      W2(n, s), Ss(n, {
        "overflow-x": "hidden",
        "overflow-y": "auto"
      });
    }), Ng = oe((n, s) => {
      W2(n, s);
    }), I1 = oe((n, s) => {
      Jy(n, Math.floor(s));
    });
    var bm;
    (function(n) {
      n.TopToBottom = "toptobottom", n.BottomToTop = "bottomtotop";
    })(bm || (bm = {}));
    const G0 = "data-alloy-vertical-dir", ok = (n) => yh(n, (s) => mc(s) && Dr(s, "data-alloy-vertical-dir") === bm.BottomToTop);
    var Ha;
    (function(n) {
      n[n.HighlightMenuAndItem = 0] = "HighlightMenuAndItem", n[n.HighlightJustMenu = 1] = "HighlightJustMenu", n[n.HighlightNone = 2] = "HighlightNone";
    })(Ha || (Ha = {}));
    const Lu = {
      init: () => vl({
        readState: oe("No State required")
      })
    }, vl = (n) => n, sk = {
      can: St,
      abort: an,
      run: U
    }, Kh = (n) => {
      if (!Un(n, "can") && !Un(n, "abort") && !Un(n, "run"))
        throw new Error("EventHandler defined by: " + JSON.stringify(n, null, 2) + " does not have can, abort, or run!");
      return {
        ...sk,
        ...n
      };
    }, bw = (n, s) => (...a) => ao(n, (l, d) => l && s(d).apply(void 0, a), !0), q0 = (n, s) => (...a) => ao(n, (l, d) => l || s(d).apply(void 0, a), !1), rk = (n) => Xe(n) ? {
      can: St,
      abort: an,
      run: n
    } : n, vw = (n) => {
      const s = bw(n, (d) => d.can), a = q0(n, (d) => d.abort);
      return {
        can: s,
        abort: a,
        run: (...d) => {
          He(n, (g) => {
            g.run.apply(void 0, d);
          });
        }
      };
    }, Wn = (n, s) => {
      Y0(n, n.element, s, {});
    }, tn = (n, s, a) => {
      Y0(n, n.element, s, a);
    }, Yh = (n) => {
      Wn(n, wa());
    }, K0 = (n, s, a) => {
      Y0(n, s, a, {});
    }, Y0 = (n, s, a, l) => {
      const d = {
        target: s,
        ...l
      };
      n.getSystem().triggerEvent(a, s, d);
    }, ak = (n, s, a, l) => {
      const d = {
        ...l,
        target: s
      };
      n.getSystem().triggerEvent(a, s, d);
    }, G2 = (n, s, a, l) => {
      n.getSystem().triggerEvent(a, s, l.event);
    }, Ts = (n) => Ph(n), X0 = (n, s) => ({
      key: n,
      value: Kh({
        abort: s
      })
    }), Q0 = (n, s) => ({
      key: n,
      value: Kh({
        can: s
      })
    }), q2 = (n) => ({
      key: n,
      value: Kh({
        run: (s, a) => {
          a.event.prevent();
        }
      })
    }), Ie = (n, s) => ({
      key: n,
      value: Kh({
        run: s
      })
    }), Xh = (n, s, a) => ({
      key: n,
      value: Kh({
        run: (l, d) => {
          s.apply(void 0, [l, d].concat(a));
        }
      })
    }), Mg = (n) => (s) => Ie(n, s), Td = (n) => (s) => ({
      key: n,
      value: Kh({
        run: (a, l) => {
          a2(a, l) && s(a, l);
        }
      })
    }), Ji = (n, s) => Ie(n, (a, l) => {
      a.getSystem().getByUid(s).each((d) => {
        G2(d, d.element, n, l);
      });
    }), kd = (n, s, a) => {
      const l = s.partUids[a];
      return Ji(n, l);
    }, Qh = (n, s) => Ie(n, (a, l) => {
      const d = l.event, g = a.getSystem().getByDom(d.target).getOrThunk(
        // If we don't find an alloy component for the target, I guess we go up the tree
        // until we find an alloy component? Performance concern?
        // TODO: Write tests for this.
        () => Ll(d.target, (C) => a.getSystem().getByDom(C).toOptional(), an).getOr(a)
      );
      s(a, g, l);
    }), Pg = (n) => Ie(n, (s, a) => {
      a.cut();
    }), ck = (n) => Ie(n, (s, a) => {
      a.stop();
    }), Jh = (n, s) => Td(n)(s), hs = Td(Mu()), eu = Td(Ci()), K2 = Td(C1()), Ef = Mg(wa()), Hu = (n) => ({
      classes: Cn(n.classes) ? [] : n.classes,
      attributes: Cn(n.attributes) ? {} : n.attributes,
      styles: Cn(n.styles) ? {} : n.styles
    }), za = (n, s) => ({
      ...n,
      attributes: { ...n.attributes, ...s.attributes },
      styles: { ...n.styles, ...s.styles },
      classes: n.classes.concat(s.classes)
    }), yw = (n, s, a) => Ef((l) => {
      a(l, n, s);
    }), Y2 = (n, s, a) => K2((l, d) => {
      a(l, n, s);
    }), Cw = (n, s, a, l, d, g) => {
      const h = ml(n), C = Wc(s, [
        V3("config", n)
      ]);
      return xw(h, C, s, a, l, d, g);
    }, lk = (n, s, a, l, d, g) => {
      const h = n, C = Wc(s, [
        Ru("config", n)
      ]);
      return xw(h, C, s, a, l, d, g);
    }, ik = (n, s, a) => Z3((d, ...g) => {
      const h = [d].concat(g);
      return d.config({
        name: oe(n)
      }).fold(() => {
        throw new Error("We could not find any behaviour configuration for: " + n + ". Using API: " + a);
      }, (C) => {
        const x = Array.prototype.slice.call(h, 1);
        return s.apply(void 0, [d, C.config, C.state].concat(x));
      });
    }, a, s), X2 = (n) => ({
      key: n,
      value: void 0
    }), xw = (n, s, a, l, d, g, h) => {
      const C = (N) => Un(N, a) ? N[a]() : A.none(), x = Bs(d, (N, L) => ik(a, N, L)), _ = {
        ...Bs(g, (N, L) => E1(N, L)),
        ...x,
        revoke: jt(X2, a),
        config: (N) => {
          const L = yc(a + "-config", n, N);
          return {
            key: a,
            value: {
              config: L,
              me: _,
              configAsRaw: Bc(() => yc(a + "-config", n, N)),
              initialConfig: N,
              state: h
            }
          };
        },
        schema: oe(s),
        exhibit: (N, L) => $a(C(N), Vt(l, "exhibit"), (j, Z) => Z(L, j.config, j.state)).getOrThunk(() => Hu({})),
        name: oe(a),
        handlers: (N) => C(N).map((L) => Vt(l, "events").getOr(() => ({}))(L.config, L.state)).getOr({})
      };
      return _;
    }, nt = (n) => Ph(n), Q2 = ml([
      Ze("fields"),
      Ze("name"),
      we("active", {}),
      we("apis", {}),
      we("state", Lu),
      we("extra", {})
    ]), da = (n) => {
      const s = yc("Creating behaviour: " + n.name, Q2, n);
      return Cw(s.fields, s.name, s.active, s.apis, s.extra, s.state);
    }, J2 = ml([
      Ze("branchKey"),
      Ze("branches"),
      Ze("name"),
      we("active", {}),
      we("apis", {}),
      we("state", Lu),
      we("extra", {})
    ]), eC = (n) => {
      const s = yc("Creating behaviour: " + n.name, J2, n);
      return lk(Cc(s.branchKey, s.branches), s.name, s.active, s.apis, s.extra, s.state);
    }, tC = oe(void 0), uk = (n, s) => {
      const a = Ts(s);
      return da({
        fields: [
          Ze("enabled")
        ],
        name: n,
        active: {
          events: oe(a)
        }
      });
    }, xn = (n, s) => {
      const a = uk(n, s);
      return {
        key: n,
        value: {
          config: {},
          me: a,
          configAsRaw: oe({}),
          initialConfig: {},
          state: Lu
        }
      };
    }, Sw = (n) => ({
      init: () => {
        const a = Pt(n);
        return {
          get: () => a.get(),
          set: (C) => a.set(C),
          clear: () => a.set(n),
          readState: () => a.get()
        };
      }
    }), ww = (n, s) => {
      s.ignore || ($r(n.element), s.onFocus(n));
    };
    var Ew = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      focus: ww,
      blur: (n, s) => {
        s.ignore || Os(n.element);
      },
      isFocused: (n) => Bl(n.element)
    }), Tw = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (n, s) => {
        const a = s.ignore ? {} : {
          attributes: {
            tabindex: "-1"
          }
        };
        return Hu(a);
      },
      events: (n) => Ts([
        Ie(dm(), (s, a) => {
          ww(s, n), a.stop();
        })
      ].concat(n.stopMousedown ? [
        Ie(Zc(), (s, a) => {
          a.event.prevent();
        })
      ] : []))
    }), fk = [
      // TODO: Work out when we want to  call this. Only when it is has changed?
      yo("onFocus"),
      we("stopMousedown", !1),
      we("ignore", !1)
    ];
    const En = da({
      fields: fk,
      name: "focusing",
      active: Tw,
      apis: Ew
      // Consider adding isFocused an an extra
    }), nC = [8], vm = [9], Si = [13], J0 = [27], Ac = [32], ep = [37], F1 = [38], ev = [39], tp = [40], np = oe("tooltipping.close.all"), Ad = oe("dismiss.popups"), kr = oe("reposition.popups"), ym = oe("mouse.released"), kw = (n, s, a) => {
      const l = st(n.slice(0, s)), d = st(n.slice(s + 1));
      return Lt(l.concat(d), a);
    }, oC = (n, s, a) => {
      const l = st(n.slice(0, s));
      return Lt(l, a);
    }, Aw = (n, s, a) => {
      const l = n.slice(0, s), d = n.slice(s + 1);
      return Lt(d.concat(l), a);
    }, gk = (n, s, a) => {
      const l = n.slice(s + 1);
      return Lt(l, a);
    }, io = (n) => (s) => {
      const a = s.raw;
      return bt(n, a.which);
    }, tu = (n) => (s) => We(n, (a) => a(s)), Tf = (n) => n.raw.shiftKey === !0, n5 = (n) => n.raw.ctrlKey === !0, op = X(Tf), go = (n, s) => ({
      matches: n,
      classification: s
    }), hk = (n, s) => Lt(n, (l) => l.matches(s)).map((l) => l.classification), pk = (n, s, a, l) => {
      const d = Lr(n.element, "." + s.highlightClass);
      He(d, (g) => {
        cn(l, (C) => I(C.element, g)) || (Ds(g, s.highlightClass), n.getSystem().getByDom(g).each((C) => {
          s.onDehighlight(n, C), Wn(C, k0());
        }));
      });
    }, o5 = (n, s, a) => pk(n, s, a, []), s5 = (n, s, a, l) => {
      z1(n, s, a, l) && (Ds(l.element, s.highlightClass), s.onDehighlight(n, l), Wn(l, k0()));
    }, L1 = (n, s, a, l) => {
      pk(n, s, a, [l]), z1(n, s, a, l) || (Uo(l.element, s.highlightClass), s.onHighlight(n, l), Wn(l, T0()));
    }, bk = (n, s, a) => {
      tv(n, s).each((l) => {
        L1(n, s, a, l);
      });
    }, vk = (n, s, a) => {
      sC(n, s).each((l) => {
        L1(n, s, a, l);
      });
    }, H1 = (n, s, a, l) => {
      Ck(n, s, a, l).fold((d) => {
        throw d;
      }, (d) => {
        L1(n, s, a, d);
      });
    }, yk = (n, s, a, l) => {
      const d = Dw(n, s);
      Lt(d, l).each((h) => {
        L1(n, s, a, h);
      });
    }, z1 = (n, s, a, l) => ar(l.element, s.highlightClass), _w = (n, s, a) => Po(n.element, "." + s.highlightClass).bind((l) => n.getSystem().getByDom(l).toOptional()), Ck = (n, s, a, l) => {
      const d = Lr(n.element, "." + s.itemClass);
      return A.from(d[l]).fold(() => Wt.error(new Error("No element found with index " + l)), n.getSystem().getByDom);
    }, tv = (n, s, a) => Po(n.element, "." + s.itemClass).bind((l) => n.getSystem().getByDom(l).toOptional()), sC = (n, s, a) => {
      const l = Lr(n.element, "." + s.itemClass);
      return (l.length > 0 ? A.some(l[l.length - 1]) : A.none()).bind((g) => n.getSystem().getByDom(g).toOptional());
    }, rC = (n, s, a, l) => {
      const d = Lr(n.element, "." + s.itemClass);
      return po(d, (h) => ar(h, s.highlightClass)).bind((h) => {
        const C = Nc(h, l, 0, d.length - 1);
        return n.getSystem().getByDom(d[C]).toOptional();
      });
    }, Ow = (n, s, a) => rC(n, s, a, -1), xk = (n, s, a) => rC(n, s, a, 1), Dw = (n, s, a) => {
      const l = Lr(n.element, "." + s.itemClass);
      return Al(ye(l, (d) => n.getSystem().getByDom(d).toOptional()));
    };
    var aC = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      dehighlightAll: o5,
      dehighlight: s5,
      highlight: L1,
      highlightFirst: bk,
      highlightLast: vk,
      highlightAt: H1,
      highlightBy: yk,
      isHighlighted: z1,
      getHighlighted: _w,
      getFirst: tv,
      getLast: sC,
      getPrevious: Ow,
      getNext: xk,
      getCandidates: Dw
    }), Rw = [
      Ze("highlightClass"),
      Ze("itemClass"),
      yo("onHighlight"),
      yo("onDehighlight")
    ];
    const So = da({
      fields: Rw,
      name: "highlighting",
      apis: aC
    }), Nw = (n, s, a) => {
      s.exists((d) => a.exists((g) => I(g, d))) || tn(n, w0(), {
        prevFocus: s,
        newFocus: a
      });
    }, cC = () => {
      const n = (a) => or(a.element);
      return {
        get: n,
        set: (a, l) => {
          const d = n(a);
          a.getSystem().triggerFocus(l, a.element);
          const g = n(a);
          Nw(a, d, g);
        }
      };
    }, nv = () => {
      const n = (a) => So.getHighlighted(a).map((l) => l.element);
      return {
        get: n,
        set: (a, l) => {
          const d = n(a);
          a.getSystem().getByDom(l).fold(U, (h) => {
            So.highlight(a, h);
          });
          const g = n(a);
          Nw(a, d, g);
        }
      };
    }, Cm = (n, s, a, l, d) => {
      const g = () => n.concat([
        we("focusManager", cC()),
        Vl("focusInside", "onFocus", Cd((T) => bt(["onFocus", "onEnterOrSpace", "onApi"], T) ? Wt.value(T) : Wt.error("Invalid value for focusInside"))),
        Do("handler", x),
        Do("state", s),
        Do("sendFocusIn", d)
      ]), h = (T, _, N, L, j) => {
        const Z = N(T, _, L, j);
        return hk(Z, _.event).bind((ne) => ne(T, _, L, j));
      }, x = {
        schema: g,
        processKey: h,
        toEvents: (T, _) => {
          const N = T.focusInside !== Tg.OnFocusMode ? A.none() : d(T).map((Z) => Ie(dm(), (ne, ae) => {
            Z(ne, T, _), ae.stop();
          })), L = (Z, ne) => {
            const ae = io(Ac.concat(Si))(ne.event);
            T.focusInside === Tg.OnEnterOrSpaceMode && ae && a2(Z, ne) && d(T).each((Y) => {
              Y(Z, T, _), ne.stop();
            });
          }, j = [
            Ie(na(), (Z, ne) => {
              h(Z, ne, a, T, _).fold(() => {
                L(Z, ne);
              }, (ae) => {
                ne.stop();
              });
            }),
            Ie($h(), (Z, ne) => {
              h(Z, ne, l, T, _).each((ae) => {
                ne.stop();
              });
            })
          ];
          return Ts(N.toArray().concat(j));
        }
      };
      return x;
    }, lC = (n) => {
      const s = [
        Fo("onEscape"),
        Fo("onEnter"),
        we("selector", '[data-alloy-tabstop="true"]:not(:disabled)'),
        we("firstTabstop", 0),
        we("useTabstopAt", St),
        // Maybe later we should just expose isVisible
        Fo("visibilitySelector")
      ].concat([
        n
      ]), a = (Y, le) => {
        const pe = Y.visibilitySelector.bind((Ee) => xa(le, Ee)).getOr(le);
        return hr(pe) > 0;
      }, l = (Y, le) => {
        const pe = Lr(Y.element, le.selector), Ee = Ln(pe, (Oe) => a(le, Oe));
        return A.from(Ee[le.firstTabstop]);
      }, d = (Y, le) => le.focusManager.get(Y).bind((pe) => xa(pe, le.selector)), g = (Y, le) => a(Y, le) && Y.useTabstopAt(le), h = (Y, le, pe) => {
        l(Y, le).each((Ee) => {
          le.focusManager.set(Y, Ee);
        });
      }, C = (Y, le, pe, Ee, Oe) => Oe(le, pe, (gt) => g(Ee, gt)).fold(
        // Even if there is only one, still capture the event if cycling
        () => Ee.cyclic ? A.some(!0) : A.none(),
        (gt) => (Ee.focusManager.set(Y, gt), A.some(!0))
      ), x = (Y, le, pe, Ee) => {
        const Oe = Ln(Lr(Y.element, pe.selector), (gt) => a(pe, gt));
        return d(Y, pe).bind((gt) => po(Oe, jt(I, gt)).bind((Qe) => C(Y, Oe, Qe, pe, Ee)));
      }, T = (Y, le, pe) => {
        const Ee = pe.cyclic ? kw : oC;
        return x(Y, le, pe, Ee);
      }, _ = (Y, le, pe) => {
        const Ee = pe.cyclic ? Aw : gk;
        return x(Y, le, pe, Ee);
      }, N = (Y) => Gp(Y).bind(Qn).exists((le) => I(le, Y)), L = (Y, le, pe) => d(Y, pe).filter((Ee) => !pe.useTabstopAt(Ee)).bind((Ee) => (N(Ee) ? T : _)(Y, le, pe)), j = (Y, le, pe) => pe.onEnter.bind((Ee) => Ee(Y, le)), Z = (Y, le, pe) => (Y.getSystem().broadcastOn([np()], {
        closedTooltip: () => {
          le.stop();
        }
      }), le.isStopped() ? A.none() : pe.onEscape.bind((Ee) => Ee(Y, le))), ne = oe([
        go(tu([Tf, io(vm)]), T),
        go(io(vm), _),
        go(tu([op, io(Si)]), j)
      ]), ae = oe([
        go(io(J0), Z),
        go(io(vm), L)
      ]);
      return Cm(s, Lu.init, ne, ae, () => A.some(h));
    };
    var Sk = lC(xc("cyclic", an)), Mw = lC(xc("cyclic", St));
    const sp = (n) => va("input")(n) && Dr(n, "type") !== "radio" || va("textarea")(n), Pw = (n, s, a) => (K0(n, a, wa()), A.some(!0)), V1 = (n, s, a) => sp(a) && io(Ac)(s.event) ? A.none() : Pw(n, s, a), U1 = (n, s) => A.some(!0), iC = [
      we("execute", V1),
      we("useSpace", !1),
      we("useEnter", !0),
      we("useControlEnter", !1),
      we("useDown", !1)
    ], kf = (n, s, a) => a.execute(n, s, n.element), Bw = (n, s, a, l) => {
      const d = a.useSpace && !sp(n.element) ? Ac : [], g = a.useEnter ? Si : [], h = a.useDown ? tp : [], C = d.concat(g).concat(h);
      return [
        go(io(C), kf)
      ].concat(a.useControlEnter ? [
        go(tu([n5, io(Si)]), kf)
      ] : []);
    }, $w = (n, s, a, l) => a.useSpace && !sp(n.element) ? [go(io(Ac), U1)] : [];
    var Iw = Cm(iC, Lu.init, Bw, $w, () => A.none());
    const Fw = () => {
      const n = hn();
      return vl({
        readState: () => n.get().map((d) => ({
          numRows: String(d.numRows),
          numColumns: String(d.numColumns)
        })).getOr({
          numRows: "?",
          numColumns: "?"
        }),
        setGridSize: (d, g) => {
          n.set({ numRows: d, numColumns: g });
        },
        getNumRows: () => n.get().map((d) => d.numRows),
        getNumColumns: () => n.get().map((d) => d.numColumns)
      });
    };
    var Lw = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      flatgrid: Fw,
      init: (n) => n.state(n)
    });
    const ov = (n) => (s, a, l, d) => {
      const g = n(s.element);
      return av(g, s, a, l, d);
    }, sv = (n, s) => {
      const a = t1(n, s);
      return ov(a);
    }, j1 = (n, s) => {
      const a = t1(s, n);
      return ov(a);
    }, rv = (n) => (s, a, l, d) => av(n, s, a, l, d), av = (n, s, a, l, d) => l.focusManager.get(s).bind((h) => n(s.element, h, l, d)).map((h) => (l.focusManager.set(s, h), !0)), Rt = rv, Af = rv, _d = rv, W1 = (n, s) => po(n, s).map((a) => ({
      index: a,
      candidates: n
    })), Hw = (n, s, a) => {
      const l = (h) => I(h, s), d = Lr(n, a), g = Ln(d, ku);
      return W1(g, l);
    }, uC = (n, s) => po(n, (a) => I(s, a)), dC = (n, s, a, l) => {
      const d = Math.floor(s / a), g = s % a;
      return l(d, g).bind((h) => {
        const C = h.row * a + h.column;
        return C >= 0 && C < n.length ? A.some(n[C]) : A.none();
      });
    }, zw = (n, s, a, l, d) => dC(n, s, l, (g, h) => {
      const x = g === a - 1 ? n.length - g * l : l, T = Nc(h, d, 0, x - 1);
      return A.some({
        row: g,
        column: T
      });
    }), Vw = (n, s, a, l, d) => dC(n, s, l, (g, h) => {
      const C = Nc(g, d, 0, a - 1), T = C === a - 1 ? n.length - C * l : l, _ = nr(h, 0, T - 1);
      return A.some({
        row: C,
        column: _
      });
    }), Uw = (n, s, a, l) => zw(n, s, a, l, 1), cv = (n, s, a, l) => zw(n, s, a, l, -1), Ar = (n, s, a, l) => Vw(n, s, a, l, -1), nu = (n, s, a, l) => Vw(n, s, a, l, 1), lv = [
      Ze("selector"),
      we("execute", V1),
      hl("onEscape"),
      we("captureTab", !1),
      ow()
    ], jw = (n, s, a) => {
      Po(n.element, s.selector).each((l) => {
        s.focusManager.set(n, l);
      });
    }, Ww = (n, s) => s.focusManager.get(n).bind((a) => xa(a, s.selector)), Zw = (n, s, a, l) => Ww(n, a).bind((d) => a.execute(n, s, d)), iv = (n) => (s, a, l, d) => Hw(s, a, l.selector).bind((g) => n(g.candidates, g.index, d.getNumRows().getOr(l.initSize.numRows), d.getNumColumns().getOr(l.initSize.numColumns))), mC = (n, s, a) => a.captureTab ? A.some(!0) : A.none(), Gw = (n, s, a) => a.onEscape(n, s), qw = iv(cv), Z1 = iv(Uw), fC = iv(Ar), uv = iv(nu), gC = oe([
      go(io(ep), sv(qw, Z1)),
      go(io(ev), j1(qw, Z1)),
      go(io(F1), Rt(fC)),
      go(io(tp), Af(uv)),
      go(tu([Tf, io(vm)]), mC),
      go(tu([op, io(vm)]), mC),
      // Probably should make whether space is used configurable
      go(io(Ac.concat(Si)), Zw)
    ]), wk = oe([
      go(io(J0), Gw),
      go(io(Ac), U1)
    ]);
    var Kw = Cm(lv, Fw, gC, wk, () => A.some(jw));
    const Yw = (n, s, a, l, d) => {
      const g = (C) => Nl(C) === "button" && Dr(C, "disabled") === "disabled", h = (C, x, T) => d(C, x, l, 0, T.length - 1, T[x], (_) => g(T[_]) ? h(C, _, T) : A.from(T[_]));
      return Hw(n, a, s).bind((C) => {
        const x = C.index, T = C.candidates;
        return h(x, x, T);
      });
    }, dv = (n, s, a, l) => Yw(n, s, a, l, (d, g, h, C, x, T, _) => {
      const N = nr(g + h, C, x);
      return N === d ? A.from(T) : _(N);
    }), Bg = (n, s, a, l) => Yw(n, s, a, l, (d, g, h, C, x, T, _) => {
      const N = Nc(g, h, C, x);
      return N === d ? A.none() : _(N);
    }), Xw = [
      Ze("selector"),
      we("getInitial", A.none),
      we("execute", V1),
      hl("onEscape"),
      we("executeOnMove", !1),
      we("allowVertical", !0),
      we("allowHorizontal", !0),
      we("cycles", !0)
    ], Qw = (n, s) => s.focusManager.get(n).bind((a) => xa(a, s.selector)), mv = (n, s, a) => Qw(n, a).bind((l) => a.execute(n, s, l)), Ek = (n, s, a) => {
      s.getInitial(n).orThunk(() => Po(n.element, s.selector)).each((l) => {
        s.focusManager.set(n, l);
      });
    }, Tk = (n, s, a) => (a.cycles ? Bg : dv)(n, a.selector, s, -1), $g = (n, s, a) => (a.cycles ? Bg : dv)(n, a.selector, s, 1), hC = (n) => (s, a, l, d) => n(s, a, l, d).bind(() => l.executeOnMove ? mv(s, a, l) : A.some(!0)), kk = (n, s, a) => a.onEscape(n, s), Ak = (n, s, a, l) => {
      const d = [...a.allowHorizontal ? ep : []].concat(a.allowVertical ? F1 : []), g = [...a.allowHorizontal ? ev : []].concat(a.allowVertical ? tp : []);
      return [
        go(io(d), hC(sv(Tk, $g))),
        go(io(g), hC(j1(Tk, $g))),
        go(io(Si), mv),
        go(io(Ac), mv)
      ];
    }, Jw = oe([
      go(io(Ac), U1),
      go(io(J0), kk)
    ]);
    var _k = Cm(Xw, Lu.init, Ak, Jw, () => A.some(Ek));
    const pC = (n, s, a) => A.from(n[s]).bind((l) => A.from(l[a]).map((d) => ({
      rowIndex: s,
      columnIndex: a,
      cell: d
    }))), fv = (n, s, a, l) => {
      const g = n[s].length, h = Nc(a, l, 0, g - 1);
      return pC(n, s, h);
    }, bC = (n, s, a, l) => {
      const d = Nc(a, l, 0, n.length - 1), g = n[d].length, h = nr(s, 0, g - 1);
      return pC(n, d, h);
    }, Od = (n, s, a, l) => {
      const g = n[s].length, h = nr(a + l, 0, g - 1);
      return pC(n, s, h);
    }, eE = (n, s, a, l) => {
      const d = nr(a + l, 0, n.length - 1), g = n[d].length, h = nr(s, 0, g - 1);
      return pC(n, d, h);
    }, gv = (n, s, a) => fv(n, s, a, 1), Ok = (n, s, a) => fv(n, s, a, -1), _f = (n, s, a) => bC(n, a, s, -1), Dk = (n, s, a) => bC(n, a, s, 1), Rk = (n, s, a) => Od(n, s, a, -1), a5 = (n, s, a) => Od(n, s, a, 1), c5 = (n, s, a) => eE(n, a, s, -1), rp = (n, s, a) => eE(n, a, s, 1), G1 = [
      xd("selectors", [
        Ze("row"),
        Ze("cell")
      ]),
      // Used to determine whether pressing right/down at the end cycles back to the start/top
      we("cycles", !0),
      we("previousSelector", A.none),
      we("execute", V1)
    ], vC = (n, s, a) => {
      s.previousSelector(n).orThunk(() => {
        const d = s.selectors;
        return Po(n.element, d.cell);
      }).each((d) => {
        s.focusManager.set(n, d);
      });
    }, Nk = (n, s, a) => or(n.element).bind((l) => a.execute(n, s, l)), Mk = (n, s) => ye(n, (a) => Lr(a, s.selectors.cell)), hv = (n, s) => (a, l, d) => {
      const g = d.cycles ? n : s;
      return xa(l, d.selectors.row).bind((h) => {
        const C = Lr(h, d.selectors.cell);
        return uC(C, l).bind((x) => {
          const T = Lr(a, d.selectors.row);
          return uC(T, h).bind((_) => {
            const N = Mk(T, d);
            return g(N, _, x).map((L) => L.cell);
          });
        });
      });
    }, tE = hv(Ok, Rk), nE = hv(gv, a5), q1 = hv(_f, c5), pv = hv(Dk, rp), yC = oe([
      go(io(ep), sv(tE, nE)),
      go(io(ev), j1(tE, nE)),
      go(io(F1), Rt(q1)),
      go(io(tp), Af(pv)),
      go(io(Ac.concat(Si)), Nk)
    ]), K1 = oe([
      go(io(Ac), U1)
    ]);
    var CC = Cm(G1, Lu.init, yC, K1, () => A.some(vC));
    const Pk = [
      Ze("selector"),
      we("execute", V1),
      we("moveOnTab", !1)
    ], Y1 = (n, s, a) => a.focusManager.get(n).bind((l) => a.execute(n, s, l)), oE = (n, s, a) => {
      Po(n.element, s.selector).each((l) => {
        s.focusManager.set(n, l);
      });
    }, bv = (n, s, a) => Bg(n, a.selector, s, -1), vv = (n, s, a) => Bg(n, a.selector, s, 1), Ig = (n, s, a, l) => a.moveOnTab ? _d(bv)(n, s, a, l) : A.none(), Bk = (n, s, a, l) => a.moveOnTab ? _d(vv)(n, s, a, l) : A.none(), Dd = oe([
      go(io(F1), _d(bv)),
      go(io(tp), _d(vv)),
      go(tu([Tf, io(vm)]), Ig),
      go(tu([op, io(vm)]), Bk),
      go(io(Si), Y1),
      go(io(Ac), Y1)
    ]), $k = oe([
      go(io(Ac), U1)
    ]);
    var sE = Cm(Pk, Lu.init, Dd, $k, () => A.some(oE));
    const Ik = [
      hl("onSpace"),
      hl("onEnter"),
      hl("onShiftEnter"),
      hl("onLeft"),
      hl("onRight"),
      hl("onTab"),
      hl("onShiftTab"),
      hl("onUp"),
      hl("onDown"),
      hl("onEscape"),
      we("stopSpaceKeyup", !1),
      Fo("focusIn")
    ], l5 = (n, s, a) => [
      go(io(Ac), a.onSpace),
      go(tu([op, io(Si)]), a.onEnter),
      go(tu([Tf, io(Si)]), a.onShiftEnter),
      go(tu([Tf, io(vm)]), a.onShiftTab),
      go(tu([op, io(vm)]), a.onTab),
      go(io(F1), a.onUp),
      go(io(tp), a.onDown),
      go(io(ep), a.onLeft),
      go(io(ev), a.onRight),
      go(io(Ac), a.onSpace)
    ], yv = (n, s, a) => [
      ...a.stopSpaceKeyup ? [go(io(Ac), U1)] : [],
      go(io(J0), a.onEscape)
    ];
    var Fk = Cm(Ik, Lu.init, l5, yv, (n) => n.focusIn);
    const Lk = Sk.schema(), Hk = Mw.schema(), xC = _k.schema(), zk = Kw.schema(), rE = CC.schema(), SC = Iw.schema(), Vk = sE.schema(), Uk = Fk.schema();
    var wC = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      acyclic: Lk,
      cyclic: Hk,
      flow: xC,
      flatgrid: zk,
      matrix: rE,
      execution: SC,
      menu: Vk,
      special: Uk
    });
    const aE = (n) => Un(n, "setGridSize"), Xt = eC({
      branchKey: "mode",
      branches: wC,
      name: "keying",
      active: {
        events: (n, s) => n.handler.toEvents(n, s)
      },
      apis: {
        focusIn: (n, s, a) => {
          s.sendFocusIn(s).fold(() => {
            n.getSystem().triggerFocus(n.element, n.element);
          }, (l) => {
            l(n, s, a);
          });
        },
        // These APIs are going to be interesting because they are not
        // available for all keying modes
        setGridSize: (n, s, a, l, d) => {
          aE(a) ? a.setGridSize(l, d) : console.error("Layout does not support setGridSize");
        }
      },
      state: Lw
    }), X1 = Ct("alloy-premade"), cE = (n) => (Object.defineProperty(n.element.dom, X1, {
      value: n.uid,
      writable: !0
    }), ff(X1, n)), jk = (n) => mo(n.dom, X1), EC = (n) => Vt(n, X1), Q1 = (n) => sw((s, ...a) => n(s.getApis(), s, ...a), n), Cv = (n) => n.getSystem().isConnected(), J1 = (n) => {
      Wn(n, Ci());
      const s = n.components();
      He(s, J1);
    }, ap = (n) => {
      const s = n.components();
      He(s, ap), Wn(n, Mu());
    }, TC = (n, s) => {
      n.getSystem().addToWorld(s), bo(n.element) && ap(s);
    }, kC = (n) => {
      J1(n), n.getSystem().removeFromWorld(n);
    }, lE = (n, s) => {
      Fr(n.element, s.element);
    }, AC = (n) => {
      He(n.components(), (s) => al(s.element)), hh(n.element), n.syncComponents();
    }, iE = (n, s, a) => {
      const l = n.components();
      AC(n);
      const d = a(s), g = ze(l, d);
      He(g, (h) => {
        J1(h), n.getSystem().removeFromWorld(h);
      }), He(d, (h) => {
        Cv(h) ? lE(n, h) : (n.getSystem().addToWorld(h), lE(n, h), bo(n.element) && ap(h));
      }), n.syncComponents();
    }, cp = (n, s, a) => {
      const l = n.components(), d = xe(s, (C) => EC(C).toArray());
      He(l, (C) => {
        bt(d, C) || kC(C);
      });
      const g = a(s), h = ze(l, g);
      He(h, (C) => {
        Cv(C) && kC(C);
      }), He(g, (C) => {
        Cv(C) || TC(n, C);
      }), n.syncComponents();
    }, xm = (n, s) => {
      lp(n, s, Fr);
    }, lp = (n, s, a) => {
      n.getSystem().addToWorld(s), a(n.element, s.element), bo(n.element) && ap(s), n.syncComponents();
    }, Sm = (n) => {
      J1(n), al(n.element), n.getSystem().removeFromWorld(n);
    }, wm = (n) => {
      const s = gc(n.element).bind((a) => n.getSystem().getByDom(a).toOptional());
      Sm(n), s.each((a) => {
        a.syncComponents();
      });
    }, uE = (n) => {
      const s = n.components();
      He(s, Sm), hh(n.element), n.syncComponents();
    }, eb = (n, s) => {
      dE(n, s, Fr);
    }, ou = (n, s) => {
      dE(n, s, Yp);
    }, dE = (n, s, a) => {
      a(n, s.element);
      const l = ai(s.element);
      He(l, (d) => {
        s.getByDom(d).each(ap);
      });
    }, mE = (n) => {
      const s = ai(n.element);
      He(s, (a) => {
        n.getByDom(a).each(J1);
      }), al(n.element);
    }, _C = (n, s, a) => md(n, s).map((d) => {
      if (a.exists((h) => !I(h, d))) {
        const h = a.map(Nl).getOr("span"), C = at.fromTag(h);
        return fd(d, C), C;
      } else
        return d;
    }), OC = (n, s, a) => {
      a.fold(
        // There is nothing here, so just append to the parent
        () => Fr(n, s),
        (l) => {
          I(l, s) || (fd(l, s), al(l));
        }
      );
    }, fE = (n, s, a) => {
      const l = ye(s, a), d = ai(n);
      return He(d.slice(l.length), al), l;
    }, gE = (n, s, a, l) => {
      const d = md(n, s), g = l(a, d), h = _C(n, s, d);
      return OC(n, g.element, h), g;
    }, Wk = (n, s, a) => fE(n, s, (l, d) => gE(n, d, l, a)), hE = (n, s) => fE(n, s, (a, l) => {
      const d = md(n, l);
      return OC(n, a, d), a;
    }), Fg = (n, s) => {
      const a = mr(s), l = Ir(a).bind((g) => {
        const h = (C) => I(g, C);
        return h(s) ? A.some(s) : o1(s, h);
      }), d = n(s);
      return l.each((g) => {
        Ir(a).filter((h) => I(h, g)).fold(() => {
          $r(g);
        }, U);
      }), d;
    }, DC = (n, s) => {
      Fg(() => {
        iE(n, s, () => ye(s, n.getSystem().build));
      }, n.element);
    }, pE = (n, s) => {
      Fg(() => {
        cp(n, s, () => Wk(n.element, s, n.getSystem().buildOrPatch));
      }, n.element);
    }, RC = (n, s, a, l) => {
      kC(s);
      const d = gE(n.element, a, l, n.getSystem().buildOrPatch);
      TC(n, d), n.syncComponents();
    }, NC = (n, s, a) => {
      const l = n.getSystem().build(a);
      lp(n, l, s);
    }, MC = (n, s, a, l) => {
      wm(s), NC(n, (d, g) => Xp(d, g, a), l);
    }, Zk = (n, s, a, l) => (s.reuseDom ? pE : DC)(n, l), Lg = (n, s, a, l) => {
      NC(n, Fr, l);
    }, Hg = (n, s, a, l) => {
      NC(n, gh, l);
    }, xv = (n, s, a, l) => {
      const d = Sv(n);
      Lt(d, (h) => I(l.element, h.element)).each(wm);
    }, Sv = (n, s) => n.components(), bE = (n, s, a, l, d) => {
      const g = Sv(n);
      return A.from(g[l]).map((h) => (d.fold(() => wm(h), (C) => {
        (s.reuseDom ? RC : MC)(n, h, l, C);
      }), h));
    };
    var vE = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      append: Lg,
      prepend: Hg,
      remove: xv,
      replaceAt: bE,
      replaceBy: (n, s, a, l, d) => {
        const g = Sv(n);
        return po(g, l).bind((h) => bE(n, s, a, h, d));
      },
      set: Zk,
      contents: Sv
    });
    const An = da({
      fields: [
        zr("reuseDom", !0)
      ],
      name: "replacing",
      apis: vE
    }), wv = (n, s, a) => I(s, n.element) && !I(s, a), Wl = Ts([
      Q0(dm(), (n, s) => {
        const a = s.event, l = a.originator, d = a.target;
        return wv(n, l, d) ? (console.warn(dm() + ` did not get interpreted by the desired target. 
Originator: ` + Pu(l) + `
Target: ` + Pu(d) + `
Check the ` + dm() + " event handlers"), !1) : !0;
      })
    ]);
    var tb = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: Wl
    });
    const qk = oe("alloy-id-"), Ev = oe("data-alloy-id"), Kk = qk(), PC = Ev(), BC = (n, s) => {
      const a = Ct(Kk + n);
      return nb(s, a), a;
    }, nb = (n, s) => {
      Object.defineProperty(n.dom, PC, {
        value: s,
        writable: !0
      });
    }, zu = (n) => {
      const s = mc(n) ? n.dom[PC] : null;
      return A.from(s);
    }, ip = (n) => Ct(n), Yk = Yt, zg = (n) => {
      const s = (d) => `The component must be in a context to execute: ${d}` + (n ? `
` + Pu(n().element) + " is not in context." : ""), a = (d) => () => {
        throw new Error(s(d));
      }, l = (d) => () => {
        console.warn(s(d));
      };
      return {
        debugInfo: oe("fake"),
        triggerEvent: l("triggerEvent"),
        triggerFocus: l("triggerFocus"),
        triggerEscape: l("triggerEscape"),
        broadcast: l("broadcast"),
        broadcastOn: l("broadcastOn"),
        broadcastEvent: l("broadcastEvent"),
        build: a("build"),
        buildOrPatch: a("buildOrPatch"),
        addToWorld: a("addToWorld"),
        removeFromWorld: a("removeFromWorld"),
        addToGui: a("addToGui"),
        removeFromGui: a("removeFromGui"),
        getByUid: a("getByUid"),
        getByDom: a("getByDom"),
        isConnected: an
      };
    }, ob = zg(), Tv = (n, s) => {
      const a = ye(s, (d) => (
        // Optional here probably just due to ForeignGui listing everything it supports. Can most likely
        // change it to strict once I fix the other errors.
        Wc(d.name(), [
          Ze("config"),
          we("state", Lu)
        ])
      )), l = Fs("component.behaviours", on(a), n.behaviours).fold((d) => {
        throw new Error(Rh(d) + `
Complete spec:
` + JSON.stringify(n, null, 2));
      }, Yt);
      return {
        list: s,
        data: Bs(l, (d) => {
          const g = d.map((h) => ({
            config: h.config,
            state: h.state.init(h.config)
          }));
          return oe(g);
        })
      };
    }, Wr = (n) => n.list, Xk = (n) => n.data, $C = (n, s) => {
      const a = {};
      return ds(n, (l, d) => {
        ds(l, (g, h) => {
          const C = Vt(a, h).getOr([]);
          a[h] = C.concat([
            s(d, g)
          ]);
        });
      }), a;
    }, Of = (n, s, a, l) => {
      const d = { ...s };
      He(a, (_) => {
        d[_.name()] = _.exhibit(n, l);
      });
      const g = $C(d, (_, N) => ({ name: _, modification: N })), h = (_) => oo(_, (N, L) => ({ ...L.modification, ...N }), {}), C = oo(g.classes, (_, N) => N.modification.concat(_), []), x = h(g.attributes), T = h(g.styles);
      return Hu({
        classes: C,
        attributes: x,
        styles: T
      });
    }, Rd = (n, s, a, l) => {
      try {
        const d = Io(a, (g, h) => {
          const C = g[s], x = h[s], T = l.indexOf(C), _ = l.indexOf(x);
          if (T === -1)
            throw new Error("The ordering for " + n + " does not have an entry for " + C + `.
Order specified: ` + JSON.stringify(l, null, 2));
          if (_ === -1)
            throw new Error("The ordering for " + n + " does not have an entry for " + x + `.
Order specified: ` + JSON.stringify(l, null, 2));
          return T < _ ? -1 : _ < T ? 1 : 0;
        });
        return Wt.value(d);
      } catch (d) {
        return Wt.error([d]);
      }
    }, IC = (n, s) => ({
      handler: n,
      purpose: s
    }), yE = (n, s) => ({
      cHandler: n,
      purpose: s
    }), Qk = (n, s) => yE(jt.apply(void 0, [n.handler].concat(s)), n.purpose), kv = (n) => n.cHandler, sb = (n, s) => ({
      name: n,
      handler: s
    }), Df = (n, s) => {
      const a = {};
      return He(n, (l) => {
        a[l.name()] = l.handlers(s);
      }), a;
    }, Av = (n, s, a) => {
      const l = {
        ...a,
        ...Df(s, n)
      };
      return $C(l, sb);
    }, _v = (n, s, a, l) => {
      const d = Av(n, a, l);
      return Ov(d, s);
    }, Rf = (n) => {
      const s = rk(n);
      return (a, l, ...d) => {
        const g = [a, l].concat(d);
        s.abort.apply(void 0, g) ? l.stop() : s.can.apply(void 0, g) && s.run.apply(void 0, g);
      };
    }, rb = (n, s) => Wt.error([
      "The event (" + n + `) has more than one behaviour that listens to it.
When this occurs, you must specify an event ordering for the behaviours in your spec (e.g. [ "listing", "toggling" ]).
The behaviours that can trigger it are: ` + JSON.stringify(ye(s, (a) => a.name), null, 2)
    ]), FC = (n, s, a) => {
      const l = s[a];
      return l ? Rd("Event: " + a, "name", n, l).map((d) => {
        const g = ye(d, (h) => h.handler);
        return vw(g);
      }) : rb(a, n);
    }, Ov = (n, s) => {
      const a = rs(n, (l, d) => (l.length === 1 ? Wt.value(l[0].handler) : FC(l, s, d)).map((h) => {
        const C = Rf(h), x = l.length > 1 ? Ln(s[d], (T) => cn(l, (_) => _.name === T)).join(" > ") : l[0].name;
        return ff(d, IC(C, x));
      }));
      return U3(a, {});
    }, Vu = "alloy.base.behaviour", CE = on([
      ta("dom", "dom", bi(), on([
        // Note, no children.
        Ze("tag"),
        we("styles", {}),
        we("classes", []),
        we("attributes", {}),
        Fo("value"),
        Fo("innerHtml")
      ])),
      Ze("components"),
      Ze("uid"),
      we("events", {}),
      we("apis", {}),
      // Use mergeWith in the future when pre-built behaviours conflict
      ta("eventOrder", "eventOrder", _h({
        // Note, not using constant behaviour names to avoid code size of unused behaviours
        [wa()]: ["disabling", Vu, "toggling", "typeaheadevents"],
        [dm()]: [Vu, "focusing", "keying"],
        [C1()]: [Vu, "disabling", "toggling", "representing", "tooltipping"],
        [Nu()]: [Vu, "representing", "streaming", "invalidating"],
        [Ci()]: [Vu, "representing", "item-events", "toolbar-button-events", "tooltipping"],
        [Zc()]: ["focusing", Vu, "item-type-events"],
        [gl()]: ["focusing", Vu, "item-type-events"],
        [Ul()]: ["item-type-events", "tooltipping"],
        [mm()]: ["receiving", "reflecting", "tooltipping"]
      }), pi()),
      Fo("domModification")
    ]), Nd = (n) => Fs("custom.definition", CE, n), LC = (n) => (
      // EFFICIENCY: Consider not merging here.
      {
        ...n.dom,
        uid: n.uid,
        domChildren: ye(n.components, (s) => s.element)
      }
    ), Dv = (n) => n.domModification.fold(() => Hu({}), Hu), up = (n) => n.events, ab = (n, s) => {
      const a = xo(n), l = xo(s), d = ze(l, a), g = js(n, (h, C) => !mo(s, C) || h !== s[C]).t;
      return { toRemove: d, toSet: g };
    }, Rv = (n, s) => {
      const { class: a, style: l, ...d } = gd(s), { toSet: g, toRemove: h } = ab(n.attributes, d), C = () => {
        He(h, (pe) => fs(s, pe)), Qp(s, g);
      }, x = sr(s), { toSet: T, toRemove: _ } = ab(n.styles, x), N = () => {
        He(_, (pe) => Kn(s, pe)), Ss(s, T);
      }, L = c1(s), j = ze(L, n.classes), Z = ze(n.classes, L), ne = () => {
        Zi(s, Z), ia(s, j);
      }, ae = (pe) => {
        $l(s, pe);
      }, Y = () => {
        const pe = n.domChildren;
        hE(s, pe);
      }, le = () => {
        const pe = s, Ee = n.value.getOrUndefined();
        Ee !== bc(pe) && fi(pe, Ee ?? "");
      };
      return C(), ne(), N(), n.innerHtml.fold(Y, ae), le(), s;
    }, Jk = (n) => {
      const s = at.fromTag(n.tag);
      Qp(s, n.attributes), Zi(s, n.classes), Ss(s, n.styles), n.innerHtml.each((l) => $l(s, l));
      const a = n.domChildren;
      return n0(s, a), n.value.each((l) => {
        fi(s, l);
      }), s;
    }, xE = (n, s) => {
      try {
        const a = Rv(n, s);
        return A.some(a);
      } catch {
        return A.none();
      }
    }, Nv = (n) => n.innerHtml.isSome() && n.domChildren.length > 0, eA = (n, s) => {
      const a = (d) => Nl(d) === n.tag && !Nv(n) && !jk(d), l = s.filter(a).bind((d) => xE(n, d)).getOrThunk(() => Jk(n));
      return nb(l, n.uid), l;
    }, HC = (n) => {
      const s = Vt(n, "behaviours").getOr({});
      return xe(xo(s), (a) => {
        const l = s[a];
        return un(l) ? [l.me] : [];
      });
    }, Uu = (n, s) => Tv(n, s), zC = (n) => {
      const s = HC(n);
      return Uu(n, s);
    }, tA = (n, s, a) => {
      const l = LC(n), d = Dv(n), g = {
        "alloy.base.modification": d
      }, h = s.length > 0 ? Of(a, g, s, l) : d;
      return za(l, h);
    }, SE = (n, s, a) => {
      const l = {
        "alloy.base.behaviour": up(n)
      };
      return _v(a, n.eventOrder, s, l).getOrDie();
    }, wE = (n, s) => {
      const a = () => pe, l = Pt(ob), d = yi(Nd(n)), g = zC(n), h = Wr(g), C = Xk(g), x = tA(d, h, C), T = eA(x, s), _ = SE(d, h, C), N = Pt(d.components), L = (Ee) => {
        l.set(Ee);
      }, j = () => {
        l.set(zg(a));
      }, Z = () => {
        const Ee = ai(T), Oe = xe(Ee, (gt) => l.get().getByDom(gt).fold(() => [], qn));
        N.set(Oe);
      }, ne = (Ee) => {
        const Oe = C;
        return (Xe(Oe[Ee.name()]) ? Oe[Ee.name()] : () => {
          throw new Error("Could not find " + Ee.name() + " in " + JSON.stringify(n, null, 2));
        })();
      }, ae = (Ee) => Xe(C[Ee.name()]), Y = () => d.apis, le = (Ee) => C[Ee]().map((Oe) => Oe.state.readState()).getOr("not enabled"), pe = {
        uid: n.uid,
        getSystem: l.get,
        config: ne,
        hasConfigured: ae,
        spec: n,
        readState: le,
        getApis: Y,
        connect: L,
        disconnect: j,
        element: T,
        syncComponents: Z,
        components: N.get,
        events: _
      };
      return pe;
    }, EE = (n, s) => {
      const a = Vt(n, "components").getOr([]);
      return s.fold(() => ye(a, p), (l) => ye(a, (d, g) => m(d, md(l, g))));
    }, nA = (n, s) => {
      const { events: a, ...l } = Yk(n), d = EE(l, s), g = {
        ...l,
        events: { ...tb, ...a },
        components: d
      };
      return Wt.value(
        // Note, this isn't a spec any more, because it has built children
        wE(g, s)
      );
    }, xs = (n) => {
      const s = at.fromText(n);
      return Zl({
        element: s
      });
    }, Zl = (n) => {
      const s = yc("external.component", ml([
        Ze("element"),
        Fo("uid")
      ]), n), a = Pt(zg()), l = (C) => {
        a.set(C);
      }, d = () => {
        a.set(zg(() => h));
      }, g = s.uid.getOrThunk(() => ip("external"));
      nb(s.element, g);
      const h = {
        uid: g,
        getSystem: a.get,
        config: A.none,
        hasConfigured: an,
        connect: l,
        disconnect: d,
        getApis: () => ({}),
        element: s.element,
        spec: n,
        readState: oe("No state"),
        syncComponents: U,
        components: oe([]),
        events: {}
      };
      return cE(h);
    }, dp = ip, i = (n) => mo(n, "uid"), m = (n, s) => EC(n).getOrThunk(() => {
      const a = i(n) ? n : {
        uid: dp(""),
        ...n
      };
      return nA(a, s).getOrDie();
    }), p = (n) => m(n, A.none()), y = cE;
    var z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      block: (n, s, a, l) => {
        ln(n.element, "aria-busy", !0);
        const d = s.getRoot(n).getOr(n), g = nt([
          // Trap the "Tab" key and don't let it escape.
          Xt.config({
            mode: "special",
            onTab: () => A.some(!0),
            onShiftTab: () => A.some(!0)
          }),
          En.config({})
        ]), h = l(d, g), C = d.getSystem().build(h);
        An.append(d, y(C)), C.hasConfigured(Xt) && s.focus && Xt.focusIn(C), a.isBlocked() || s.onBlock(n), a.blockWith(() => An.remove(d, C));
      },
      unblock: (n, s, a) => {
        fs(n.element, "aria-busy"), a.isBlocked() && s.onUnblock(n), a.clear();
      },
      isBlocked: (n, s, a) => a.isBlocked()
    }), K = [
      // The blocking behaviour places a blocking element over the DOM while the
      // component is in the blocked state. If a function is provided here that
      // returns Some, then the blocking element will be added as a child of the
      // element returned. Otherwise, it will be added as a child of the main
      // component.
      cs("getRoot", A.none),
      // This boolean, if provided, will specify whether the blocking element is
      // focused when the component is first blocked
      zr("focus", !0),
      // This function, if provided, will be called any time the component is
      // blocked (unless it was already blocked).
      yo("onBlock"),
      // This function, if provided, will be called any time the component is
      // unblocked (unless it was already unblocked).
      yo("onUnblock")
    ], Ce = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const n = Zm(), s = (a) => {
          n.set({ destroy: a });
        };
        return vl({
          readState: n.isSet,
          blockWith: s,
          clear: n.clear,
          isBlocked: n.isSet
        });
      }
    });
    const Ge = da({
      fields: K,
      name: "blocking",
      apis: z,
      state: Ce
    });
    var wt = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getCurrent: (n, s, a) => s.find(n)
    });
    const Gt = [
      Ze("find")
    ], Fe = da({
      fields: Gt,
      name: "composing",
      apis: wt
    });
    var Bn = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getCoupled: (n, s, a, l) => a.getOrCreate(n, s, l),
      getExistingCoupled: (n, s, a, l) => a.getExisting(n, s, l)
    }), Bt = [
      Uc("others", jS(Wt.value, pi()))
    ], $o = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const n = {}, s = (g, h) => {
          if (xo(g.others).length === 0)
            throw new Error("Cannot find any known coupled components");
          return Vt(n, h);
        }, a = (g, h, C) => s(h, C).getOrThunk(() => {
          const T = Vt(h.others, C).getOrDie("No information found for coupled component: " + C)(g), _ = g.getSystem().build(T);
          return n[C] = _, _;
        }), l = (g, h, C) => s(h, C).orThunk(() => (Vt(h.others, C).getOrDie("No information found for coupled component: " + C), A.none())), d = oe({});
        return vl({
          readState: d,
          getExisting: l,
          getOrCreate: a
        });
      }
    });
    const Rn = da({
      fields: Bt,
      name: "coupling",
      apis: Bn,
      state: $o
    }), br = [
      "input",
      "button",
      "textarea",
      "select"
    ], wi = (n, s, a) => {
      (s.disabled() ? oc : Gl)(n, s);
    }, Em = (n, s) => s.useNative === !0 && bt(br, Nl(n.element)), Nf = (n) => Jr(n.element, "disabled"), Vg = (n) => {
      ln(n.element, "disabled", "disabled");
    }, Ko = (n) => {
      fs(n.element, "disabled");
    }, _c = (n) => Dr(n.element, "aria-disabled") === "true", Ys = (n) => {
      ln(n.element, "aria-disabled", "true");
    }, ju = (n) => {
      ln(n.element, "aria-disabled", "false");
    }, oc = (n, s, a) => {
      s.disableClass.each((d) => {
        Uo(n.element, d);
      }), (Em(n, s) ? Vg : Ys)(n), s.onDisabled(n);
    }, Gl = (n, s, a) => {
      s.disableClass.each((d) => {
        Ds(n.element, d);
      }), (Em(n, s) ? Ko : ju)(n), s.onEnabled(n);
    }, ka = (n, s) => Em(n, s) ? Nf(n) : _c(n);
    var cb = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      enable: Gl,
      disable: oc,
      isDisabled: ka,
      onLoad: wi,
      set: (n, s, a, l) => {
        (l ? oc : Gl)(n, s);
      }
    }), oA = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (n, s) => Hu({
        // Do not add the attribute yet, because it will depend on the node name
        // if we use "aria-disabled" or just "disabled"
        classes: s.disabled() ? s.disableClass.toArray() : []
      }),
      events: (n, s) => Ts([
        X0(wa(), (a, l) => ka(a, n)),
        Y2(n, s, wi)
      ])
    }), TE = [
      cs("disabled", an),
      we("useNative", !0),
      Fo("disableClass"),
      yo("onDisabled"),
      yo("onEnabled")
    ];
    const Ft = da({
      fields: TE,
      name: "disabling",
      active: oA,
      apis: cb
    }), qc = (n, s, a, l, d) => {
      const g = (h) => h + "px";
      return {
        position: n,
        left: s.map(g),
        top: a.map(g),
        right: l.map(g),
        bottom: d.map(g)
      };
    }, sA = (n) => ({
      ...n,
      position: A.some(n.position)
    }), Pv = (n, s) => {
      ea(n, sA(s));
    }, kE = (n, s) => {
      const a = n.element;
      Uo(a, s.transitionClass), Ds(a, s.fadeOutClass), Uo(a, s.fadeInClass), s.onShow(n);
    }, Ug = (n, s) => {
      const a = n.element;
      Uo(a, s.transitionClass), Ds(a, s.fadeInClass), Uo(a, s.fadeOutClass), s.onHide(n);
    }, rA = (n, s) => n.y < s.bottom && n.bottom > s.y, AE = (n, s) => n.y >= s.y, VC = (n, s) => n.bottom <= s.bottom, UC = (n, s, a) => ({
      location: "top",
      leftX: s,
      topY: a.bounds.y - n.y
    }), _E = (n, s, a) => ({
      location: "bottom",
      leftX: s,
      bottomY: n.bottom - a.bounds.bottom
    }), jC = (n) => n.box.x - n.win.x, b7 = (n, s, a) => {
      const l = s.win, d = s.box, g = jC(s);
      return ga(n, (h) => {
        switch (h) {
          case "bottom":
            return VC(d, a.bounds) ? A.none() : A.some(_E(l, g, a));
          case "top":
            return AE(d, a.bounds) ? A.none() : A.some(UC(l, g, a));
          default:
            return A.none();
        }
      }).getOr({
        location: "no-dock"
      });
    }, v7 = (n, s, a) => We(n, (l) => {
      switch (l) {
        case "bottom":
          return VC(s, a.bounds);
        case "top":
          return AE(s, a.bounds);
      }
    }), y7 = (n, s) => {
      const a = s.optScrollEnv.fold(oe(n.bounds.y), (l) => l.scrollElmTop + (n.bounds.y - l.currentScrollTop));
      return Mo(n.bounds.x, a);
    }, WC = (n, s) => {
      const a = s.optScrollEnv.fold(oe(n.y), (l) => n.y + l.currentScrollTop - l.scrollElmTop);
      return Mo(n.x, a);
    }, ZC = (n, s, a) => a.getInitialPos().map((l) => {
      const d = y7(l, s);
      return {
        box: Rr(d.left, d.top, la(n), hr(n)),
        location: l.location
      };
    }), i5 = (n, s, a, l, d) => {
      const g = WC(s, a), h = Rr(g.left, g.top, s.width, s.height);
      l.setInitialPos({
        style: sr(n),
        position: gs(n, "position") || "static",
        bounds: h,
        location: d.location
      });
    }, u5 = (n, s, a, l, d) => {
      l.getInitialPos().fold(() => i5(n, s, a, l, d), () => U);
    }, d5 = (n, s, a) => a.getInitialPos().bind((l) => {
      switch (a.clearInitialPos(), l.position) {
        case "static":
          return A.some({
            morph: "static"
          });
        case "absolute":
          const d = lf(n).getOr(Lc()), g = wr(d), h = d.dom.scrollTop ?? 0;
          return A.some({
            morph: "absolute",
            positionCss: qc("absolute", Vt(l.style, "left").map((C) => s.x - g.x), Vt(l.style, "top").map((C) => s.y - g.y + h), Vt(l.style, "right").map((C) => g.right - s.right), Vt(l.style, "bottom").map((C) => g.bottom - s.bottom))
          });
        default:
          return A.none();
      }
    }), m5 = (n, s, a) => ZC(n, s, a).filter(({ box: l }) => v7(a.getModes(), l, s)).bind(({ box: l }) => d5(n, l, a)), GC = (n) => {
      switch (n.location) {
        case "top":
          return A.some({
            morph: "fixed",
            positionCss: qc("fixed", A.some(n.leftX), A.some(n.topY), A.none(), A.none())
          });
        case "bottom":
          return A.some({
            morph: "fixed",
            positionCss: qc("fixed", A.some(n.leftX), A.none(), A.none(), A.some(n.bottomY))
          });
        default:
          return A.none();
      }
    }, Bv = (n, s, a) => {
      const l = wr(n), d = Ia(), g = b7(a.getModes(), {
        win: d,
        box: l
      }, s);
      return g.location === "top" || g.location === "bottom" ? (i5(n, l, s, a, g), GC(g)) : A.none();
    }, aA = (n, s, a) => m5(n, s, a).orThunk(() => s.optScrollEnv.bind((l) => ZC(n, s, a)).bind(({ box: l, location: d }) => {
      const g = Ia(), h = jC({ win: g, box: l }), C = d === "top" ? UC(g, h, s) : _E(g, h, s);
      return GC(C);
    })), C7 = (n, s, a) => {
      const l = n.element;
      return uc(Cs(l, "position"), "fixed") ? aA(l, s, a) : Bv(l, s, a);
    }, x7 = (n, s, a) => {
      const l = n.element;
      return ZC(l, s, a).bind(({ box: d }) => d5(l, d, a));
    }, f5 = (n, s, a, l) => {
      const d = wr(n), g = Ia(), h = jC({ win: g, box: d }), C = l(g, h, s);
      return C.location === "bottom" || C.location === "top" ? (u5(n, d, s, a, C), GC(C)) : A.none();
    }, jg = (n, s, a) => {
      a.setDocked(!1), He(["left", "right", "top", "bottom", "position"], (l) => Kn(n.element, l)), s.onUndocked(n);
    }, qC = (n, s, a, l) => {
      const d = l.position === "fixed";
      a.setDocked(d), Pv(n.element, l), (d ? s.onDocked : s.onUndocked)(n);
    }, OE = (n, s, a, l, d = !1) => {
      s.contextual.each((g) => {
        g.lazyContext(n).each((h) => {
          const C = rA(h, l.bounds);
          C !== a.isVisible() && (a.setVisible(C), d && !C ? (Zi(n.element, [g.fadeOutClass]), g.onHide(n)) : (C ? kE : Ug)(n, g));
        });
      });
    }, KC = (n, s, a, l, d) => {
      OE(n, s, a, l, !0), qC(n, s, a, d.positionCss);
    }, g5 = (n, s, a, l, d) => {
      switch (d.morph) {
        case "static":
          return jg(n, s, a);
        case "absolute":
          return qC(n, s, a, d.positionCss);
        case "fixed":
          return KC(n, s, a, l, d);
      }
    }, DE = (n, s, a) => {
      const l = s.lazyViewport(n);
      OE(n, s, a, l), C7(n, l, a).each((d) => {
        g5(n, s, a, l, d);
      });
    }, cA = (n, s, a) => {
      const l = n.element;
      a.setDocked(!1);
      const d = s.lazyViewport(n);
      x7(n, d, a).each((g) => {
        switch (g.morph) {
          case "static": {
            jg(n, s, a);
            break;
          }
          case "absolute": {
            qC(n, s, a, g.positionCss);
            break;
          }
        }
      }), a.setVisible(!0), s.contextual.each((g) => {
        ia(l, [g.fadeInClass, g.fadeOutClass, g.transitionClass]), g.onShow(n);
      }), RE(n, s, a);
    }, RE = (n, s, a) => {
      n.getSystem().isConnected() && DE(n, s, a);
    }, h5 = (n, s, a) => {
      a.isDocked() && cA(n, s, a);
    }, km = (n) => (s, a, l) => {
      const d = a.lazyViewport(s);
      f5(s.element, d, l, n).each((h) => {
        KC(s, a, l, d, h);
      });
    }, S7 = km(UC), w7 = km(_E);
    var lA = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      refresh: RE,
      reset: h5,
      isDocked: (n, s, a) => a.isDocked(),
      getModes: (n, s, a) => a.getModes(),
      setModes: (n, s, a, l) => a.setModes(l),
      forceDockToTop: S7,
      forceDockToBottom: w7
    }), p5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n, s) => Ts([
        Jh(v0(), (a, l) => {
          n.contextual.each((d) => {
            ar(a.element, d.transitionClass) && (ia(a.element, [d.transitionClass, d.fadeInClass]), (s.isVisible() ? d.onShown : d.onHidden)(a)), l.stop();
          });
        }),
        Ie(E2(), (a, l) => {
          RE(a, n, s);
        }),
        Ie(XS(), (a, l) => {
          RE(a, n, s);
        }),
        Ie(Lh(), (a, l) => {
          h5(a, n, s);
        })
      ])
    }), iA = [
      Wc("contextual", [
        qs("fadeInClass"),
        qs("fadeOutClass"),
        qs("transitionClass"),
        fl("lazyContext"),
        yo("onShow"),
        yo("onShown"),
        yo("onHide"),
        yo("onHidden")
      ]),
      cs("lazyViewport", () => ({
        bounds: Ia(),
        optScrollEnv: A.none()
      })),
      df("modes", ["top", "bottom"], Hr),
      yo("onDocked"),
      yo("onUndocked")
    ], b5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: (n) => {
        const s = Pt(!1), a = Pt(!0), l = hn(), d = Pt(n.modes), g = () => `docked:  ${s.get()}, visible: ${a.get()}, modes: ${d.get().join(",")}`;
        return vl({
          isDocked: s.get,
          setDocked: s.set,
          getInitialPos: l.get,
          setInitialPos: l.set,
          clearInitialPos: l.clear,
          isVisible: a.get,
          setVisible: a.set,
          getModes: d.get,
          setModes: d.set,
          readState: g
        });
      }
    });
    const Ns = da({
      fields: iA,
      name: "docking",
      active: p5,
      apis: lA,
      state: b5
    }), uA = Ma.generate([
      { offset: ["x", "y"] },
      { absolute: ["x", "y"] },
      { fixed: ["x", "y"] }
    ]), NE = (n) => (s) => s.translate(-n.left, -n.top), XC = (n) => (s) => s.translate(n.left, n.top), Mf = (n) => (s, a) => ao(n, (l, d) => d(l), Mo(s, a)), ME = (n, s, a) => n.fold(
      // offset to fixed
      Mf([XC(a), NE(s)]),
      // absolute to fixed
      Mf([NE(s)]),
      // fixed to fixed
      Mf([])
    ), $v = (n, s, a) => n.fold(
      // offset to absolute
      Mf([XC(a)]),
      // absolute to absolute
      Mf([]),
      // fixed to absolute
      Mf([XC(s)])
    ), dA = (n, s, a) => n.fold(
      // offset to offset
      Mf([]),
      // absolute to offset
      Mf([NE(a)]),
      // fixed to offset
      Mf([XC(s), NE(a)])
    ), v5 = (n, s, a, l, d, g) => {
      const h = $v(n, d, g), C = $v(s, d, g);
      return Math.abs(h.left - C.left) <= a && Math.abs(h.top - C.top) <= l;
    }, y5 = (n, s, a, l, d, g) => {
      const h = $v(n, d, g), C = $v(s, d, g), x = Math.abs(h.left - C.left), T = Math.abs(h.top - C.top);
      return Mo(x, T);
    }, mA = (n, s, a) => {
      const l = n.fold(
        (d, g) => ({ position: A.some("absolute"), left: A.some(d + "px"), top: A.some(g + "px") }),
        // offset
        (d, g) => ({ position: A.some("absolute"), left: A.some(d - a.left + "px"), top: A.some(g - a.top + "px") }),
        // absolute
        (d, g) => ({ position: A.some("fixed"), left: A.some(d + "px"), top: A.some(g + "px") })
        // fixed
      );
      return { right: A.none(), bottom: A.none(), ...l };
    }, PE = (n, s, a) => n.fold((l, d) => Pf(l + s, d + a), (l, d) => Pd(l + s, d + a), (l, d) => lb(l + s, d + a)), BE = (n, s, a, l) => {
      const d = (g, h) => (C, x) => {
        const T = g(s, a, l);
        return h(C.getOr(T.left), x.getOr(T.top));
      };
      return n.fold(d(dA, Pf), d($v, Pd), d(ME, lb));
    }, Pf = uA.offset, Pd = uA.absolute, lb = uA.fixed, C5 = (n, s) => {
      const a = Dr(n, s);
      return Cn(a) ? NaN : parseInt(a, 10);
    }, E7 = (n, s) => {
      const a = n.element, l = C5(a, s.leftAttr), d = C5(a, s.topAttr);
      return isNaN(l) || isNaN(d) ? A.none() : A.some(Mo(l, d));
    }, T7 = (n, s, a) => {
      const l = n.element;
      ln(l, s.leftAttr, a.left + "px"), ln(l, s.topAttr, a.top + "px");
    }, x5 = (n, s) => {
      const a = n.element;
      fs(a, s.leftAttr), fs(a, s.topAttr);
    }, k7 = (n, s, a, l) => E7(n, s).fold(() => a, (d) => (
      // We have a pre-snap position, so we have to apply the delta ourselves
      lb(d.left + l.left, d.top + l.top)
    )), S5 = (n, s, a, l, d, g) => {
      const h = k7(n, s, a, l), C = s.mustSnap ? E5(n, s, h, d, g) : Iv(n, s, h, d, g), x = ME(h, d, g);
      return T7(n, s, x), C.fold(
        () => ({
          coord: lb(x.left, x.top),
          extra: A.none()
        }),
        (T) => ({
          coord: T.output,
          extra: T.extra
        })
      );
    }, A7 = (n, s) => {
      x5(n, s);
    }, w5 = (n, s, a, l) => ga(n, (d) => {
      const g = d.sensor;
      return v5(s, g, d.range.left, d.range.top, a, l) ? A.some({
        output: BE(d.output, s, a, l),
        extra: d.extra
      }) : A.none();
    }), E5 = (n, s, a, l, d) => {
      const g = s.getSnapPoints(n);
      return w5(g, a, l, d).orThunk(() => ao(g, (x, T) => {
        const _ = T.sensor, N = y5(a, _, T.range.left, T.range.top, l, d);
        return x.deltas.fold(() => ({
          deltas: A.some(N),
          snap: A.some(T)
        }), (L) => {
          const j = (N.left + N.top) / 2, Z = (L.left + L.top) / 2;
          return j <= Z ? {
            deltas: A.some(N),
            snap: A.some(T)
          } : x;
        });
      }, {
        deltas: A.none(),
        snap: A.none()
      }).snap.map((x) => ({
        output: BE(x.output, a, l, d),
        extra: x.extra
      })));
    }, Iv = (n, s, a, l, d) => {
      const g = s.getSnapPoints(n);
      return w5(g, a, l, d);
    }, T5 = (n, s, a) => ({
      // TODO: This looks to be incorrect and needs fixing as DragCoord definitely needs a number
      // based drag coord for the second argument here, so this is probably a bug.
      coord: BE(n.output, n.output, s, a),
      extra: n.extra
    });
    var O7 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      snapTo: (n, s, a, l) => {
        const d = s.getTarget(n.element);
        if (s.repositionTarget) {
          const g = fc(n.element), h = Ls(g), C = i0(d), x = T5(l, h, C), T = mA(x.coord, h, C);
          ea(d, T);
        }
      }
    });
    const Aa = (n, s) => mf(n, {}, ye(s, (a) => z3(a.name(), "Cannot configure " + a.name() + " for " + n)).concat([
      xc("dump", Yt)
    ])), QC = (n) => n.dump, rc = (n, s) => ({
      ...nt(s),
      ...n.dump
    }), Bd = {
      field: Aa,
      augment: rc,
      get: QC
    }, D7 = (n, s) => (n.length > 0 ? [
      xd("parts", n)
    ] : []).concat([
      Ze("uid"),
      we("dom", {}),
      // Maybe get rid of.
      we("components", []),
      nw("originalSpec"),
      we("debug.sketcher", {})
    ]).concat(s), k5 = (n, s, a, l, d) => {
      const g = D7(l, d);
      return yc(n + " [SpecSchema]", ml(g.concat(s)), a);
    }, R7 = (n, s, a, l) => {
      const d = IE(l), g = k5(n, s, d, [], []);
      return a(g, d);
    }, fA = (n, s, a, l, d) => {
      const g = IE(d), h = Ur(a), C = pm(a), x = k5(n, s, g, h, [C]), T = Gc(n, x, a), _ = $0(n, x, T.internals());
      return l(x, _, g, T.externals());
    }, $E = (n) => mo(n, "uid"), IE = (n) => $E(n) ? n : {
      ...n,
      uid: ip("uid")
    }, N7 = (n) => n.uid !== void 0, IY = ml([
      Ze("name"),
      Ze("factory"),
      Ze("configFields"),
      we("apis", {}),
      we("extraApis", {})
    ]), A5 = ml([
      Ze("name"),
      Ze("factory"),
      Ze("configFields"),
      Ze("partFields"),
      we("apis", {}),
      we("extraApis", {})
    ]), su = (n) => {
      const s = yc("Sketcher for " + n.name, IY, n), a = (g) => R7(s.name, s.configFields, s.factory, g), l = Bs(s.apis, Q1), d = Bs(s.extraApis, (g, h) => E1(g, h));
      return {
        name: s.name,
        configFields: s.configFields,
        sketch: a,
        ...l,
        ...d
      };
    }, yl = (n) => {
      const s = yc("Sketcher for " + n.name, A5, n), a = (h) => fA(s.name, s.configFields, s.partFields, s.factory, h), l = bf(s.name, s.partFields), d = Bs(s.apis, Q1), g = Bs(s.extraApis, (h, C) => E1(h, C));
      return {
        name: s.name,
        partFields: s.partFields,
        configFields: s.configFields,
        sketch: a,
        parts: l,
        ...d,
        ...g
      };
    }, Am = su({
      name: "Container",
      factory: (n) => {
        const { attributes: s, ...a } = n.dom;
        return {
          uid: n.uid,
          dom: {
            tag: "div",
            attributes: {
              role: "presentation",
              ...s
            },
            ...a
          },
          components: n.components,
          behaviours: QC(n.containerBehaviours),
          events: n.events,
          domModification: n.domModification,
          eventOrder: n.eventOrder
        };
      },
      configFields: [
        we("components", []),
        Aa("containerBehaviours", []),
        // TODO: Deprecate
        we("events", {}),
        we("domModification", {}),
        we("eventOrder", {})
      ]
    }), gA = "data-initial-z-index", M7 = (n) => {
      gc(n.element).filter(mc).each((s) => {
        Qr(s, gA).fold(() => Kn(s, "z-index"), (a) => gn(s, "z-index", a)), fs(s, gA);
      });
    }, P7 = (n) => {
      gc(n.element).filter(mc).each((s) => {
        Cs(s, "z-index").each((a) => {
          ln(s, gA, a);
        }), gn(s, "z-index", gs(n.element, "z-index"));
      });
    }, _5 = (n, s) => {
      n.getSystem().addToGui(s), P7(s);
    }, Fv = (n) => {
      M7(n), n.getSystem().removeFromGui(n);
    }, FE = (n, s, a) => n.getSystem().build(Am.sketch({
      dom: {
        // Probably consider doing with classes?
        styles: {
          left: "0px",
          top: "0px",
          width: "100%",
          height: "100%",
          position: "fixed",
          "z-index": "1000000000000000"
        },
        classes: [s]
      },
      events: a
    }));
    var B7 = Wc("snaps", [
      Ze("getSnapPoints"),
      yo("onSensor"),
      Ze("leftAttr"),
      Ze("topAttr"),
      we("lazyViewport", Ia),
      we("mustSnap", !1)
    ]);
    const JC = [
      // Is this used?
      we("useFixed", an),
      Ze("blockerClass"),
      we("getTarget", Yt),
      we("onDrag", U),
      we("repositionTarget", !0),
      we("onDrop", U),
      cs("getBounds", Ia),
      B7
    ], LE = (n) => Pr(Cs(n, "left"), Cs(n, "top"), Cs(n, "position"), (s, a, l) => (l === "fixed" ? lb : Pf)(parseInt(s, 10), parseInt(a, 10))).getOrThunk(() => {
      const s = Ca(n);
      return Pd(s.left, s.top);
    }), hA = (n, s, a, l, d) => {
      const g = d.bounds, h = $v(s, a, l), C = nr(h.left, g.x, g.x + g.width - d.width), x = nr(h.top, g.y, g.y + g.height - d.height), T = Pd(C, x);
      return s.fold(
        // offset
        () => {
          const _ = dA(T, a, l);
          return Pf(_.left, _.top);
        },
        // absolute
        oe(T),
        // fixed
        () => {
          const _ = ME(T, a, l);
          return lb(_.left, _.top);
        }
      );
    }, $7 = (n, s, a, l, d, g, h) => {
      const C = s.fold(() => {
        const x = PE(a, g.left, g.top), T = ME(x, l, d);
        return lb(T.left, T.top);
      }, (x) => {
        const T = S5(n, x, a, g, l, d);
        return T.extra.each((_) => {
          x.onSensor(n, _);
        }), T.coord;
      });
      return hA(n, C, l, d, h);
    }, I7 = (n, s, a, l) => {
      const d = s.getTarget(n.element);
      if (s.repositionTarget) {
        const g = fc(n.element), h = Ls(g), C = i0(d), x = LE(d), T = $7(n, s.snaps, x, h, C, l, a), _ = mA(T, h, C);
        ea(d, _);
      }
      s.onDrag(n, d, l);
    }, O5 = (n, s) => ({
      bounds: n.getBounds(),
      height: pr(s.element),
      width: Au(s.element)
    }), pA = (n, s, a, l, d) => {
      const g = a.update(l, d), h = a.getStartData().getOrThunk(() => O5(s, n));
      g.each((C) => {
        I7(n, s, h, C);
      });
    }, D5 = (n, s, a, l) => {
      s.each(Fv), a.snaps.each((g) => {
        A7(n, g);
      });
      const d = a.getTarget(n.element);
      l.reset(), a.onDrop(n, d);
    }, bA = (n) => (s, a) => {
      const l = (d) => {
        a.setStartData(O5(s, d));
      };
      return Ts([
        Ie(E2(), (d) => {
          a.getStartData().each(() => l(d));
        }),
        ...n(s, a, l)
      ]);
    }, F7 = (n) => Ts([
      // When the user clicks on the blocker, something has probably gone slightly
      // wrong, so we'll just drop for safety. The blocker should really only
      // be there when the mouse is already down and not released, so a 'click'
      Ie(Zc(), n.forceDrop),
      // When the user releases the mouse on the blocker, that is a drop
      Ie(b0(), n.drop),
      // As the user moves the mouse around (while pressed down), we move the
      // component around
      Ie(Bh(), (s, a) => {
        n.move(a.event);
      }),
      // When the use moves outside the range, schedule a block to occur but
      // give it a chance to be cancelled.
      Ie(Nr(), n.delayDrop)
    ]);
    var H7 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getData: (n) => A.from(Mo(n.x, n.y)),
      getDelta: (n, s) => Mo(s.left - n.left, s.top - n.top)
    });
    const R5 = (n, s, a) => [
      Ie(Zc(), (l, d) => {
        if (d.event.raw.button !== 0)
          return;
        d.stop();
        const h = () => D5(l, A.some(T), n, s), C = G3(h, 200), x = {
          drop: h,
          delayDrop: C.schedule,
          forceDrop: h,
          move: (N) => {
            C.cancel(), pA(l, n, s, H7, N);
          }
        }, T = FE(l, n.blockerClass, F7(x));
        (() => {
          a(l), _5(l, T);
        })();
      })
    ], z7 = [
      ...JC,
      Do("dragger", {
        handlers: bA(R5)
      })
    ], V7 = (n) => Ts([
      // When the user taps on the blocker, something has probably gone slightly
      // wrong, so we'll just drop for safety. The blocker should really only
      // be there when their finger is already down and not released, so a 'tap'
      Ie(gl(), n.forceDrop),
      // When the user releases their finger on the blocker, that is a drop
      Ie(gf(), n.drop),
      Ie(v1(), n.drop),
      // As the user moves their finger around (while pressed down), we move the
      // component around
      Ie(ir(), (s, a) => {
        n.move(a.event);
      })
    ]), Lv = (n) => {
      const s = n[0];
      return A.some(Mo(s.clientX, s.clientY));
    };
    var HE = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getData: (n) => {
        const a = n.raw.touches;
        return a.length === 1 ? Lv(a) : A.none();
      },
      getDelta: (n, s) => Mo(s.left - n.left, s.top - n.top)
    });
    const M5 = (n, s, a) => {
      const l = hn(), d = (g) => {
        D5(g, l.get(), n, s), l.clear();
      };
      return [
        Ie(gl(), (g, h) => {
          h.stop();
          const C = () => d(g), x = {
            drop: C,
            // delayDrop is not used by touch
            delayDrop: U,
            forceDrop: C,
            move: (N) => {
              pA(g, n, s, HE, N);
            }
          }, T = FE(g, n.blockerClass, V7(x));
          l.set(T), (() => {
            a(g), _5(g, T);
          })();
        }),
        Ie(ir(), (g, h) => {
          h.stop(), pA(g, n, s, HE, h.event);
        }),
        Ie(gf(), (g, h) => {
          h.stop(), d(g);
        }),
        Ie(v1(), d)
      ];
    }, Et = [
      ...JC,
      Do("dragger", {
        handlers: bA(M5)
      })
    ], ib = (n, s, a) => [
      ...R5(n, s, a),
      ...M5(n, s, a)
    ], U7 = [
      ...JC,
      Do("dragger", {
        handlers: bA(ib)
      })
    ];
    var W7 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      mouse: z7,
      touch: Et,
      mouseOrTouch: U7
    }), B5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        let n = A.none(), s = A.none();
        const a = () => {
          n = A.none(), s = A.none();
        }, l = (x, T) => {
          const _ = n.map((N) => x.getDelta(N, T));
          return n = A.some(T), _;
        }, d = (x, T) => x.getData(T).bind((_) => l(x, _)), g = (x) => {
          s = A.some(x);
        }, h = () => s, C = oe({});
        return vl({
          readState: C,
          reset: a,
          update: d,
          getStartData: h,
          setStartData: g
        });
      }
    });
    const Wg = eC({
      branchKey: "mode",
      branches: W7,
      name: "dragging",
      active: {
        events: (n, s) => n.dragger.handlers(n, s)
      },
      extra: {
        // Extra. Does not need component as input.
        snap: (n) => ({
          sensor: n.sensor,
          range: n.range,
          output: n.output,
          extra: A.from(n.extra)
        })
      },
      state: B5,
      apis: O7
    }), G7 = [
      "input",
      "textarea"
    ], CA = (n) => {
      const s = Nl(n);
      return bt(G7, s);
    }, $5 = (n, s) => {
      const a = s.getRoot(n).getOr(n.element);
      Ds(a, s.invalidClass), s.notify.each((l) => {
        CA(n.element) && ln(n.element, "aria-invalid", !1), l.getContainer(n).each((d) => {
          $l(d, l.validHtml);
        }), l.onValid(n);
      });
    }, I5 = (n, s, a, l) => {
      const d = s.getRoot(n).getOr(n.element);
      Uo(d, s.invalidClass), s.notify.each((g) => {
        CA(n.element) && ln(n.element, "aria-invalid", !0), g.getContainer(n).each((h) => {
          $l(h, l);
        }), g.onInvalid(n, l);
      });
    }, xA = (n, s, a) => s.validator.fold(() => Zo.pure(Wt.value(!0)), (l) => l.validate(n)), SA = (n, s, a) => (s.notify.each((l) => {
      l.onValidate(n);
    }), xA(n, s).map((l) => n.getSystem().isConnected() ? l.fold((d) => (I5(n, s, a, d), Wt.error(d)), (d) => ($5(n, s), Wt.value(d))) : Wt.error("No longer in system")));
    var wA = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      markValid: $5,
      markInvalid: I5,
      query: xA,
      run: SA,
      isInvalid: (n, s) => {
        const a = s.getRoot(n).getOr(n.element);
        return ar(a, s.invalidClass);
      }
    }), zE = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n, s) => n.validator.map((a) => Ts([
        Ie(a.onEvent, (l) => {
          SA(l, n, s).get(Yt);
        })
      ].concat(a.validateOnLoad ? [
        hs((l) => {
          SA(l, n, s).get(U);
        })
      ] : []))).getOr({})
    }), VE = [
      Ze("invalidClass"),
      we("getRoot", A.none),
      // TODO: Completely rework the notify API
      Wc("notify", [
        we("aria", "alert"),
        // Maybe we should use something else.
        we("getContainer", A.none),
        we("validHtml", ""),
        yo("onValid"),
        yo("onInvalid"),
        yo("onValidate")
      ]),
      Wc("validator", [
        Ze("validate"),
        we("onEvent", "input"),
        we("validateOnLoad", !0)
      ])
    ];
    const Hv = (n, s, a) => {
      s.store.manager.onLoad(n, s, a);
    }, _m = (n, s, a) => {
      s.store.manager.onUnload(n, s, a);
    };
    var zY = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      onLoad: Hv,
      onUnload: _m,
      setValue: (n, s, a, l) => {
        s.store.manager.setValue(n, s, a, l);
      },
      getValue: (n, s, a) => s.store.manager.getValue(n, s, a),
      getState: (n, s, a) => a
    }), Y7 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n, s) => {
        const a = n.resetOnDom ? [
          hs((l, d) => {
            Hv(l, n, s);
          }),
          eu((l, d) => {
            _m(l, n, s);
          })
        ] : [
          Y2(n, s, Hv)
        ];
        return Ts(a);
      }
    });
    const UE = () => {
      const n = Pt(null), s = () => ({
        mode: "memory",
        value: n.get()
      }), a = () => n.get() === null, l = () => {
        n.set(null);
      };
      return vl({
        set: n.set,
        get: n.get,
        isNotSet: a,
        clear: l,
        readState: s
      });
    }, X7 = () => vl({
      readState: U
    }), F5 = () => {
      const n = Pt({}), s = Pt({});
      return vl({
        readState: () => ({
          mode: "dataset",
          dataByValue: n.get(),
          dataByText: s.get()
        }),
        lookup: (h) => Vt(n.get(), h).orThunk(() => Vt(s.get(), h)),
        update: (h) => {
          const C = n.get(), x = s.get(), T = {}, _ = {};
          He(h, (N) => {
            T[N.value] = N, Vt(N, "meta").each((L) => {
              Vt(L, "text").each((j) => {
                _[j] = N;
              });
            });
          }), n.set({
            ...C,
            ...T
          }), s.set({
            ...x,
            ..._
          });
        },
        clear: () => {
          n.set({}), s.set({});
        }
      });
    };
    var L5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      memory: UE,
      dataset: F5,
      manual: X7,
      init: (n) => n.store.manager.state(n)
    });
    const H5 = (n, s, a, l) => {
      const d = s.store;
      a.update([l]), d.setValue(n, l), s.onSetValue(n, l);
    }, Q7 = (n, s, a) => {
      const l = s.store, d = l.getDataKey(n);
      return a.lookup(d).getOrThunk(() => l.getFallbackEntry(d));
    }, z5 = (n, s, a) => {
      s.store.initialValue.each((d) => {
        H5(n, s, a, d);
      });
    }, V5 = (n, s, a) => {
      a.clear();
    };
    var J7 = [
      Fo("initialValue"),
      Ze("getFallbackEntry"),
      Ze("getDataKey"),
      Ze("setValue"),
      Do("manager", {
        setValue: H5,
        getValue: Q7,
        onLoad: z5,
        onUnload: V5,
        state: F5
      })
    ];
    const U5 = (n, s, a) => s.store.getValue(n), eH = (n, s, a, l) => {
      s.store.setValue(n, l), s.onSetValue(n, l);
    }, EA = (n, s, a) => {
      s.store.initialValue.each((l) => {
        s.store.setValue(n, l);
      });
    };
    var j5 = [
      Ze("getValue"),
      we("setValue", U),
      Fo("initialValue"),
      Do("manager", {
        setValue: eH,
        getValue: U5,
        onLoad: EA,
        onUnload: U,
        state: Lu.init
      })
    ];
    const W5 = (n, s, a, l) => {
      a.set(l), s.onSetValue(n, l);
    }, Z5 = (n, s, a) => a.get(), tH = (n, s, a) => {
      s.store.initialValue.each((l) => {
        a.isNotSet() && a.set(l);
      });
    }, nH = (n, s, a) => {
      a.clear();
    };
    var oH = [
      Fo("initialValue"),
      Do("manager", {
        setValue: W5,
        getValue: Z5,
        onLoad: tH,
        onUnload: nH,
        state: UE
      })
    ], sH = [
      Vl("store", { mode: "memory" }, Cc("mode", {
        memory: oH,
        manual: j5,
        dataset: J7
      })),
      yo("onSetValue"),
      we("resetOnDom", !1)
    ];
    const _t = da({
      fields: sH,
      name: "representing",
      active: Y7,
      apis: zY,
      extra: {
        setValueFrom: (n, s) => {
          const a = _t.getValue(s);
          _t.setValue(n, a);
        }
      },
      state: L5
    }), ru = da({
      fields: VE,
      name: "invalidating",
      active: zE,
      apis: wA,
      extra: {
        // Note, this requires representing to be on the validatee
        validation: (n) => (s) => {
          const a = _t.getValue(s);
          return Zo.pure(n(a));
        }
      }
    });
    var G5 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (n, s) => Hu({
        classes: [],
        styles: s.useFixed() ? {} : { position: "relative" }
      })
    });
    const jE = Ma.generate([
      { none: [] },
      { relative: ["x", "y", "width", "height"] },
      { fixed: ["x", "y", "width", "height"] }
    ]), TA = (n, s, a, l, d, g) => {
      const h = s.rect, C = h.x - a, x = h.y - l, T = h.width, _ = h.height, N = d - (C + T), L = g - (x + _), j = A.some(C), Z = A.some(x), ne = A.some(N), ae = A.some(L), Y = A.none();
      return F0(
        s.direction,
        () => qc(n, j, Z, Y, Y),
        // southeast
        () => qc(n, Y, Z, ne, Y),
        // southwest
        () => qc(n, j, Y, Y, ae),
        // northeast
        () => qc(n, Y, Y, ne, ae),
        // northwest
        () => qc(n, j, Z, Y, Y),
        // south
        () => qc(n, j, Y, Y, ae),
        // north
        () => qc(n, j, Z, Y, Y),
        // east
        () => qc(n, Y, Z, ne, Y)
        // west
      );
    }, kA = (n, s) => n.fold(() => {
      const a = s.rect;
      return qc("absolute", A.some(a.x), A.some(a.y), A.none(), A.none());
    }, (a, l, d, g) => TA("absolute", s, a, l, d, g), (a, l, d, g) => TA("fixed", s, a, l, d, g)), AA = (n, s) => {
      const a = jt(i1, s), l = n.fold(a, a, () => {
        const h = Ls();
        return i1(s).translate(-h.left, -h.top);
      }), d = Au(s), g = pr(s);
      return Rr(l.left, l.top, d, g);
    }, aH = (n, s) => s.fold(
      /* There are no bounds supplied */
      () => n.fold(Ia, Ia, Rr),
      (a) => (
        /* Use any bounds supplied or remove the scroll position of the bounds for fixed. */
        n.fold(oe(a), oe(a), () => {
          const l = q5(n, a.x, a.y);
          return Rr(l.left, l.top, a.width, a.height);
        })
      )
    ), q5 = (n, s, a) => {
      const l = Mo(s, a), d = () => {
        const g = Ls();
        return l.translate(-g.left, -g.top);
      };
      return n.fold(oe(l), oe(l), d);
    }, _A = (n, s, a, l) => n.fold(s, a, l);
    jE.none;
    const cH = jE.relative, WE = jE.fixed, lH = (n, s) => ({
      anchorBox: n,
      origin: s
    }), K5 = (n, s) => lH(n, s), _a = Ma.generate([
      { fit: ["reposition"] },
      { nofit: ["reposition", "visibleW", "visibleH", "isVisible"] }
    ]), iH = (n, s) => {
      const { x: a, y: l, right: d, bottom: g } = s, { x: h, y: C, right: x, bottom: T, width: _, height: N } = n, L = h >= a && h <= d, j = C >= l && C <= g, Z = L && j, ne = x <= d && x >= a, ae = T <= g && T >= l, Y = ne && ae, le = Math.min(_, h >= a ? d - h : x - a), pe = Math.min(N, C >= l ? g - C : T - l);
      return {
        originInBounds: Z,
        sizeInBounds: Y,
        visibleW: le,
        visibleH: pe
      };
    }, Y5 = (n, s) => {
      const { x: a, y: l, right: d, bottom: g } = s, { x: h, y: C, width: x, height: T } = n, _ = Math.max(a, d - x), N = Math.max(l, g - T), L = nr(h, a, _), j = nr(C, l, N), Z = Math.min(L + x, d) - L, ne = Math.min(j + T, g) - j;
      return Rr(L, j, Z, ne);
    }, X5 = (n, s, a) => {
      const l = oe(s.bottom - a.y), d = oe(a.bottom - s.y), g = _g(
        n,
        d,
        /* middle */
        d,
        l
      ), h = oe(s.right - a.x), C = oe(a.right - s.x);
      return {
        maxWidth: Cf(
          n,
          C,
          /* middle */
          C,
          h
        ),
        maxHeight: g
      };
    }, uH = (n, s, a, l) => {
      const d = n.bubble, g = d.offset, h = Sf(l, n.restriction, g), C = n.x + g.left, x = n.y + g.top, T = Rr(C, x, s, a), { originInBounds: _, sizeInBounds: N, visibleW: L, visibleH: j } = iH(T, h), Z = _ && N, ne = Z ? T : Y5(T, h), ae = ne.width > 0 && ne.height > 0, { maxWidth: Y, maxHeight: le } = X5(n.direction, ne, l), pe = {
        rect: ne,
        maxHeight: le,
        maxWidth: Y,
        direction: n.direction,
        placement: n.placement,
        classes: {
          on: d.classesOn,
          off: d.classesOff
        },
        layout: n.label,
        testY: x
      };
      return Z || n.alwaysFit ? _a.fit(pe) : _a.nofit(pe, L, j, ae);
    }, Q5 = (n, s, a, l, d, g) => {
      const h = l.width, C = l.height, x = (_, N, L, j, Z) => {
        const ne = _(a, l, d, n, g), ae = uH(ne, h, C, g);
        return ae.fold(oe(ae), (Y, le, pe, Ee) => (Z === Ee ? pe > j || le > L : !Z && Ee) ? ae : _a.nofit(N, L, j, Z));
      };
      return ao(
        s,
        (_, N) => {
          const L = jt(x, N);
          return _.fold(oe(_), L);
        },
        // fold base case: No candidates, it's never going to be correct, so do whatever
        _a.nofit({
          rect: a,
          maxHeight: l.height,
          maxWidth: l.width,
          direction: _1(),
          placement: "southeast",
          classes: {
            on: [],
            off: []
          },
          layout: "none",
          testY: a.y
        }, -1, -1, !1)
      ).fold(Yt, Yt);
    }, OA = ["top", "bottom", "right", "left"], ZE = "data-alloy-transition-timer", dH = (n, s) => vh(n, s.classes), mH = (n, s, a) => a.exists((l) => {
      const d = n.mode;
      return d === "all" ? !0 : l[d] !== s[d];
    }), fH = (n, s) => {
      const a = (l) => parseFloat(l).toFixed(3);
      return cc(s, (l, d) => {
        const g = n[d].map(a), h = l.map(a);
        return !Xs(g, h);
      }).isSome();
    }, J5 = (n) => {
      const s = (g) => {
        const C = gs(n, g).split(/\s*,\s*/);
        return Ln(C, ni);
      }, a = (g) => {
        if (De(g) && /^[\d.]+/.test(g)) {
          const h = parseFloat(g);
          return nl(g, "ms") ? h : h * 1e3;
        } else
          return 0;
      }, l = s("transition-delay"), d = s("transition-duration");
      return ao(d, (g, h, C) => {
        const x = a(l[C]) + a(h);
        return Math.max(g, x);
      }, 0);
    }, gH = (n, s) => {
      const a = As(), l = As();
      let d;
      const g = (T) => {
        const _ = T.raw.pseudoElement ?? "";
        return I(T.target, n) && ha(_) && bt(OA, T.raw.propertyName);
      }, h = (T) => {
        if (pn(T) || g(T)) {
          a.clear(), l.clear();
          const _ = T?.raw.type;
          (pn(_) || _ === v0()) && (clearTimeout(d), fs(n, ZE), ia(n, s.classes));
        }
      }, C = Oo(n, um(), (T) => {
        g(T) && (C.unbind(), a.set(Oo(n, v0(), h)), l.set(Oo(n, j3(), h)));
      }), x = J5(n);
      window.requestAnimationFrame(() => {
        d = setTimeout(h, x + 17), ln(n, ZE, d);
      });
    }, hH = (n, s) => {
      Zi(n, s.classes), Qr(n, ZE).each((a) => {
        clearTimeout(parseInt(a, 10)), fs(n, ZE);
      }), gH(n, s);
    }, eM = (n, s, a, l, d, g) => {
      const h = mH(l, d, g);
      if (h || dH(n, l)) {
        gn(n, "position", a.position);
        const C = AA(s, n), x = kA(s, { ...d, rect: C }), T = no(OA, (_) => x[_]);
        fH(a, T) && (ea(n, T), h && hH(n, l), Il(n));
      } else
        ia(n, l.classes);
    }, tM = (n) => ({
      width: Math.ceil(Au(n)),
      height: pr(n)
    }), nM = (n, s, a, l) => {
      Kn(s, "max-height"), Kn(s, "max-width");
      const d = tM(s);
      return Q5(s, l.preference, n, d, a, l.bounds);
    }, pH = (n, s) => {
      const a = s.classes;
      ia(n, a.off), Zi(n, a.on);
    }, bH = (n, s, a) => {
      const l = a.maxHeightFunction;
      l(n, s.maxHeight);
    }, vH = (n, s, a) => {
      const l = a.maxWidthFunction;
      l(n, s.maxWidth);
    }, yH = (n, s, a) => {
      const l = kA(a.origin, s);
      a.transition.each((d) => {
        eM(n, a.origin, l, d, s, a.lastPlacement);
      }), Pv(n, l);
    }, oM = (n, s) => {
      Wh(n, s.placement);
    }, DA = (n, s, a) => n[s] === void 0 ? a : n[s], mp = (n, s, a, l, d, g, h, C) => {
      const x = DA(h, "maxHeightFunction", Z2()), T = DA(h, "maxWidthFunction", U), _ = n.anchorBox, N = n.origin, L = {
        bounds: aH(N, g),
        origin: N,
        preference: l,
        maxHeightFunction: x,
        maxWidthFunction: T,
        lastPlacement: d,
        transition: C
      };
      return sM(_, s, a, L);
    }, sM = (n, s, a, l) => {
      const d = nM(n, s, a, l);
      return yH(s, d, l), oM(s, d), pH(s, d), bH(s, d, l), vH(s, d, l), {
        layout: d.layout,
        placement: d.placement
      };
    }, ex = Yt, fp = () => Wc("layouts", [
      Ze("onLtr"),
      Ze("onRtl"),
      Fo("onBottomLtr"),
      Fo("onBottomRtl")
    ]), GE = (n, s, a, l, d, g, h) => {
      const C = h.map(ok).getOr(!1), x = s.layouts.map((j) => j.onLtr(n)), T = s.layouts.map((j) => j.onRtl(n)), _ = C ? s.layouts.bind((j) => j.onBottomLtr.map((Z) => Z(n))).or(x).getOr(d) : x.getOr(a), N = C ? s.layouts.bind((j) => j.onBottomRtl.map((Z) => Z(n))).or(T).getOr(g) : T.getOr(l);
      return t1(_, N)(n);
    }, zv = (n, s, a) => {
      const l = s.hotspot, d = AA(a, l.element), g = GE(n.element, s, U2(), U0(), V0(), V2(), A.some(s.hotspot.element));
      return A.some(ex({
        anchorBox: d,
        bubble: s.bubble.getOr(yf()),
        overrides: s.overrides,
        layouts: g
      }));
    };
    var CH = [
      Ze("hotspot"),
      Fo("bubble"),
      we("overrides", {}),
      fp(),
      Do("placement", zv)
    ];
    const xH = (n, s, a) => {
      const l = q5(a, s.x, s.y), d = Rr(l.left, l.top, s.width, s.height), g = GE(
        n.element,
        s,
        z2(),
        hw(),
        // No default bottomToTop layouts currently needed
        z2(),
        hw(),
        A.none()
      );
      return A.some(ex({
        anchorBox: d,
        bubble: s.bubble,
        overrides: s.overrides,
        layouts: g
      }));
    };
    var rM = [
      Ze("x"),
      Ze("y"),
      we("height", 0),
      we("width", 0),
      we("bubble", yf()),
      we("overrides", {}),
      fp(),
      Do("placement", xH)
    ];
    const aM = Ma.generate([
      { screen: ["point"] },
      { absolute: ["point", "scrollLeft", "scrollTop"] }
    ]), SH = (n) => (
      // TODO: Use new ADT methods
      n.fold(Yt, (s, a, l) => s.translate(-a, -l))
    ), wH = (n) => n.fold(Yt, Yt), RA = (n) => ao(n, (s, a) => s.translate(a.left, a.top), Mo(0, 0)), NA = (n) => {
      const s = ye(n, SH);
      return RA(s);
    }, qE = (n) => {
      const s = ye(n, wH);
      return RA(s);
    }, EH = aM.screen, gp = aM.absolute, cM = (n, s, a) => {
      const l = sg(a.root).dom, d = (g) => {
        const h = fc(g), C = fc(n.element);
        return I(h, C);
      };
      return A.from(l.frameElement).map(at.fromDom).filter(d).map(Ca);
    }, MA = (n, s, a) => {
      const l = fc(n.element), d = Ls(l), g = cM(n, s, a).getOr(d);
      return gp(g, d.left, d.top);
    }, PA = (n, s, a, l) => {
      const d = EH(Mo(n, s));
      return A.some(af(d, a, l));
    }, lM = (n, s, a, l, d) => n.map((g) => {
      const h = [s, g.point], C = _A(l, () => qE(h), () => qE(h), () => NA(h)), x = M3(C.left, C.top, g.width, g.height), T = a.showAbove ? V0() : U2(), _ = a.showAbove ? V2() : U0(), N = GE(d, a, T, _, T, _, A.none());
      return ex({
        anchorBox: x,
        bubble: a.bubble.getOr(yf()),
        overrides: a.overrides,
        layouts: N
      });
    }), tx = (n, s, a) => {
      const l = MA(n, a, s);
      return s.node.filter(bo).bind((d) => {
        const g = d.dom.getBoundingClientRect(), h = PA(g.left, g.top, g.width, g.height), C = s.node.getOr(n.element);
        return lM(h, l, s, a, C);
      });
    };
    var nx = [
      Ze("node"),
      Ze("root"),
      Fo("bubble"),
      fp(),
      // chiefly MaxHeight.expandable()
      we("overrides", {}),
      we("showAbove", !1),
      Do("placement", tx)
    ];
    const ox = (n, s) => ({
      element: n,
      offset: s
    }), BA = (n, s) => {
      const a = ai(n);
      if (a.length === 0)
        return ox(n, s);
      if (s < a.length)
        return ox(a[s], 0);
      {
        const l = a[a.length - 1], d = dd(l) ? bh(l).length : ai(l).length;
        return ox(l, d);
      }
    }, Zg = (n, s) => dd(n) ? ox(n, s) : BA(n, s), Bf = (n) => n.foffset !== void 0, iM = (n, s) => s.getSelection.getOrThunk(() => () => fg(n))().map((l) => {
      if (Bf(l)) {
        const d = Zg(l.start, l.soffset), g = Zg(l.finish, l.foffset);
        return Hl.range(d.element, d.offset, g.element, g.offset);
      } else
        return l;
    }), TH = (n, s, a) => {
      const l = sg(s.root).dom, d = MA(n, a, s), g = iM(l, s).bind((x) => {
        if (Bf(x))
          return rf(l, Hl.exactFromRange(x)).orThunk(() => {
            const _ = at.fromText(Gm);
            fd(x.start, _);
            const N = gg(l, Hl.exact(_, 0, _, 1));
            return al(_), N;
          }).bind((_) => PA(_.left, _.top, _.width, _.height));
        {
          const T = Bs(x, (N) => N.dom.getBoundingClientRect()), _ = {
            left: Math.min(T.firstCell.left, T.lastCell.left),
            right: Math.max(T.firstCell.right, T.lastCell.right),
            top: Math.min(T.firstCell.top, T.lastCell.top),
            bottom: Math.max(T.firstCell.bottom, T.lastCell.bottom)
          };
          return PA(_.left, _.top, _.right - _.left, _.bottom - _.top);
        }
      }), C = iM(l, s).bind((x) => Bf(x) ? mc(x.start) ? A.some(x.start) : Li(x.start) : A.some(x.firstCell)).getOr(n.element);
      return lM(g, d, s, a, C);
    };
    var uM = [
      Fo("getSelection"),
      Ze("root"),
      Fo("bubble"),
      fp(),
      we("overrides", {}),
      we("showAbove", !1),
      Do("placement", TH)
    ];
    const Id = "link-layout", KE = (n) => n.x + n.width, dM = (n, s) => n.x - s.width, $A = (n, s) => n.y - s.height + n.height, IA = (n) => n.y, FA = (n, s, a) => Ea(KE(n), IA(n), a.southeast(), _1(), "southeast", jr(n, {
      left: 0,
      top: 2
      /* AnchorBoxBounds.TopEdge */
    }), Id), YE = (n, s, a) => Ea(dM(n, s), IA(n), a.southwest(), $2(), "southwest", jr(n, {
      right: 1,
      top: 2
      /* AnchorBoxBounds.TopEdge */
    }), Id), LA = (n, s, a) => Ea(KE(n), $A(n, s), a.northeast(), L0(), "northeast", jr(n, {
      left: 0,
      bottom: 3
      /* AnchorBoxBounds.BottomEdge */
    }), Id), mM = (n, s, a) => Ea(dM(n, s), $A(n, s), a.northwest(), Og(), "northwest", jr(n, {
      right: 1,
      bottom: 3
      /* AnchorBoxBounds.BottomEdge */
    }), Id), fM = () => [FA, YE, LA, mM], gM = () => [YE, FA, mM, LA], XE = (n, s, a) => {
      const l = AA(a, s.item.element), d = GE(
        n.element,
        s,
        fM(),
        gM(),
        // No default bottomToTop layouts currently needed
        fM(),
        gM(),
        A.none()
      );
      return A.some(ex({
        anchorBox: l,
        bubble: yf(),
        overrides: s.overrides,
        layouts: d
      }));
    };
    var HA = [
      Ze("item"),
      fp(),
      we("overrides", {}),
      Do("placement", XE)
    ], QE = Cc("type", {
      selection: uM,
      node: nx,
      hotspot: CH,
      submenu: HA,
      makeshift: rM
    });
    const hM = [
      jc("classes", Hr),
      Sc("mode", "all", ["all", "layout", "placement"])
    ], kH = [
      we("useFixed", an),
      Fo("getBounds")
    ], pM = [
      Uc("anchor", QE),
      Wc("transition", hM)
    ], bM = () => {
      const n = document.documentElement;
      return WE(0, 0, n.clientWidth, n.clientHeight);
    }, vM = (n) => {
      const s = Ca(n.element), a = n.element.dom.getBoundingClientRect();
      return cH(s.left, s.top, a.width, a.height);
    }, yM = (n, s, a, l, d, g) => {
      const h = K5(s.anchorBox, n);
      return mp(h, l.element, s.bubble, s.layouts, d, a, s.overrides, g);
    }, AH = (n, s, a, l, d) => {
      const g = A.none();
      JE(n, s, a, l, d, g);
    }, JE = (n, s, a, l, d, g) => {
      const h = yc("placement.info", on(pM), d), C = h.anchor, x = l.element, T = a.get(l.uid);
      Fg(() => {
        gn(x, "position", "fixed");
        const _ = Cs(x, "visibility");
        gn(x, "visibility", "hidden");
        const N = s.useFixed() ? bM() : vM(n);
        C.placement(n, C, N).each((L) => {
          const j = g.orThunk(() => s.getBounds.map(ns)), Z = yM(N, L, j, l, T, h.transition);
          a.set(l.uid, Z);
        }), _.fold(() => {
          Kn(x, "visibility");
        }, (L) => {
          gn(x, "visibility", L);
        }), Cs(x, "left").isNone() && Cs(x, "top").isNone() && Cs(x, "right").isNone() && Cs(x, "bottom").isNone() && uc(Cs(x, "position"), "fixed") && Kn(x, "position");
      }, x);
    };
    var _H = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      position: AH,
      positionWithinBounds: JE,
      getMode: (n, s, a) => s.useFixed() ? "fixed" : "absolute",
      reset: (n, s, a, l) => {
        const d = l.element;
        He(["position", "left", "right", "top", "bottom"], (g) => Kn(d, g)), N1(d), a.clear(l.uid);
      }
    }), CM = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        let n = {};
        return vl({
          readState: () => n,
          clear: (d) => {
            un(d) ? delete n[d] : n = {};
          },
          set: (d, g) => {
            n[d] = g;
          },
          get: (d) => Vt(n, d)
        });
      }
    });
    const Oc = da({
      fields: kH,
      name: "positioning",
      active: G5,
      apis: _H,
      state: CM
    }), OH = (n, s) => s.universal ? n : Ln(n, (a) => bt(s.channels, a));
    var sx = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n) => Ts([
        Ie(mm(), (s, a) => {
          const l = n.channels, d = xo(l), g = a, h = OH(d, g);
          He(h, (C) => {
            const x = l[C], T = x.schema, _ = yc("channel[" + C + `] data
Receiver: ` + Pu(s.element), T, g.data);
            x.onReceive(s, _);
          });
        })
      ])
    }), RH = [
      Uc("channels", jS(
        // Allow any keys.
        Wt.value,
        ml([
          hf("onReceive"),
          we("schema", pi())
        ])
      ))
    ];
    const Dc = da({
      fields: RH,
      name: "receiving",
      active: sx
    });
    var SM = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n, s) => {
        const a = (l, d) => {
          n.updateState.each((g) => {
            const h = g(l, d);
            s.set(h);
          }), n.renderComponents.each((g) => {
            const h = g(d, s.get());
            (n.reuseDom ? pE : DC)(l, h);
          });
        };
        return Ts([
          Ie(mm(), (l, d) => {
            const g = d;
            if (!g.universal) {
              const h = n.channel;
              bt(g.channels, h) && a(l, g.data);
            }
          }),
          hs((l, d) => {
            n.initialData.each((g) => {
              a(l, g);
            });
          })
        ]);
      }
    }), MH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      getState: (n, s, a) => a
    }), PH = [
      Ze("channel"),
      Fo("renderComponents"),
      Fo("updateState"),
      Fo("initialData"),
      zr("reuseDom", !0)
    ], $H = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const n = Pt(A.none()), s = () => n.set(A.none());
        return {
          readState: () => n.get().getOr("none"),
          get: n.get,
          set: n.set,
          clear: s
        };
      }
    });
    const ql = da({
      fields: PH,
      name: "reflecting",
      active: SM,
      apis: MH,
      state: $H
    }), wM = (n, s, a, l) => {
      a.get().each((h) => {
        uE(n);
      });
      const d = s.getAttachPoint(n);
      xm(d, n);
      const g = n.getSystem().build(l);
      return xm(n, g), a.set(g), g;
    }, EM = (n, s, a, l) => {
      const d = wM(n, s, a, l);
      return s.onOpen(n, d), d;
    }, TM = (n, s, a, l) => a.get().map(() => wM(n, s, a, l)), eT = (n, s, a, l, d) => {
      zA(n, s), EM(n, s, a, l), d(), AM(n, s);
    }, tT = (n, s, a) => {
      a.get().each((l) => {
        uE(n), wm(n), s.onClose(n, l), a.clear();
      });
    }, nT = (n, s, a) => a.isOpen(), IH = (n, s, a, l) => nT(n, s, a) && a.get().exists((d) => s.isPartOf(n, d, l)), FH = (n, s, a) => a.get(), LH = (n, s, a, l) => {
      Cs(n.element, s).fold(() => {
        fs(n.element, a);
      }, (d) => {
        ln(n.element, a, d);
      }), gn(n.element, s, l);
    }, HH = (n, s, a) => {
      Qr(n.element, a).fold(() => Kn(n.element, s), (l) => gn(n.element, s, l));
    }, zA = (n, s, a) => {
      const l = s.getAttachPoint(n);
      gn(n.element, "position", Oc.getMode(l)), LH(n, "visibility", s.cloakVisibilityAttr, "hidden");
    }, kM = (n) => cn(["top", "left", "right", "bottom"], (s) => Cs(n, s).isSome()), AM = (n, s, a) => {
      kM(n.element) || Kn(n.element, "position"), HH(n, "visibility", s.cloakVisibilityAttr);
    };
    var zH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      cloak: zA,
      decloak: AM,
      open: EM,
      openWhileCloaked: eT,
      close: tT,
      isOpen: nT,
      isPartOf: IH,
      getState: FH,
      setContent: TM
    }), VH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n, s) => Ts([
        Ie(x0(), (a, l) => {
          tT(a, n, s);
        })
      ])
    }), UH = [
      yo("onOpen"),
      yo("onClose"),
      // Maybe this should be optional
      Ze("isPartOf"),
      Ze("getAttachPoint"),
      we("cloakVisibilityAttr", "data-precloak-visibility")
    ], _M = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const n = hn(), s = oe("not-implemented");
        return vl({
          readState: s,
          isOpen: n.isSet,
          clear: n.clear,
          set: n.set,
          get: n.get
        });
      }
    });
    const Co = da({
      fields: UH,
      name: "sandboxing",
      active: VH,
      apis: zH,
      state: _M
    }), rx = (n, s) => s.getAnimationRoot.fold(() => n.element, (a) => a(n)), Gg = (n) => n.dimension.property, ub = (n, s) => n.dimension.getDimension(s), oT = (n, s) => {
      const a = rx(n, s);
      ia(a, [s.shrinkingClass, s.growingClass]);
    }, $f = (n, s) => {
      Ds(n.element, s.openClass), Uo(n.element, s.closedClass), gn(n.element, Gg(s), "0px"), Il(n.element);
    }, VA = (n, s) => {
      Ds(n.element, s.closedClass), Uo(n.element, s.openClass), Kn(n.element, Gg(s));
    }, OM = (n, s, a, l) => {
      a.setCollapsed(), gn(n.element, Gg(s), ub(s, n.element)), oT(n, s), $f(n, s), s.onStartShrink(n), s.onShrunk(n);
    }, db = (n, s, a, l) => {
      const d = l.getOrThunk(() => ub(s, n.element));
      a.setCollapsed(), gn(n.element, Gg(s), d), Il(n.element);
      const g = rx(n, s);
      Ds(g, s.growingClass), Uo(g, s.shrinkingClass), $f(n, s), s.onStartShrink(n);
    }, UA = (n, s, a) => {
      const l = ub(s, n.element);
      (l === "0px" ? OM : db)(n, s, a, A.some(l));
    }, DM = (n, s, a) => {
      const l = rx(n, s), d = ar(l, s.shrinkingClass), g = ub(s, n.element);
      VA(n, s);
      const h = ub(s, n.element);
      (d ? () => {
        gn(n.element, Gg(s), g), Il(n.element);
      } : () => {
        $f(n, s);
      })(), Ds(l, s.shrinkingClass), Uo(l, s.growingClass), VA(n, s), gn(n.element, Gg(s), h), a.setExpanded(), s.onStartGrow(n);
    }, hp = (n, s, a) => {
      if (a.isExpanded()) {
        Kn(n.element, Gg(s));
        const l = ub(s, n.element);
        gn(n.element, Gg(s), l);
      }
    }, jH = (n, s, a) => {
      a.isExpanded() || DM(n, s, a);
    }, WH = (n, s, a) => {
      a.isExpanded() && UA(n, s, a);
    }, Wu = (n, s, a) => {
      a.isExpanded() && OM(n, s, a);
    }, RM = (n, s, a) => a.isExpanded(), NM = (n, s, a) => a.isCollapsed(), jA = (n, s, a) => {
      const l = rx(n, s);
      return ar(l, s.growingClass) === !0;
    }, MM = (n, s, a) => {
      const l = rx(n, s);
      return ar(l, s.shrinkingClass) === !0;
    };
    var GH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      refresh: hp,
      grow: jH,
      shrink: WH,
      immediateShrink: Wu,
      hasGrown: RM,
      hasShrunk: NM,
      isGrowing: jA,
      isShrinking: MM,
      isTransitioning: (n, s, a) => jA(n, s) || MM(n, s),
      toggleGrow: (n, s, a) => {
        (a.isExpanded() ? UA : DM)(n, s, a);
      },
      disableTransitions: oT,
      immediateGrow: (n, s, a) => {
        a.isExpanded() || (VA(n, s), gn(n.element, Gg(s), ub(s, n.element)), oT(n, s), a.setExpanded(), s.onStartGrow(n), s.onGrown(n));
      }
    }), BM = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (n, s, a) => {
        const l = s.expanded;
        return Hu(l ? {
          classes: [s.openClass],
          styles: {}
        } : {
          classes: [s.closedClass],
          styles: ff(s.dimension.property, "0px")
        });
      },
      events: (n, s) => Ts([
        Jh(v0(), (a, l) => {
          l.event.raw.propertyName === n.dimension.property && (oT(a, n), s.isExpanded() && Kn(a.element, n.dimension.property), (s.isExpanded() ? n.onGrown : n.onShrunk)(a));
        })
      ])
    }), $M = [
      Ze("closedClass"),
      Ze("openClass"),
      Ze("shrinkingClass"),
      Ze("growingClass"),
      // Element which shrinking and growing animations
      Fo("getAnimationRoot"),
      yo("onShrunk"),
      yo("onStartShrink"),
      yo("onGrown"),
      yo("onStartGrow"),
      we("expanded", !1),
      Uc("dimension", Cc("property", {
        width: [
          Do("property", "width"),
          Do("getDimension", (n) => la(n) + "px")
        ],
        height: [
          Do("property", "height"),
          Do("getDimension", (n) => hr(n) + "px")
        ]
      }))
    ], KH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: (n) => {
        const s = Pt(n.expanded), a = () => "expanded: " + s.get();
        return vl({
          isExpanded: () => s.get() === !0,
          isCollapsed: () => s.get() === !1,
          setCollapsed: jt(s.set, !1),
          setExpanded: jt(s.set, !0),
          readState: a
        });
      }
    });
    const Kc = da({
      fields: $M,
      name: "sliding",
      active: BM,
      apis: GH,
      state: KH
    });
    var XH = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n, s) => {
        const l = n.stream.streams.setup(n, s);
        return Ts([
          Ie(n.event, l),
          eu(() => s.cancel())
        ].concat(n.cancelEvent.map((d) => [
          Ie(d, () => s.cancel())
        ]).getOr([])));
      }
    });
    const IM = (n) => {
      const s = Pt(null);
      return vl({
        readState: () => ({
          timer: s.get() !== null ? "set" : "unset"
        }),
        setTimer: (g) => {
          s.set(g);
        },
        cancel: () => {
          const g = s.get();
          g !== null && g.cancel();
        }
      });
    };
    var GA = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      throttle: IM,
      init: (n) => n.stream.streams.state(n)
    });
    const QH = (n, s) => {
      const a = n.stream, l = Xa(n.onStream, a.delay);
      return s.setTimer(l), (d, g) => {
        l.throttle(d, g), a.stopEvent && g.stop();
      };
    };
    var ax = [
      Uc("stream", Cc("mode", {
        throttle: [
          Ze("delay"),
          we("stopEvent", !0),
          Do("streams", {
            setup: QH,
            state: IM
          })
        ]
      })),
      we("event", "input"),
      Fo("cancelEvent"),
      hf("onStream")
    ];
    const Vv = da({
      fields: ax,
      name: "streaming",
      active: XH,
      state: GA
    });
    var FM = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: (n, s) => Hu({
        attributes: Ph([
          { key: s.tabAttr, value: "true" }
        ])
      })
    }), ez = [
      we("tabAttr", "data-alloy-tabstop")
    ];
    const is = da({
      fields: ez,
      name: "tabstopping",
      active: FM
    }), tz = (n, s, a) => {
      const l = s.aria;
      l.update(n, l, a.get());
    }, nz = (n, s, a) => {
      s.toggleClass.each((l) => {
        a.get() ? Uo(n.element, l) : Ds(n.element, l);
      });
    }, mb = (n, s, a, l) => {
      const d = a.get();
      a.set(l), nz(n, s, a), tz(n, s, a), d !== l && s.onToggled(n, l);
    }, qA = (n, s, a) => {
      mb(n, s, a, !a.get());
    }, LM = (n, s, a) => {
      mb(n, s, a, !0);
    }, KA = (n, s, a) => {
      mb(n, s, a, !1);
    }, oz = (n, s, a) => a.get(), YA = (n, s, a) => {
      mb(n, s, a, s.selected);
    };
    var sz = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      onLoad: YA,
      toggle: qA,
      isOn: oz,
      on: LM,
      off: KA,
      set: mb
    }), HM = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      exhibit: () => Hu({}),
      events: (n, s) => {
        const a = yw(n, s, qA), l = Y2(n, s, YA);
        return Ts(en([
          n.toggleOnExecute ? [a] : [],
          [l]
        ]));
      }
    });
    const rz = (n, s, a) => {
      ln(n.element, "aria-pressed", a), s.syncWithExpanded && QA(n, s, a);
    }, az = (n, s, a) => {
      ln(n.element, "aria-selected", a);
    }, XA = (n, s, a) => {
      ln(n.element, "aria-checked", a);
    }, QA = (n, s, a) => {
      ln(n.element, "aria-expanded", a);
    };
    var zM = [
      we("selected", !1),
      Fo("toggleClass"),
      we("toggleOnExecute", !0),
      yo("onToggled"),
      Vl("aria", {
        mode: "none"
      }, Cc("mode", {
        pressed: [
          we("syncWithExpanded", !1),
          Do("update", rz)
        ],
        checked: [
          Do("update", XA)
        ],
        expanded: [
          Do("update", QA)
        ],
        selected: [
          Do("update", az)
        ],
        none: [
          Do("update", U)
        ]
      }))
    ];
    const eo = da({
      fields: zM,
      name: "toggling",
      active: HM,
      apis: sz,
      state: Sw(!1)
    }), sT = Ct("tooltip.exclusive"), cx = Ct("tooltip.show"), lx = Ct("tooltip.hide"), ix = Ct("tooltip.immediateHide"), ux = Ct("tooltip.immediateShow"), VM = (n, s, a) => {
      n.getSystem().broadcastOn([sT], {});
    };
    var lz = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      hideAllExclusive: VM,
      immediateOpenClose: (n, s, a, l) => Wn(n, l ? ux : ix),
      isEnabled: (n, s, a) => a.isEnabled(),
      setComponents: (n, s, a, l) => {
        a.getTooltip().each((d) => {
          d.getSystem().isConnected() && An.set(d, l);
        });
      },
      setEnabled: (n, s, a, l) => a.setEnabled(l)
    }), iz = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: (n, s) => {
        const a = (h) => {
          s.getTooltip().each((C) => {
            C.getSystem().isConnected() && (wm(C), n.onHide(h, C), s.clearTooltip());
          }), s.clearTimer();
        }, l = (h) => {
          if (!s.isShowing() && s.isEnabled()) {
            VM(h);
            const C = n.lazySink(h).getOrDie(), x = h.getSystem().build({
              dom: n.tooltipDom,
              components: n.tooltipComponents,
              events: Ts(n.mode === "normal" ? [
                Ie(Ul(), (T) => {
                  Wn(h, cx);
                }),
                Ie(Nr(), (T) => {
                  Wn(h, lx);
                })
              ] : []),
              behaviours: nt([
                An.config({})
              ])
            });
            s.setTooltip(x), xm(C, x), n.onShow(h, x), Oc.position(C, x, { anchor: n.anchor(h) });
          }
        }, d = (h) => {
          s.getTooltip().each((C) => {
            const x = n.lazySink(h).getOrDie();
            Oc.position(x, C, { anchor: n.anchor(h) });
          });
        }, g = () => {
          switch (n.mode) {
            case "normal":
              return [
                Ie(Ki(), (h) => {
                  Wn(h, ux);
                }),
                Ie(Ih(), (h) => {
                  Wn(h, ix);
                }),
                Ie(Ul(), (h) => {
                  Wn(h, cx);
                }),
                Ie(Nr(), (h) => {
                  Wn(h, lx);
                })
              ];
            case "follow-highlight":
              return [
                Ie(T0(), (h, C) => {
                  Wn(h, cx);
                }),
                Ie(k0(), (h) => {
                  Wn(h, lx);
                })
              ];
            case "children-normal":
              return [
                Ie(Ki(), (h, C) => {
                  or(h.element).each((x) => {
                    Vo(C.event.target, "[data-mce-tooltip]") && s.getTooltip().fold(() => {
                      Wn(h, ux);
                    }, (T) => {
                      s.isShowing() && (n.onShow(h, T), d(h));
                    });
                  });
                }),
                Ie(Ih(), (h) => {
                  or(h.element).fold(() => {
                    Wn(h, ix);
                  }, U);
                }),
                Ie(Ul(), (h) => {
                  Po(h.element, "[data-mce-tooltip]:hover").each((C) => {
                    s.getTooltip().fold(() => {
                      Wn(h, cx);
                    }, (x) => {
                      s.isShowing() && (n.onShow(h, x), d(h));
                    });
                  });
                }),
                Ie(Nr(), (h) => {
                  Po(h.element, "[data-mce-tooltip]:hover").fold(() => {
                    Wn(h, lx);
                  }, U);
                })
              ];
            default:
              return [
                Ie(Ki(), (h, C) => {
                  or(h.element).each((x) => {
                    Vo(C.event.target, "[data-mce-tooltip]") && s.getTooltip().fold(() => {
                      Wn(h, ux);
                    }, (T) => {
                      s.isShowing() && (n.onShow(h, T), d(h));
                    });
                  });
                }),
                Ie(Ih(), (h) => {
                  or(h.element).fold(() => {
                    Wn(h, ix);
                  }, U);
                })
              ];
          }
        };
        return Ts(en([
          [
            K2((h) => {
              n.onSetup(h);
            }),
            Ie(cx, (h) => {
              s.resetTimer(() => {
                l(h);
              }, n.delayForShow());
            }),
            Ie(lx, (h) => {
              s.resetTimer(() => {
                a(h);
              }, n.delayForHide());
            }),
            Ie(ux, (h) => {
              s.resetTimer(() => {
                l(h);
              }, 0);
            }),
            Ie(ix, (h) => {
              s.resetTimer(() => {
                a(h);
              }, 0);
            }),
            Ie(mm(), (h, C) => {
              const x = C;
              x.universal || (bt(x.channels, sT) || bt(x.channels, np())) && (x.data.closedTooltip && s.isShowing() && x.data.closedTooltip(), a(h));
            }),
            eu((h) => {
              a(h);
            })
          ],
          g()
        ]));
      }
    }), uz = [
      Ze("lazySink"),
      Ze("tooltipDom"),
      we("exclusive", !0),
      we("tooltipComponents", []),
      cs("delayForShow", oe(300)),
      cs("delayForHide", oe(100)),
      cs("onSetup", U),
      Sc("mode", "normal", ["normal", "follow-highlight", "children-keyboard-focus", "children-normal"]),
      we("anchor", (n) => ({
        type: "hotspot",
        hotspot: n,
        layouts: {
          onLtr: oe([Tr, Rs, Mr, Ta, Er, ua]),
          onRtl: oe([Tr, Rs, Mr, Ta, Er, ua])
        },
        bubble: bl(0, -2, {})
      })),
      yo("onHide"),
      yo("onShow")
    ], dz = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      init: () => {
        const n = Pt(!0), s = hn(), a = hn(), l = () => {
          s.on(clearTimeout);
        }, d = (h, C) => {
          l(), s.set(setTimeout(h, C));
        }, g = oe("not-implemented");
        return vl({
          getTooltip: a.get,
          isShowing: a.isSet,
          setTooltip: a.set,
          clearTooltip: a.clear,
          clearTimer: l,
          resetTimer: d,
          readState: g,
          isEnabled: () => n.get(),
          setEnabled: (h) => n.set(h)
        });
      }
    });
    const ps = da({
      fields: uz,
      name: "tooltipping",
      active: iz,
      state: dz,
      apis: lz
    });
    var e_ = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      events: () => Ts([
        X0(y1(), St)
      ]),
      exhibit: () => Hu({
        styles: {
          "-webkit-user-select": "none",
          "user-select": "none",
          "-ms-user-select": "none",
          "-moz-user-select": "-moz-none"
        },
        attributes: {
          unselectable: "on"
        }
      })
    });
    const Om = da({
      fields: [],
      name: "unselecting",
      active: e_
    }), mz = (n) => {
      const s = n.dom.attributes !== void 0 ? n.dom.attributes : [];
      return ao(s, (a, l) => l.name === "class" ? a : { ...a, [l.name]: l.value }, {});
    }, fz = (n) => Array.prototype.slice.call(n.dom.classList, 0), Dm = (n) => {
      const s = at.fromHtml(n), a = ai(s), l = mz(s), d = fz(s), g = a.length === 0 ? {} : { innerHtml: Hi(s) };
      return {
        tag: Nl(s),
        classes: d,
        attributes: l,
        ...g
      };
    }, To = (n) => {
      const s = N7(n) && Un(n, "uid") ? n.uid : ip("memento");
      return {
        get: (g) => g.getSystem().getByUid(s).getOrDie(),
        getOpt: (g) => g.getSystem().getByUid(s).toOptional(),
        asSpec: () => ({
          ...n,
          uid: s
        })
      };
    }, ma = Ag, au = B0, gz = (n, s) => {
      const a = Pt(!1), l = Pt(!1);
      return {
        stop: () => {
          a.set(!0);
        },
        cut: () => {
          l.set(!0);
        },
        isStopped: a.get,
        isCut: l.get,
        event: n,
        // Used only for tiered menu at the moment. It is an element, not a component
        setSource: s.set,
        getSource: s.get
      };
    }, jM = (n) => {
      const s = Pt(!1);
      return {
        stop: () => {
          s.set(!0);
        },
        cut: U,
        // cutting has no meaning for a broadcasted event
        isStopped: s.get,
        isCut: an,
        event: n,
        // Nor do targets really
        setSource: se("Cannot set source of a broadcasted event"),
        getSource: se("Cannot get source of a broadcasted event")
      };
    }, WM = (n) => n.raw.which === nC[0] && !bt(["input", "textarea"], Nl(n.target)) && !dg(n.target, '[contenteditable="true"]'), ZM = (n, s) => {
      const a = {
        stopBackspace: !0,
        ...s
      }, l = [
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "gesturestart",
        "mousedown",
        "mouseup",
        "mouseover",
        "mousemove",
        "mouseout",
        "click"
      ], d = Y3(a), g = ye(l.concat([
        "selectstart",
        "input",
        "contextmenu",
        "change",
        "transitionend",
        "transitioncancel",
        // Test the drag events
        "drag",
        "dragstart",
        "dragend",
        "dragenter",
        "dragleave",
        "dragover",
        "drop",
        "keyup"
      ]), (j) => Oo(n, j, (Z) => {
        d.fireIfReady(Z, j).each((ae) => {
          ae && Z.kill();
        }), a.triggerEvent(j, Z) && Z.kill();
      })), h = hn(), C = Oo(n, "paste", (j) => {
        d.fireIfReady(j, "paste").each((ne) => {
          ne && j.kill();
        }), a.triggerEvent("paste", j) && j.kill(), h.set(setTimeout(() => {
          a.triggerEvent(y0(), j);
        }, 0));
      }), x = Oo(n, "keydown", (j) => {
        a.triggerEvent("keydown", j) ? j.kill() : a.stopBackspace && WM(j) && j.prevent();
      }), T = Oo(n, "focusin", (j) => {
        a.triggerEvent("focusin", j) && j.kill();
      }), _ = hn(), N = Oo(n, "focusout", (j) => {
        a.triggerEvent("focusout", j) && j.kill(), _.set(setTimeout(() => {
          a.triggerEvent(Ih(), j);
        }, 0));
      });
      return {
        unbind: () => {
          He(g, (j) => {
            j.unbind();
          }), x.unbind(), T.unbind(), N.unbind(), C.unbind(), h.on(clearTimeout), _.on(clearTimeout);
        }
      };
    }, If = (n, s) => {
      const a = Vt(n, "target").getOr(s);
      return Pt(a);
    }, Zu = Ma.generate([
      { stopped: [] },
      { resume: ["element"] },
      { complete: [] }
    ]), t_ = (n, s, a, l, d, g) => {
      const h = n(s, l), C = gz(a, d);
      return h.fold(() => (g.logEventNoHandlers(s, l), Zu.complete()), (x) => {
        const T = x.descHandler;
        return kv(T)(C), C.isStopped() ? (g.logEventStopped(s, x.element, T.purpose), Zu.stopped()) : C.isCut() ? (g.logEventCut(s, x.element, T.purpose), Zu.complete()) : gc(x.element).fold(() => (g.logNoParent(s, x.element, T.purpose), Zu.complete()), (N) => (g.logEventResponse(s, x.element, T.purpose), Zu.resume(N)));
      });
    }, fb = (n, s, a, l, d, g) => t_(n, s, a, l, d, g).fold(
      // stopped.
      St,
      // Go again.
      (h) => fb(n, s, a, h, d, g),
      // completed
      an
    ), hz = (n, s, a, l, d) => {
      const g = If(a, l);
      return t_(n, s, a, l, g, d);
    }, n_ = (n, s, a) => {
      const l = jM(s);
      return He(n, (d) => {
        const g = d.descHandler;
        kv(g)(l);
      }), l.isStopped();
    }, GM = (n, s, a, l) => rT(n, s, a, a.target, l), rT = (n, s, a, l, d) => {
      const g = If(a, l);
      return fb(n, s, a, l, g, d);
    }, aT = (n, s) => ({
      element: n,
      descHandler: s
    }), qM = (n, s) => ({
      id: n,
      descHandler: s
    }), Gu = () => {
      const n = {}, s = (h, C, x) => {
        ds(x, (T, _) => {
          const N = n[_] !== void 0 ? n[_] : {};
          N[C] = Qk(T, h), n[_] = N;
        });
      }, a = (h, C) => zu(C).bind((x) => Vt(h, x)).map((x) => aT(C, x));
      return {
        registerId: s,
        unregisterId: (h) => {
          ds(n, (C, x) => {
            mo(C, h) && delete C[h];
          });
        },
        filterByType: (h) => Vt(n, h).map((C) => rs(C, (x, T) => qM(T, x))).getOr([]),
        find: (h, C, x) => Vt(n, C).bind((T) => Ll(x, (_) => a(T, _), h))
      };
    }, o_ = () => {
      const n = Gu(), s = {}, a = (T) => {
        const _ = T.element;
        return zu(_).getOrThunk(() => (
          // No existing tag, so add one.
          BC("uid-", T.element)
        ));
      }, l = (T, _) => {
        const N = s[_];
        if (N === T)
          g(T);
        else
          throw new Error('The tagId "' + _ + '" is already used by: ' + Pu(N.element) + `
Cannot use it for: ` + Pu(T.element) + `
The conflicting element is` + (bo(N.element) ? " " : " not ") + "already in the DOM");
      }, d = (T) => {
        const _ = a(T);
        Un(s, _) && l(T, _);
        const N = [T];
        n.registerId(N, _, T.events), s[_] = T;
      }, g = (T) => {
        zu(T.element).each((_) => {
          delete s[_], n.unregisterId(_);
        });
      };
      return {
        find: (T, _, N) => n.find(T, _, N),
        filter: (T) => n.filterByType(T),
        register: d,
        unregister: g,
        getById: (T) => Vt(s, T)
      };
    }, s_ = (n) => {
      const s = (Y) => gc(n.element).fold(St, (le) => I(Y, le)), a = o_(), l = (Y, le) => a.find(s, Y, le), d = ZM(n.element, {
        triggerEvent: (Y, le) => _2(Y, le.target, (pe) => GM(l, Y, le, pe))
      }), g = {
        // This is a real system
        debugInfo: oe("real"),
        triggerEvent: (Y, le, pe) => {
          _2(Y, le, (Ee) => (
            // The return value is not used because this is a fake event.
            rT(l, Y, pe, le, Ee)
          ));
        },
        triggerFocus: (Y, le) => {
          zu(Y).fold(() => {
            $r(Y);
          }, (pe) => {
            _2(dm(), Y, (Ee) => (hz(l, dm(), {
              // originator is used by the default events to ensure that focus doesn't
              // get called infinitely
              originator: le,
              kill: U,
              prevent: U,
              target: Y
            }, Y, Ee), !1));
          });
        },
        triggerEscape: (Y, le) => {
          g.triggerEvent("keydown", Y.element, le.event);
        },
        getByUid: (Y) => ne(Y),
        getByDom: (Y) => ae(Y),
        build: p,
        buildOrPatch: m,
        addToGui: (Y) => {
          x(Y);
        },
        removeFromGui: (Y) => {
          T(Y);
        },
        addToWorld: (Y) => {
          h(Y);
        },
        removeFromWorld: (Y) => {
          C(Y);
        },
        broadcast: (Y) => {
          L(Y);
        },
        broadcastOn: (Y, le) => {
          j(Y, le);
        },
        broadcastEvent: (Y, le) => {
          Z(Y, le);
        },
        isConnected: St
      }, h = (Y) => {
        Y.connect(g), dd(Y.element) || (a.register(Y), He(Y.components(), h), g.triggerEvent(C1(), Y.element, { target: Y.element }));
      }, C = (Y) => {
        dd(Y.element) || (He(Y.components(), C), a.unregister(Y)), Y.disconnect();
      }, x = (Y) => {
        xm(n, Y);
      }, T = (Y) => {
        wm(Y);
      }, _ = () => {
        d.unbind(), al(n.element);
      }, N = (Y) => {
        const le = a.filter(mm());
        He(le, (pe) => {
          const Ee = pe.descHandler;
          kv(Ee)(Y);
        });
      }, L = (Y) => {
        N({
          universal: !0,
          data: Y
        });
      }, j = (Y, le) => {
        N({
          universal: !1,
          channels: Y,
          data: le
        });
      }, Z = (Y, le) => {
        const pe = a.filter(Y);
        return n_(pe, le);
      }, ne = (Y) => a.getById(Y).fold(() => Wt.error(new Error('Could not find component with uid: "' + Y + '" in system.')), Wt.value), ae = (Y) => {
        const le = zu(Y).getOr("not found");
        return ne(le);
      };
      return h(n), {
        root: n,
        element: n.element,
        destroy: _,
        add: x,
        remove: T,
        getByUid: ne,
        getByDom: ae,
        addToWorld: h,
        removeFromWorld: C,
        broadcast: L,
        broadcastOn: j,
        broadcastEvent: Z
      };
    }, KM = () => {
      const n = (s, a) => {
        a.stop(), Yh(s);
      };
      return [
        // Trigger execute when clicked
        Ie(Cg(), n),
        Ie(Fh(), n),
        // Other mouse down listeners above this one should not get mousedown behaviour (like dragging)
        Pg(gl()),
        Pg(Zc())
      ];
    }, r_ = (n) => {
      const s = (a) => Ef((l, d) => {
        a(l), d.stop();
      });
      return Ts(en([
        // Only listen to execute if it is supplied
        n.map(s).toArray(),
        KM()
      ]));
    }, oa = su({
      name: "Button",
      factory: (n) => {
        const s = r_(n.action), a = n.dom.tag, l = (g) => Vt(n.dom, "attributes").bind((h) => Vt(h, g)), d = () => {
          if (a === "button") {
            const g = l("type").getOr("button"), h = l("role").map((C) => ({ role: C })).getOr({});
            return {
              type: g,
              ...h
            };
          } else
            return { role: n.role.getOr(l("role").getOr("button")) };
        };
        return {
          uid: n.uid,
          dom: n.dom,
          components: n.components,
          events: s,
          behaviours: Bd.augment(n.buttonBehaviours, [
            En.config({}),
            Xt.config({
              mode: "execution",
              // Note execution will capture keyup when the focus is on the button
              // on Firefox, because otherwise it will fire a click event and double
              // up on the action
              useSpace: !0,
              useEnter: !0
            })
          ]),
          domModification: {
            attributes: d()
          },
          eventOrder: n.eventOrder
        };
      },
      configFields: [
        we("uid", void 0),
        Ze("dom"),
        we("components", []),
        Bd.field("buttonBehaviours", [En, Xt]),
        Fo("action"),
        Fo("role"),
        we("eventOrder", {})
      ]
    }), pz = oe([
      we("shell", !1),
      Ze("makeItem"),
      we("setupItem", U),
      Bd.field("listBehaviours", [An])
    ]), a_ = Ec({
      name: "items",
      overrides: () => ({
        behaviours: nt([
          An.config({})
        ])
      })
    }), vz = oe([
      a_
    ]), c_ = oe("CustomList"), l_ = (n, s, a, l) => {
      const d = (C, x) => {
        h(C).fold(() => {
          throw console.error("Custom List was defined to not be a shell, but no item container was specified in components"), new Error("Custom List was defined to not be a shell, but no item container was specified in components");
        }, (T) => {
          const _ = An.contents(T), N = x.length, L = N - _.length, j = L > 0 ? fn(L, () => n.makeItem()) : [], Z = _.slice(N);
          He(Z, (ae) => An.remove(T, ae)), He(j, (ae) => An.append(T, ae));
          const ne = An.contents(T);
          He(ne, (ae, Y) => {
            n.setupItem(C, ae, x[Y], Y);
          });
        });
      }, g = n.shell ? { behaviours: [An.config({})], components: [] } : { behaviours: [], components: s }, h = (C) => n.shell ? A.some(C) : Jo(C, n, "items");
      return {
        uid: n.uid,
        dom: n.dom,
        components: g.components,
        behaviours: rc(n.listBehaviours, g.behaviours),
        apis: {
          setItems: d
        }
      };
    }, YM = yl({
      name: c_(),
      configFields: pz(),
      partFields: vz(),
      factory: l_,
      apis: {
        setItems: (n, s, a) => {
          n.setItems(s, a);
        }
      }
    }), Uv = "aria-controls", XM = (n) => nf(n, (a) => {
      if (!mc(a))
        return !1;
      const l = Dr(a, "id");
      return l !== void 0 && l.indexOf(Uv) > -1;
    }).bind((a) => {
      const l = Dr(a, "id"), d = mr(a);
      return Po(d, `[${Uv}="${l}"]`);
    }), QM = () => {
      const n = Ct(Uv);
      return {
        id: n,
        link: (l) => {
          ln(l, Uv, n);
        },
        unlink: (l) => {
          fs(l, Uv);
        }
      };
    }, JM = (n, s) => XM(s).exists((a) => pp(n, a)), pp = (n, s) => yh(s, (a) => I(a, n.element), an) || JM(n, s), eP = "alloy.item-hover", tP = "alloy.item-focus", nP = "alloy.item-toggled", oP = (n) => {
      (or(n.element).isNone() || En.isFocused(n)) && (En.isFocused(n) || En.focus(n), tn(n, eP, { item: n }));
    }, sP = (n) => {
      tn(n, tP, { item: n });
    }, rP = (n, s) => {
      tn(n, nP, { item: n, state: s });
    }, i_ = oe(eP), yz = oe(tP), aP = oe(nP), cP = (n) => n.role.fold(() => n.toggling.map((s) => s.exclusive ? "menuitemradio" : "menuitemcheckbox").getOr("menuitem"), Yt), Cz = (n, s) => ({
      aria: {
        mode: s ? "selected" : "checked"
      },
      // Filter out the additional properties that are not in Toggling Behaviour's configuration (e.g. exclusive)
      ...dr(n, (a, l) => l !== "exclusive"),
      onToggled: (a, l) => {
        Xe(n.onToggled) && n.onToggled(a, l), rP(a, l);
      }
    }), xz = (n) => ({
      dom: n.dom,
      domModification: {
        // INVESTIGATE: If more efficient, destructure attributes out
        ...n.domModification,
        attributes: {
          role: cP(n),
          ...n.domModification.attributes,
          "aria-haspopup": n.hasSubmenu,
          ...n.hasSubmenu ? { "aria-expanded": !1 } : {}
        }
      },
      behaviours: Bd.augment(n.itemBehaviours, [
        // Investigate, is the Toggling.revoke still necessary here?
        n.toggling.fold(eo.revoke, (s) => eo.config(Cz(s, n.role.exists((a) => a === "option")))),
        En.config({
          ignore: n.ignoreFocus,
          // Rationale: because nothing is focusable, when you click
          // on the items to choose them, the focus jumps to the first
          // focusable outer container ... often the body. If we prevent
          // mouseDown ... that doesn't happen. But only tested on Chrome/FF.
          stopMousedown: n.ignoreFocus,
          onFocus: (s) => {
            sP(s);
          }
        }),
        Xt.config({
          mode: "execution"
        }),
        _t.config({
          store: {
            mode: "memory",
            initialValue: n.data
          }
        }),
        xn("item-type-events", [
          // Treat clicks the same as a button
          ...KM(),
          Ie(Ul(), oP),
          Ie(xg(), En.focus)
        ])
      ]),
      components: n.components,
      eventOrder: n.eventOrder
    });
    var u_ = [
      Ze("data"),
      Ze("components"),
      Ze("dom"),
      we("hasSubmenu", !1),
      Fo("toggling"),
      Fo("role"),
      // Maybe this needs to have fewer behaviours
      Bd.field("itemBehaviours", [eo, En, Xt, _t]),
      we("ignoreFocus", !1),
      we("domModification", {}),
      Do("builder", xz),
      we("eventOrder", {})
    ];
    const lP = (n) => ({
      dom: n.dom,
      components: n.components,
      events: Ts([
        ck(xg())
      ])
    });
    var iP = [
      Ze("dom"),
      Ze("components"),
      Do("builder", lP)
    ];
    const d_ = oe("item-widget"), m_ = oe([
      nc({
        name: "widget",
        overrides: (n) => ({
          behaviours: nt([
            _t.config({
              store: {
                mode: "manual",
                getValue: (s) => n.data,
                setValue: U
              }
            })
          ])
        })
      })
    ]), uP = (n) => {
      const s = Gc(d_(), n, m_()), a = $0(d_(), n, s.internals()), l = (g) => Jo(g, n, "widget").map((h) => (Xt.focusIn(h), h)), d = (g, h) => sp(h.event.target) ? A.none() : (n.autofocus && h.setSource(g.element), A.none());
      return {
        dom: n.dom,
        components: a,
        domModification: n.domModification,
        events: Ts([
          Ef((g, h) => {
            l(g).each((C) => {
              h.stop();
            });
          }),
          Ie(Ul(), oP),
          Ie(xg(), (g, h) => {
            n.autofocus ? l(g) : En.focus(g);
          })
        ]),
        behaviours: Bd.augment(n.widgetBehaviours, [
          _t.config({
            store: {
              mode: "memory",
              initialValue: n.data
            }
          }),
          En.config({
            ignore: n.ignoreFocus,
            // What about stopMousedown from ItemType?
            onFocus: (g) => {
              sP(g);
            }
          }),
          Xt.config({
            mode: "special",
            // This is required as long as Highlighting tries to focus the first thing (after focusItem fires)
            focusIn: n.autofocus ? (g) => {
              l(g);
            } : tC(),
            onLeft: d,
            onRight: d,
            onEscape: (g, h) => !En.isFocused(g) && !n.autofocus ? (En.focus(g), A.some(!0)) : (n.autofocus && h.setSource(g.element), A.none())
          })
        ])
      };
    };
    var f_ = [
      Ze("uid"),
      Ze("data"),
      Ze("components"),
      Ze("dom"),
      we("autofocus", !1),
      we("ignoreFocus", !1),
      Bd.field("widgetBehaviours", [_t, En, Xt]),
      we("domModification", {}),
      // We don't have the uid at this point
      pm(m_()),
      Do("builder", uP)
    ];
    const mP = Cc("type", {
      widget: f_,
      item: u_,
      separator: iP
    }), fP = (n, s) => ({
      mode: "flatgrid",
      selector: "." + n.markers.item,
      initSize: {
        numColumns: s.initSize.numColumns,
        numRows: s.initSize.numRows
      },
      focusManager: n.focusManager
    }), gP = (n, s) => ({
      mode: "matrix",
      selectors: {
        row: s.rowSelector,
        cell: "." + n.markers.item
      },
      previousSelector: s.previousSelector,
      focusManager: n.focusManager
    }), Ez = (n, s) => ({
      mode: "menu",
      selector: "." + n.markers.item,
      moveOnTab: s.moveOnTab,
      focusManager: n.focusManager
    }), g_ = oe([
      P0({
        factory: {
          sketch: (n) => {
            const s = yc("menu.spec item", mP, n);
            return s.builder(s);
          }
        },
        name: "items",
        unit: "item",
        defaults: (n, s) => mo(s, "uid") ? s : {
          ...s,
          uid: ip("item")
        },
        overrides: (n, s) => ({
          type: s.type,
          ignoreFocus: n.fakeFocus,
          domModification: {
            classes: [n.markers.item]
          }
        })
      })
    ]), Tz = oe([
      Ks("role"),
      Ze("value"),
      Ze("items"),
      Ze("dom"),
      Ze("components"),
      we("eventOrder", {}),
      Aa("menuBehaviours", [So, _t, Fe, Xt]),
      Vl("movement", {
        // When you don't specify movement for a Menu, this is what you get
        // a "menu" type of movement that moves on tab. If you want finer-grained
        // control, like disabling moveOnTab, then you need to specify
        // your entire movement configuration when creating your MenuSpec.
        mode: "menu",
        moveOnTab: !0
      }, Cc("mode", {
        grid: [
          ow(),
          Do("config", fP)
        ],
        matrix: [
          Do("config", gP),
          Ze("rowSelector"),
          we("previousSelector", A.none)
        ],
        menu: [
          we("moveOnTab", !0),
          Do("config", Ez)
        ]
      })),
      O2(),
      we("fakeFocus", !1),
      we("focusManager", cC()),
      yo("onHighlight"),
      yo("onDehighlight"),
      we("showMenuRole", !0)
    ]), h_ = oe("alloy.menu-focus"), hP = (n, s) => {
      const a = Lr(n.element, '[role="menuitemradio"][aria-checked="true"]');
      He(a, (l) => {
        I(l, s.element) || n.getSystem().getByDom(l).each((d) => {
          eo.off(d);
        });
      });
    }, gb = (n, s, a, l) => ({
      uid: n.uid,
      dom: n.dom,
      markers: n.markers,
      behaviours: rc(n.menuBehaviours, [
        So.config({
          // Highlighting for a menu is selecting items inside the menu
          highlightClass: n.markers.selectedItem,
          itemClass: n.markers.item,
          onHighlight: n.onHighlight,
          onDehighlight: n.onDehighlight
        }),
        _t.config({
          store: {
            mode: "memory",
            initialValue: n.value
          }
        }),
        Fe.config({
          find: A.some
        }),
        Xt.config(n.movement.config(n, n.movement))
      ]),
      events: Ts([
        // This is dispatched from a menu to tell an item to be highlighted.
        Ie(yz(), (d, g) => {
          const h = g.event;
          d.getSystem().getByDom(h.target).each((C) => {
            So.highlight(d, C), g.stop(), tn(d, h_(), { menu: d, item: C });
          });
        }),
        // Highlight the item that the cursor is over. The onHighlight
        // code needs to handle updating focus if required
        Ie(i_(), (d, g) => {
          const h = g.event.item;
          So.highlight(d, h);
        }),
        // Enforce only a single radio menu item is toggled by finding any other toggled
        // radio menu items and untoggling them when a certain item is toggled
        Ie(aP(), (d, g) => {
          const { item: h, state: C } = g.event;
          C && Dr(h.element, "role") === "menuitemradio" && hP(d, h);
        })
      ]),
      components: s,
      eventOrder: n.eventOrder,
      ...n.showMenuRole ? {
        domModification: {
          attributes: {
            role: n.role.getOr("menu")
          }
        }
      } : {}
    }), qg = yl({
      name: "Menu",
      configFields: Tz(),
      partFields: g_(),
      factory: gb
    }), p_ = (n) => (
      // Assumes no duplicate fields.
      vu(n, (s, a) => ({ k: s, v: a }))
    ), dx = (n, s, a, l) => (
      // Given a finishing submenu (which will be the value of expansions),
      // find the triggering item, find its menu, and repeat the process. If there
      // is no triggering item, we are done.
      Vt(a, l).bind((d) => Vt(n, d).bind((g) => {
        const h = dx(n, s, a, g);
        return A.some([g].concat(h));
      })).getOr([])
    ), kz = (n, s) => {
      const a = {};
      ds(n, (h, C) => {
        He(h, (x) => {
          a[x] = C;
        });
      });
      const l = s, d = p_(s), g = Bs(d, (h, C) => [C].concat(dx(a, l, d, C)));
      return Bs(a, (h) => Vt(g, h).getOr([h]));
    }, pP = () => {
      const n = Pt({}), s = Pt({}), a = Pt({}), l = hn(), d = Pt({}), g = () => {
        n.set({}), s.set({}), a.set({}), l.clear();
      }, h = () => l.get().isNone(), C = (Oe, gt) => {
        s.set({
          ...s.get(),
          [Oe]: {
            type: "prepared",
            menu: gt
          }
        });
      }, x = (Oe, gt, Ue, Qe) => {
        l.set(Oe), n.set(Ue), s.set(gt), d.set(Qe);
        const Ke = kz(Qe, Ue);
        a.set(Ke);
      }, T = (Oe) => cc(n.get(), (gt, Ue) => gt === Oe), _ = (Oe, gt, Ue) => ne(Oe).bind((Qe) => T(Oe).bind((Ke) => gt(Ke).map((Qt) => ({
        triggeredMenu: Qe,
        triggeringItem: Qt,
        triggeringPath: Ue
      })))), N = (Oe, gt) => {
        const Ue = Ln(Y(Oe).toArray(), (Qe) => ne(Qe).isSome());
        return Vt(a.get(), Oe).bind((Qe) => {
          const Ke = st(Ue.concat(Qe)), Qt = xe(Ke, (zt, jn) => (
            // finding menuValue, it should match the trigger
            _(zt, gt, Ke.slice(0, jn + 1)).fold(() => uc(l.get(), zt) ? [] : [A.none()], (Jt) => [A.some(Jt)])
          ));
          return ld(Qt);
        });
      }, L = (Oe) => Vt(n.get(), Oe).map((gt) => {
        const Ue = Vt(a.get(), Oe).getOr([]);
        return [gt].concat(Ue);
      }), j = (Oe) => (
        // Look up which key has the itemValue
        Vt(a.get(), Oe).bind((gt) => gt.length > 1 ? A.some(gt.slice(1)) : A.none())
      ), Z = (Oe) => Vt(a.get(), Oe), ne = (Oe) => ae(Oe).bind(b_), ae = (Oe) => Vt(s.get(), Oe), Y = (Oe) => Vt(n.get(), Oe);
      return {
        setMenuBuilt: C,
        setContents: x,
        expand: L,
        refresh: Z,
        collapse: j,
        lookupMenu: ae,
        lookupItem: Y,
        otherMenus: (Oe) => {
          const gt = d.get();
          return ze(xo(gt), Oe);
        },
        getPrimary: () => l.get().bind(ne),
        getMenus: () => s.get(),
        clear: g,
        isClear: h,
        getTriggeringPath: N
      };
    }, b_ = (n) => n.type === "prepared" ? A.some(n.menu) : A.none(), v_ = {
      init: pP,
      extractPreparedMenu: b_
    }, cT = Ct("tiered-menu-item-highlight"), y_ = Ct("tiered-menu-item-dehighlight"), Az = (n, s) => {
      const a = hn(), l = (Ve, ct, mn) => Bs(mn, (Pn, qt) => {
        const Nn = () => qg.sketch({
          ...Pn,
          value: qt,
          // The TieredMenu markers should be inherited by the Menu. "Markers" are things like
          // what is the class for the currently selected item
          markers: n.markers,
          // If the TieredMenu has been configured with FakeFocus, it needs the menus that it generates
          // to preserve that configuration. Generally, FakeFocus is used for situations where the user
          // wants to keep focus inside some editable element (like an input, or editor content)
          fakeFocus: n.fakeFocus,
          // The TieredMenu detail.onHighlight function only relates to selecting an item,
          // not a menu, and the menuComp it is passed is the menu, not the tiered menu.
          // This makes it a difficult handler to use for a tieredmenu, so we are
          // deprecating it.
          onHighlight: (Xo, ko) => {
            tn(Xo, cT, {
              menuComp: Xo,
              itemComp: ko
            });
          },
          onDehighlight: (Xo, ko) => {
            tn(Xo, y_, {
              menuComp: Xo,
              itemComp: ko
            });
          },
          // The Menu itself doesn't set the focusManager based on the value of fakeFocus. It only uses
          // its fakeFocus configuration for creating items that ignore focus, but it still needs to be
          // told which focusManager to use. Perhaps we should change this, though it does allow for more
          // complex focusManagers in single menus.
          focusManager: n.fakeFocus ? nv() : cC()
        });
        return qt === ct ? {
          type: "prepared",
          menu: Ve.getSystem().build(Nn())
        } : {
          type: "notbuilt",
          nbMenu: Nn
        };
      }), d = v_.init(), g = (Ve) => {
        const ct = l(Ve, n.data.primary, n.data.menus), mn = x();
        return d.setContents(n.data.primary, ct, n.data.expansions, mn), d.getPrimary();
      }, h = (Ve) => _t.getValue(Ve).value, C = (Ve, ct, mn) => (
        // Can *greatly* improve the performance of this by calculating things up front.
        ga(ct, (Pn) => {
          if (!Pn.getSystem().isConnected())
            return A.none();
          const qt = So.getCandidates(Pn);
          return Lt(qt, (Nn) => h(Nn) === mn);
        })
      ), x = (Ve) => Bs(n.data.menus, (ct, mn) => xe(ct.items, (Pn) => Pn.type === "separator" ? [] : [Pn.data.value])), T = So.highlight, _ = (Ve, ct) => {
        T(Ve, ct), So.getHighlighted(ct).orThunk(() => So.getFirst(ct)).each((mn) => {
          n.fakeFocus ? So.highlight(ct, mn) : K0(Ve, mn.element, xg());
        });
      }, N = (Ve, ct) => Al(ye(ct, (mn) => Ve.lookupMenu(mn).bind((Pn) => Pn.type === "prepared" ? A.some(Pn.menu) : A.none()))), L = (Ve, ct, mn) => {
        const Pn = N(ct, ct.otherMenus(mn));
        He(Pn, (qt) => {
          ia(qt.element, [n.markers.backgroundMenu]), n.stayInDom || An.remove(Ve, qt);
        });
      }, j = (Ve) => a.get().getOrThunk(() => {
        const ct = {}, mn = Lr(Ve.element, `.${n.markers.item}`), Pn = Ln(mn, (qt) => Dr(qt, "aria-haspopup") === "true");
        return He(Pn, (qt) => {
          Ve.getSystem().getByDom(qt).each((Nn) => {
            const Xo = h(Nn);
            ct[Xo] = Nn;
          });
        }), a.set(ct), ct;
      }), Z = (Ve, ct) => {
        const mn = j(Ve);
        ds(mn, (Pn, qt) => {
          const Nn = bt(ct, qt);
          ln(Pn.element, "aria-expanded", Nn);
        });
      }, ne = (Ve, ct, mn) => A.from(mn[0]).bind((Pn) => ct.lookupMenu(Pn).bind((qt) => {
        if (qt.type === "notbuilt")
          return A.none();
        {
          const Nn = qt.menu, Xo = N(ct, mn.slice(1));
          return He(Xo, (ko) => {
            Uo(ko.element, n.markers.backgroundMenu);
          }), bo(Nn.element) || An.append(Ve, y(Nn)), ia(Nn.element, [n.markers.backgroundMenu]), _(Ve, Nn), L(Ve, ct, mn), A.some(Nn);
        }
      }));
      let ae;
      (function(Ve) {
        Ve[Ve.HighlightSubmenu = 0] = "HighlightSubmenu", Ve[Ve.HighlightParent = 1] = "HighlightParent";
      })(ae || (ae = {}));
      const Y = (Ve, ct, mn) => {
        if (mn.type === "notbuilt") {
          const Pn = Ve.getSystem().build(mn.nbMenu());
          return d.setMenuBuilt(ct, Pn), Pn;
        } else
          return mn.menu;
      }, le = (Ve, ct, mn = ae.HighlightSubmenu) => {
        if (ct.hasConfigured(Ft) && Ft.isDisabled(ct))
          return A.some(ct);
        {
          const Pn = h(ct);
          return d.expand(Pn).bind((qt) => (Z(Ve, qt), A.from(qt[0]).bind((Nn) => d.lookupMenu(Nn).bind((Xo) => {
            const ko = Y(Ve, Nn, Xo);
            return bo(ko.element) || An.append(Ve, y(ko)), n.onOpenSubmenu(Ve, ct, ko, st(qt)), mn === ae.HighlightSubmenu ? (So.highlightFirst(ko), ne(Ve, d, qt)) : (So.dehighlightAll(ko), A.some(ct));
          }))));
        }
      }, pe = (Ve, ct) => {
        const mn = h(ct);
        return d.collapse(mn).bind((Pn) => (Z(Ve, Pn), ne(Ve, d, Pn).map((qt) => (n.onCollapseMenu(Ve, ct, qt), qt))));
      }, Ee = (Ve, ct) => {
        const mn = h(ct);
        return d.refresh(mn).bind((Pn) => (Z(Ve, Pn), ne(Ve, d, Pn)));
      }, Oe = (Ve, ct) => sp(ct.element) ? A.none() : le(Ve, ct, ae.HighlightSubmenu), gt = (Ve, ct) => (
        // Exclude inputs, textareas etc.
        sp(ct.element) ? A.none() : pe(Ve, ct)
      ), Ue = (Ve, ct) => pe(Ve, ct).orThunk(
        () => n.onEscape(Ve, ct).map(() => Ve)
        // This should only fire when the user presses ESC ... not any other close.
      ), Qe = (Ve) => (ct, mn) => xa(mn.getSource(), `.${n.markers.item}`).bind((Pn) => ct.getSystem().getByDom(Pn).toOptional().bind((qt) => Ve(ct, qt).map(St))), Ke = Ts([
        // Set "active-menu" for the menu with focus
        Ie(h_(), (Ve, ct) => {
          const mn = ct.event.item;
          d.lookupItem(h(mn)).each(() => {
            const Pn = ct.event.menu;
            So.highlight(Ve, Pn);
            const qt = h(ct.event.item);
            d.refresh(qt).each((Nn) => L(Ve, d, Nn));
          });
        }),
        Ef((Ve, ct) => {
          const mn = ct.event.target;
          Ve.getSystem().getByDom(mn).each((Pn) => {
            h(Pn).indexOf("collapse-item") === 0 && pe(Ve, Pn), le(Ve, Pn, ae.HighlightSubmenu).fold(() => {
              n.onExecute(Ve, Pn);
            }, U);
          });
        }),
        // Open the menu as soon as it is added to the DOM
        hs((Ve, ct) => {
          g(Ve).each((mn) => {
            An.append(Ve, y(mn)), n.onOpenMenu(Ve, mn), n.highlightOnOpen === Ha.HighlightMenuAndItem ? _(Ve, mn) : n.highlightOnOpen === Ha.HighlightJustMenu && T(Ve, mn);
          });
        }),
        // Listen to the events bubbling up from menu about highlighting, and trigger
        // our handlers with tmenu, menu and item
        Ie(cT, (Ve, ct) => {
          n.onHighlightItem(Ve, ct.event.menuComp, ct.event.itemComp);
        }),
        Ie(y_, (Ve, ct) => {
          n.onDehighlightItem(Ve, ct.event.menuComp, ct.event.itemComp);
        }),
        ...n.navigateOnHover ? [
          // Hide any irrelevant submenus and expand any submenus based
          // on hovered item
          Ie(i_(), (Ve, ct) => {
            const mn = ct.event.item;
            Ee(Ve, mn), le(Ve, mn, ae.HighlightParent), n.onHover(Ve, mn);
          })
        ] : []
      ]), Qt = (Ve) => So.getHighlighted(Ve).bind(So.getHighlighted), zt = (Ve) => {
        Qt(Ve).each((ct) => {
          pe(Ve, ct);
        });
      }, jn = (Ve) => {
        d.getPrimary().each((ct) => {
          _(Ve, ct);
        });
      }, Jt = (Ve) => A.from(Ve.components()[0]).filter((ct) => Dr(ct.element, "role") === "menu"), Ut = {
        collapseMenu: zt,
        highlightPrimary: jn,
        repositionMenus: (Ve) => {
          d.getPrimary().bind((mn) => (
            // Get the triggering path (item, menu) up to the active item
            Qt(Ve).bind((Pn) => {
              const qt = h(Pn), Nn = Ka(d.getMenus()), Xo = Al(ye(Nn, v_.extractPreparedMenu));
              return d.getTriggeringPath(qt, (ko) => C(Ve, Xo, ko));
            }).map((Pn) => ({ primary: mn, triggeringPath: Pn }))
          )).fold(() => {
            Jt(Ve).each((mn) => {
              n.onRepositionMenu(Ve, mn, []);
            });
          }, ({ primary: mn, triggeringPath: Pn }) => {
            n.onRepositionMenu(Ve, mn, Pn);
          });
        }
      };
      return {
        uid: n.uid,
        dom: n.dom,
        markers: n.markers,
        behaviours: rc(n.tmenuBehaviours, [
          Xt.config({
            mode: "special",
            onRight: Qe(Oe),
            onLeft: Qe(gt),
            onEscape: Qe(Ue),
            focusIn: (Ve, ct) => {
              d.getPrimary().each((mn) => {
                K0(Ve, mn.element, xg());
              });
            }
          }),
          // Highlighting is used for highlighting the active menu
          So.config({
            highlightClass: n.markers.selectedMenu,
            itemClass: n.markers.menu
          }),
          Fe.config({
            find: (Ve) => So.getHighlighted(Ve)
          }),
          An.config({})
        ]),
        eventOrder: n.eventOrder,
        apis: Ut,
        events: Ke
      };
    }, bP = oe("collapse-item"), vP = (n, s, a) => ({
      primary: n,
      menus: s,
      expansions: a
    }), yP = (n, s) => ({
      primary: n,
      menus: ff(n, s),
      expansions: {}
    }), CP = (n) => ({
      value: Ct(bP()),
      meta: {
        text: n
      }
    }), hb = su({
      name: "TieredMenu",
      configFields: [
        w1("onExecute"),
        w1("onEscape"),
        hf("onOpenMenu"),
        hf("onOpenSubmenu"),
        yo("onRepositionMenu"),
        yo("onCollapseMenu"),
        // Ideally, we should validate that this is a valid value, but
        // this is an number-based enum, so it would just be a number.
        we("highlightOnOpen", Ha.HighlightMenuAndItem),
        xd("data", [
          Ze("primary"),
          Ze("menus"),
          Ze("expansions")
        ]),
        we("fakeFocus", !1),
        yo("onHighlightItem"),
        yo("onDehighlightItem"),
        yo("onHover"),
        tw(),
        Ze("dom"),
        we("navigateOnHover", !0),
        we("stayInDom", !1),
        Aa("tmenuBehaviours", [Xt, So, Fe, An]),
        we("eventOrder", {})
      ],
      apis: {
        collapseMenu: (n, s) => {
          n.collapseMenu(s);
        },
        // This will highlight the primary menu AND an item in the primary menu
        // Do not use just to set the active menu.
        highlightPrimary: (n, s) => {
          n.highlightPrimary(s);
        },
        repositionMenus: (n, s) => {
          n.repositionMenus(s);
        }
      },
      factory: Az,
      extraApis: {
        tieredData: vP,
        singleData: yP,
        collapseItem: CP
      }
    }), lT = oe("sink"), _z = oe(Ec({
      name: lT(),
      overrides: oe({
        dom: {
          tag: "div"
        },
        behaviours: nt([
          Oc.config({
            // TODO: Make an internal sink also be able to be used with relative layouts
            useFixed: St
          })
        ]),
        events: Ts([
          // Sinks should not let keydown or click propagate
          Pg(na()),
          Pg(Zc()),
          Pg(Cg())
        ])
      })
    })), Oz = ml([
      we("isExtraPart", an),
      Wc("fireEventInstead", [
        we("event", fm())
      ])
    ]), C_ = (n) => {
      const s = yc("Dismissal", Oz, n);
      return {
        [Ad()]: {
          schema: ml([
            Ze("target")
          ]),
          onReceive: (a, l) => {
            Co.isOpen(a) && (Co.isPartOf(a, l.target) || s.isExtraPart(a, l.target) || s.fireEventInstead.fold(() => Co.close(a), (g) => Wn(a, g.event)));
          }
        }
      };
    }, Dz = ml([
      Wc("fireEventInstead", [
        we("event", YS())
      ]),
      fl("doReposition")
    ]), iT = (n) => {
      const s = yc("Reposition", Dz, n);
      return {
        [kr()]: {
          onReceive: (a) => {
            Co.isOpen(a) && s.fireEventInstead.fold(() => s.doReposition(a), (l) => Wn(a, l.event));
          }
        }
      };
    }, xP = (n, s) => {
      const a = n.getHotspot(s).getOr(s), l = "hotspot", d = n.getAnchorOverrides();
      return n.layouts.fold(() => ({ type: l, hotspot: a, overrides: d }), (g) => ({ type: l, hotspot: a, overrides: d, layouts: g }));
    }, mx = (n, s, a) => {
      const l = n.fetch;
      return l(a).map(s);
    }, SP = (n, s, a, l, d, g, h) => {
      const C = mx(n, s, l), x = wP(l, n);
      return C.map((T) => T.bind((_) => {
        const N = _.menus[_.primary];
        return A.from(N).each((L) => {
          n.listRole.each((j) => {
            L.role = j;
          });
        }), A.from(hb.sketch({
          // Externals are configured by the "menu" part. It's called external because it isn't contained
          // within the DOM descendants of the dropdown. You can configure things like `fakeFocus` here.
          ...g.menu(),
          uid: ip(""),
          data: _,
          highlightOnOpen: h,
          onOpenMenu: (L, j) => {
            const Z = x().getOrDie();
            Oc.position(Z, j, { anchor: a }), Co.decloak(d);
          },
          onOpenSubmenu: (L, j, Z) => {
            const ne = x().getOrDie();
            Oc.position(ne, Z, {
              anchor: {
                type: "submenu",
                item: j
              }
            }), Co.decloak(d);
          },
          onRepositionMenu: (L, j, Z) => {
            const ne = x().getOrDie();
            Oc.position(ne, j, { anchor: a }), He(Z, (ae) => {
              Oc.position(ne, ae.triggeredMenu, {
                anchor: { type: "submenu", item: ae.triggeringItem }
              });
            });
          },
          onEscape: () => (En.focus(l), Co.close(d), A.some(!0))
        }));
      }));
    }, uT = (n, s, a, l, d, g, h) => {
      const C = xP(n, a);
      return SP(n, s, C, a, l, d, h).map((T) => (T.fold(() => {
        Co.isOpen(l) && Co.close(l);
      }, (_) => {
        Co.cloak(l), Co.open(l, _), g(l);
      }), l));
    }, Rz = (n, s, a, l, d, g, h) => (Co.close(l), Zo.pure(l)), dT = (n, s, a, l, d, g) => {
      const h = Rn.getCoupled(a, "sandbox");
      return (Co.isOpen(h) ? Rz : uT)(n, s, a, h, l, d, g);
    }, Nz = (n, s, a) => {
      const l = Fe.getCurrent(s).getOr(s), d = la(n.element);
      a ? gn(l.element, "min-width", d + "px") : pd(l.element, d);
    }, wP = (n, s) => n.getSystem().getByUid(s.uid + "-" + lT()).map((a) => () => Wt.value(a)).getOrThunk(() => s.lazySink.fold(() => () => Wt.error(new Error("No internal sink is specified, nor could an external sink be found")), (a) => () => a(n))), EP = (n) => {
      Co.getState(n).each((s) => {
        hb.repositionMenus(s);
      });
    }, TP = (n, s, a) => {
      const l = QM(), d = (C, x) => {
        const T = xP(n, s);
        l.link(s.element), n.matchWidth && Nz(T.hotspot, x, n.useMinWidth), n.onOpen(T, C, x), a !== void 0 && a.onOpen !== void 0 && a.onOpen(C, x);
      }, g = (C, x) => {
        l.unlink(s.element), h().getOr(x).element.dom.dispatchEvent(new window.FocusEvent("focusout")), a !== void 0 && a.onClose !== void 0 && a.onClose(C, x);
      }, h = wP(s, n);
      return {
        dom: {
          tag: "div",
          classes: n.sandboxClasses,
          // TODO: Add aria-selected attribute
          attributes: {
            id: l.id
          }
        },
        behaviours: Bd.augment(n.sandboxBehaviours, [
          _t.config({
            store: {
              mode: "memory",
              initialValue: s
            }
          }),
          Co.config({
            onOpen: d,
            onClose: g,
            isPartOf: (C, x, T) => pp(x, T) || pp(s, T),
            getAttachPoint: () => h().getOrDie()
          }),
          // The Composing of the dropdown here is the the active menu of the TieredMenu
          // inside the sandbox.
          Fe.config({
            find: (C) => Co.getState(C).bind((x) => Fe.getCurrent(x))
          }),
          Dc.config({
            channels: {
              ...C_({
                isExtraPart: an
              }),
              ...iT({
                doReposition: EP
              })
            }
          })
        ])
      };
    }, Mz = (n) => {
      const s = Rn.getCoupled(n, "sandbox");
      EP(s);
    }, x_ = () => [
      we("sandboxClasses", []),
      Bd.field("sandboxBehaviours", [Fe, Dc, Co, _t])
    ], Pz = oe([
      Ze("dom"),
      Ze("fetch"),
      yo("onOpen"),
      hl("onExecute"),
      we("getHotspot", A.some),
      we("getAnchorOverrides", oe({})),
      fp(),
      Aa("dropdownBehaviours", [eo, Rn, Xt, En]),
      Ze("toggleClass"),
      we("eventOrder", {}),
      Fo("lazySink"),
      we("matchWidth", !1),
      we("useMinWidth", !1),
      Fo("role"),
      Fo("listRole")
    ].concat(x_())), Bz = oe([
      xi({
        schema: [
          tw(),
          // Defining a defaulted field isn't necessary when dealing with
          // external parts, because the post-boulder part spec is not passed
          // through to any of these functions (defaults, overrides etc.). So all
          // this does is make it a bit clearer what you should expect, but remember
          // that the default value here is irrelevant!
          we("fakeFocus", !1)
        ],
        name: "menu",
        defaults: (n) => ({
          onExecute: n.onExecute
        })
      }),
      _z()
    ]), $z = (n, s, a, l) => {
      const d = (_) => Vt(n.dom, "attributes").bind((N) => Vt(N, _)), g = (_) => {
        Co.getState(_).each((N) => {
          hb.highlightPrimary(N);
        });
      }, h = (_, N, L) => dT(n, Yt, _, l, N, L), C = (_) => {
        h(_, g, Ha.HighlightMenuAndItem).get(U);
      }, x = {
        expand: (_) => {
          eo.isOn(_) || h(_, U, Ha.HighlightNone).get(U);
        },
        open: (_) => {
          eo.isOn(_) || h(_, U, Ha.HighlightMenuAndItem).get(U);
        },
        refetch: (_) => Rn.getExistingCoupled(_, "sandbox").fold(() => h(_, U, Ha.HighlightMenuAndItem).map(U), (L) => uT(
          n,
          Yt,
          _,
          // NOTE: The TieredMenu is inside the sandbox. They aren't the same component.
          L,
          l,
          U,
          Ha.HighlightMenuAndItem
        ).map(U)),
        isOpen: eo.isOn,
        close: (_) => {
          eo.isOn(_) && h(_, U, Ha.HighlightMenuAndItem).get(U);
        },
        // If we are open, refresh the menus in the tiered menu system
        repositionMenus: (_) => {
          eo.isOn(_) && Mz(_);
        }
      }, T = (_, N) => (Yh(_), A.some(!0));
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        behaviours: rc(n.dropdownBehaviours, [
          eo.config({
            toggleClass: n.toggleClass,
            aria: {
              mode: "expanded"
            }
          }),
          Rn.config({
            others: {
              sandbox: (_) => TP(n, _, {
                onOpen: () => eo.on(_),
                onClose: () => eo.off(_)
              })
            }
          }),
          Xt.config({
            mode: "special",
            onSpace: T,
            onEnter: T,
            onDown: (_, N) => {
              if (Kl.isOpen(_)) {
                const L = Rn.getCoupled(_, "sandbox");
                g(L);
              } else
                Kl.open(_);
              return A.some(!0);
            },
            onEscape: (_, N) => Kl.isOpen(_) ? (Kl.close(_), A.some(!0)) : A.none()
          }),
          En.config({})
        ]),
        events: r_(A.some(C)),
        eventOrder: {
          ...n.eventOrder,
          // Order, the button state is toggled first, so assumed !selected means close.
          [wa()]: ["disabling", "toggling", "alloy.base.behaviour"]
        },
        apis: x,
        domModification: {
          attributes: {
            "aria-haspopup": n.listRole.getOr("true"),
            ...n.role.fold(() => ({}), (_) => ({ role: _ })),
            ...n.dom.tag === "button" ? { type: d("type").getOr("button") } : {}
          }
        }
      };
    }, Kl = yl({
      name: "Dropdown",
      configFields: Pz(),
      partFields: Bz(),
      factory: $z,
      apis: {
        open: (n, s) => n.open(s),
        refetch: (n, s) => n.refetch(s),
        expand: (n, s) => n.expand(s),
        close: (n, s) => n.close(s),
        isOpen: (n, s) => n.isOpen(s),
        repositionMenus: (n, s) => n.repositionMenus(s)
      }
    }), kP = "form", Iz = [
      Aa("formBehaviours", [_t])
    ], S_ = (n) => "<alloy.field." + n + ">", Fz = (n) => {
      const s = (() => {
        const g = [];
        return {
          field: (C, x) => (g.push(C), P2(kP, S_(C), x)),
          record: oe(g)
        };
      })(), a = n(s), l = s.record(), d = ye(l, (g) => nc({ name: g, pname: S_(g) }));
      return fA(kP, Iz, d, _P, a);
    }, AP = (n, s) => n.fold(() => Wt.error(s), Wt.value), _P = (n, s) => ({
      uid: n.uid,
      dom: n.dom,
      components: s,
      // Form has an assumption that every field must have composing, and that the composed element has representing.
      behaviours: rc(n.formBehaviours, [
        _t.config({
          store: {
            mode: "manual",
            getValue: (a) => {
              const l = $u(a, n);
              return Bs(l, (d, g) => d().bind((h) => {
                const C = Fe.getCurrent(h);
                return AP(C, new Error(`Cannot find a current component to extract the value from for form part '${g}': ` + Pu(h.element)));
              }).map(_t.getValue));
            },
            setValue: (a, l) => {
              ds(l, (d, g) => {
                Jo(a, n, g).each((h) => {
                  Fe.getCurrent(h).each((C) => {
                    _t.setValue(C, d);
                  });
                });
              });
            }
          }
        })
      ]),
      apis: {
        getField: (a, l) => Jo(a, n, l).bind(Fe.getCurrent)
      }
    }), bp = {
      getField: Q1((n, s, a) => n.getField(s, a)),
      sketch: Fz
    }, jv = oe([
      Ze("dom"),
      we("shell", !0),
      Aa("toolbarBehaviours", [An])
    ]), Hz = oe([
      // Note, is the container for putting all the groups in, not a group itself.
      Ec({
        name: "groups",
        overrides: () => ({
          behaviours: nt([
            An.config({})
          ])
        })
      })
    ]), fx = (n, s, a, l) => {
      const d = (C, x) => {
        g(C).fold(() => {
          throw console.error("Toolbar was defined to not be a shell, but no groups container was specified in components"), new Error("Toolbar was defined to not be a shell, but no groups container was specified in components");
        }, (T) => {
          An.set(T, x);
        });
      }, g = (C) => n.shell ? A.some(C) : Jo(C, n, "groups"), h = n.shell ? { behaviours: [An.config({})], components: [] } : { behaviours: [], components: s };
      return {
        uid: n.uid,
        dom: n.dom,
        components: h.components,
        behaviours: rc(n.toolbarBehaviours, h.behaviours),
        apis: {
          setGroups: d,
          refresh: U
        },
        domModification: {
          attributes: {
            role: "group"
          }
        }
      };
    }, Rm = yl({
      name: "Toolbar",
      configFields: jv(),
      partFields: Hz(),
      factory: fx,
      apis: {
        setGroups: (n, s, a) => {
          n.setGroups(s, a);
        }
      }
    }), zz = oe([
      lo(["toggledClass"]),
      Ze("lazySink"),
      fl("fetch"),
      qi("getBounds"),
      Wc("fireDismissalEventInstead", [
        we("event", fm())
      ]),
      fp(),
      yo("onToggled")
    ]), Vz = oe([
      xi({
        name: "button",
        overrides: (n) => ({
          dom: {
            attributes: {
              "aria-haspopup": "true"
            }
          },
          buttonBehaviours: nt([
            eo.config({
              toggleClass: n.markers.toggledClass,
              aria: {
                mode: "expanded"
              },
              toggleOnExecute: !1,
              /**
               * For FloatingToolbars, we can hook up our `onToggled` handler directly to the Toggling
               * because we don't have to worry about any animations.
               *
               * Unfortunately, for SlidingToolbars, Toggling is more directly hooked into the animation for growing,
               * so to have an event `onToggled` that doesn't care about the animation, we can't just hook into the Toggling config.
               */
              onToggled: n.onToggled
            })
          ])
        })
      }),
      xi({
        factory: Rm,
        schema: jv(),
        name: "toolbar",
        overrides: (n) => ({
          toolbarBehaviours: nt([
            Xt.config({
              mode: "cyclic",
              onEscape: (s) => (Jo(s, n, "button").each(En.focus), A.none())
            })
          ])
        })
      })
    ]), Wv = hn(), OP = (n, s) => {
      Wv.set(!0), w_(n, s), Wv.clear();
    }, w_ = (n, s) => {
      const a = Rn.getCoupled(n, "toolbarSandbox");
      Co.isOpen(a) ? Co.close(a) : Co.open(a, s.toolbar());
    }, gx = (n, s, a, l) => {
      const d = a.getBounds.map((h) => h()), g = a.lazySink(n).getOrDie();
      Oc.positionWithinBounds(g, s, {
        anchor: {
          type: "hotspot",
          hotspot: n,
          layouts: l,
          overrides: {
            maxWidthFunction: I1()
          }
        }
      }, d);
    }, DP = (n, s, a, l, d) => {
      Rm.setGroups(s, d), gx(n, s, a, l), eo.on(n);
    }, Uz = (n, s, a) => {
      const l = QM(), d = (h, C) => {
        const x = Wv.get().getOr(!1);
        a.fetch().get((T) => {
          DP(n, C, a, s.layouts, T), l.link(n.element), x || Xt.focusIn(C);
        });
      }, g = () => {
        eo.off(n), Wv.get().getOr(!1) || En.focus(n), l.unlink(n.element);
      };
      return {
        dom: {
          tag: "div",
          attributes: {
            id: l.id
          }
        },
        behaviours: nt([
          Xt.config({
            mode: "special",
            onEscape: (h) => (Co.close(h), A.some(!0))
          }),
          Co.config({
            onOpen: d,
            onClose: g,
            isPartOf: (h, C, x) => pp(C, x) || pp(n, x),
            getAttachPoint: () => a.lazySink(n).getOrDie()
          }),
          Dc.config({
            channels: {
              ...C_({
                isExtraPart: an,
                ...a.fireDismissalEventInstead.map((h) => ({ fireEventInstead: { event: h.event } })).getOr({})
              }),
              ...iT({
                doReposition: () => {
                  Co.getState(Rn.getCoupled(n, "toolbarSandbox")).each((h) => {
                    gx(n, h, a, s.layouts);
                  });
                }
              })
            }
          })
        ])
      };
    }, Kg = yl({
      name: "FloatingToolbarButton",
      factory: (n, s, a, l) => ({
        ...oa.sketch({
          ...l.button(),
          action: (d) => {
            w_(d, l);
          },
          buttonBehaviours: Bd.augment({ dump: l.button().buttonBehaviours }, [
            Rn.config({
              others: {
                toolbarSandbox: (d) => Uz(d, a, n)
              }
            })
          ])
        }),
        apis: {
          setGroups: (d, g) => {
            Co.getState(Rn.getCoupled(d, "toolbarSandbox")).each((h) => {
              DP(d, h, n, a.layouts, g);
            });
          },
          reposition: (d) => {
            Co.getState(Rn.getCoupled(d, "toolbarSandbox")).each((g) => {
              gx(d, g, n, a.layouts);
            });
          },
          toggle: (d) => {
            w_(d, l);
          },
          toggleWithoutFocusing: (d) => {
            OP(d, l);
          },
          getToolbar: (d) => Co.getState(Rn.getCoupled(d, "toolbarSandbox")),
          isOpen: (d) => Co.isOpen(Rn.getCoupled(d, "toolbarSandbox"))
        }
      }),
      configFields: zz(),
      partFields: Vz(),
      apis: {
        setGroups: (n, s, a) => {
          n.setGroups(s, a);
        },
        reposition: (n, s) => {
          n.reposition(s);
        },
        toggle: (n, s) => {
          n.toggle(s);
        },
        toggleWithoutFocusing: (n, s) => {
          n.toggleWithoutFocusing(s);
        },
        getToolbar: (n, s) => n.getToolbar(s),
        isOpen: (n, s) => n.isOpen(s)
      }
    }), RP = oe([
      we("prefix", "form-field"),
      Aa("fieldBehaviours", [Fe, _t])
    ]), jz = oe([
      Ec({
        schema: [Ze("dom")],
        name: "label"
      }),
      Ec({
        factory: {
          sketch: (n) => ({
            uid: n.uid,
            dom: {
              tag: "span",
              styles: {
                display: "none"
              },
              attributes: {
                "aria-hidden": "true"
              },
              innerHtml: n.text
            }
          })
        },
        schema: [Ze("text")],
        name: "aria-descriptor"
      }),
      nc({
        factory: {
          sketch: (n) => {
            const s = C2(n, ["factory"]);
            return n.factory.sketch(s);
          }
        },
        schema: [Ze("factory")],
        name: "field"
      })
    ]), Wz = (n, s, a, l) => {
      const d = rc(n.fieldBehaviours, [
        Fe.config({
          find: (C) => Jo(C, n, "field")
        }),
        _t.config({
          store: {
            mode: "manual",
            getValue: (C) => Fe.getCurrent(C).bind(_t.getValue),
            setValue: (C, x) => {
              Fe.getCurrent(C).each((T) => {
                _t.setValue(T, x);
              });
            }
          }
        })
      ]), g = Ts([
        // Used to be systemInit
        hs((C, x) => {
          const T = hm(C, n, ["label", "field", "aria-descriptor"]);
          T.field().each((_) => {
            const N = Ct(n.prefix);
            T.label().each((L) => {
              ln(L.element, "for", N), ln(_.element, "id", N);
            }), T["aria-descriptor"]().each((L) => {
              const j = Ct(n.prefix);
              ln(L.element, "id", j), ln(_.element, "aria-describedby", j);
            });
          });
        })
      ]), h = {
        getField: (C) => Jo(C, n, "field"),
        getLabel: (C) => (
          // TODO: Use constants for part names
          Jo(C, n, "label")
        )
      };
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        behaviours: d,
        events: g,
        apis: h
      };
    }, Yn = yl({
      name: "FormField",
      configFields: RP(),
      partFields: jz(),
      factory: Wz,
      apis: {
        getField: (n, s) => n.getField(s),
        getLabel: (n, s) => n.getLabel(s)
      }
    }), Zz = oe([
      we("field1Name", "field1"),
      we("field2Name", "field2"),
      hf("onLockedChange"),
      lo(["lockClass"]),
      we("locked", !1),
      Bd.field("coupledFieldBehaviours", [Fe, _t]),
      cs("onInput", U)
    ]), Gz = (n, s, a) => Jo(n, s, a).bind(Fe.getCurrent), NP = (n, s) => nc({
      factory: Yn,
      name: n,
      overrides: (a) => ({
        fieldBehaviours: nt([
          xn("coupled-input-behaviour", [
            Ie(Nu(), (l) => {
              Gz(l, a, s).each((d) => {
                Jo(l, a, "lock").each((g) => {
                  eo.isOn(g) && a.onLockedChange(l, d, g), a.onInput(l);
                });
              });
            })
          ])
        ])
      })
    }), qz = oe([
      NP("field1", "field2"),
      NP("field2", "field1"),
      nc({
        factory: oa,
        schema: [
          Ze("dom")
        ],
        name: "lock",
        overrides: (n) => ({
          buttonBehaviours: nt([
            eo.config({
              selected: n.locked,
              toggleClass: n.markers.lockClass,
              aria: {
                mode: "pressed"
              }
            })
          ])
        })
      })
    ]), Kz = (n, s, a, l) => ({
      uid: n.uid,
      dom: n.dom,
      components: s,
      behaviours: Bd.augment(n.coupledFieldBehaviours, [
        Fe.config({ find: A.some }),
        _t.config({
          store: {
            mode: "manual",
            getValue: (d) => {
              const g = I0(d, n, ["field1", "field2"]);
              return {
                [n.field1Name]: _t.getValue(g.field1()),
                [n.field2Name]: _t.getValue(g.field2())
              };
            },
            setValue: (d, g) => {
              const h = I0(d, n, ["field1", "field2"]);
              Un(g, n.field1Name) && _t.setValue(h.field1(), g[n.field1Name]), Un(g, n.field2Name) && _t.setValue(h.field2(), g[n.field2Name]);
            }
          }
        })
      ]),
      apis: {
        getField1: (d) => Jo(d, n, "field1"),
        getField2: (d) => Jo(d, n, "field2"),
        getLock: (d) => Jo(d, n, "lock")
      }
    }), vr = yl({
      name: "FormCoupledInputs",
      configFields: Zz(),
      partFields: qz(),
      factory: Kz,
      apis: {
        getField1: (n, s) => n.getField1(s),
        getField2: (n, s) => n.getField2(s),
        getLock: (n, s) => n.getLock(s)
      }
    }), Yz = (n, s) => {
      const a = ye(n.options, (d) => ({
        dom: {
          tag: "option",
          value: d.value,
          innerHtml: d.text
        }
      })), l = n.data.map((d) => ff("initialValue", d)).getOr({});
      return {
        uid: n.uid,
        dom: {
          tag: "select",
          classes: n.selectClasses,
          attributes: n.selectAttributes
        },
        components: a,
        behaviours: rc(n.selectBehaviours, [
          En.config({}),
          _t.config({
            store: {
              mode: "manual",
              getValue: (d) => bc(d.element),
              setValue: (d, g) => {
                const h = _o(n.options);
                Lt(n.options, (x) => x.value === g).isSome() ? fi(d.element, g) : d.element.dom.selectedIndex === -1 && g === "" && h.each((x) => fi(d.element, x.value));
              },
              ...l
            }
          })
        ])
      };
    }, T_ = su({
      name: "HtmlSelect",
      configFields: [
        Ze("options"),
        Aa("selectBehaviours", [En, _t]),
        we("selectClasses", []),
        we("selectAttributes", {}),
        Fo("data")
      ],
      factory: Yz
    }), MP = (n, s, a, l, d) => {
      const g = () => n.lazySink(s), h = l.type === "horizontal" ? { layouts: {
        onLtr: () => U2(),
        onRtl: () => U0()
      } } : {}, C = (T) => T.length === 2, x = (T) => C(T) ? h : {};
      return hb.sketch({
        dom: {
          tag: "div"
        },
        data: l.data,
        markers: l.menu.markers,
        highlightOnOpen: l.menu.highlightOnOpen,
        fakeFocus: l.menu.fakeFocus,
        onEscape: () => (Co.close(s), n.onEscape.map((T) => T(s)), A.some(!0)),
        onExecute: () => A.some(!0),
        onOpenMenu: (T, _) => {
          Oc.positionWithinBounds(g().getOrDie(), _, a, d());
        },
        onOpenSubmenu: (T, _, N, L) => {
          const j = g().getOrDie();
          Oc.position(j, N, {
            anchor: {
              type: "submenu",
              item: _,
              ...x(L)
            }
          });
        },
        onRepositionMenu: (T, _, N) => {
          const L = g().getOrDie();
          Oc.positionWithinBounds(L, _, a, d()), He(N, (j) => {
            const Z = x(j.triggeringPath);
            Oc.position(L, j.triggeredMenu, {
              anchor: { type: "submenu", item: j.triggeringItem, ...Z }
            });
          });
        }
      });
    }, Xz = (n, s) => {
      const a = (L, j) => n.getRelated(L).exists((ne) => pp(ne, j)), l = (L, j) => {
        Co.setContent(L, j);
      }, d = (L, j, Z) => {
        const ne = A.none;
        g(L, j, Z, ne);
      }, g = (L, j, Z, ne) => {
        const ae = n.lazySink(L).getOrDie();
        Co.openWhileCloaked(L, j, () => Oc.positionWithinBounds(ae, L, Z, ne())), _t.setValue(L, A.some({
          mode: "position",
          config: Z,
          getBounds: ne
        }));
      }, h = (L, j, Z) => {
        C(L, j, Z, A.none);
      }, C = (L, j, Z, ne) => {
        const ae = MP(n, L, j, Z, ne);
        Co.open(L, ae), _t.setValue(L, A.some({
          mode: "menu",
          menu: ae
        }));
      }, x = (L) => {
        Co.isOpen(L) && (_t.setValue(L, A.none()), Co.close(L));
      }, T = (L) => Co.getState(L), _ = (L) => {
        Co.isOpen(L) && _t.getValue(L).each((j) => {
          switch (j.mode) {
            case "menu":
              Co.getState(L).each(hb.repositionMenus);
              break;
            case "position":
              const Z = n.lazySink(L).getOrDie();
              Oc.positionWithinBounds(Z, L, j.config, j.getBounds());
              break;
          }
        });
      }, N = {
        setContent: l,
        showAt: d,
        showWithinBounds: g,
        showMenuAt: h,
        showMenuWithinBounds: C,
        hide: x,
        getContent: T,
        reposition: _,
        isOpen: Co.isOpen
      };
      return {
        uid: n.uid,
        dom: n.dom,
        behaviours: rc(n.inlineBehaviours, [
          Co.config({
            isPartOf: (L, j, Z) => pp(j, Z) || a(L, Z),
            getAttachPoint: (L) => n.lazySink(L).getOrDie(),
            onOpen: (L) => {
              n.onShow(L);
            },
            onClose: (L) => {
              n.onHide(L);
            }
          }),
          _t.config({
            store: {
              mode: "memory",
              initialValue: A.none()
            }
          }),
          Dc.config({
            channels: {
              ...C_({
                isExtraPart: s.isExtraPart,
                ...n.fireDismissalEventInstead.map((L) => ({ fireEventInstead: { event: L.event } })).getOr({})
              }),
              ...iT({
                ...n.fireRepositionEventInstead.map((L) => ({ fireEventInstead: { event: L.event } })).getOr({}),
                doReposition: _
              })
            }
          })
        ]),
        eventOrder: n.eventOrder,
        apis: N
      };
    }, Us = su({
      name: "InlineView",
      configFields: [
        Ze("lazySink"),
        yo("onShow"),
        yo("onHide"),
        qi("onEscape"),
        Aa("inlineBehaviours", [Co, _t, Dc]),
        Wc("fireDismissalEventInstead", [
          we("event", fm())
        ]),
        Wc("fireRepositionEventInstead", [
          we("event", YS())
        ]),
        we("getRelated", A.none),
        we("isExtraPart", an),
        we("eventOrder", A.none)
      ],
      factory: Xz,
      apis: {
        showAt: (n, s, a, l) => {
          n.showAt(s, a, l);
        },
        showWithinBounds: (n, s, a, l, d) => {
          n.showWithinBounds(s, a, l, d);
        },
        showMenuAt: (n, s, a, l) => {
          n.showMenuAt(s, a, l);
        },
        showMenuWithinBounds: (n, s, a, l, d) => {
          n.showMenuWithinBounds(s, a, l, d);
        },
        hide: (n, s) => {
          n.hide(s);
        },
        isOpen: (n, s) => n.isOpen(s),
        getContent: (n, s) => n.getContent(s),
        setContent: (n, s, a) => {
          n.setContent(s, a);
        },
        reposition: (n, s) => {
          n.reposition(s);
        }
      }
    }), k_ = oe([
      Vs("type", "text"),
      Fo("data"),
      we("inputAttributes", {}),
      we("inputStyles", {}),
      we("tag", "input"),
      we("inputClasses", []),
      yo("onSetValue"),
      cs("fromInputValue", Yt),
      cs("toInputValue", Yt),
      we("styles", {}),
      we("eventOrder", {}),
      Aa("inputBehaviours", [_t, En]),
      we("selectOnFocus", !0)
    ]), PP = (n) => nt([
      En.config({
        onFocus: n.selectOnFocus ? (s) => {
          const a = s.element, l = bc(a);
          n.type !== "range" && a.dom.setSelectionRange(0, l.length);
        } : U
      })
    ]), Qz = (n) => ({
      ...PP(n),
      ...rc(n.inputBehaviours, [
        _t.config({
          store: {
            mode: "manual",
            // Propagating its Optional
            ...n.data.map((s) => ({ initialValue: s })).getOr({}),
            getValue: (s) => n.fromInputValue(bc(s.element)),
            setValue: (s, a) => {
              bc(s.element) !== a && fi(s.element, n.toInputValue(a));
            }
          },
          onSetValue: n.onSetValue
        })
      ])
    }), A_ = (n) => ({
      tag: n.tag,
      attributes: {
        type: n.type,
        ...n.inputAttributes
      },
      styles: n.inputStyles,
      classes: n.inputClasses
    }), BP = (n, s) => ({
      uid: n.uid,
      dom: A_(n),
      // No children.
      components: [],
      behaviours: Qz(n),
      eventOrder: n.eventOrder
    }), Ff = su({
      name: "Input",
      configFields: k_(),
      factory: BP
    }), __ = bf(d_(), m_()), Jz = (n, s) => {
      const a = Qr(n, "id").fold(() => {
        const l = Ct("dialog-label");
        return ln(s, "id", l), l;
      }, Yt);
      ln(n, "aria-labelledby", a);
    }, e9 = oe([
      Ze("lazySink"),
      Fo("dragBlockClass"),
      cs("getBounds", Ia),
      we("useTabstopAt", St),
      we("firstTabstop", 0),
      we("eventOrder", {}),
      Aa("modalBehaviours", [Xt]),
      hl("onExecute"),
      w1("onEscape")
    ]), mT = { sketch: Yt }, O_ = oe([
      Ec({
        name: "draghandle",
        overrides: (n, s) => ({
          behaviours: nt([
            Wg.config({
              mode: "mouse",
              getTarget: (a) => Fl(a, '[role="dialog"]').getOr(a),
              blockerClass: n.dragBlockClass.getOrDie(
                // TODO: Support errors in Optional getOrDie.
                new Error(`The drag blocker class was not specified for a dialog with a drag handle: 
` + JSON.stringify(s, null, 2)).message
              ),
              getBounds: n.getDragBounds
            })
          ])
        })
      }),
      nc({
        schema: [Ze("dom")],
        name: "title"
      }),
      nc({
        factory: mT,
        schema: [Ze("dom")],
        name: "close"
      }),
      nc({
        factory: mT,
        schema: [Ze("dom")],
        name: "body"
      }),
      Ec({
        factory: mT,
        schema: [Ze("dom")],
        name: "footer"
      }),
      xi({
        factory: {
          sketch: (n, s) => (
            // Merging should take care of the uid
            {
              ...n,
              dom: s.dom,
              components: s.components
            }
          )
        },
        schema: [
          we("dom", {
            tag: "div",
            styles: {
              position: "fixed",
              left: "0px",
              top: "0px",
              right: "0px",
              bottom: "0px"
            }
          }),
          we("components", [])
        ],
        name: "blocker"
      })
    ]), t9 = (n, s, a, l) => {
      const d = hn(), g = (Z) => {
        d.set(Z);
        const ne = n.lazySink(Z).getOrDie(), ae = l.blocker(), Y = ne.getSystem().build({
          ...ae,
          components: ae.components.concat([
            y(Z)
          ]),
          behaviours: nt([
            En.config({}),
            xn("dialog-blocker-events", [
              // Ensure we use runOnSource otherwise this would cause an infinite loop, as `focusIn` would fire a `focusin` which would then get responded to and so forth
              Jh(Ki(), () => {
                Ge.isBlocked(Z) ? U() : Xt.focusIn(Z);
              })
            ])
          ])
        });
        xm(ne, Y), Xt.focusIn(Z);
      }, h = (Z) => {
        d.clear(), gc(Z.element).each((ne) => {
          Z.getSystem().getByDom(ne).each((ae) => {
            wm(ae);
          });
        });
      }, C = (Z) => Bu(Z, n, "body"), x = (Z) => Jo(Z, n, "footer"), T = (Z, ne) => {
        Ge.block(Z, ne);
      }, _ = (Z) => {
        Ge.unblock(Z);
      }, N = Ct("modal-events"), L = {
        ...n.eventOrder,
        [Mu()]: [N].concat(n.eventOrder["alloy.system.attached"] || [])
      }, j = Zs();
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        apis: {
          show: g,
          hide: h,
          getBody: C,
          getFooter: x,
          setIdle: _,
          setBusy: T
        },
        eventOrder: L,
        domModification: {
          attributes: {
            role: "dialog",
            "aria-modal": "true"
          }
        },
        behaviours: rc(n.modalBehaviours, [
          An.config({}),
          Xt.config({
            mode: "cyclic",
            onEnter: n.onExecute,
            onEscape: n.onEscape,
            useTabstopAt: n.useTabstopAt,
            firstTabstop: n.firstTabstop
          }),
          Ge.config({
            getRoot: d.get
          }),
          xn(N, [
            hs((Z) => {
              const ne = Bu(Z, n, "title").element, ae = n2(ne);
              j.os.isMacOS() && un(ae) ? ln(Z.element, "aria-label", ae) : Jz(Z.element, ne);
            })
          ])
        ])
      };
    }, sa = yl({
      name: "ModalDialog",
      configFields: e9(),
      partFields: O_(),
      factory: t9,
      apis: {
        show: (n, s) => {
          n.show(s);
        },
        hide: (n, s) => {
          n.hide(s);
        },
        getBody: (n, s) => n.getBody(s),
        getFooter: (n, s) => n.getFooter(s),
        setBusy: (n, s, a) => {
          n.setBusy(s, a);
        },
        setIdle: (n, s) => {
          n.setIdle(s);
        }
      }
    }), n9 = Ec({
      schema: [Ze("dom")],
      name: "label"
    }), vp = (n) => Ec({
      name: "" + n + "-edge",
      overrides: (s) => s.model.manager.edgeActions[n].fold(() => ({}), (l) => ({
        events: Ts([
          Xh(gl(), (d, g, h) => l(d, h), [s]),
          Xh(Zc(), (d, g, h) => l(d, h), [s]),
          Xh(Bh(), (d, g, h) => {
            h.mouseIsDown.get() && l(d, h);
          }, [s])
        ])
      }))
    }), o9 = vp("top-left"), s9 = vp("top"), $P = vp("top-right"), IP = vp("right"), r9 = vp("bottom-right"), a9 = vp("bottom"), c9 = vp("bottom-left"), Ei = vp("left"), Fd = nc({
      name: "thumb",
      defaults: oe({
        dom: {
          styles: { position: "absolute" }
        }
      }),
      overrides: (n) => ({
        events: Ts([
          // If the user touches the thumb itself, pretend they touched the spectrum instead. This
          // allows sliding even when they touchstart the current value
          kd(gl(), n, "spectrum"),
          kd(ir(), n, "spectrum"),
          kd(gf(), n, "spectrum"),
          kd(Zc(), n, "spectrum"),
          kd(Bh(), n, "spectrum"),
          kd(b0(), n, "spectrum")
        ])
      })
    }), hx = (n) => Tf(n.event), D_ = nc({
      schema: [
        xc("mouseIsDown", () => Pt(!1))
      ],
      name: "spectrum",
      overrides: (n) => {
        const a = n.model.manager, l = (d, g) => a.getValueFromEvent(g).map((h) => a.setValueFrom(d, n, h));
        return {
          behaviours: nt([
            // Move left and right along the spectrum
            Xt.config({
              mode: "special",
              onLeft: (d, g) => a.onLeft(d, n, hx(g)),
              onRight: (d, g) => a.onRight(d, n, hx(g)),
              onUp: (d, g) => a.onUp(d, n, hx(g)),
              onDown: (d, g) => a.onDown(d, n, hx(g))
            }),
            is.config({}),
            En.config({})
          ]),
          events: Ts([
            Ie(gl(), l),
            Ie(ir(), l),
            Ie(Zc(), l),
            Ie(Bh(), (d, g) => {
              n.mouseIsDown.get() && l(d, g);
            })
          ])
        };
      }
    });
    var R_ = [
      n9,
      Ei,
      IP,
      s9,
      a9,
      o9,
      $P,
      c9,
      r9,
      Fd,
      D_
    ];
    const px = oe("slider.change.value"), FP = (n) => n.type.indexOf("touch") !== -1, pb = (n) => {
      const s = n.event.raw;
      if (FP(s)) {
        const a = s;
        return a.touches !== void 0 && a.touches.length === 1 ? A.some(a.touches[0]).map((l) => Mo(l.clientX, l.clientY)) : A.none();
      } else {
        const a = s;
        return a.clientX !== void 0 ? A.some(a).map((l) => Mo(l.clientX, l.clientY)) : A.none();
      }
    }, l9 = "top", fT = "right", M_ = "bottom", LP = "left", Nm = (n) => n.model.minX, bb = (n) => n.model.minY, gT = (n) => n.model.minX - 1, cu = (n) => n.model.minY - 1, Ua = (n) => n.model.maxX, Mm = (n) => n.model.maxY, Yc = (n) => n.model.maxX + 1, hT = (n) => n.model.maxY + 1, us = (n, s, a) => s(n) - a(n), P_ = (n) => us(n, Ua, Nm), Pm = (n) => us(n, Mm, bb), Zv = (n) => P_(n) / 2, B_ = (n) => Pm(n) / 2, yp = (n, s) => s ? n.stepSize * n.speedMultiplier : n.stepSize, pT = (n) => n.snapToGrid, HP = (n) => n.snapStart, bT = (n) => n.rounded, vT = (n, s) => n[s + "-edge"] !== void 0, $_ = (n) => vT(n, LP), I_ = (n) => vT(n, fT), yT = (n) => vT(n, l9), F_ = (n) => vT(n, M_), Ld = (n) => n.model.value.get(), Cp = (n, s) => ({
      x: n,
      y: s
    }), Hd = (n, s) => {
      tn(n, px(), { value: s });
    }, i9 = (n, s) => {
      Hd(n, Cp(gT(s), cu(s)));
    }, u9 = (n, s) => {
      Hd(n, cu(s));
    }, d9 = (n, s) => {
      Hd(n, Cp(Zv(s), cu(s)));
    }, zP = (n, s) => {
      Hd(n, Cp(Yc(s), cu(s)));
    }, m9 = (n, s) => {
      Hd(n, Yc(s));
    }, f9 = (n, s) => {
      Hd(n, Cp(Yc(s), B_(s)));
    }, VP = (n, s) => {
      Hd(n, Cp(Yc(s), hT(s)));
    }, g9 = (n, s) => {
      Hd(n, hT(s));
    }, UP = (n, s) => {
      Hd(n, Cp(Zv(s), hT(s)));
    }, bx = (n, s) => {
      Hd(n, Cp(gT(s), hT(s)));
    }, h9 = (n, s) => {
      Hd(n, gT(s));
    }, p9 = (n, s) => {
      Hd(n, Cp(gT(s), B_(s)));
    }, CT = (n, s, a, l) => n < s ? n : n > a ? a : n === s ? s - 1 : Math.max(s, n - l), xT = (n, s, a, l) => n > a ? n : n < s ? s : n === a ? a + 1 : Math.min(a, n + l), ST = (n, s, a) => Math.max(s, Math.min(a, n)), jP = (n, s, a, l, d) => (
      // We are snapping by the step size. Therefore, find the nearest multiple of
      // the step
      d.fold(() => {
        const g = n - s, h = Math.round(g / l) * l;
        return ST(s + h, s - 1, a + 1);
      }, (g) => {
        const h = (n - g) % l, C = Math.round(h / l), x = Math.floor((n - g) / l), T = Math.floor((a - g) / l), _ = Math.min(T, x + C), N = g + _ * l;
        return Math.max(g, N);
      })
    ), b9 = (n, s, a) => Math.min(a, Math.max(n, s)) - s, WP = (n) => {
      const { min: s, max: a, range: l, value: d, step: g, snap: h, snapStart: C, rounded: x, hasMinEdge: T, hasMaxEdge: _, minBound: N, maxBound: L, screenRange: j } = n, Z = T ? s - 1 : s, ne = _ ? a + 1 : a;
      if (d < N)
        return Z;
      if (d > L)
        return ne;
      {
        const ae = b9(d, N, L), Y = ST(ae / j * l + s, Z, ne);
        return h && Y >= s && Y <= a ? jP(Y, s, a, g, C) : x ? Math.round(Y) : Y;
      }
    }, ZP = (n) => {
      const { min: s, max: a, range: l, value: d, hasMinEdge: g, hasMaxEdge: h, maxBound: C, maxOffset: x, centerMinEdge: T, centerMaxEdge: _ } = n;
      return d < s ? g ? 0 : T : d > a ? h ? C : _ : (d - s) / l * x;
    }, L_ = "top", GP = "right", qP = "bottom", wT = "left", zd = "width", v9 = "height", Vd = (n) => n.element.dom.getBoundingClientRect(), qu = (n, s) => n[s], vx = (n) => {
      const s = Vd(n);
      return qu(s, wT);
    }, KP = (n) => {
      const s = Vd(n);
      return qu(s, GP);
    }, yx = (n) => {
      const s = Vd(n);
      return qu(s, L_);
    }, H_ = (n) => {
      const s = Vd(n);
      return qu(s, qP);
    }, z_ = (n) => {
      const s = Vd(n);
      return qu(s, zd);
    }, YP = (n) => {
      const s = Vd(n);
      return qu(s, v9);
    }, XP = (n, s, a) => (n + s) / 2 - a, QP = (n, s) => {
      const a = Vd(n), l = Vd(s), d = qu(a, wT), g = qu(a, GP), h = qu(l, wT);
      return XP(d, g, h);
    }, JP = (n, s) => {
      const a = Vd(n), l = Vd(s), d = qu(a, L_), g = qu(a, qP), h = qu(l, L_);
      return XP(d, g, h);
    }, ET = (n, s) => {
      tn(n, px(), { value: s });
    }, V_ = (n, s, a) => {
      const l = {
        min: Nm(s),
        max: Ua(s),
        range: P_(s),
        value: a,
        step: yp(s),
        snap: pT(s),
        snapStart: HP(s),
        rounded: bT(s),
        hasMinEdge: $_(s),
        hasMaxEdge: I_(s),
        minBound: vx(n),
        maxBound: KP(n),
        screenRange: z_(n)
      };
      return WP(l);
    }, y9 = (n, s, a) => {
      const l = V_(n, s, a);
      return ET(n, l), l;
    }, eB = (n, s) => {
      const a = Nm(s);
      ET(n, a);
    }, tB = (n, s) => {
      const a = Ua(s);
      ET(n, a);
    }, nB = (n, s, a, l) => {
      const g = (n > 0 ? xT : CT)(Ld(a), Nm(a), Ua(a), yp(a, l));
      return ET(s, g), A.some(g);
    }, U_ = (n) => (s, a, l) => nB(n, s, a, l).map(St), C9 = (n) => pb(n).map((a) => a.left), x9 = (n, s, a, l, d) => {
      const h = z_(n), C = l.bind((_) => A.some(QP(_, n))).getOr(0), x = d.bind((_) => A.some(QP(_, n))).getOr(h), T = {
        min: Nm(s),
        max: Ua(s),
        range: P_(s),
        value: a,
        hasMinEdge: $_(s),
        hasMaxEdge: I_(s),
        minBound: vx(n),
        maxBound: KP(n),
        maxOffset: h,
        centerMinEdge: C,
        centerMaxEdge: x
      };
      return ZP(T);
    }, j_ = (n, s, a, l, d, g) => {
      const h = x9(s, g, a, l, d);
      return vx(s) - vx(n) + h;
    }, oB = (n, s, a, l) => {
      const d = Ld(a), g = j_(n, l.getSpectrum(n), d, l.getLeftEdge(n), l.getRightEdge(n), a), h = la(s.element) / 2;
      gn(s.element, "left", g - h + "px");
    }, Gv = U_(-1), TT = U_(1), S9 = A.none, sB = A.none, rB = {
      "top-left": A.none(),
      top: A.none(),
      "top-right": A.none(),
      right: A.some(m9),
      "bottom-right": A.none(),
      bottom: A.none(),
      "bottom-left": A.none(),
      left: A.some(h9)
    };
    var aB = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setValueFrom: y9,
      setToMin: eB,
      setToMax: tB,
      findValueOfOffset: V_,
      getValueFromEvent: C9,
      findPositionOfValue: j_,
      setPositionFromValue: oB,
      onLeft: Gv,
      onRight: TT,
      onUp: S9,
      onDown: sB,
      edgeActions: rB
    });
    const Cx = (n, s) => {
      tn(n, px(), { value: s });
    }, xx = (n, s, a) => {
      const l = {
        min: bb(s),
        max: Mm(s),
        range: Pm(s),
        value: a,
        step: yp(s),
        snap: pT(s),
        snapStart: HP(s),
        rounded: bT(s),
        hasMinEdge: yT(s),
        hasMaxEdge: F_(s),
        minBound: yx(n),
        maxBound: H_(n),
        screenRange: YP(n)
      };
      return WP(l);
    }, W_ = (n, s, a) => {
      const l = xx(n, s, a);
      return Cx(n, l), l;
    }, w9 = (n, s) => {
      const a = bb(s);
      Cx(n, a);
    }, E9 = (n, s) => {
      const a = Mm(s);
      Cx(n, a);
    }, T9 = (n, s, a, l) => {
      const g = (n > 0 ? xT : CT)(Ld(a), bb(a), Mm(a), yp(a, l));
      return Cx(s, g), A.some(g);
    }, Z_ = (n) => (s, a, l) => T9(n, s, a, l).map(St), cB = (n) => pb(n).map((a) => a.top), k9 = (n, s, a, l, d) => {
      const h = YP(n), C = l.bind((_) => A.some(JP(_, n))).getOr(0), x = d.bind((_) => A.some(JP(_, n))).getOr(h), T = {
        min: bb(s),
        max: Mm(s),
        range: Pm(s),
        value: a,
        hasMinEdge: yT(s),
        hasMaxEdge: F_(s),
        minBound: yx(n),
        maxBound: H_(n),
        maxOffset: h,
        centerMinEdge: C,
        centerMaxEdge: x
      };
      return ZP(T);
    }, G_ = (n, s, a, l, d, g) => {
      const h = k9(s, g, a, l, d);
      return yx(s) - yx(n) + h;
    }, lB = (n, s, a, l) => {
      const d = Ld(a), g = G_(n, l.getSpectrum(n), d, l.getTopEdge(n), l.getBottomEdge(n), a), h = hr(s.element) / 2;
      gn(s.element, "top", g - h + "px");
    }, A9 = A.none, _9 = A.none, O9 = Z_(-1), D9 = Z_(1), R9 = {
      "top-left": A.none(),
      top: A.some(u9),
      "top-right": A.none(),
      right: A.none(),
      "bottom-right": A.none(),
      bottom: A.some(g9),
      "bottom-left": A.none(),
      left: A.none()
    };
    var N9 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setValueFrom: W_,
      setToMin: w9,
      setToMax: E9,
      findValueOfOffset: xx,
      getValueFromEvent: cB,
      findPositionOfValue: G_,
      setPositionFromValue: lB,
      onLeft: A9,
      onRight: _9,
      onUp: O9,
      onDown: D9,
      edgeActions: R9
    });
    const kT = (n, s) => {
      tn(n, px(), { value: s });
    }, Sx = (n, s) => ({
      x: n,
      y: s
    }), iB = (n, s, a) => {
      const l = V_(n, s, a.left), d = xx(n, s, a.top), g = Sx(l, d);
      return kT(n, g), g;
    }, M9 = (n, s, a, l, d) => {
      const g = n > 0 ? xT : CT, h = s ? Ld(l).x : g(Ld(l).x, Nm(l), Ua(l), yp(l, d)), C = s ? g(Ld(l).y, bb(l), Mm(l), yp(l, d)) : Ld(l).y;
      return kT(a, Sx(h, C)), A.some(h);
    }, AT = (n, s) => (a, l, d) => M9(n, s, a, l, d).map(St), P9 = (n, s) => {
      const a = Nm(s), l = bb(s);
      kT(n, Sx(a, l));
    }, uB = (n, s) => {
      const a = Ua(s), l = Mm(s);
      kT(n, Sx(a, l));
    }, B9 = (n) => pb(n), $9 = (n, s, a, l) => {
      const d = Ld(a), g = j_(n, l.getSpectrum(n), d.x, l.getLeftEdge(n), l.getRightEdge(n), a), h = G_(n, l.getSpectrum(n), d.y, l.getTopEdge(n), l.getBottomEdge(n), a), C = la(s.element) / 2, x = hr(s.element) / 2;
      gn(s.element, "left", g - C + "px"), gn(s.element, "top", h - x + "px");
    }, I9 = AT(-1, !1), _T = AT(1, !1), F9 = AT(-1, !0), L9 = AT(1, !0), H9 = {
      "top-left": A.some(i9),
      top: A.some(d9),
      "top-right": A.some(zP),
      right: A.some(f9),
      "bottom-right": A.some(VP),
      bottom: A.some(UP),
      "bottom-left": A.some(bx),
      left: A.some(p9)
    };
    var z9 = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setValueFrom: iB,
      setToMin: P9,
      setToMax: uB,
      getValueFromEvent: B9,
      setPositionFromValue: $9,
      onLeft: I9,
      onRight: _T,
      onUp: F9,
      onDown: L9,
      edgeActions: H9
    });
    const V9 = [
      we("stepSize", 1),
      we("speedMultiplier", 10),
      we("onChange", U),
      we("onChoose", U),
      we("onInit", U),
      we("onDragStart", U),
      we("onDragEnd", U),
      we("snapToGrid", !1),
      we("rounded", !0),
      Fo("snapStart"),
      Uc("model", Cc("mode", {
        x: [
          we("minX", 0),
          we("maxX", 100),
          xc("value", (n) => Pt(n.mode.minX)),
          Ze("getInitialValue"),
          Do("manager", aB)
        ],
        y: [
          we("minY", 0),
          we("maxY", 100),
          xc("value", (n) => Pt(n.mode.minY)),
          Ze("getInitialValue"),
          Do("manager", N9)
        ],
        xy: [
          we("minX", 0),
          we("maxX", 100),
          we("minY", 0),
          we("maxY", 100),
          xc("value", (n) => Pt({
            x: n.mode.minX,
            y: n.mode.minY
          })),
          Ze("getInitialValue"),
          Do("manager", z9)
        ]
      })),
      Aa("sliderBehaviours", [Xt, _t]),
      xc("mouseIsDown", () => Pt(!1))
    ], Ud = yl({
      name: "Slider",
      configFields: V9,
      partFields: R_,
      factory: (n, s, a, l) => {
        const d = (Oe) => Bu(Oe, n, "thumb"), g = (Oe) => Bu(Oe, n, "spectrum"), h = (Oe) => Jo(Oe, n, "left-edge"), C = (Oe) => Jo(Oe, n, "right-edge"), x = (Oe) => Jo(Oe, n, "top-edge"), T = (Oe) => Jo(Oe, n, "bottom-edge"), _ = n.model, N = _.manager, L = (Oe, gt) => {
          N.setPositionFromValue(Oe, gt, n, {
            getLeftEdge: h,
            getRightEdge: C,
            getTopEdge: x,
            getBottomEdge: T,
            getSpectrum: g
          });
        }, j = (Oe, gt) => {
          _.value.set(gt);
          const Ue = d(Oe);
          L(Oe, Ue);
        }, Z = (Oe, gt) => {
          j(Oe, gt);
          const Ue = d(Oe);
          return n.onChange(Oe, Ue, gt), A.some(!0);
        }, ne = (Oe) => {
          N.setToMin(Oe, n);
        }, ae = (Oe) => {
          N.setToMax(Oe, n);
        }, Y = (Oe) => {
          const gt = () => {
            Jo(Oe, n, "thumb").each((Qe) => {
              const Ke = _.value.get();
              n.onChoose(Oe, Qe, Ke);
            });
          }, Ue = n.mouseIsDown.get();
          n.mouseIsDown.set(!1), Ue && gt();
        }, le = (Oe, gt) => {
          gt.stop(), n.mouseIsDown.set(!0), n.onDragStart(Oe, d(Oe));
        }, pe = (Oe, gt) => {
          gt.stop(), n.onDragEnd(Oe, d(Oe)), Y(Oe);
        }, Ee = (Oe) => {
          Jo(Oe, n, "spectrum").map(Xt.focusIn);
        };
        return {
          uid: n.uid,
          dom: n.dom,
          components: s,
          behaviours: rc(n.sliderBehaviours, [
            Xt.config({
              mode: "special",
              focusIn: Ee
            }),
            _t.config({
              store: {
                mode: "manual",
                getValue: (Oe) => _.value.get(),
                setValue: j
              }
            }),
            Dc.config({
              channels: {
                [ym()]: {
                  onReceive: Y
                }
              }
            })
          ]),
          events: Ts([
            Ie(px(), (Oe, gt) => {
              Z(Oe, gt.event.value);
            }),
            hs((Oe, gt) => {
              const Ue = _.getInitialValue();
              _.value.set(Ue);
              const Qe = d(Oe);
              L(Oe, Qe);
              const Ke = g(Oe);
              n.onInit(Oe, Qe, Ke, _.value.get());
            }),
            Ie(gl(), le),
            Ie(gf(), pe),
            Ie(Zc(), (Oe, gt) => {
              Ee(Oe), le(Oe, gt);
            }),
            Ie(b0(), pe)
          ]),
          apis: {
            resetToMin: ne,
            resetToMax: ae,
            setValue: j,
            refresh: L
          },
          domModification: {
            styles: {
              position: "relative"
            }
          }
        };
      },
      apis: {
        setValue: (n, s, a) => {
          n.setValue(s, a);
        },
        resetToMin: (n, s) => {
          n.resetToMin(s);
        },
        resetToMax: (n, s) => {
          n.resetToMax(s);
        },
        refresh: (n, s) => {
          n.refresh(s);
        }
      }
    }), dB = "container", U9 = [
      Aa("slotBehaviours", [])
    ], mB = (n) => "<alloy.field." + n + ">", j9 = (n) => {
      const s = (() => {
        const g = [];
        return {
          slot: (C, x) => (g.push(C), P2(dB, mB(C), x)),
          record: oe(g)
        };
      })(), a = n(s), l = s.record(), d = ye(l, (g) => nc({ name: g, pname: mB(g) }));
      return fA(dB, U9, d, W9, a);
    }, W9 = (n, s) => {
      const a = (ne) => jl(n), l = (ne, ae) => Jo(ne, n, ae), d = (ne, ae) => (Y, le) => Jo(Y, n, le).map((pe) => ne(pe, le)).getOr(ae), g = (ne) => (ae, Y) => {
        He(Y, (le) => ne(ae, le));
      }, h = (ne, ae) => Dr(ne.element, "aria-hidden") !== "true", C = (ne, ae) => {
        if (!h(ne)) {
          const Y = ne.element;
          Kn(Y, "display"), fs(Y, "aria-hidden"), tn(ne, T2(), { name: ae, visible: !0 });
        }
      }, x = (ne, ae) => {
        if (h(ne)) {
          const Y = ne.element;
          gn(Y, "display", "none"), ln(Y, "aria-hidden", "true"), tn(ne, T2(), { name: ae, visible: !1 });
        }
      }, T = d(h, !1), _ = d(x), N = g(_), L = (ne) => N(ne, a()), j = d(C), Z = {
        getSlotNames: a,
        getSlot: l,
        isShowing: T,
        hideSlot: _,
        hideAllSlots: L,
        showSlot: j
      };
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        behaviours: QC(n.slotBehaviours),
        apis: Z
      };
    }, ja = {
      ...Bs({
        getSlotNames: (n, s) => n.getSlotNames(s),
        getSlot: (n, s, a) => n.getSlot(s, a),
        isShowing: (n, s, a) => n.isShowing(s, a),
        hideSlot: (n, s, a) => n.hideSlot(s, a),
        hideAllSlots: (n, s) => n.hideAllSlots(s),
        showSlot: (n, s, a) => n.showSlot(s, a)
      }, (n) => Q1(n)),
      sketch: j9
    }, Z9 = (n, s) => ao(n, (d, g) => s(g, d.len).fold(oe(d), (C) => ({
      len: C.finish,
      list: d.list.concat([C])
    })), {
      len: 0,
      list: []
    }).list, q_ = (n, s, a) => ({
      within: n,
      extra: s,
      withinWidth: a
    }), fB = (n, s, a) => {
      const l = Z9(n, (C, x) => {
        const T = a(C);
        return A.some({
          element: C,
          start: x,
          finish: x + T,
          width: T
        });
      }), d = Ln(l, (C) => C.finish <= s), g = oo(d, (C, x) => C + x.width, 0), h = l.slice(d.length);
      return {
        within: d,
        extra: h,
        withinWidth: g
      };
    }, wx = (n) => ye(n, (s) => s.element), G9 = (n, s, a) => {
      const l = wx(n.concat(s));
      return q_(l, [], a);
    }, q9 = (n, s, a, l) => {
      const d = wx(n).concat([a]);
      return q_(d, wx(s), l);
    }, K9 = (n, s, a) => q_(wx(n), [], a), Y9 = (n, s, a) => {
      const l = fB(s, n, a);
      return l.extra.length === 0 ? A.some(l) : A.none();
    }, X9 = (n, s, a, l) => {
      const d = Y9(n, s, a).getOrThunk(() => (
        // If that doesn't work, overflow
        fB(s, n - a(l), a)
      )), g = d.within, h = d.extra, C = d.withinWidth;
      return h.length === 1 && h[0].width <= a(l) ? G9(g, h, C) : h.length >= 1 ? q9(g, h, l, C) : K9(g, h, C);
    }, gB = (n, s) => {
      const a = ye(s, (l) => y(l));
      Rm.setGroups(n, a);
    }, K_ = (n) => ga(n, (s) => or(s.element).bind((a) => s.getSystem().getByDom(a).toOptional())), hB = (n, s, a) => {
      const l = s.builtGroups.get();
      if (l.length === 0)
        return;
      const d = Bu(n, s, "primary"), g = Rn.getCoupled(n, "overflowGroup");
      gn(d.element, "visibility", "hidden");
      const h = l.concat([g]), C = K_(h);
      a([]), gB(d, h);
      const x = la(d.element), T = X9(x, s.builtGroups.get(), (_) => Math.ceil(_.element.dom.getBoundingClientRect().width), g);
      T.extra.length === 0 ? (An.remove(d, g), a([])) : (gB(d, T.within), a(T.extra)), Kn(d.element, "visibility"), Il(d.element), C.each(En.focus);
    }, pB = oe([
      Aa("splitToolbarBehaviours", [Rn]),
      xc("builtGroups", () => Pt([]))
    ]), Q9 = oe([
      lo(["overflowToggledClass"]),
      qi("getOverflowBounds"),
      Ze("lazySink"),
      xc("overflowGroups", () => Pt([])),
      yo("onOpened"),
      yo("onClosed")
    ].concat(pB())), J9 = oe([
      nc({
        factory: Rm,
        schema: jv(),
        name: "primary"
      }),
      xi({
        schema: jv(),
        name: "overflow"
      }),
      xi({
        name: "overflow-button"
      }),
      xi({
        name: "overflow-group"
      })
    ]), eV = oe([
      Ze("items"),
      lo(["itemSelector"]),
      Aa("tgroupBehaviours", [Xt])
    ]), tV = oe([
      P0({
        name: "items",
        unit: "item"
      })
    ]), nV = (n, s, a, l) => ({
      uid: n.uid,
      dom: n.dom,
      components: s,
      behaviours: rc(n.tgroupBehaviours, [
        Xt.config({
          mode: "flow",
          selector: n.markers.itemSelector
        })
      ]),
      domModification: {
        attributes: {
          role: "toolbar"
        }
      }
    }), OT = yl({
      name: "ToolbarGroup",
      configFields: eV(),
      partFields: tV(),
      factory: nV
    }), bB = (n) => ye(n, (s) => y(s)), vB = (n, s, a) => {
      hB(n, a, (l) => {
        a.overflowGroups.set(l), s.getOpt(n).each((d) => {
          Kg.setGroups(d, bB(l));
        });
      });
    }, oV = (n, s, a, l) => {
      const d = To(Kg.sketch({
        fetch: () => Zo.nu((g) => {
          g(bB(n.overflowGroups.get()));
        }),
        layouts: {
          onLtr: () => [Er, Mr],
          onRtl: () => [Mr, Er],
          onBottomLtr: () => [ua, Ta],
          onBottomRtl: () => [Ta, ua]
        },
        getBounds: a.getOverflowBounds,
        lazySink: n.lazySink,
        fireDismissalEventInstead: {},
        markers: {
          toggledClass: n.markers.overflowToggledClass
        },
        parts: {
          button: l["overflow-button"](),
          toolbar: l.overflow()
        },
        onToggled: (g, h) => n[h ? "onOpened" : "onClosed"](g)
      }));
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        behaviours: rc(n.splitToolbarBehaviours, [
          Rn.config({
            others: {
              overflowGroup: () => OT.sketch({
                ...l["overflow-group"](),
                items: [
                  d.asSpec()
                ]
              })
            }
          })
        ]),
        apis: {
          setGroups: (g, h) => {
            n.builtGroups.set(ye(h, g.getSystem().build)), vB(g, d, n);
          },
          refresh: (g) => vB(g, d, n),
          toggle: (g) => {
            d.getOpt(g).each((h) => {
              Kg.toggle(h);
            });
          },
          toggleWithoutFocusing: (g) => {
            d.getOpt(g).each(Kg.toggleWithoutFocusing);
          },
          isOpen: (g) => d.getOpt(g).map(Kg.isOpen).getOr(!1),
          reposition: (g) => {
            d.getOpt(g).each((h) => {
              Kg.reposition(h);
            });
          },
          getOverflow: (g) => d.getOpt(g).bind(Kg.getToolbar)
        },
        domModification: {
          attributes: { role: "group" }
        }
      };
    }, yB = yl({
      name: "SplitFloatingToolbar",
      configFields: Q9(),
      partFields: J9(),
      factory: oV,
      apis: {
        setGroups: (n, s, a) => {
          n.setGroups(s, a);
        },
        refresh: (n, s) => {
          n.refresh(s);
        },
        reposition: (n, s) => {
          n.reposition(s);
        },
        toggle: (n, s) => {
          n.toggle(s);
        },
        toggleWithoutFocusing: (n, s) => {
          n.toggle(s);
        },
        isOpen: (n, s) => n.isOpen(s),
        getOverflow: (n, s) => n.getOverflow(s)
      }
    }), sV = oe([
      lo(["closedClass", "openClass", "shrinkingClass", "growingClass", "overflowToggledClass"]),
      yo("onOpened"),
      yo("onClosed")
    ].concat(pB())), rV = oe([
      nc({
        factory: Rm,
        schema: jv(),
        name: "primary"
      }),
      nc({
        factory: Rm,
        schema: jv(),
        name: "overflow",
        overrides: (n) => ({
          toolbarBehaviours: nt([
            Kc.config({
              dimension: {
                property: "height"
              },
              closedClass: n.markers.closedClass,
              openClass: n.markers.openClass,
              shrinkingClass: n.markers.shrinkingClass,
              growingClass: n.markers.growingClass,
              onShrunk: (s) => {
                Jo(s, n, "overflow-button").each((a) => {
                  eo.off(a);
                }), n.onClosed(s);
              },
              onGrown: (s) => {
                n.onOpened(s);
              },
              onStartGrow: (s) => {
                Jo(s, n, "overflow-button").each(eo.on);
              }
            }),
            Xt.config({
              mode: "acyclic",
              onEscape: (s) => (Jo(s, n, "overflow-button").each(En.focus), A.some(!0))
            })
          ])
        })
      }),
      xi({
        name: "overflow-button",
        overrides: (n) => ({
          buttonBehaviours: nt([
            eo.config({
              toggleClass: n.markers.overflowToggledClass,
              aria: {
                mode: "expanded"
              },
              toggleOnExecute: !1
            })
          ])
        })
      }),
      xi({
        name: "overflow-group"
      })
    ]), aV = (n, s) => Jo(n, s, "overflow").map(Kc.hasGrown).getOr(!1), Ex = (n, s, a) => {
      Jo(n, s, "overflow-button").each((l) => {
        Jo(n, s, "overflow").each((d) => {
          if (Y_(n, s), Kc.hasShrunk(d)) {
            const g = s.onOpened;
            s.onOpened = (h) => {
              a || Xt.focusIn(d), g(h), s.onOpened = g;
            };
          } else {
            const g = s.onClosed;
            s.onClosed = (h) => {
              a || En.focus(l), g(h), s.onClosed = g;
            };
          }
          Kc.toggleGrow(d);
        });
      });
    }, Y_ = (n, s) => {
      Jo(n, s, "overflow").each((a) => {
        hB(n, s, (l) => {
          const d = ye(l, (g) => y(g));
          Rm.setGroups(a, d);
        }), Jo(n, s, "overflow-button").each((l) => {
          Kc.hasGrown(a) && eo.on(l);
        }), Kc.refresh(a);
      });
    }, cV = (n, s, a, l) => {
      const d = "alloy.toolbar.toggle", g = (h, C) => {
        const x = ye(C, h.getSystem().build);
        n.builtGroups.set(x);
      };
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        behaviours: rc(n.splitToolbarBehaviours, [
          Rn.config({
            others: {
              overflowGroup: (h) => OT.sketch({
                ...l["overflow-group"](),
                items: [
                  oa.sketch({
                    ...l["overflow-button"](),
                    action: (C) => {
                      Wn(h, d);
                    }
                  })
                ]
              })
            }
          }),
          xn("toolbar-toggle-events", [
            Ie(d, (h) => {
              Ex(h, n, !1);
            })
          ])
        ]),
        apis: {
          setGroups: (h, C) => {
            g(h, C), Y_(h, n);
          },
          refresh: (h) => Y_(h, n),
          toggle: (h) => {
            Ex(h, n, !1);
          },
          toggleWithoutFocusing: (h) => {
            Ex(h, n, !0);
          },
          isOpen: (h) => aV(h, n)
        },
        domModification: {
          attributes: { role: "group" }
        }
      };
    }, X_ = yl({
      name: "SplitSlidingToolbar",
      configFields: sV(),
      partFields: rV(),
      factory: cV,
      apis: {
        setGroups: (n, s, a) => {
          n.setGroups(s, a);
        },
        refresh: (n, s) => {
          n.refresh(s);
        },
        toggle: (n, s) => {
          n.toggle(s);
        },
        isOpen: (n, s) => n.isOpen(s)
      }
    }), Tx = (n, s) => ({
      uid: n.uid,
      dom: n.dom,
      components: n.components,
      events: r_(n.action),
      behaviours: rc(n.tabButtonBehaviours, [
        En.config({}),
        Xt.config({
          mode: "execution",
          useSpace: !0,
          useEnter: !0
        }),
        _t.config({
          store: {
            mode: "memory",
            initialValue: n.value
          }
        })
      ]),
      domModification: n.domModification
    }), CB = su({
      name: "TabButton",
      configFields: [
        we("uid", void 0),
        Ze("value"),
        ta("dom", "dom", im(() => ({
          attributes: {
            role: "tab",
            // NOTE: This is used in TabSection to connect "labelledby"
            id: Ct("aria"),
            "aria-selected": "false"
          }
        })), pi()),
        Fo("action"),
        we("domModification", {}),
        Aa("tabButtonBehaviours", [En, Xt, _t]),
        Ze("view")
      ],
      factory: Tx
    }), lV = oe([
      Ze("tabs"),
      Ze("dom"),
      we("clickToDismiss", !1),
      Aa("tabbarBehaviours", [So, Xt]),
      lo(["tabClass", "selectedClass"])
    ]), iV = P0({
      factory: CB,
      name: "tabs",
      unit: "tab",
      overrides: (n) => {
        const s = (l, d) => {
          So.dehighlight(l, d), tn(l, E0(), {
            tabbar: l,
            button: d
          });
        }, a = (l, d) => {
          So.highlight(l, d), tn(l, k2(), {
            tabbar: l,
            button: d
          });
        };
        return {
          action: (l) => {
            const d = l.getSystem().getByUid(n.uid).getOrDie(), g = So.isHighlighted(d, l);
            (g && n.clickToDismiss ? s : g ? U : a)(d, l);
          },
          domModification: {
            classes: [n.markers.tabClass]
          }
        };
      }
    }), xB = oe([
      iV
    ]), uV = (n, s, a, l) => ({
      uid: n.uid,
      dom: n.dom,
      components: s,
      "debug.sketcher": "Tabbar",
      domModification: {
        attributes: {
          role: "tablist"
        }
      },
      behaviours: rc(n.tabbarBehaviours, [
        So.config({
          highlightClass: n.markers.selectedClass,
          itemClass: n.markers.tabClass,
          // https://www.w3.org/TR/2010/WD-wai-aria-practices-20100916/#tabpanel
          // Consider a more seam-less way of combining highlighting and toggling
          onHighlight: (d, g) => {
            ln(g.element, "aria-selected", "true");
          },
          onDehighlight: (d, g) => {
            ln(g.element, "aria-selected", "false");
          }
        }),
        Xt.config({
          mode: "flow",
          getInitial: (d) => So.getHighlighted(d).map((g) => g.element),
          selector: "." + n.markers.tabClass,
          executeOnMove: !0
        })
      ])
    }), SB = yl({
      name: "Tabbar",
      configFields: lV(),
      partFields: xB(),
      factory: uV
    }), dV = (n, s) => ({
      uid: n.uid,
      dom: n.dom,
      behaviours: rc(n.tabviewBehaviours, [
        An.config({})
      ]),
      domModification: {
        attributes: { role: "tabpanel" }
      }
    }), mV = su({
      name: "Tabview",
      configFields: [
        Aa("tabviewBehaviours", [An])
      ],
      factory: dV
    }), fV = oe([
      we("selectFirst", !0),
      yo("onChangeTab"),
      yo("onDismissTab"),
      we("tabs", []),
      Aa("tabSectionBehaviours", [])
    ]), gV = nc({
      factory: SB,
      schema: [
        Ze("dom"),
        xd("markers", [
          Ze("tabClass"),
          Ze("selectedClass")
        ])
      ],
      name: "tabbar",
      defaults: (n) => ({
        tabs: n.tabs
      })
    }), hV = nc({
      factory: mV,
      name: "tabview"
    }), pV = oe([
      gV,
      hV
    ]), wB = (n, s, a, l) => {
      const d = (h) => {
        const C = _t.getValue(h);
        Jo(h, n, "tabview").each((x) => {
          Lt(n.tabs, (_) => _.value === C).each((_) => {
            const N = _.view();
            Qr(h.element, "id").each((L) => {
              ln(x.element, "aria-labelledby", L);
            }), An.set(x, N), n.onChangeTab(x, h, N);
          });
        });
      }, g = (h, C) => {
        Jo(h, n, "tabbar").each((x) => {
          C(x).each(Yh);
        });
      };
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        behaviours: QC(n.tabSectionBehaviours),
        events: Ts(en([
          n.selectFirst ? [
            hs((h, C) => {
              g(h, So.getFirst);
            })
          ] : [],
          [
            Ie(k2(), (h, C) => {
              const x = C.event.button;
              d(x);
            }),
            Ie(E0(), (h, C) => {
              const x = C.event.button;
              n.onDismissTab(h, x);
            })
          ]
        ])),
        apis: {
          getViewItems: (h) => Jo(h, n, "tabview").map((C) => An.contents(C)).getOr([]),
          // How should "clickToDismiss" interact with this? At the moment, it will never dismiss
          showTab: (h, C) => {
            g(h, (T) => {
              const _ = So.getCandidates(T);
              return Lt(_, (L) => _t.getValue(L) === C).filter((L) => !So.isHighlighted(T, L));
            });
          }
        }
      };
    }, vb = yl({
      name: "TabSection",
      configFields: fV(),
      partFields: pV(),
      factory: wB,
      apis: {
        getViewItems: (n, s) => n.getViewItems(s),
        showTab: (n, s, a) => {
          n.showTab(s, a);
        }
      }
    }), DT = (n, s, a) => {
      const l = _t.getValue(a);
      _t.setValue(s, l), J_(s);
    }, Q_ = (n, s) => {
      const a = n.element, l = bc(a), d = a.dom;
      Dr(a, "type") !== "number" && s(d, l);
    }, J_ = (n) => {
      Q_(n, (s, a) => s.setSelectionRange(a.length, a.length));
    }, EB = (n, s) => {
      Q_(n, (a, l) => a.setSelectionRange(s, l.length));
    }, TB = (n, s, a) => {
      if (n.selectsOver) {
        const l = _t.getValue(s), d = n.getDisplayText(l), g = _t.getValue(a);
        return n.getDisplayText(g).indexOf(d) === 0 ? A.some(() => {
          DT(n, s, a), EB(s, d.length);
        }) : A.none();
      } else
        return A.none();
    }, eO = oe("alloy.typeahead.itemexecute"), bV = (n, s, a, l) => {
      const d = (N, L, j) => {
        n.previewing.set(!1);
        const Z = Rn.getCoupled(N, "sandbox");
        if (Co.isOpen(Z))
          Fe.getCurrent(Z).each((ne) => {
            So.getHighlighted(ne).fold(() => {
              j(ne);
            }, () => {
              G2(Z, ne.element, "keydown", L);
            });
          });
        else {
          const ne = (ae) => {
            Fe.getCurrent(ae).each(j);
          };
          uT(n, h(N), N, Z, l, ne, Ha.HighlightMenuAndItem).get(U);
        }
      }, g = PP(n), h = (N) => (L) => L.map((j) => {
        const Z = Ka(j.menus), ne = xe(Z, (Y) => Ln(Y.items, (le) => le.type === "item"));
        return _t.getState(N).update(ye(ne, (Y) => Y.data)), j;
      }), C = (N) => Fe.getCurrent(N), x = "typeaheadevents", T = [
        En.config({}),
        _t.config({
          onSetValue: n.onSetValue,
          store: {
            mode: "dataset",
            getDataKey: (N) => bc(N.element),
            // This really needs to be configurable
            getFallbackEntry: (N) => ({
              value: N,
              meta: {}
            }),
            setValue: (N, L) => {
              fi(N.element, n.model.getDisplayText(L));
            },
            ...n.initialData.map((N) => ff("initialValue", N)).getOr({})
          }
        }),
        Vv.config({
          stream: {
            mode: "throttle",
            delay: n.responseTime,
            stopEvent: !1
          },
          onStream: (N, L) => {
            const j = Rn.getCoupled(N, "sandbox");
            if (En.isFocused(N) && bc(N.element).length >= n.minChars) {
              const ne = C(j).bind((Y) => So.getHighlighted(Y).map(_t.getValue));
              n.previewing.set(!0);
              const ae = (Y) => {
                C(j).each((le) => {
                  ne.fold(() => {
                    n.model.selectsOver && So.highlightFirst(le);
                  }, (pe) => {
                    So.highlightBy(le, (Ee) => _t.getValue(Ee).value === pe.value), So.getHighlighted(le).orThunk(() => (So.highlightFirst(le), A.none()));
                  });
                });
              };
              uT(
                n,
                h(N),
                N,
                j,
                l,
                ae,
                // The onOpenSync takes care of what should be given the highlights, but
                // we want to highlight just the menu so that the onOpenSync can find the
                // activeMenu.
                Ha.HighlightJustMenu
              ).get(U);
            }
          },
          cancelEvent: S0()
        }),
        Xt.config({
          mode: "special",
          onDown: (N, L) => (d(N, L, So.highlightFirst), A.some(!0)),
          onEscape: (N) => {
            const L = Rn.getCoupled(N, "sandbox");
            return Co.isOpen(L) ? (Co.close(L), A.some(!0)) : A.none();
          },
          onUp: (N, L) => (d(N, L, So.highlightLast), A.some(!0)),
          onEnter: (N) => {
            const L = Rn.getCoupled(N, "sandbox"), j = Co.isOpen(L);
            if (j && !n.previewing.get())
              return C(L).bind((Z) => So.getHighlighted(Z)).map((Z) => (tn(N, eO(), { item: Z }), !0));
            {
              const Z = _t.getValue(N);
              return Wn(N, S0()), n.onExecute(L, N, Z), j && Co.close(L), A.some(!0);
            }
          }
        }),
        eo.config({
          toggleClass: n.markers.openClass,
          aria: {
            mode: "expanded"
          }
        }),
        Rn.config({
          others: {
            sandbox: (N) => TP(n, N, {
              onOpen: () => eo.on(N),
              onClose: () => {
                n.lazyTypeaheadComp.get().each((L) => fs(L.element, "aria-activedescendant")), eo.off(N);
              }
            })
          }
        }),
        xn(x, [
          hs((N) => {
            n.lazyTypeaheadComp.set(A.some(N));
          }),
          eu((N) => {
            n.lazyTypeaheadComp.set(A.none());
          }),
          Ef((N) => {
            const L = U;
            dT(n, h(N), N, l, L, Ha.HighlightMenuAndItem).get(U);
          }),
          Ie(eO(), (N, L) => {
            const j = Rn.getCoupled(N, "sandbox");
            DT(n.model, N, L.event.item), Wn(N, S0()), n.onItemExecute(N, j, L.event.item, _t.getValue(N)), Co.close(j), J_(N);
          })
        ].concat(n.dismissOnBlur ? [
          Ie(Ih(), (N) => {
            const L = Rn.getCoupled(N, "sandbox");
            or(L.element).isNone() && Co.close(L);
          })
        ] : []))
      ], _ = {
        [Ci()]: [
          _t.name(),
          Vv.name(),
          x
        ],
        ...n.eventOrder
      };
      return {
        uid: n.uid,
        dom: A_(Ho(n, {
          // TODO: Add aria-activedescendant attribute
          inputAttributes: {
            role: "combobox",
            "aria-autocomplete": "list",
            "aria-haspopup": "true"
          }
        })),
        behaviours: {
          ...g,
          ...rc(n.typeaheadBehaviours, T)
        },
        eventOrder: _
      };
    }, vV = oe([
      Fo("lazySink"),
      Ze("fetch"),
      we("minChars", 5),
      we("responseTime", 1e3),
      yo("onOpen"),
      // TODO: Remove dupe with Dropdown
      we("getHotspot", A.some),
      we("getAnchorOverrides", oe({})),
      we("layouts", A.none()),
      we("eventOrder", {}),
      // Information about what these model settings do can be found in TypeaheadTypes
      mf("model", {}, [
        we("getDisplayText", (n) => n.meta !== void 0 && n.meta.text !== void 0 ? n.meta.text : n.value),
        we("selectsOver", !0),
        we("populateFromBrowse", !0)
      ]),
      yo("onSetValue"),
      hl("onExecute"),
      yo("onItemExecute"),
      we("inputClasses", []),
      we("inputAttributes", {}),
      we("inputStyles", {}),
      we("matchWidth", !0),
      we("useMinWidth", !1),
      we("dismissOnBlur", !0),
      lo(["openClass"]),
      Fo("initialData"),
      Fo("listRole"),
      Aa("typeaheadBehaviours", [
        En,
        _t,
        Vv,
        Xt,
        eo,
        Rn
      ]),
      xc("lazyTypeaheadComp", () => Pt(A.none)),
      xc("previewing", () => Pt(!0))
    ].concat(k_()).concat(x_())), yV = oe([
      xi({
        schema: [
          tw()
        ],
        name: "menu",
        overrides: (n) => ({
          fakeFocus: !0,
          onHighlightItem: (s, a, l) => {
            n.previewing.get() ? n.lazyTypeaheadComp.get().each((d) => {
              TB(n.model, d, l).fold(
                // If we are in "previewing" mode and we can't select over the
                // thing that is first, then clear the highlight.
                // Hopefully, this doesn't cause a flicker. Find a better
                // way to do this.
                () => {
                  n.model.selectsOver ? (So.dehighlight(a, l), n.previewing.set(!0)) : n.previewing.set(!1);
                },
                (g) => {
                  g(), n.previewing.set(!1);
                }
              );
            }) : n.lazyTypeaheadComp.get().each((d) => {
              n.model.populateFromBrowse && DT(n.model, d, l), Qr(l.element, "id").each((g) => ln(d.element, "aria-activedescendant", g));
            });
          },
          // Because the focus stays inside the input, this onExecute is fired when the
          // user "clicks" on an item. The focusing behaviour should be configured
          // so that items don't get focus, but they prevent a mousedown event from
          // firing so that the typeahead doesn't lose focus. This is the handler
          // for clicking on an item. We need to close the sandbox, update the typeahead
          // to show the item clicked on, and fire an execute.
          onExecute: (s, a) => n.lazyTypeaheadComp.get().map((l) => (tn(l, eO(), { item: a }), !0)),
          onHover: (s, a) => {
            n.previewing.set(!1), n.lazyTypeaheadComp.get().each((l) => {
              n.model.populateFromBrowse && DT(n.model, l, a);
            });
          }
        })
      })
    ]), tO = yl({
      name: "Typeahead",
      configFields: vV(),
      partFields: yV(),
      factory: bV
    });
    var kB = tinymce.util.Tools.resolve("tinymce.ThemeManager"), RT = tinymce.util.Tools.resolve("tinymce.util.Delay"), qv = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), CV = tinymce.util.Tools.resolve("tinymce.EditorManager"), Kv = tinymce.util.Tools.resolve("tinymce.Env"), lu;
    (function(n) {
      n.default = "wrap", n.floating = "floating", n.sliding = "sliding", n.scrolling = "scrolling";
    })(lu || (lu = {}));
    var Yv;
    (function(n) {
      n.auto = "auto", n.top = "top", n.bottom = "bottom";
    })(Yv || (Yv = {}));
    const Yo = (n) => (s) => s.options.get(n), Xv = (n) => (s) => A.from(n(s)), AB = (n) => {
      const s = Kv.deviceType.isPhone(), a = Kv.deviceType.isTablet() || s, l = n.options.register, d = (h) => De(h) || h === !1, g = (h) => De(h) || In(h);
      l("skin", {
        processor: (h) => De(h) || h === !1,
        default: "oxide"
      }), l("skin_url", {
        processor: "string"
      }), l("height", {
        processor: g,
        default: Math.max(n.getElement().offsetHeight, 400)
      }), l("width", {
        processor: g,
        default: qv.DOM.getStyle(n.getElement(), "width")
      }), l("min_height", {
        processor: "number",
        default: 100
      }), l("min_width", {
        processor: "number"
      }), l("max_height", {
        processor: "number"
      }), l("max_width", {
        processor: "number"
      }), l("style_formats", {
        processor: "object[]"
      }), l("style_formats_merge", {
        processor: "boolean",
        default: !1
      }), l("style_formats_autohide", {
        processor: "boolean",
        default: !1
      }), l("line_height_formats", {
        processor: "string",
        default: "1 1.1 1.2 1.3 1.4 1.5 2"
      }), l("font_family_formats", {
        processor: "string",
        default: "Andale Mono=andale mono,monospace;Arial=arial,helvetica,sans-serif;Arial Black=arial black,sans-serif;Book Antiqua=book antiqua,palatino,serif;Comic Sans MS=comic sans ms,sans-serif;Courier New=courier new,courier,monospace;Georgia=georgia,palatino,serif;Helvetica=helvetica,arial,sans-serif;Impact=impact,sans-serif;Symbol=symbol;Tahoma=tahoma,arial,helvetica,sans-serif;Terminal=terminal,monaco,monospace;Times New Roman=times new roman,times,serif;Trebuchet MS=trebuchet ms,geneva,sans-serif;Verdana=verdana,geneva,sans-serif;Webdings=webdings;Wingdings=wingdings,zapf dingbats"
      }), l("font_size_formats", {
        processor: "string",
        default: "8pt 10pt 12pt 14pt 18pt 24pt 36pt"
      }), l("font_size_input_default_unit", {
        processor: "string",
        default: "pt"
      }), l("block_formats", {
        processor: "string",
        default: "Paragraph=p;Heading 1=h1;Heading 2=h2;Heading 3=h3;Heading 4=h4;Heading 5=h5;Heading 6=h6;Preformatted=pre"
      }), l("content_langs", {
        processor: "object[]"
      }), l("removed_menuitems", {
        processor: "string",
        default: ""
      }), l("menubar", {
        processor: (h) => De(h) || vn(h),
        // Phones don't have a lot of screen space so disable the menubar
        default: !s
      }), l("menu", {
        processor: "object",
        default: {}
      }), l("toolbar", {
        processor: (h) => vn(h) || De(h) || $n(h) ? { value: h, valid: !0 } : { valid: !1, message: "Must be a boolean, string or array." },
        default: !0
      }), fn(9, (h) => {
        l("toolbar" + (h + 1), {
          processor: "string"
        });
      }), l("toolbar_mode", {
        processor: "string",
        // Use the default side-scrolling toolbar for tablets/phones
        default: a ? "scrolling" : "floating"
      }), l("toolbar_groups", {
        processor: "object",
        default: {}
      }), l("toolbar_location", {
        processor: "string",
        default: Yv.auto
      }), l("toolbar_persist", {
        processor: "boolean",
        default: !1
      }), l("toolbar_sticky", {
        processor: "boolean",
        default: n.inline
      }), l("toolbar_sticky_offset", {
        processor: "number",
        default: 0
      }), l("fixed_toolbar_container", {
        processor: "string",
        default: ""
      }), l("fixed_toolbar_container_target", {
        processor: "object"
      }), l("ui_mode", {
        processor: "string",
        default: "combined"
      }), l("file_picker_callback", {
        processor: "function"
      }), l("file_picker_validator_handler", {
        processor: "function"
      }), l("file_picker_types", {
        processor: "string"
      }), l("typeahead_urls", {
        processor: "boolean",
        default: !0
      }), l("anchor_top", {
        processor: d,
        default: "#top"
      }), l("anchor_bottom", {
        processor: d,
        default: "#bottom"
      }), l("draggable_modal", {
        processor: "boolean",
        default: !1
      }), l("statusbar", {
        processor: "boolean",
        default: !0
      }), l("elementpath", {
        processor: "boolean",
        default: !0
      }), l("branding", {
        processor: "boolean",
        default: !0
      }), l("promotion", {
        processor: "boolean",
        default: !0
      }), l("resize", {
        processor: (h) => h === "both" || vn(h),
        // Editor resize doesn't work on touch devices at this stage
        default: !Kv.deviceType.isTouch()
      }), l("sidebar_show", {
        processor: "string"
      }), l("help_accessibility", {
        processor: "boolean",
        default: n.hasPlugin("help")
      }), l("default_font_stack", {
        processor: "string[]",
        default: []
      });
    }, _B = Yo("readonly"), NT = Yo("disabled"), nO = Yo("height"), oO = Yo("width"), sO = Xv(Yo("min_width")), rO = Xv(Yo("min_height")), MT = Xv(Yo("max_width")), aO = Xv(Yo("max_height")), OB = Xv(Yo("style_formats")), DB = Yo("style_formats_merge"), cO = Yo("style_formats_autohide"), RB = Yo("content_langs"), NB = Yo("removed_menuitems"), yb = Yo("toolbar_mode"), MB = Yo("toolbar_groups"), lO = Yo("toolbar_location"), PT = Yo("fixed_toolbar_container"), PB = Yo("fixed_toolbar_container_target"), BB = Yo("toolbar_persist"), $B = Yo("toolbar_sticky_offset"), IB = Yo("menubar"), BT = Yo("toolbar"), FB = Yo("file_picker_callback"), LB = Yo("file_picker_validator_handler"), $T = Yo("font_size_input_default_unit"), iO = Yo("file_picker_types"), uO = Yo("typeahead_urls"), HB = Yo("anchor_top"), dO = Yo("anchor_bottom"), zB = Yo("draggable_modal"), VB = Yo("statusbar"), UB = Yo("elementpath"), mO = Yo("branding"), jB = Yo("resize"), WB = Yo("paste_as_text"), ZB = Yo("sidebar_show"), GB = Yo("promotion"), qB = Yo("help_accessibility"), KB = Yo("default_font_stack"), kx = Yo("skin"), Ax = (n) => n.options.get("skin") === !1, Qv = (n) => n.options.get("menubar") !== !1, fO = (n) => {
      const s = n.options.get("skin_url");
      if (Ax(n))
        return s;
      if (s)
        return n.documentBaseURI.toAbsolute(s);
      {
        const a = n.options.get("skin");
        return CV.baseURL + "/skins/ui/" + a;
      }
    }, xV = (n) => A.from(n.options.get("skin_url")), YB = (n) => n.options.get("line_height_formats").split(" "), Jv = (n) => {
      const s = BT(n), a = De(s), l = $n(s) && s.length > 0;
      return !xp(n) && (l || a || s === !0);
    }, _x = (n) => {
      const s = fn(9, (l) => n.options.get("toolbar" + (l + 1))), a = Ln(s, De);
      return Br(a.length > 0, a);
    }, xp = (n) => _x(n).fold(() => {
      const s = BT(n);
      return lt(s, De) && s.length > 0;
    }, St), IT = (n) => lO(n) === Yv.bottom, XB = (n) => {
      if (!n.inline)
        return A.none();
      const s = PT(n) ?? "";
      if (s.length > 0)
        return Po(Lc(), s);
      const a = PB(n);
      return un(a) ? A.some(at.fromDom(a)) : A.none();
    }, ey = (n) => n.inline && XB(n).isSome(), gO = (n) => XB(n).getOrThunk(() => ci(mr(at.fromDom(n.getElement())))), hO = (n) => n.inline && !Qv(n) && !Jv(n) && !xp(n), ty = (n) => (n.options.get("toolbar_sticky") || n.inline) && !ey(n) && !hO(n), Sp = (n) => !ey(n) && n.options.get("ui_mode") === "split", QB = (n) => {
      const s = n.options.get("menu");
      return Bs(s, (a) => ({ ...a, items: a.items }));
    };
    var SV = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      get ToolbarMode() {
        return lu;
      },
      get ToolbarLocation() {
        return Yv;
      },
      register: AB,
      getSkinUrl: fO,
      getSkinUrlOption: xV,
      isReadOnly: _B,
      isDisabled: NT,
      getSkin: kx,
      isSkinDisabled: Ax,
      getHeightOption: nO,
      getWidthOption: oO,
      getMinWidthOption: sO,
      getMinHeightOption: rO,
      getMaxWidthOption: MT,
      getMaxHeightOption: aO,
      getUserStyleFormats: OB,
      shouldMergeStyleFormats: DB,
      shouldAutoHideStyleFormats: cO,
      getLineHeightFormats: YB,
      getContentLanguages: RB,
      getRemovedMenuItems: NB,
      isMenubarEnabled: Qv,
      isMultipleToolbars: xp,
      isToolbarEnabled: Jv,
      isToolbarPersist: BB,
      getMultipleToolbarsOption: _x,
      getUiContainer: gO,
      useFixedContainer: ey,
      isSplitUiMode: Sp,
      getToolbarMode: yb,
      isDraggableModal: zB,
      isDistractionFree: hO,
      isStickyToolbar: ty,
      getStickyToolbarOffset: $B,
      getToolbarLocation: lO,
      isToolbarLocationBottom: IT,
      getToolbarGroups: MB,
      getMenus: QB,
      getMenubar: IB,
      getToolbar: BT,
      getFilePickerCallback: FB,
      getFilePickerTypes: iO,
      useTypeaheadUrls: uO,
      getAnchorTop: HB,
      getAnchorBottom: dO,
      getFilePickerValidatorHandler: LB,
      getFontSizeInputDefaultUnit: $T,
      useStatusBar: VB,
      useElementPath: UB,
      promotionEnabled: GB,
      useBranding: mO,
      getResize: jB,
      getPasteAsText: WB,
      getSidebarShow: ZB,
      useHelpAccessibility: qB,
      getDefaultFontStack: KB
    });
    const wV = ["visible", "hidden", "clip"], JB = (n) => vt(n).length > 0 && !bt(wV, n), e6 = (n) => {
      if (te(n)) {
        const s = gs(n, "overflow-x"), a = gs(n, "overflow-y");
        return JB(s) || JB(a);
      } else
        return !1;
    }, t6 = (n) => n.plugins.fullscreen && n.plugins.fullscreen.isFullscreen(), EV = (n, s) => {
      const a = cr(s, e6), l = a.length === 0 ? Is(s).map(Eo).map((d) => cr(d, e6)).getOr([]) : a;
      return _o(l).map((d) => ({
        element: d,
        // A list of all scrolling elements above the nearest scroller,
        // ordered from closest to popup -> closest to top of document
        others: l.slice(1),
        isFullscreen: () => t6(n)
      }));
    }, Yg = (n, s) => Sp(n) ? EV(n, s) : A.none(), Cb = (n) => {
      const s = [
        // sc.element is the main scroller, others are *additional* scrollers above that
        // we need to combine all of them to constrain the bounds
        ...ye(n.others, wr),
        Ia()
      ];
      return n.isFullscreen() ? Ia() : r2(wr(n.element), s);
    };
    /*! @license DOMPurify 3.2.6 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.6/LICENSE */
    const {
      entries: n6,
      setPrototypeOf: Bm,
      isFrozen: TV,
      getPrototypeOf: kV,
      getOwnPropertyDescriptor: pO
    } = Object;
    let {
      freeze: bs,
      seal: jd,
      create: o6
    } = Object, {
      apply: bO,
      construct: vO
    } = typeof Reflect < "u" && Reflect;
    bs || (bs = function(s) {
      return s;
    }), jd || (jd = function(s) {
      return s;
    }), bO || (bO = function(s, a, l) {
      return s.apply(a, l);
    }), vO || (vO = function(s, a) {
      return new s(...a);
    });
    const FT = ki(Array.prototype.forEach), AV = ki(Array.prototype.lastIndexOf), s6 = ki(Array.prototype.pop), Ox = ki(Array.prototype.push), _V = ki(Array.prototype.splice), LT = ki(String.prototype.toLowerCase), yO = ki(String.prototype.toString), r6 = ki(String.prototype.match), Dx = ki(String.prototype.replace), OV = ki(String.prototype.indexOf), DV = ki(String.prototype.trim), $m = ki(Object.prototype.hasOwnProperty), Ti = ki(RegExp.prototype.test), Rx = RV(TypeError);
    function ki(n) {
      return function(s) {
        s instanceof RegExp && (s.lastIndex = 0);
        for (var a = arguments.length, l = new Array(a > 1 ? a - 1 : 0), d = 1; d < a; d++)
          l[d - 1] = arguments[d];
        return bO(n, s, l);
      };
    }
    function RV(n) {
      return function() {
        for (var s = arguments.length, a = new Array(s), l = 0; l < s; l++)
          a[l] = arguments[l];
        return vO(n, a);
      };
    }
    function vs(n, s) {
      let a = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : LT;
      Bm && Bm(n, null);
      let l = s.length;
      for (; l--; ) {
        let d = s[l];
        if (typeof d == "string") {
          const g = a(d);
          g !== d && (TV(s) || (s[l] = g), d = g);
        }
        n[d] = !0;
      }
      return n;
    }
    function NV(n) {
      for (let s = 0; s < n.length; s++)
        $m(n, s) || (n[s] = null);
      return n;
    }
    function Xg(n) {
      const s = o6(null);
      for (const [a, l] of n6(n))
        $m(n, a) && (Array.isArray(l) ? s[a] = NV(l) : l && typeof l == "object" && l.constructor === Object ? s[a] = Xg(l) : s[a] = l);
      return s;
    }
    function Nx(n, s) {
      for (; n !== null; ) {
        const l = pO(n, s);
        if (l) {
          if (l.get)
            return ki(l.get);
          if (typeof l.value == "function")
            return ki(l.value);
        }
        n = kV(n);
      }
      function a() {
        return null;
      }
      return a;
    }
    const a6 = bs(["a", "abbr", "acronym", "address", "area", "article", "aside", "audio", "b", "bdi", "bdo", "big", "blink", "blockquote", "body", "br", "button", "canvas", "caption", "center", "cite", "code", "col", "colgroup", "content", "data", "datalist", "dd", "decorator", "del", "details", "dfn", "dialog", "dir", "div", "dl", "dt", "element", "em", "fieldset", "figcaption", "figure", "font", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "img", "input", "ins", "kbd", "label", "legend", "li", "main", "map", "mark", "marquee", "menu", "menuitem", "meter", "nav", "nobr", "ol", "optgroup", "option", "output", "p", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "section", "select", "shadow", "small", "source", "spacer", "span", "strike", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "time", "tr", "track", "tt", "u", "ul", "var", "video", "wbr"]), HT = bs(["svg", "a", "altglyph", "altglyphdef", "altglyphitem", "animatecolor", "animatemotion", "animatetransform", "circle", "clippath", "defs", "desc", "ellipse", "filter", "font", "g", "glyph", "glyphref", "hkern", "image", "line", "lineargradient", "marker", "mask", "metadata", "mpath", "path", "pattern", "polygon", "polyline", "radialgradient", "rect", "stop", "style", "switch", "symbol", "text", "textpath", "title", "tref", "tspan", "view", "vkern"]), CO = bs(["feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence"]), c6 = bs(["animate", "color-profile", "cursor", "discard", "font-face", "font-face-format", "font-face-name", "font-face-src", "font-face-uri", "foreignobject", "hatch", "hatchpath", "mesh", "meshgradient", "meshpatch", "meshrow", "missing-glyph", "script", "set", "solidcolor", "unknown", "use"]), xO = bs(["math", "menclose", "merror", "mfenced", "mfrac", "mglyph", "mi", "mlabeledtr", "mmultiscripts", "mn", "mo", "mover", "mpadded", "mphantom", "mroot", "mrow", "ms", "mspace", "msqrt", "mstyle", "msub", "msup", "msubsup", "mtable", "mtd", "mtext", "mtr", "munder", "munderover", "mprescripts"]), l6 = bs(["maction", "maligngroup", "malignmark", "mlongdiv", "mscarries", "mscarry", "msgroup", "mstack", "msline", "msrow", "semantics", "annotation", "annotation-xml", "mprescripts", "none"]), i6 = bs(["#text"]), SO = bs(["accept", "action", "align", "alt", "autocapitalize", "autocomplete", "autopictureinpicture", "autoplay", "background", "bgcolor", "border", "capture", "cellpadding", "cellspacing", "checked", "cite", "class", "clear", "color", "cols", "colspan", "controls", "controlslist", "coords", "crossorigin", "datetime", "decoding", "default", "dir", "disabled", "disablepictureinpicture", "disableremoteplayback", "download", "draggable", "enctype", "enterkeyhint", "face", "for", "headers", "height", "hidden", "high", "href", "hreflang", "id", "inputmode", "integrity", "ismap", "kind", "label", "lang", "list", "loading", "loop", "low", "max", "maxlength", "media", "method", "min", "minlength", "multiple", "muted", "name", "nonce", "noshade", "novalidate", "nowrap", "open", "optimum", "pattern", "placeholder", "playsinline", "popover", "popovertarget", "popovertargetaction", "poster", "preload", "pubdate", "radiogroup", "readonly", "rel", "required", "rev", "reversed", "role", "rows", "rowspan", "spellcheck", "scope", "selected", "shape", "size", "sizes", "span", "srclang", "start", "src", "srcset", "step", "style", "summary", "tabindex", "title", "translate", "type", "usemap", "valign", "value", "width", "wrap", "xmlns", "slot"]), wO = bs(["accent-height", "accumulate", "additive", "alignment-baseline", "amplitude", "ascent", "attributename", "attributetype", "azimuth", "basefrequency", "baseline-shift", "begin", "bias", "by", "class", "clip", "clippathunits", "clip-path", "clip-rule", "color", "color-interpolation", "color-interpolation-filters", "color-profile", "color-rendering", "cx", "cy", "d", "dx", "dy", "diffuseconstant", "direction", "display", "divisor", "dur", "edgemode", "elevation", "end", "exponent", "fill", "fill-opacity", "fill-rule", "filter", "filterunits", "flood-color", "flood-opacity", "font-family", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-variant", "font-weight", "fx", "fy", "g1", "g2", "glyph-name", "glyphref", "gradientunits", "gradienttransform", "height", "href", "id", "image-rendering", "in", "in2", "intercept", "k", "k1", "k2", "k3", "k4", "kerning", "keypoints", "keysplines", "keytimes", "lang", "lengthadjust", "letter-spacing", "kernelmatrix", "kernelunitlength", "lighting-color", "local", "marker-end", "marker-mid", "marker-start", "markerheight", "markerunits", "markerwidth", "maskcontentunits", "maskunits", "max", "mask", "media", "method", "mode", "min", "name", "numoctaves", "offset", "operator", "opacity", "order", "orient", "orientation", "origin", "overflow", "paint-order", "path", "pathlength", "patterncontentunits", "patterntransform", "patternunits", "points", "preservealpha", "preserveaspectratio", "primitiveunits", "r", "rx", "ry", "radius", "refx", "refy", "repeatcount", "repeatdur", "restart", "result", "rotate", "scale", "seed", "shape-rendering", "slope", "specularconstant", "specularexponent", "spreadmethod", "startoffset", "stddeviation", "stitchtiles", "stop-color", "stop-opacity", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke", "stroke-width", "style", "surfacescale", "systemlanguage", "tabindex", "tablevalues", "targetx", "targety", "transform", "transform-origin", "text-anchor", "text-decoration", "text-rendering", "textlength", "type", "u1", "u2", "unicode", "values", "viewbox", "visibility", "version", "vert-adv-y", "vert-origin-x", "vert-origin-y", "width", "word-spacing", "wrap", "writing-mode", "xchannelselector", "ychannelselector", "x", "x1", "x2", "xmlns", "y", "y1", "y2", "z", "zoomandpan"]), u6 = bs(["accent", "accentunder", "align", "bevelled", "close", "columnsalign", "columnlines", "columnspan", "denomalign", "depth", "dir", "display", "displaystyle", "encoding", "fence", "frame", "height", "href", "id", "largeop", "length", "linethickness", "lspace", "lquote", "mathbackground", "mathcolor", "mathsize", "mathvariant", "maxsize", "minsize", "movablelimits", "notation", "numalign", "open", "rowalign", "rowlines", "rowspacing", "rowspan", "rspace", "rquote", "scriptlevel", "scriptminsize", "scriptsizemultiplier", "selection", "separator", "separators", "stretchy", "subscriptshift", "supscriptshift", "symmetric", "voffset", "width", "xmlns"]), zT = bs(["xlink:href", "xml:id", "xlink:title", "xml:space", "xmlns:xlink"]), MV = jd(/\{\{[\w\W]*|[\w\W]*\}\}/gm), PV = jd(/<%[\w\W]*|[\w\W]*%>/gm), BV = jd(/\$\{[\w\W]*/gm), $V = jd(/^data-[\-\w.\u00B7-\uFFFF]+$/), IV = jd(/^aria-[\-\w]+$/), d6 = jd(
      /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp|matrix):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i
      // eslint-disable-line no-useless-escape
    ), FV = jd(/^(?:\w+script|data):/i), LV = jd(
      /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g
      // eslint-disable-line no-control-regex
    ), m6 = jd(/^html$/i), HV = jd(/^[a-z][.\w]*(-[.\w]+)+$/i);
    var EO = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      ARIA_ATTR: IV,
      ATTR_WHITESPACE: LV,
      CUSTOM_ELEMENT: HV,
      DATA_ATTR: $V,
      DOCTYPE_NAME: m6,
      ERB_EXPR: PV,
      IS_ALLOWED_URI: d6,
      IS_SCRIPT_OR_DATA: FV,
      MUSTACHE_EXPR: MV,
      TMPLIT_EXPR: BV
    });
    const Mx = {
      element: 1,
      text: 3,
      // Deprecated
      progressingInstruction: 7,
      comment: 8,
      document: 9
    }, zV = function() {
      return typeof window > "u" ? null : window;
    }, VV = function(s, a) {
      if (typeof s != "object" || typeof s.createPolicy != "function")
        return null;
      let l = null;
      const d = "data-tt-policy-suffix";
      a && a.hasAttribute(d) && (l = a.getAttribute(d));
      const g = "dompurify" + (l ? "#" + l : "");
      try {
        return s.createPolicy(g, {
          createHTML(h) {
            return h;
          },
          createScriptURL(h) {
            return h;
          }
        });
      } catch {
        return console.warn("TrustedTypes policy " + g + " could not be created."), null;
      }
    }, f6 = function() {
      return {
        afterSanitizeAttributes: [],
        afterSanitizeElements: [],
        afterSanitizeShadowDOM: [],
        beforeSanitizeAttributes: [],
        beforeSanitizeElements: [],
        beforeSanitizeShadowDOM: [],
        uponSanitizeAttribute: [],
        uponSanitizeElement: [],
        uponSanitizeShadowNode: []
      };
    };
    function g6() {
      let n = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : zV();
      const s = (t) => g6(t);
      if (s.version = "3.2.6", s.removed = [], !n || !n.document || n.document.nodeType !== Mx.document || !n.Element)
        return s.isSupported = !1, s;
      let {
        document: a
      } = n;
      const l = a, d = l.currentScript, {
        DocumentFragment: g,
        HTMLTemplateElement: h,
        Node: C,
        Element: x,
        NodeFilter: T,
        NamedNodeMap: _ = n.NamedNodeMap || n.MozNamedAttrMap,
        HTMLFormElement: N,
        DOMParser: L,
        trustedTypes: j
      } = n, Z = x.prototype, ne = Nx(Z, "cloneNode"), ae = Nx(Z, "remove"), Y = Nx(Z, "nextSibling"), le = Nx(Z, "childNodes"), pe = Nx(Z, "parentNode");
      if (typeof h == "function") {
        const t = a.createElement("template");
        t.content && t.content.ownerDocument && (a = t.content.ownerDocument);
      }
      let Ee, Oe = "";
      const {
        implementation: gt,
        createNodeIterator: Ue,
        createDocumentFragment: Qe,
        getElementsByTagName: Ke
      } = a, {
        importNode: Qt
      } = l;
      let zt = f6();
      s.isSupported = typeof n6 == "function" && typeof pe == "function" && gt && gt.createHTMLDocument !== void 0;
      const {
        MUSTACHE_EXPR: jn,
        ERB_EXPR: Jt,
        TMPLIT_EXPR: _n,
        DATA_ATTR: Ut,
        ARIA_ATTR: Ve,
        IS_SCRIPT_OR_DATA: ct,
        ATTR_WHITESPACE: mn,
        CUSTOM_ELEMENT: Pn
      } = EO;
      let {
        IS_ALLOWED_URI: qt
      } = EO, Nn = null;
      const Xo = vs({}, [...a6, ...HT, ...CO, ...xO, ...i6]);
      let ko = null;
      const ac = vs({}, [...SO, ...wO, ...u6, ...zT]);
      let Ms = Object.seal(o6(null, {
        tagNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        attributeNameCheck: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: null
        },
        allowCustomizedBuiltInElements: {
          writable: !0,
          configurable: !1,
          enumerable: !0,
          value: !1
        }
      })), Yl = null, Da = null, mu = !0, Wa = !0, nd = !1, Pp = !0, qf = !1, Ny = !0, Kf = !1, kS = !1, BN = !1, My = !1, Py = !1, By = !1, n7 = !0, $N = !1;
      const wY = "user-content-";
      let IN = !0, $y = !1, Iy = {}, qd = null;
      const FN = vs({}, ["annotation-xml", "audio", "colgroup", "desc", "foreignobject", "head", "iframe", "math", "mi", "mn", "mo", "ms", "mtext", "noembed", "noframes", "noscript", "plaintext", "script", "style", "svg", "template", "thead", "title", "video", "xmp"]);
      let o7 = null;
      const AS = vs({}, ["audio", "video", "img", "source", "image", "track"]);
      let Bp = null;
      const _S = vs({}, ["alt", "class", "for", "id", "label", "name", "pattern", "placeholder", "role", "summary", "title", "value", "style", "xmlns"]), OS = "http://www.w3.org/1998/Math/MathML", Ub = "http://www.w3.org/2000/svg", aa = "http://www.w3.org/1999/xhtml";
      let ch = aa, x3 = !1, S3 = null;
      const EY = vs({}, [OS, Ub, aa], yO);
      let w3 = vs({}, ["mi", "mo", "mn", "ms", "mtext"]), Um = vs({}, ["annotation-xml"]);
      const _X = vs({}, ["title", "style", "font", "a", "script"]);
      let DS = null;
      const s7 = ["application/xhtml+xml", "text/html"], Fy = "text/html";
      let Za = null, jb = null;
      const TY = a.createElement("form"), r7 = function(o) {
        return o instanceof RegExp || o instanceof Function;
      }, LN = function() {
        let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(jb && jb === o)) {
          if ((!o || typeof o != "object") && (o = {}), o = Xg(o), DS = // eslint-disable-next-line unicorn/prefer-includes
          s7.indexOf(o.PARSER_MEDIA_TYPE) === -1 ? Fy : o.PARSER_MEDIA_TYPE, Za = DS === "application/xhtml+xml" ? yO : LT, Nn = $m(o, "ALLOWED_TAGS") ? vs({}, o.ALLOWED_TAGS, Za) : Xo, ko = $m(o, "ALLOWED_ATTR") ? vs({}, o.ALLOWED_ATTR, Za) : ac, S3 = $m(o, "ALLOWED_NAMESPACES") ? vs({}, o.ALLOWED_NAMESPACES, yO) : EY, Bp = $m(o, "ADD_URI_SAFE_ATTR") ? vs(Xg(_S), o.ADD_URI_SAFE_ATTR, Za) : _S, o7 = $m(o, "ADD_DATA_URI_TAGS") ? vs(Xg(AS), o.ADD_DATA_URI_TAGS, Za) : AS, qd = $m(o, "FORBID_CONTENTS") ? vs({}, o.FORBID_CONTENTS, Za) : FN, Yl = $m(o, "FORBID_TAGS") ? vs({}, o.FORBID_TAGS, Za) : Xg({}), Da = $m(o, "FORBID_ATTR") ? vs({}, o.FORBID_ATTR, Za) : Xg({}), Iy = $m(o, "USE_PROFILES") ? o.USE_PROFILES : !1, mu = o.ALLOW_ARIA_ATTR !== !1, Wa = o.ALLOW_DATA_ATTR !== !1, nd = o.ALLOW_UNKNOWN_PROTOCOLS || !1, Pp = o.ALLOW_SELF_CLOSE_IN_ATTR !== !1, qf = o.SAFE_FOR_TEMPLATES || !1, Ny = o.SAFE_FOR_XML !== !1, Kf = o.WHOLE_DOCUMENT || !1, My = o.RETURN_DOM || !1, Py = o.RETURN_DOM_FRAGMENT || !1, By = o.RETURN_TRUSTED_TYPE || !1, BN = o.FORCE_BODY || !1, n7 = o.SANITIZE_DOM !== !1, $N = o.SANITIZE_NAMED_PROPS || !1, IN = o.KEEP_CONTENT !== !1, $y = o.IN_PLACE || !1, qt = o.ALLOWED_URI_REGEXP || d6, ch = o.NAMESPACE || aa, w3 = o.MATHML_TEXT_INTEGRATION_POINTS || w3, Um = o.HTML_INTEGRATION_POINTS || Um, Ms = o.CUSTOM_ELEMENT_HANDLING || {}, o.CUSTOM_ELEMENT_HANDLING && r7(o.CUSTOM_ELEMENT_HANDLING.tagNameCheck) && (Ms.tagNameCheck = o.CUSTOM_ELEMENT_HANDLING.tagNameCheck), o.CUSTOM_ELEMENT_HANDLING && r7(o.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) && (Ms.attributeNameCheck = o.CUSTOM_ELEMENT_HANDLING.attributeNameCheck), o.CUSTOM_ELEMENT_HANDLING && typeof o.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements == "boolean" && (Ms.allowCustomizedBuiltInElements = o.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements), qf && (Wa = !1), Py && (My = !0), Iy && (Nn = vs({}, i6), ko = [], Iy.html === !0 && (vs(Nn, a6), vs(ko, SO)), Iy.svg === !0 && (vs(Nn, HT), vs(ko, wO), vs(ko, zT)), Iy.svgFilters === !0 && (vs(Nn, CO), vs(ko, wO), vs(ko, zT)), Iy.mathMl === !0 && (vs(Nn, xO), vs(ko, u6), vs(ko, zT))), o.ADD_TAGS && (Nn === Xo && (Nn = Xg(Nn)), vs(Nn, o.ADD_TAGS, Za)), o.ADD_ATTR && (ko === ac && (ko = Xg(ko)), vs(ko, o.ADD_ATTR, Za)), o.ADD_URI_SAFE_ATTR && vs(Bp, o.ADD_URI_SAFE_ATTR, Za), o.FORBID_CONTENTS && (qd === FN && (qd = Xg(qd)), vs(qd, o.FORBID_CONTENTS, Za)), IN && (Nn["#text"] = !0), Kf && vs(Nn, ["html", "head", "body"]), Nn.table && (vs(Nn, ["tbody"]), delete Yl.tbody), o.TRUSTED_TYPES_POLICY) {
            if (typeof o.TRUSTED_TYPES_POLICY.createHTML != "function")
              throw Rx('TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.');
            if (typeof o.TRUSTED_TYPES_POLICY.createScriptURL != "function")
              throw Rx('TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.');
            Ee = o.TRUSTED_TYPES_POLICY, Oe = Ee.createHTML("");
          } else
            Ee === void 0 && (Ee = VV(j, d)), Ee !== null && typeof Oe == "string" && (Oe = Ee.createHTML(""));
          bs && bs(o), jb = o;
        }
      }, a7 = vs({}, [...HT, ...CO, ...c6]), Wb = vs({}, [...xO, ...l6]), OX = function(o) {
        let r = pe(o);
        (!r || !r.tagName) && (r = {
          namespaceURI: ch,
          tagName: "template"
        });
        const c = LT(o.tagName), u = LT(r.tagName);
        return S3[o.namespaceURI] ? o.namespaceURI === Ub ? r.namespaceURI === aa ? c === "svg" : r.namespaceURI === OS ? c === "svg" && (u === "annotation-xml" || w3[u]) : !!a7[c] : o.namespaceURI === OS ? r.namespaceURI === aa ? c === "math" : r.namespaceURI === Ub ? c === "math" && Um[u] : !!Wb[c] : o.namespaceURI === aa ? r.namespaceURI === Ub && !Um[u] || r.namespaceURI === OS && !w3[u] ? !1 : !Wb[c] && (_X[c] || !a7[c]) : !!(DS === "application/xhtml+xml" && S3[o.namespaceURI]) : !1;
      }, Yf = function(o) {
        Ox(s.removed, {
          element: o
        });
        try {
          pe(o).removeChild(o);
        } catch {
          ae(o);
        }
      }, Ly = function(o, r) {
        try {
          Ox(s.removed, {
            attribute: r.getAttributeNode(o),
            from: r
          });
        } catch {
          Ox(s.removed, {
            attribute: null,
            from: r
          });
        }
        if (r.removeAttribute(o), o === "is")
          if (My || Py)
            try {
              Yf(r);
            } catch {
            }
          else
            try {
              r.setAttribute(o, "");
            } catch {
            }
      }, kY = function(o) {
        let r = null, c = null;
        if (BN)
          o = "<remove></remove>" + o;
        else {
          const b = r6(o, /^[\r\n\t ]+/);
          c = b && b[0];
        }
        DS === "application/xhtml+xml" && ch === aa && (o = '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' + o + "</body></html>");
        const u = Ee ? Ee.createHTML(o) : o;
        if (ch === aa)
          try {
            r = new L().parseFromString(u, DS);
          } catch {
          }
        if (!r || !r.documentElement) {
          r = gt.createDocument(ch, "template", null);
          try {
            r.documentElement.innerHTML = x3 ? Oe : u;
          } catch {
          }
        }
        const f = r.body || r.documentElement;
        return o && c && f.insertBefore(a.createTextNode(c), f.childNodes[0] || null), ch === aa ? Ke.call(r, Kf ? "html" : "body")[0] : Kf ? r.documentElement : f;
      }, c7 = function(o) {
        return Ue.call(
          o.ownerDocument || o,
          o,
          // eslint-disable-next-line no-bitwise
          T.SHOW_ELEMENT | T.SHOW_COMMENT | T.SHOW_TEXT | T.SHOW_PROCESSING_INSTRUCTION | T.SHOW_CDATA_SECTION,
          null
        );
      }, HN = function(o) {
        return o instanceof N && (typeof o.nodeName != "string" || typeof o.textContent != "string" || typeof o.removeChild != "function" || !(o.attributes instanceof _) || typeof o.removeAttribute != "function" || typeof o.setAttribute != "function" || typeof o.namespaceURI != "string" || typeof o.insertBefore != "function" || typeof o.hasChildNodes != "function");
      }, Hy = function(o) {
        return typeof C == "function" && o instanceof C;
      };
      function lh(t, o, r) {
        FT(t, (c) => {
          c.call(s, o, r, jb);
        });
      }
      const l7 = function(o) {
        let r = null;
        if (lh(zt.beforeSanitizeElements, o, null), HN(o))
          return Yf(o), !0;
        const c = Za(o.nodeName);
        if (lh(zt.uponSanitizeElement, o, {
          tagName: c,
          allowedTags: Nn
        }), Ny && o.hasChildNodes() && !Hy(o.firstElementChild) && Ti(/<[/\w!]/g, o.innerHTML) && Ti(/<[/\w!]/g, o.textContent) || o.nodeType === Mx.progressingInstruction || Ny && o.nodeType === Mx.comment && Ti(/<[/\w]/g, o.data))
          return Yf(o), !0;
        if (!Nn[c] || Yl[c]) {
          if (!Yl[c] && i7(c) && (Ms.tagNameCheck instanceof RegExp && Ti(Ms.tagNameCheck, c) || Ms.tagNameCheck instanceof Function && Ms.tagNameCheck(c)))
            return !1;
          if (IN && !qd[c]) {
            const u = pe(o) || o.parentNode, f = le(o) || o.childNodes;
            if (f && u) {
              const b = f.length;
              for (let v = b - 1; v >= 0; --v) {
                const S = ne(f[v], !0);
                S.__removalCount = (o.__removalCount || 0) + 1, u.insertBefore(S, Y(o));
              }
            }
          }
          return Yf(o), !0;
        }
        return o instanceof x && !OX(o) || (c === "noscript" || c === "noembed" || c === "noframes") && Ti(/<\/no(script|embed|frames)/i, o.innerHTML) ? (Yf(o), !0) : (qf && o.nodeType === Mx.text && (r = o.textContent, FT([jn, Jt, _n], (u) => {
          r = Dx(r, u, " ");
        }), o.textContent !== r && (Ox(s.removed, {
          element: o.cloneNode()
        }), o.textContent = r)), lh(zt.afterSanitizeElements, o, null), !1);
      }, zN = function(o, r, c) {
        if (n7 && (r === "id" || r === "name") && (c in a || c in TY))
          return !1;
        if (!(Wa && !Da[r] && Ti(Ut, r))) {
          if (!(mu && Ti(Ve, r))) {
            if (!ko[r] || Da[r]) {
              if (
                // First condition does a very basic check if a) it's basically a valid custom element tagname AND
                // b) if the tagName passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                // and c) if the attribute name passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.attributeNameCheck
                !(i7(o) && (Ms.tagNameCheck instanceof RegExp && Ti(Ms.tagNameCheck, o) || Ms.tagNameCheck instanceof Function && Ms.tagNameCheck(o)) && (Ms.attributeNameCheck instanceof RegExp && Ti(Ms.attributeNameCheck, r) || Ms.attributeNameCheck instanceof Function && Ms.attributeNameCheck(r)) || // Alternative, second condition checks if it's an `is`-attribute, AND
                // the value passes whatever the user has configured for CUSTOM_ELEMENT_HANDLING.tagNameCheck
                r === "is" && Ms.allowCustomizedBuiltInElements && (Ms.tagNameCheck instanceof RegExp && Ti(Ms.tagNameCheck, c) || Ms.tagNameCheck instanceof Function && Ms.tagNameCheck(c)))
              ) return !1;
            } else if (!Bp[r]) {
              if (!Ti(qt, Dx(c, mn, ""))) {
                if (!((r === "src" || r === "xlink:href" || r === "href") && o !== "script" && OV(c, "data:") === 0 && o7[o])) {
                  if (!(nd && !Ti(ct, Dx(c, mn, "")))) {
                    if (c)
                      return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, i7 = function(o) {
        return o !== "annotation-xml" && r6(o, Pn);
      }, AY = function(o) {
        lh(zt.beforeSanitizeAttributes, o, null);
        const {
          attributes: r
        } = o;
        if (!r || HN(o))
          return;
        const c = {
          attrName: "",
          attrValue: "",
          keepAttr: !0,
          allowedAttributes: ko,
          forceKeepAttr: void 0
        };
        let u = r.length;
        for (; u--; ) {
          const f = r[u], {
            name: b,
            namespaceURI: v,
            value: S
          } = f, O = Za(b), R = S;
          let M = b === "value" ? R : DV(R);
          if (c.attrName = O, c.attrValue = M, c.keepAttr = !0, c.forceKeepAttr = void 0, lh(zt.uponSanitizeAttribute, o, c), M = c.attrValue, $N && (O === "id" || O === "name") && (Ly(b, o), M = wY + M), Ny && Ti(/((--!?|])>)|<\/(style|title)/i, M)) {
            Ly(b, o);
            continue;
          }
          if (c.forceKeepAttr)
            continue;
          if (!c.keepAttr) {
            Ly(b, o);
            continue;
          }
          if (!Pp && Ti(/\/>/i, M)) {
            Ly(b, o);
            continue;
          }
          qf && FT([jn, Jt, _n], (J) => {
            M = Dx(M, J, " ");
          });
          const H = Za(o.nodeName);
          if (!zN(H, O, M)) {
            Ly(b, o);
            continue;
          }
          if (Ee && typeof j == "object" && typeof j.getAttributeType == "function" && !v)
            switch (j.getAttributeType(H, O)) {
              case "TrustedHTML": {
                M = Ee.createHTML(M);
                break;
              }
              case "TrustedScriptURL": {
                M = Ee.createScriptURL(M);
                break;
              }
            }
          if (M !== R)
            try {
              v ? o.setAttributeNS(v, b, M) : o.setAttribute(b, M), HN(o) ? Yf(o) : s6(s.removed);
            } catch {
              Ly(b, o);
            }
        }
        lh(zt.afterSanitizeAttributes, o, null);
      }, e = function t(o) {
        let r = null;
        const c = c7(o);
        for (lh(zt.beforeSanitizeShadowDOM, o, null); r = c.nextNode(); )
          lh(zt.uponSanitizeShadowNode, r, null), l7(r), AY(r), r.content instanceof g && t(r.content);
        lh(zt.afterSanitizeShadowDOM, o, null);
      };
      return s.sanitize = function(t) {
        let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, r = null, c = null, u = null, f = null;
        if (x3 = !t, x3 && (t = "<!-->"), typeof t != "string" && !Hy(t))
          if (typeof t.toString == "function") {
            if (t = t.toString(), typeof t != "string")
              throw Rx("dirty is not a string, aborting");
          } else
            throw Rx("toString is not a function");
        if (!s.isSupported)
          return t;
        if (kS || LN(o), s.removed = [], typeof t == "string" && ($y = !1), $y) {
          if (t.nodeName) {
            const S = Za(t.nodeName);
            if (!Nn[S] || Yl[S])
              throw Rx("root node is forbidden and cannot be sanitized in-place");
          }
        } else if (t instanceof C)
          r = kY("<!---->"), c = r.ownerDocument.importNode(t, !0), c.nodeType === Mx.element && c.nodeName === "BODY" || c.nodeName === "HTML" ? r = c : r.appendChild(c);
        else {
          if (!My && !qf && !Kf && // eslint-disable-next-line unicorn/prefer-includes
          t.indexOf("<") === -1)
            return Ee && By ? Ee.createHTML(t) : t;
          if (r = kY(t), !r)
            return My ? null : By ? Oe : "";
        }
        r && BN && Yf(r.firstChild);
        const b = c7($y ? t : r);
        for (; u = b.nextNode(); )
          l7(u), AY(u), u.content instanceof g && e(u.content);
        if ($y)
          return t;
        if (My) {
          if (Py)
            for (f = Qe.call(r.ownerDocument); r.firstChild; )
              f.appendChild(r.firstChild);
          else
            f = r;
          return (ko.shadowroot || ko.shadowrootmode) && (f = Qt.call(l, f, !0)), f;
        }
        let v = Kf ? r.outerHTML : r.innerHTML;
        return Kf && Nn["!doctype"] && r.ownerDocument && r.ownerDocument.doctype && r.ownerDocument.doctype.name && Ti(m6, r.ownerDocument.doctype.name) && (v = "<!DOCTYPE " + r.ownerDocument.doctype.name + `>
` + v), qf && FT([jn, Jt, _n], (S) => {
          v = Dx(v, S, " ");
        }), Ee && By ? Ee.createHTML(v) : v;
      }, s.setConfig = function() {
        let t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        LN(t), kS = !0;
      }, s.clearConfig = function() {
        jb = null, kS = !1;
      }, s.isValidAttribute = function(t, o, r) {
        jb || LN({});
        const c = Za(t), u = Za(o);
        return zN(c, u, r);
      }, s.addHook = function(t, o) {
        typeof o == "function" && Ox(zt[t], o);
      }, s.removeHook = function(t, o) {
        if (o !== void 0) {
          const r = AV(zt[t], o);
          return r === -1 ? void 0 : _V(zt[t], r, 1)[0];
        }
        return s6(zt[t]);
      }, s.removeHooks = function(t) {
        zt[t] = [];
      }, s.removeAllHooks = function() {
        zt = f6();
      }, s;
    }
    var TO = g6();
    const Px = (n) => TO().sanitize(n);
    var Rc = tinymce.util.Tools.resolve("tinymce.util.I18n");
    const VT = {
      indent: !0,
      outdent: !0,
      "table-insert-column-after": !0,
      "table-insert-column-before": !0,
      "paste-column-after": !0,
      "paste-column-before": !0,
      "unordered-list": !0,
      "list-bull-circle": !0,
      "list-bull-disc": !0,
      "list-bull-default": !0,
      "list-bull-square": !0
    }, h6 = "temporary-placeholder", kO = (n) => () => Vt(n, h6).getOr("!not found!"), AO = (n, s) => {
      const a = n.toLowerCase();
      if (Rc.isRtl()) {
        const l = Pi(a, "-rtl");
        return mo(s, l) ? l : a;
      } else
        return a;
    }, p6 = (n, s) => Vt(s, AO(n, s)), UV = (n, s) => {
      const a = s();
      return p6(n, a).getOrThunk(kO(a));
    }, UT = (n, s, a) => {
      const l = s();
      return p6(n, l).or(a).getOrThunk(kO(l));
    }, ny = (n) => Rc.isRtl() ? mo(VT, n) : !1, _O = () => xn("add-focusable", [
      hs((n) => {
        vd(n.element, "svg").each((s) => ln(s, "focusable", "false"));
      })
    ]), OO = (n, s, a, l) => {
      const d = ny(s) ? ["tox-icon--flip"] : [], g = Vt(a, AO(s, a)).or(l).getOrThunk(kO(a));
      return {
        dom: {
          tag: n.tag,
          attributes: n.attributes ?? {},
          classes: n.classes.concat(d),
          innerHtml: g
        },
        behaviours: nt([
          ...n.behaviours ?? [],
          _O()
        ]),
        eventOrder: n.eventOrder ?? {}
      };
    }, iu = (n, s, a, l = A.none()) => OO(s, n, a(), l), jV = (n, s, a) => {
      const l = a(), d = Lt(n, (g) => mo(l, AO(g, l)));
      return OO(s, d.getOr(h6), l, A.none());
    }, WV = {
      success: "checkmark",
      error: "warning",
      err: "error",
      warning: "warning",
      warn: "warning",
      info: "info"
    }, DO = su({
      name: "Notification",
      factory: (n) => {
        const s = Ct("notification-text"), a = To({
          dom: Dm(`<p id=${s}>${Px(n.backstageProvider.translate(n.text))}</p>`),
          behaviours: nt([
            An.config({})
          ])
        }), l = (Z) => ({
          dom: {
            tag: "div",
            classes: ["tox-bar"],
            styles: {
              width: `${Z}%`
            }
          }
        }), d = (Z) => ({
          dom: {
            tag: "div",
            classes: ["tox-text"],
            innerHtml: `${Z}%`
          }
        }), g = To({
          dom: {
            tag: "div",
            classes: n.progress ? ["tox-progress-bar", "tox-progress-indicator"] : ["tox-progress-bar"]
          },
          components: [
            {
              dom: {
                tag: "div",
                classes: ["tox-bar-container"]
              },
              components: [
                l(0)
              ]
            },
            d(0)
          ],
          behaviours: nt([
            An.config({})
          ])
        }), x = {
          updateProgress: (Z, ne) => {
            Z.getSystem().isConnected() && g.getOpt(Z).each((ae) => {
              An.set(ae, [
                {
                  dom: {
                    tag: "div",
                    classes: ["tox-bar-container"]
                  },
                  components: [
                    l(ne)
                  ]
                },
                d(ne)
              ]);
            });
          },
          updateText: (Z, ne) => {
            if (Z.getSystem().isConnected()) {
              const ae = a.get(Z);
              An.set(ae, [
                xs(ne)
              ]);
            }
          }
        }, T = en([
          n.icon.toArray(),
          [n.level],
          A.from(WV[n.level]).toArray()
        ]), _ = To(oa.sketch({
          dom: {
            tag: "button",
            classes: ["tox-notification__dismiss", "tox-button", "tox-button--naked", "tox-button--icon"],
            attributes: {
              "aria-label": n.backstageProvider.translate("Close")
            }
          },
          components: [
            iu("close", {
              tag: "span",
              classes: ["tox-icon"]
            }, n.iconProvider)
          ],
          buttonBehaviours: nt([
            is.config({}),
            ps.config({
              ...n.backstageProvider.tooltips.getConfig({
                tooltipText: n.backstageProvider.translate("Close")
              })
            })
          ]),
          action: (Z) => {
            n.onAction(Z);
          }
        })), N = jV(T, { tag: "div", classes: ["tox-notification__icon"] }, n.iconProvider), L = {
          dom: {
            tag: "div",
            classes: ["tox-notification__body"]
          },
          components: [
            a.asSpec()
          ],
          behaviours: nt([
            An.config({})
          ])
        }, j = [N, L];
        return {
          uid: n.uid,
          dom: {
            tag: "div",
            attributes: {
              role: "alert",
              "aria-labelledby": s
            },
            classes: ["tox-notification", "tox-notification--in", `tox-notification--${n.level}`]
          },
          behaviours: nt([
            is.config({}),
            En.config({}),
            Xt.config({
              mode: "special",
              onEscape: (Z) => (n.onAction(Z), A.some(!0))
            })
          ]),
          components: j.concat(n.progress ? [g.asSpec()] : []).concat([_.asSpec()]),
          apis: x
        };
      },
      configFields: [
        Sc("level", "info", ["success", "error", "warning", "warn", "info"]),
        Ze("progress"),
        Fo("icon"),
        Ze("onAction"),
        Ze("text"),
        Ze("iconProvider"),
        Ze("backstageProvider")
      ],
      apis: {
        updateProgress: (n, s, a) => {
          n.updateProgress(s, a);
        },
        updateText: (n, s, a) => {
          n.updateText(s, a);
        }
      }
    });
    var ZV = (n, s, a, l) => {
      const d = s.backstage.shared, g = () => at.fromDom(n.queryCommandValue("ToggleView") === "" ? n.getContentAreaContainer() : n.getContainer()), h = () => {
        const N = wr(g());
        return A.some(N);
      }, C = (N) => {
        h().each((L) => {
          He(N, (j) => {
            Kn(j.element, "width"), la(j.element) > L.width && gn(j.element, "width", L.width + "px");
          });
        });
      };
      return {
        open: (N, L, j) => {
          const Z = () => {
            const pe = (Ue) => {
              An.remove(Ue, ae), Y();
            }, Ee = (Ue, Qe) => {
              ai(Ue.element).length === 0 ? Oe(Ue, Qe) : gt(Ue, Qe);
            }, Oe = (Ue, Qe) => {
              Us.hide(Ue), l.clear(), Qe && n.focus();
            }, gt = (Ue, Qe) => {
              Qe && Xt.focusIn(Ue);
            };
            l.on((Ue) => {
              L();
              const Qe = j();
              pe(Ue), Ee(Ue, Qe);
            });
          }, ne = () => !ty(n) || !d.header.isPositionedAtTop(), ae = p(DO.sketch({
            text: N.text,
            level: bt(["success", "error", "warning", "warn", "info"], N.type) ? N.type : void 0,
            progress: N.progressBar === !0,
            icon: N.icon,
            onAction: Z,
            iconProvider: d.providers.icons,
            backstageProvider: d.providers
          }));
          if (l.isSet()) {
            const pe = y(ae);
            l.on((Ee) => {
              An.append(Ee, pe), Us.reposition(Ee), ae.hasConfigured(Ns) && Ns.refresh(Ee), C(Ee.components());
            });
          } else {
            const pe = p(Us.sketch({
              dom: {
                tag: "div",
                classes: ["tox-notifications-container"],
                attributes: {
                  "aria-label": "Notifications",
                  role: "region"
                }
              },
              lazySink: d.getSink,
              fireDismissalEventInstead: {},
              ...d.header.isPositionedAtTop() ? {} : { fireRepositionEventInstead: {} },
              inlineBehaviours: nt([
                Xt.config({
                  mode: "cyclic",
                  selector: ".tox-notification, .tox-notification a, .tox-notification button"
                }),
                An.config({}),
                ...ne() ? [
                  Ns.config({
                    contextual: {
                      lazyContext: () => A.some(wr(g())),
                      fadeInClass: "tox-notification-container-dock-fadein",
                      fadeOutClass: "tox-notification-container-dock-fadeout",
                      transitionClass: "tox-notification-container-dock-transition"
                    },
                    modes: ["top"],
                    lazyViewport: (Ue) => Yg(n, Ue.element).map((Ke) => ({
                      bounds: Cb(Ke),
                      optScrollEnv: A.some({
                        currentScrollTop: Ke.element.dom.scrollTop,
                        scrollElmTop: Ca(Ke.element).top
                      })
                    })).getOrThunk(() => ({
                      bounds: Ia(),
                      optScrollEnv: A.none()
                    }))
                  })
                ] : []
              ])
            })), Ee = y(ae), Oe = {
              maxHeightFunction: Ng()
            }, gt = {
              ...d.anchors.banner(),
              overrides: Oe
            };
            l.set(pe), a.add(pe), Us.showWithinBounds(pe, Ee, { anchor: gt }, h);
          }
          In(N.timeout) && N.timeout > 0 && RT.setEditorTimeout(n, () => {
            Z();
          }, N.timeout);
          const Y = () => {
            l.on((pe) => {
              Us.reposition(pe), pe.hasConfigured(Ns) && Ns.refresh(pe), C(pe.components());
            });
          };
          return {
            close: Z,
            reposition: Y,
            text: (pe) => {
              DO.updateText(ae, pe);
            },
            settings: N,
            getEl: () => ae.element.dom,
            progressBar: {
              value: (pe) => {
                DO.updateProgress(ae, pe);
              }
            }
          };
        },
        close: (N) => {
          N.close();
        },
        getArgs: (N) => N.settings
      };
    };
    const GV = {
      setup: (n, s) => {
        const a = (d, g) => {
          tn(d, na(), { raw: g });
        }, l = () => n.getMenu().bind(So.getHighlighted);
        s.on("keydown", (d) => {
          const g = d.which;
          n.isActive() && (n.isMenuOpen() ? g === 13 ? (l().each(Yh), d.preventDefault()) : g === 40 ? (l().fold(
            // No current item, so highlight the first one
            () => {
              n.getMenu().each(So.highlightFirst);
            },
            // There is a current item, so move down in the menu
            (h) => {
              a(h, d);
            }
          ), d.preventDefault(), d.stopImmediatePropagation()) : (g === 37 || g === 38 || g === 39) && l().each((h) => {
            a(h, d), d.preventDefault(), d.stopImmediatePropagation();
          }) : (g === 13 || g === 38 || g === 40) && n.cancelIfNecessary());
        }), s.on("NodeChange", () => {
          n.isActive() && !n.isProcessingAction() && !s.queryCommandState("mceAutoCompleterInRange") && n.cancelIfNecessary();
        });
      }
    };
    var RO;
    (function(n) {
      n[n.CLOSE_ON_EXECUTE = 0] = "CLOSE_ON_EXECUTE", n[n.BUBBLE_TO_SANDBOX = 1] = "BUBBLE_TO_SANDBOX";
    })(RO || (RO = {}));
    var Wd = RO;
    const NO = "tox-menu-nav__js", Bx = "tox-collection__item", wp = "tox-swatch", xb = {
      normal: NO,
      color: wp
    }, MO = "tox-collection__item--enabled", b6 = "tox-collection__group-heading", PO = "tox-collection__item-icon", jT = "tox-collection__item-image", qV = "tox-collection__item-image-selector", Qg = "tox-collection__item-label", Sb = "tox-collection__item-accessory", v6 = "tox-collection__item-caret", KV = "tox-collection__item-checkmark", wb = "tox-collection__item--active", y6 = "tox-collection__item-container", YV = "tox-collection__item-container--column", C6 = "tox-collection__item-container--row", XV = "tox-collection__item-container--align-right", QV = "tox-collection__item-container--align-left", WT = "tox-collection__item-container--valign-top", x6 = "tox-collection__item-container--valign-middle", JV = "tox-collection__item-container--valign-bottom", BO = (n) => Vt(xb, n).getOr(NO), eU = (n) => n === "color" ? "tox-swatches" : "tox-menu", $O = (n) => ({
      backgroundMenu: "tox-background-menu",
      selectedMenu: "tox-selected-menu",
      selectedItem: "tox-collection__item--active",
      hasIcons: "tox-menu--has-icons",
      menu: eU(n),
      tieredMenu: "tox-tiered-menu"
    }), Lf = (n) => {
      const s = $O(n);
      return {
        backgroundMenu: s.backgroundMenu,
        selectedMenu: s.selectedMenu,
        menu: s.menu,
        selectedItem: s.selectedItem,
        item: BO(n)
      };
    }, iX = (n, s, a) => {
      const l = $O(a);
      return {
        tag: "div",
        classes: en([
          [l.menu, `tox-menu-${s}-column`],
          n ? [l.hasIcons] : []
        ])
      };
    }, IO = [
      qg.parts.items({})
    ], $x = (n, s, a) => {
      const l = $O(a);
      return {
        dom: {
          tag: "div",
          classes: en([
            [l.tieredMenu]
          ])
        },
        markers: Lf(a)
      };
    }, S6 = Ct("refetch-trigger-event"), w6 = Ct("redirect-menu-item-interaction"), E6 = "tox-menu__searcher", Ix = (n) => Po(n.element, `.${E6}`).bind((s) => n.getSystem().getByDom(s).toOptional()), T6 = Ix, tU = (n, s) => {
      _t.setValue(n, s.fetchPattern), n.element.dom.selectionStart = s.selectionStart, n.element.dom.selectionEnd = s.selectionEnd;
    }, FO = (n) => {
      const s = _t.getValue(n), a = n.element.dom.selectionStart, l = n.element.dom.selectionEnd;
      return {
        fetchPattern: s,
        selectionStart: a,
        selectionEnd: l
      };
    }, k6 = (n, s) => {
      Qr(s.element, "id").each((a) => ln(n.element, "aria-activedescendant", a));
    }, nU = (n) => {
      const s = (d, g) => (g.cut(), A.none()), a = (d, g) => {
        const h = {
          interactionEvent: g.event,
          eventType: g.event.raw.type
        };
        return tn(d, w6, h), A.some(!0);
      }, l = "searcher-events";
      return {
        dom: {
          tag: "div",
          // NOTE: This is very intentionally NOT the navigation class, because
          // we don't want the searcher to be part of the navigation. This class
          // is just for styling consistency. Perhaps it should be its own class.
          classes: [Bx]
        },
        components: [
          Ff.sketch({
            inputClasses: [E6, "tox-textfield"],
            inputAttributes: {
              ...n.placeholder.map((d) => ({ placeholder: n.i18n(d) })).getOr({}),
              // This ARIA is based on the algolia example documented in TINY-8952
              type: "search",
              "aria-autocomplete": "list"
            },
            inputBehaviours: nt([
              xn(l, [
                // When the user types into the search field, we want to retrigger
                // a fetch on the dropdown. This will be fired from within the
                // dropdown's sandbox, so the dropdown is going to have to listen
                // for it there. See CommonDropdown.ts.
                Ie(
                  // Use "input" to handle keydown, paste etc.
                  Nu(),
                  (d) => {
                    Wn(d, S6);
                  }
                ),
                Ie(na(), (d, g) => {
                  g.event.raw.key === "Escape" && g.stop();
                })
              ]),
              // In addition to input handling, we want special handling for
              // Up/Down/Left/Right/Enter/Escape/Space. We can divide these into two categories
              //  - events that we don't want to allow the overall menu system to process (left and right and space)
              //  - events that we want to redispatch on the "highlighted item" based on the
              // current fake focus.
              Xt.config({
                mode: "special",
                onLeft: s,
                onRight: s,
                onSpace: s,
                onEnter: a,
                onEscape: a,
                onUp: a,
                onDown: a
              })
            ]),
            // Because we have customised handling for keydown, and we are configuring
            // Keying, we need to specify which "behaviour" (custom events or keying) gets to
            // process the keydown event first. In this situation, we want to stop escape before
            // anything happens (although it really isn't necessary)
            eventOrder: {
              keydown: [l, Xt.name()]
            }
          })
        ]
      };
    }, ZT = "tox-collection--results__js", Fx = (n) => n.dom ? {
      ...n,
      dom: {
        ...n.dom,
        attributes: {
          ...n.dom.attributes ?? {},
          id: Ct("aria-item-search-result-id"),
          "aria-selected": "false"
        }
      }
    } : n, LO = "Use arrow keys to navigate.", HO = (n, s) => (a) => {
      const l = Fn(a, s);
      return ye(l, (d) => ({
        dom: n,
        components: d
      }));
    }, zO = (n) => ({
      dom: {
        tag: "div",
        classes: ["tox-menu", "tox-swatches-menu"],
        attributes: {
          "aria-label": Rc.translate(LO)
        }
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-swatches"]
          },
          components: [
            qg.parts.items({
              preprocess: n !== "auto" ? HO({
                tag: "div",
                classes: ["tox-swatches__row"]
              }, n) : Yt
            })
          ]
        }
      ]
    }), oU = (n) => ({
      dom: {
        tag: "div",
        classes: ["tox-menu", "tox-image-selector-menu"]
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-image-selector"]
          },
          components: [
            qg.parts.items({
              preprocess: n !== "auto" ? HO({
                tag: "div",
                classes: ["tox-image-selector__row"]
              }, n) : Yt
            })
          ]
        }
      ]
    }), VO = (n) => ({
      dom: {
        tag: "div",
        // TODO: Configurable lg setting?
        classes: ["tox-menu", "tox-collection", "tox-collection--toolbar", "tox-collection--toolbar-lg"]
      },
      components: [
        qg.parts.items({
          preprocess: HO({
            tag: "div",
            classes: ["tox-collection__group"]
          }, n)
        })
      ]
    }), A6 = (n, s) => {
      const a = [];
      let l = [];
      return He(n, (d, g) => {
        s(d, g) ? (l.length > 0 && a.push(l), l = [], (mo(d.dom, "innerHtml") || d.components && d.components.length > 0) && l.push(d)) : l.push(d);
      }), l.length > 0 && a.push(l), ye(a, (d) => ({
        dom: {
          tag: "div",
          classes: ["tox-collection__group"]
        },
        components: d
      }));
    }, UO = (n, s, a) => qg.parts.items({
      preprocess: (l) => {
        const d = ye(l, a);
        return n !== "auto" && n > 1 ? HO({
          tag: "div",
          classes: ["tox-collection__group"]
        }, n)(d) : A6(d, (g, h) => s[h].type === "separator");
      }
    }), _6 = (n) => cn(n, (s) => s.type === "widget"), jO = (n, s, a = !0) => ({
      dom: {
        tag: "div",
        classes: ["tox-menu", "tox-collection"].concat(n === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
        attributes: {
          // widget item can be inserttable, colorswatch or imageselect - all of them are navigated with arrow keys
          ..._6(s) ? { "aria-label": Rc.translate(LO) } : {}
        }
      },
      components: [
        // We don't need to add IDs for each item because there are no
        // aria relationships we need to maintain
        UO(n, s, Yt)
      ]
    }), O6 = (n, s, a = !0) => {
      const l = Ct("aria-controls-search-results");
      return {
        dom: {
          tag: "div",
          classes: ["tox-menu", "tox-collection", ZT].concat(n === 1 ? ["tox-collection--list"] : ["tox-collection--grid"]),
          attributes: {
            id: l
          }
        },
        components: [
          // For each item, it needs to have an ID, so that we can refer to it
          // by the aria-activedescendant attribute
          UO(n, s, Fx)
        ]
      };
    }, Jg = (n, s, a) => {
      const l = Ct("aria-controls-search-results");
      return {
        dom: {
          tag: "div",
          classes: ["tox-menu", "tox-collection"].concat(n === 1 ? ["tox-collection--list"] : ["tox-collection--grid"])
        },
        components: [
          // Importantly, the search bar is not in the "items" part, which means that it is
          // not given any of the item decorations by default. In order to ensure that is
          // not part of the navigation, however, we need to prevent it from getting the nav
          // class. For general collection menu items, it is navClass, which is:
          // tox-menu-nav__js. So simply, do not add this class when creating
          // the search, so that it isn't in the navigation. Ideally, it would only ever look
          // inside its items section, but the items aren't guaranteed to have a separate
          // container, and navigation candidates are found anywhere inside the menu
          // container. We could add configuration to alloy's Menu movement, where there was
          // a 'navigation container' that all items would be in. That could be another
          // way to solve the problem. For now, we'll just manually avoid adding the navClass
          nU({
            i18n: Rc.translate,
            placeholder: a.placeholder
          }),
          {
            // We need a separate container for the items, because this is the container
            // that multiple tox-collection__groups might go into, and will be the container
            // that the search bar controls.
            dom: {
              tag: "div",
              classes: [
                ...n === 1 ? ["tox-collection--list"] : ["tox-collection--grid"],
                ZT
              ],
              attributes: {
                id: l
              }
            },
            components: [
              // For each item, it needs to have an ID, so that we can refer to it
              // by the aria-activedescendant attribute
              UO(n, s, Fx)
            ]
          }
        ]
      };
    }, Eb = (n, s = !0) => ({
      dom: {
        tag: "div",
        classes: ["tox-collection", "tox-collection--horizontal"]
      },
      components: [
        qg.parts.items({
          preprocess: (a) => A6(a, (l, d) => n[d].type === "separator")
        })
      ]
    }), Lx = (n) => cn(n, (s) => "icon" in s && s.icon !== void 0), Im = (n) => (console.error(Rh(n)), console.log(n), A.none()), D6 = (n, s, a, l, d) => {
      const g = Eb(a);
      return {
        value: n,
        dom: g.dom,
        components: g.components,
        items: a
      };
    }, WO = (n, s, a, l, d) => {
      const g = () => d.menuType !== "searchable" ? jO(l, a) : d.searchMode.searchMode === "search-with-field" ? Jg(l, a, d.searchMode) : O6(l, a);
      if (d.menuType === "color") {
        const h = zO(l);
        return {
          value: n,
          dom: h.dom,
          components: h.components,
          items: a
        };
      } else if (d.menuType === "imageselector" && l !== "auto") {
        const h = oU(l);
        return {
          value: n,
          dom: h.dom,
          components: h.components,
          items: a
        };
      } else if (d.menuType === "normal" && l === "auto") {
        const h = jO(l, a);
        return {
          value: n,
          dom: h.dom,
          components: h.components,
          items: a
        };
      } else if (d.menuType === "normal" || d.menuType === "searchable") {
        const h = g();
        return {
          value: n,
          dom: h.dom,
          components: h.components,
          items: a
        };
      } else if (d.menuType === "listpreview" && l !== "auto") {
        const h = VO(l);
        return {
          value: n,
          dom: h.dom,
          components: h.components,
          items: a
        };
      } else
        return {
          value: n,
          dom: iX(s, l, d.menuType),
          components: IO,
          items: a
        };
    }, tr = qs("type"), ZO = qs("name"), GT = qs("label"), eh = qs("text"), R6 = qs("title"), GO = qs("icon"), sU = qs("url"), oy = qs("value"), rU = fl("fetch"), aU = fl("getSubmenuItems"), Ep = fl("onAction"), cU = fl("onItemAction"), Tb = cs("onSetup", () => U), lU = Ks("name"), th = Ks("text"), iU = Ks("role"), Ku = Ks("icon"), kb = Ks("tooltip"), N6 = Ks("chevronTooltip"), Hx = Ks("label"), qO = Ks("shortcut"), uU = qi("select"), sy = zr("active", !1), dU = zr("borderless", !1), Yu = zr("enabled", !0), zx = zr("primary", !1), M6 = (n) => we("columns", n), KO = we("meta", {}), YO = cs("onAction", U), Ab = (n) => Vs("type", n), XO = (n) => ta("name", "name", u1(() => Ct(`${n}-name`)), Hr), P6 = (n) => ta("value", "value", u1(() => Ct(`${n}-value`)), pi()), ry = [
      tr,
      eh,
      Gi("level", ["info", "warn", "error", "success"]),
      GO,
      we("url", "")
    ], mU = on(ry), fU = (n) => [
      tr,
      n
    ], gU = [
      tr,
      eh,
      Yu,
      XO("button"),
      Ku,
      dU,
      // this should be defaulted to `secondary` but the implementation needs to manage the deprecation
      b2("buttonType", ["primary", "secondary", "toolbar"]),
      // this should be removed, but must live here because FieldSchema doesn't have a way to manage deprecated fields
      zx,
      Vs("context", "mode:design")
    ], qT = on(gU), Xc = [
      tr,
      ZO
    ], Xu = Xc.concat([
      Hx
    ]), B6 = Xc.concat([
      GT,
      Yu,
      Vs("context", "mode:design")
    ]), hU = on(B6), pU = zn, bU = Xu.concat([
      M6("auto"),
      Vs("context", "mode:design")
    ]), vU = on(bU), $6 = Dh([
      oy,
      eh,
      GO
    ]), I6 = Xu.concat([
      Vs("storageKey", "default"),
      Vs("context", "mode:design")
    ]), yU = on(I6), CU = Hr, SU = on(Xu), F6 = Hr, L6 = Xc.concat([
      Vs("tag", "textarea"),
      qs("scriptId"),
      qs("scriptUrl"),
      qi("onFocus"),
      ZS("settings", void 0)
    ]), H6 = Xc.concat([
      Vs("tag", "textarea"),
      fl("init")
    ]), wU = Cd((n) => Fs("customeditor.old", ml(H6), n).orThunk(() => Fs("customeditor.new", ml(L6), n))), EU = Hr, Tp = [
      Yu,
      th,
      iU,
      qO,
      P6("menuitem"),
      KO,
      Vs("context", "mode:design")
    ], TU = on([
      tr,
      ZO
    ].concat(Tp)), kU = zn, ay = [
      XO("button"),
      Ku,
      Sc("align", "end", ["start", "end"]),
      // this should be removed, but must live here because FieldSchema doesn't have a way to manage deprecated fields
      zx,
      Yu,
      // this should be defaulted to `secondary` but the implementation needs to manage the deprecation
      b2("buttonType", ["primary", "secondary"]),
      Vs("context", "mode:design")
    ], Fm = [
      ...ay,
      eh
    ], KT = [
      Gi("type", ["submit", "cancel", "custom"]),
      ...Fm
    ], Qu = [
      Gi("type", ["menu"]),
      th,
      kb,
      Ku,
      jc("items", TU),
      ...ay
    ], AU = [
      ...ay,
      Gi("type", ["togglebutton"]),
      kb,
      Ku,
      th,
      zr("active", !1)
    ], YT = Cc("type", {
      submit: KT,
      cancel: KT,
      custom: KT,
      menu: Qu,
      togglebutton: AU
    }), _U = Xu.concat([
      Vs("context", "mode:design"),
      Ks("dropAreaLabel"),
      Ks("buttonLabel"),
      Ks("allowedFileTypes"),
      p0("allowedFileExtensions", Hr)
    ]), _b = on(_U), OU = US(), QO = (n) => [
      tr,
      h1("columns"),
      n
    ], JO = [
      tr,
      qs("html"),
      Sc("presets", "presentation", ["presentation", "document"]),
      cs("onInit", U),
      zr("stretched", !1)
    ], DU = on(JO), RU = Xu.concat([
      zr("border", !1),
      zr("sandboxed", !0),
      zr("streamContent", !1),
      zr("transparent", !0)
    ]), Ob = on(RU), z6 = Hr, V6 = on(Xc.concat([
      Ks("height")
    ])), NU = on([
      qs("url"),
      Nh("zoom"),
      Nh("cachedWidth"),
      Nh("cachedHeight")
    ]), eD = Xu.concat([
      Ks("inputMode"),
      Ks("placeholder"),
      zr("maximized", !1),
      Yu,
      Vs("context", "mode:design")
    ]), U6 = on(eD), tD = Hr, j6 = (n) => [
      tr,
      GT,
      n,
      Sc("align", "start", ["start", "center", "end"]),
      Ks("for")
    ], W6 = [
      eh,
      oy
    ], Vx = [
      eh,
      jc("items", vg("items", () => Z6))
    ], Z6 = Oh([
      on(W6),
      on(Vx)
    ]), MU = Xu.concat([
      jc("items", Z6),
      Yu,
      Vs("context", "mode:design")
    ]), PU = on(MU), BU = Hr, nD = Xu.concat([
      WS("items", [
        eh,
        oy
      ]),
      p1("size", 1),
      Yu,
      Vs("context", "mode:design")
    ]), $U = on(nD), oD = Hr, IU = Xu.concat([
      zr("constrain", !0),
      Yu,
      Vs("context", "mode:design")
    ]), Ux = on(IU), G6 = on([
      qs("width"),
      qs("height")
    ]), q6 = Xc.concat([
      GT,
      p1("min", 0),
      p1("max", 0)
    ]), FU = on(q6), LU = i2, HU = [
      tr,
      jc("header", Hr),
      jc("cells", er(Hr))
    ], zU = on(HU), XT = Xu.concat([
      Ks("placeholder"),
      zr("maximized", !1),
      Yu,
      Vs("context", "mode:design"),
      v2("spellcheck")
    ]), K6 = on(XT), VU = Hr, sD = [
      Vs("buttonType", "default"),
      Ks("text"),
      Ks("tooltip"),
      Ks("icon"),
      Vl(
        "search",
        !1,
        // So our boulder validation are:
        // a) boolean -> we need to map it into an Option
        // b) object -> we need to map it into a Some
        Oh(
          [
            // Unfortunately, due to objOf not checking to see that the
            // input is an object, the boolean check MUST be first
            zn,
            on([
              Ks("placeholder")
            ])
          ],
          // This function allows you to standardise the output.
          (n) => vn(n) ? n ? A.some({ placeholder: A.none() }) : A.none() : A.some(n)
        )
      ),
      fl("fetch"),
      cs("onSetup", () => U),
      Vs("context", "mode:design")
    ], kp = on([
      tr,
      ...sD
    ]), rD = (n) => Fs("menubutton", kp, n), cy = [
      Gi("type", ["directory", "leaf"]),
      R6,
      qs("id"),
      Ru("menu", kp),
      Ks("customStateIcon"),
      Ks("customStateIconTooltip")
    ], aD = on(cy), UU = cy.concat([
      jc("children", vg("children", () => bg("type", {
        directory: Y6,
        leaf: aD
      })))
    ]), Y6 = on(UU), Db = bg("type", {
      directory: Y6,
      leaf: aD
    }), X6 = [
      tr,
      jc("items", Db),
      qi("onLeafAction"),
      qi("onToggleExpand"),
      df("defaultExpandedIds", [], Hr),
      Ks("defaultSelectedId")
    ], jU = on(X6), Q6 = Xu.concat([
      Sc("filetype", "file", ["image", "media", "file"]),
      Yu,
      Ks("picker_text"),
      Vs("context", "mode:design")
    ]), WU = on(Q6), ZU = on([
      oy,
      KO
    ]), cD = (n) => ta("items", "items", bi(), er(Cd((s) => Fs(`Checking item of ${n}`, QT, s).fold((a) => Wt.error(Rh(a)), (a) => Wt.value(a))))), QT = g1(() => bg("type", {
      alertbanner: mU,
      bar: on(fU(cD("bar"))),
      button: qT,
      checkbox: hU,
      colorinput: yU,
      colorpicker: SU,
      dropzone: _b,
      grid: on(QO(cD("grid"))),
      iframe: Ob,
      input: U6,
      listbox: PU,
      selectbox: $U,
      sizeinput: Ux,
      slider: FU,
      textarea: K6,
      urlinput: WU,
      customeditor: wU,
      htmlpanel: DU,
      imagepreview: V6,
      collection: vU,
      label: on(j6(cD("label"))),
      table: zU,
      tree: jU,
      panel: J6
    })), GU = [
      tr,
      we("classes", []),
      jc("items", QT)
    ], J6 = on(GU), qU = [
      XO("tab"),
      R6,
      jc("items", QT)
    ], KU = [
      tr,
      WS("tabs", qU)
    ], YU = on(KU), XU = Fm, QU = YT, JU = on([
      qs("title"),
      Uc("body", bg("type", {
        panel: J6,
        tabpanel: YU
      })),
      Vs("size", "normal"),
      df("buttons", [], QU),
      we("initialData", {}),
      cs("onAction", U),
      cs("onChange", U),
      cs("onSubmit", U),
      cs("onClose", U),
      cs("onCancel", U),
      cs("onTabChange", U)
    ]), e$ = (n) => Fs("dialog", JU, n), ej = on([
      Gi("type", ["cancel", "custom"]),
      ...XU
    ]), tj = on([
      qs("title"),
      qs("url"),
      Nh("height"),
      Nh("width"),
      p0("buttons", ej),
      cs("onAction", U),
      cs("onCancel", U),
      cs("onClose", U),
      cs("onMessage", U)
    ]), nj = (n) => Fs("dialog", tj, n), lD = (n) => et(n) ? [n].concat(xe(Ka(n), lD)) : $n(n) ? xe(n, lD) : [], oj = (n) => De(n.type) && De(n.name), sj = {
      checkbox: pU,
      colorinput: CU,
      colorpicker: F6,
      dropzone: OU,
      input: tD,
      iframe: z6,
      imagepreview: NU,
      selectbox: oD,
      sizeinput: G6,
      slider: LU,
      listbox: BU,
      size: G6,
      textarea: VU,
      urlinput: ZU,
      customeditor: EU,
      collection: $6,
      togglemenuitem: kU
    }, t$ = (n) => A.from(sj[n.type]), n$ = (n) => Ln(lD(n), oj), rj = (n) => {
      const s = n$(n), a = xe(s, (l) => t$(l).fold(() => [], (d) => [Uc(l.name, d)]));
      return on(a);
    }, jx = (n) => {
      const s = yi(e$(n)), a = rj(n), l = n.initialData ?? {};
      return {
        internalDialog: s,
        dataValidator: a,
        initialData: l
      };
    }, Rb = {
      open: (n, s) => {
        const a = jx(s);
        return n(a.internalDialog, a.initialData, a.dataValidator);
      },
      openUrl: (n, s) => {
        const a = yi(nj(s));
        return n(a);
      },
      redial: (n) => jx(n)
    }, o$ = on([
      tr,
      th
    ]), aj = (n) => Fs("separatormenuitem", o$, n), cj = on([
      // Currently, autocomplete items don't support configuring type, active, disabled, meta
      Ab("autocompleteitem"),
      sy,
      Yu,
      KO,
      oy,
      th,
      Ku
    ]), lj = (n) => Fs("Autocompleter.Separator", o$, n), ij = (n) => Fs("Autocompleter.Item", cj, n), ly = [
      Yu,
      kb,
      Ku,
      th,
      Tb,
      Vs("context", "mode:design")
    ], uj = on([
      tr,
      Ep,
      qO
    ].concat(ly)), Hf = (n) => Fs("toolbarbutton", uj, n), iD = [
      sy
    ].concat(ly), dj = on(iD.concat([
      tr,
      Ep,
      qO
    ])), uD = (n) => Fs("ToggleButton", dj, n), JT = [
      cs("predicate", an),
      Sc("scope", "node", ["node", "editor"]),
      Sc("position", "selection", ["node", "selection", "line"])
    ], mj = ly.concat([
      Ab("contextformbutton"),
      Vs("align", "end"),
      zx,
      Ep,
      xc("original", Yt)
    ]), fj = iD.concat([
      Ab("contextformbutton"),
      Vs("align", "end"),
      zx,
      Ep,
      xc("original", Yt)
    ]), gj = ly.concat([
      Ab("contextformbutton")
    ]), dD = iD.concat([
      Ab("contextformtogglebutton")
    ]), s$ = Cc("type", {
      contextformbutton: mj,
      contextformtogglebutton: fj
    }), Wx = [
      Hx,
      jc("commands", s$),
      Ru("launch", Cc("type", {
        contextformbutton: gj,
        contextformtogglebutton: dD
      })),
      cs("onInput", U),
      cs("onSetup", U)
    ], e4 = [
      ...JT,
      ...Wx,
      Gi("type", ["contextform"]),
      cs("initValue", oe("")),
      Ks("placeholder")
    ], iy = [
      ...JT,
      ...Wx,
      Gi("type", ["contextsliderform"]),
      cs("initValue", oe(0)),
      cs("min", oe(0)),
      cs("max", oe(100))
    ], hj = [
      ...JT,
      ...Wx,
      Gi("type", ["contextsizeinputform"]),
      cs("initValue", oe({ width: "", height: "" }))
    ], r$ = Cc("type", {
      contextform: e4,
      contextsliderform: iy,
      contextsizeinputform: hj
    }), pj = (n) => Fs("ContextForm", r$, n), uy = ly.concat([
      Ab("contexttoolbarbutton")
    ]), bj = on([
      Ab("contexttoolbar"),
      Wc("launch", uy),
      Uc("items", Oh([
        Hr,
        Dh([
          Ks("name"),
          Ks("label"),
          jc("items", Hr)
        ])
      ]))
    ].concat(JT)), t4 = (n) => ({
      name: n.name.getOrUndefined(),
      label: n.label.getOrUndefined(),
      items: n.items
    }), mD = (n) => ({
      ...n,
      launch: n.launch.getOrUndefined(),
      items: De(n.items) ? n.items : ye(n.items, t4)
    }), vj = (n) => Fs("ContextToolbar", bj, n), yj = [
      tr,
      qs("src"),
      Ks("alt"),
      df("classes", [], Hr)
    ], Cj = on(yj), fD = [
      tr,
      eh,
      lU,
      df("classes", ["tox-collection__item-label"], Hr)
    ], xj = on(fD), a$ = g1(() => bg("type", {
      cardimage: Cj,
      cardtext: xj,
      cardcontainer: Sj
    })), Sj = on([
      tr,
      Vs("direction", "horizontal"),
      Vs("align", "left"),
      Vs("valign", "middle"),
      jc("items", a$)
    ]), c$ = on([
      tr,
      Hx,
      jc("items", a$),
      Tb,
      YO
    ].concat(Tp)), gD = (n) => Fs("cardmenuitem", c$, n), wj = on([
      tr,
      sy,
      Ku,
      Hx
    ].concat(Tp)), Ej = (n) => Fs("choicemenuitem", wj, n), hD = [
      tr,
      qs("fancytype"),
      YO
    ], l$ = [
      we("initData", {})
    ].concat(hD), Tj = [
      qi("select"),
      mf("initData", {}, [
        zr("allowCustomColors", !0),
        Vs("storageKey", "default"),
        // Note: We don't validate the colors as they are instead validated by choiceschema when rendering
        p0("colors", pi())
      ])
    ].concat(hD), pD = [
      qi("select"),
      xd("initData", [
        h1("columns"),
        // Note: We don't validate the items as they are instead validated by imageMenuItemSchema when rendering
        df("items", [], pi())
      ])
    ].concat(hD), i$ = Cc("fancytype", {
      inserttable: l$,
      colorswatch: Tj,
      imageselect: pD
    }), u$ = (n) => Fs("fancymenuitem", i$, n), kj = on([
      tr,
      sy,
      sU,
      Hx,
      kb
    ].concat(Tp)), Aj = on([
      tr,
      sy,
      GO,
      GT,
      kb,
      oy
    ].concat(Tp)), d$ = (n) => Fs("imagemenuitem", kj, n), bD = (n) => Fs("resetimageitem", Aj, n), _j = on([
      tr,
      Tb,
      YO,
      Ku
    ].concat(Tp)), Oj = (n) => Fs("menuitem", _j, n), Dj = on([
      tr,
      aU,
      Tb,
      Ku
    ].concat(Tp)), Rj = (n) => Fs("nestedmenuitem", Dj, n), Nj = on([
      tr,
      Ku,
      sy,
      Tb,
      Ep
    ].concat(Tp)), Mj = (n) => Fs("togglemenuitem", Nj, n), Pj = on([
      Ku,
      kb,
      cs("onShow", U),
      cs("onHide", U),
      Tb
    ]), vD = (n) => Fs("sidebar", Pj, n), Bj = on([
      tr,
      Uc("items", Oh([
        Dh([
          ZO,
          jc("items", Hr)
        ]),
        Hr
      ]))
    ].concat(ly)), yD = (n) => Fs("GroupToolbarButton", Bj, n), $j = on([
      tr,
      kb,
      N6,
      Ku,
      th,
      uU,
      rU,
      Tb,
      // TODO: Validate the allowed presets
      Sc("presets", "normal", ["normal", "color", "listpreview"]),
      M6(1),
      Ep,
      cU,
      Vs("context", "mode:design")
    ]), Ij = (n) => Fs("SplitButton", $j, n), n4 = [
      th,
      Ku,
      Ks("tooltip"),
      Sc("buttonType", "secondary", ["primary", "secondary"]),
      zr("borderless", !1),
      fl("onAction"),
      Vs("context", "mode:design")
    ], Fj = [
      ...n4,
      eh,
      Gi("type", ["button"])
    ], Lj = [
      ...n4,
      zr("active", !1),
      Gi("type", ["togglebutton"])
    ], CD = {
      button: Fj,
      togglebutton: Lj
    }, Hj = [
      Gi("type", ["group"]),
      df("buttons", [], Cc("type", CD))
    ], zj = Cc("type", {
      ...CD,
      group: Hj
    }), Vj = on([
      df("buttons", [], zj),
      fl("onShow"),
      fl("onHide")
    ]), Uj = (n) => Fs("view", Vj, n), xD = (n, s, a) => {
      const l = Lr(n.element, "." + a);
      if (l.length > 0) {
        const d = po(l, (g) => {
          const h = g.dom.getBoundingClientRect().top, C = l[0].dom.getBoundingClientRect().top;
          return Math.abs(h - C) > s;
        }).getOr(l.length);
        return A.some({
          numColumns: d,
          numRows: Math.ceil(l.length / d)
        });
      } else
        return A.none();
    }, m$ = (n, s) => nt([
      xn(n, s)
    ]), dy = {
      namedEvents: m$,
      unnamedEvents: (n) => m$(Ct("unnamed-events"), n)
    }, Lm = {
      item: (n) => Ft.config({
        disabled: n,
        disableClass: "tox-collection__item--state-disabled"
      }),
      button: (n) => Ft.config({
        disabled: n
      }),
      splitButton: (n) => Ft.config({
        disabled: n,
        disableClass: "tox-tbtn--disabled"
      }),
      toolbarButton: (n) => Ft.config({
        disabled: n,
        disableClass: "tox-tbtn--disabled",
        useNative: !1
      })
    }, Zx = (n, s) => {
      const a = n.getApi(s);
      return (l) => {
        l(a);
      };
    }, Hm = (n, s) => hs((a) => {
      Xe(n.onBeforeSetup) && n.onBeforeSetup(a), Zx(n, a)((d) => {
        const g = n.onSetup(d);
        Xe(g) && s.set(g);
      });
    }), Ap = (n, s) => eu((a) => Zx(n, a)(s.get())), o4 = (n, s, a) => eu((l) => (a.set(_t.getValue(l)), Zx(n, l)(s.get()))), SD = "silver.uistate", Nb = "setDisabled", Wj = "setEnabled", wD = "init", Zj = ["switchmode", wD], Gx = (n, s) => {
      const a = n.mainUi.outerContainer, l = [n.mainUi.mothership, ...n.uiMotherships];
      s === Nb && He(l, (d) => {
        d.broadcastOn([Ad()], { target: a.element });
      }), He(l, (d) => {
        d.broadcastOn([SD], s);
      });
    }, f$ = (n, s) => {
      n.on("init SwitchMode", (a) => {
        Gx(s, a.type);
      }), n.on("DisabledStateChange", (a) => {
        if (!a.isDefaultPrevented()) {
          const l = a.state ? Nb : wD;
          Gx(s, l), a.state || n.nodeChanged();
        }
      }), n.on("NodeChange", (a) => {
        const l = n.ui.isEnabled() ? a.type : Nb;
        Gx(s, l);
      }), _B(n) && n.mode.set("readonly");
    }, yr = (n) => Dc.config({
      channels: {
        [SD]: {
          onReceive: (s, a) => {
            if (a === Nb || a === Wj) {
              Ft.set(s, a === Nb);
              return;
            }
            const { contextType: l, shouldDisable: d } = n();
            l === "mode" && !bt(Zj, a) || Ft.set(s, d);
          }
        }
      }
    }), nh = (n, s) => Ef((a, l) => {
      Zx(n, a)(n.onAction), !n.triggersSubmenu && s === Wd.CLOSE_ON_EXECUTE && (a.getSystem().isConnected() && Wn(a, x0()), l.stop());
    }), Gj = {
      // TODO: use the constants provided by behaviours.
      [wa()]: ["disabling", "alloy.base.behaviour", "toggling", "item-events"]
    }, zf = Al, Mb = (n, s, a, l) => {
      const d = Pt(U);
      return {
        type: "item",
        dom: s.dom,
        components: zf(s.optComponents),
        data: n.data,
        eventOrder: Gj,
        hasSubmenu: n.triggersSubmenu,
        itemBehaviours: nt([
          xn("item-events", [
            nh(n, a),
            Hm(n, d),
            Ap(n, d)
          ]),
          Lm.item(() => !n.enabled || l.checkUiComponentContext(n.context).shouldDisable),
          yr(() => l.checkUiComponentContext(n.context)),
          An.config({})
        ].concat(n.itemBehaviours))
      };
    }, oh = (n) => ({
      value: n.value,
      meta: {
        text: n.text.getOr(""),
        ...n.meta
      }
    }), qj = (n, s) => {
      const a = at.fromTag("div");
      Uo(a, "tox-image-selector-loading-spinner");
      const l = (g) => {
        Uo(g, "tox-image-selector-loading-spinner-wrapper"), Fr(g, a);
      }, d = (g) => {
        Ds(g, "tox-image-selector-loading-spinner-wrapper"), al(a);
      };
      return {
        dom: {
          tag: n.tag,
          attributes: n.attributes ?? {},
          classes: n.classes
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-image-selector-image-wrapper"]
            },
            components: [
              {
                dom: {
                  tag: "img",
                  attributes: { src: s },
                  classes: ["tox-image-selector-image-img"]
                }
              }
            ]
          },
          ...n.checkMark.toArray()
        ],
        behaviours: nt([
          ...n.behaviours ?? [],
          xn("render-image-events", [
            hs((g) => {
              l(g.element), Po(g.element, "img").each((h) => {
                cl(h).catch((C) => {
                  console.error(C);
                }).finally(() => {
                  d(g.element);
                });
              });
            })
          ])
        ])
      };
    }, Kj = (n, s) => qj(s, n), ED = (n) => {
      const s = Kv.os.isMacOS() || Kv.os.isiOS(), d = s ? {
        alt: "⌥",
        ctrl: "⌃",
        shift: "⇧",
        meta: "⌘",
        access: "⌃⌥"
      } : {
        meta: "Ctrl",
        access: "Shift+Alt"
      }, g = n.split("+"), h = ye(g, (C) => {
        const x = C.toLowerCase().trim();
        return mo(d, x) ? d[x] : C;
      });
      return s ? h.join("") : h.join("+");
    }, s4 = (n, s, a = [PO]) => iu(n, { tag: "div", classes: a }, s), g$ = (n) => ({
      dom: {
        tag: "div",
        classes: [Qg]
      },
      components: [xs(Rc.translate(n))]
    }), r4 = (n, s) => ({
      dom: {
        tag: "div",
        classes: s,
        innerHtml: n
      }
    }), TD = (n, s) => ({
      dom: {
        tag: "div",
        classes: [Qg]
      },
      components: [
        {
          dom: {
            tag: n.tag,
            styles: n.styles
          },
          components: [xs(Rc.translate(s))]
        }
      ]
    }), kD = (n) => ({
      dom: {
        tag: "div",
        classes: [Sb]
      },
      components: [
        xs(ED(n))
      ]
    }), AD = (n) => s4("checkmark", n, [KV]), uu = (n) => s4("chevron-right", n, [v6]), Yj = (n) => s4("chevron-down", n, [v6]), Xj = (n, s) => {
      const a = n.direction === "vertical" ? YV : C6, l = n.align === "left" ? QV : XV;
      return {
        dom: {
          tag: "div",
          classes: [
            y6,
            a,
            l,
            (() => {
              switch (n.valign) {
                case "top":
                  return WT;
                case "middle":
                  return x6;
                case "bottom":
                  return JV;
              }
            })()
          ]
        },
        components: s
      };
    }, h$ = (n, s, a) => ({
      dom: {
        tag: "img",
        classes: s,
        attributes: {
          src: n,
          alt: a.getOr("")
        }
      }
    }), p$ = (n, s, a) => {
      const l = "custom", d = "remove", g = n.value, h = n.iconContent.map((T) => UT(T, s.icons, a)), C = n.ariaLabel.map((T) => ({
        "aria-label": s.translate(T),
        "data-mce-name": T
      })).getOr({});
      return {
        dom: (() => {
          const T = wp, _ = h.getOr(""), N = {
            tag: "div",
            attributes: C,
            classes: [T]
          };
          return g === l ? {
            ...N,
            tag: "button",
            classes: [...N.classes, "tox-swatches__picker-btn"],
            innerHtml: _
          } : g === d ? {
            ...N,
            classes: [...N.classes, "tox-swatch--remove"],
            innerHtml: _
          } : un(g) ? {
            ...N,
            attributes: {
              ...N.attributes,
              "data-mce-color": g
            },
            styles: {
              "background-color": g
            },
            innerHtml: _
          } : N;
        })(),
        optComponents: []
      };
    }, _D = (n, s) => {
      const a = n.map((l) => ({
        attributes: {
          id: Ct("menu-item"),
          "aria-label": Rc.translate(l)
        }
      })).getOr({});
      return {
        tag: "div",
        classes: [NO, Bx].concat(s),
        ...a
      };
    }, b$ = (n) => ({
      dom: {
        tag: "label"
      },
      components: [
        xs(n)
      ]
    }), Qj = (n, s, a, l) => {
      const d = { tag: "div", classes: [PO] }, g = (L) => iu(L, d, s.icons, l), h = () => A.some({ dom: d }), C = a ? n.iconContent.map(g).orThunk(h) : A.none(), x = n.checkMark, T = A.from(n.meta).fold(() => g$, (L) => mo(L, "style") ? jt(TD, L.style) : g$), _ = n.htmlContent.fold(() => n.textContent.map(T), (L) => A.some(r4(L, [Qg])));
      return {
        dom: _D(n.ariaLabel, []),
        optComponents: [
          C,
          _,
          n.shortcutContent.map(kD),
          x,
          n.caret,
          n.labelContent.map(b$)
        ]
      };
    }, Jj = (n) => ({
      dom: _D(n.ariaLabel, [qV]),
      optComponents: [
        A.some(Kj(n.iconContent.getOrDie(), { tag: "div", classes: [jT], checkMark: n.checkMark })),
        n.labelContent.map(b$)
      ]
    }), my = (n, s, a, l = A.none()) => n.presets === "color" ? p$(n, s, l) : n.presets === "img" ? Jj(n) : Qj(n, s, a, l), v$ = (n, s, a) => Vt(n, "tooltipWorker").map((l) => [
      ps.config({
        lazySink: s.getSink,
        tooltipDom: {
          tag: "div",
          classes: ["tox-tooltip-worker-container"]
        },
        tooltipComponents: [],
        anchor: (d) => ({
          type: "submenu",
          item: d,
          overrides: {
            // NOTE: this avoids it setting overflow and max-height.
            maxHeightFunction: Ng
          }
        }),
        mode: "follow-highlight",
        onShow: (d, g) => {
          l((h) => {
            ps.setComponents(d, [
              Zl({ element: at.fromDom(h) })
            ]);
          });
        }
      })
    ]).getOrThunk(() => a.map((l) => [
      ps.config({
        ...s.providers.tooltips.getConfig({
          tooltipText: l
        }),
        mode: "follow-highlight"
      })
    ]).getOr([])), eW = (n) => qv.DOM.encode(n), OD = (n, s) => {
      const a = Rc.translate(n), l = eW(a);
      if (s.length > 0) {
        const d = new RegExp(mh(s), "gi");
        return l.replace(d, (g) => `<span class="tox-autocompleter-highlight">${g}</span>`);
      } else
        return l;
    }, tW = (n, s, a, l, d, g, h, C = !0) => {
      const x = my({
        presets: l,
        textContent: A.none(),
        htmlContent: a ? n.text.map((_) => OD(_, s)) : A.none(),
        ariaLabel: n.text,
        labelContent: A.none(),
        iconContent: n.icon,
        shortcutContent: A.none(),
        checkMark: A.none(),
        caret: A.none(),
        value: n.value
      }, h.providers, C, n.icon), T = n.text.filter((_) => !a && _ !== "");
      return Mb({
        context: "mode:design",
        data: oh(n),
        enabled: n.enabled,
        getApi: oe({}),
        onAction: (_) => d(n.value, n.meta),
        onSetup: oe(U),
        triggersSubmenu: !1,
        itemBehaviours: v$(n, h, T)
      }, x, g, h.providers);
    }, y$ = (n, s) => ye(n, (a) => {
      switch (a.type) {
        case "cardcontainer":
          return Xj(a, y$(a.items, s));
        case "cardimage":
          return h$(a.src, a.classes, a.alt);
        case "cardtext":
          const d = a.name.exists((g) => bt(s.cardText.highlightOn, g)) ? A.from(s.cardText.matchText).getOr("") : "";
          return r4(OD(a.text, d), a.classes);
      }
    }), nW = (n, s, a, l) => {
      const d = (h) => ({
        isEnabled: () => !Ft.isDisabled(h),
        setEnabled: (C) => {
          Ft.set(h, !C), He(Lr(h.element, "*"), (x) => {
            h.getSystem().getByDom(x).each((T) => {
              T.hasConfigured(Ft) && Ft.set(T, !C);
            });
          });
        }
      }), g = {
        dom: _D(n.label, []),
        optComponents: [
          A.some({
            dom: {
              tag: "div",
              classes: [y6, C6]
            },
            components: y$(n.items, l)
          })
        ]
      };
      return Mb({
        context: "mode:design",
        data: oh({ text: A.none(), ...n }),
        enabled: n.enabled,
        getApi: d,
        onAction: n.onAction,
        onSetup: n.onSetup,
        triggersSubmenu: !1,
        itemBehaviours: A.from(l.itemBehaviours).getOr([])
      }, g, s, a.providers);
    }, DD = (n, s, a, l, d, g, h, C = !0) => {
      const x = (N) => ({
        setActive: (L) => {
          eo.set(N, L);
        },
        isActive: () => eo.isOn(N),
        isEnabled: () => !Ft.isDisabled(N),
        setEnabled: (L) => Ft.set(N, !L)
      }), T = my({
        presets: a,
        textContent: s ? n.text : A.none(),
        htmlContent: A.none(),
        labelContent: n.label,
        ariaLabel: n.text,
        iconContent: n.icon,
        shortcutContent: s ? n.shortcut : A.none(),
        // useText essentially says that we have one column. In one column lists, we should show a tick
        // The tick is controlled by the tickedClass (via css). It is always present
        // but is hidden unless the tickedClass is present.
        checkMark: s ? A.some(AD(h.icons)) : A.none(),
        caret: A.none(),
        value: n.value
      }, h, C), _ = n.text.filter(oe(!s)).map((N) => ps.config(h.tooltips.getConfig({
        tooltipText: h.translate(N)
      })));
      return Ho(Mb({
        context: n.context,
        data: oh(n),
        enabled: n.enabled,
        getApi: x,
        onAction: (N) => l(n.value),
        onSetup: (N) => (N.setActive(d), U),
        triggersSubmenu: !1,
        itemBehaviours: [
          ..._.toArray()
        ]
      }, T, g, h), {
        toggling: {
          toggleClass: MO,
          toggleOnExecute: !1,
          selected: n.active,
          exclusive: !0
        }
      });
    }, a4 = (n) => ({
      value: Pb(n)
    }), c4 = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, C$ = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, l4 = (n) => c4.test(n) || C$.test(n), Pb = (n) => em(n, "#").toUpperCase(), x$ = (n) => l4(n) ? A.some({ value: Pb(n) }) : A.none(), S$ = (n) => ({ value: n.value.replace(c4, (a, l, d, g) => l + l + d + d + g + g) }), w$ = (n) => {
      const s = S$(n), a = C$.exec(s.value);
      return a === null ? ["FFFFFF", "FF", "FF", "FF"] : a;
    }, RD = (n) => {
      const s = n.toString(16);
      return (s.length === 1 ? "0" + s : s).toUpperCase();
    }, qx = (n) => {
      const s = RD(n.red) + RD(n.green) + RD(n.blue);
      return a4(s);
    }, _p = (n, s, a) => ({
      hue: n,
      saturation: s,
      value: a
    }), ND = (n) => {
      let s = 0, a = 0, l = 0;
      const d = n.red / 255, g = n.green / 255, h = n.blue / 255, C = Math.min(d, Math.min(g, h)), x = Math.max(d, Math.max(g, h));
      if (C === x)
        return l = C, _p(0, 0, l * 100);
      const T = d === C ? g - h : h === C ? d - g : h - d;
      return s = d === C ? 3 : h === C ? 1 : 5, s = 60 * (s - T / (x - C)), a = (x - C) / x, l = x, _p(Math.round(s), Math.round(a * 100), Math.round(l * 100));
    }, E$ = Math.min, MD = Math.max, Kx = Math.round, PD = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, T$ = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, fa = (n, s, a, l) => ({
      red: n,
      green: s,
      blue: a,
      alpha: l
    }), i4 = (n) => {
      const s = parseInt(n, 10);
      return s.toString() === n && s >= 0 && s <= 255;
    }, k$ = (n) => {
      let s, a, l;
      const d = (n.hue || 0) % 360;
      let g = n.saturation / 100, h = n.value / 100;
      if (g = MD(0, E$(g, 1)), h = MD(0, E$(h, 1)), g === 0)
        return s = a = l = Kx(255 * h), fa(s, a, l, 1);
      const C = d / 60, x = h * g, T = x * (1 - Math.abs(C % 2 - 1)), _ = h - x;
      switch (Math.floor(C)) {
        case 0:
          s = x, a = T, l = 0;
          break;
        case 1:
          s = T, a = x, l = 0;
          break;
        case 2:
          s = 0, a = x, l = T;
          break;
        case 3:
          s = 0, a = T, l = x;
          break;
        case 4:
          s = T, a = 0, l = x;
          break;
        case 5:
          s = x, a = 0, l = T;
          break;
        default:
          s = a = l = 0;
      }
      return s = Kx(255 * (s + _)), a = Kx(255 * (a + _)), l = Kx(255 * (l + _)), fa(s, a, l, 1);
    }, Yx = (n) => {
      const s = w$(n), a = parseInt(s[1], 16), l = parseInt(s[2], 16), d = parseInt(s[3], 16);
      return fa(a, l, d, 1);
    }, BD = (n, s, a, l) => {
      const d = parseInt(n, 10), g = parseInt(s, 10), h = parseInt(a, 10), C = parseFloat(l);
      return fa(d, g, h, C);
    }, $D = (n) => {
      const s = PD.exec(n);
      if (s !== null)
        return A.some(BD(s[1], s[2], s[3], "1"));
      const a = T$.exec(n);
      return a !== null ? A.some(BD(a[1], a[2], a[3], a[4])) : A.none();
    }, A$ = (n) => `rgba(${n.red},${n.green},${n.blue},${n.alpha})`, _$ = fa(255, 0, 0, 1), O$ = (n) => ND(Yx(n)), zm = (n) => qx(k$(n)), ID = (n) => x$(n).orThunk(() => $D(n).map(qx)).getOrThunk(() => {
      const s = document.createElement("canvas");
      s.height = 1, s.width = 1;
      const a = s.getContext("2d");
      a.clearRect(0, 0, s.width, s.height), a.fillStyle = "#FFFFFF", a.fillStyle = n, a.fillRect(0, 0, 1, 1);
      const l = a.getImageData(0, 0, 1, 1).data, d = l[0], g = l[1], h = l[2], C = l[3];
      return qx(fa(d, g, h, C));
    }), D$ = (n) => {
      n.dispatch("SkinLoaded");
    }, u4 = (n, s) => {
      n.dispatch("SkinLoadError", s);
    }, FD = (n) => {
      n.dispatch("ResizeEditor");
    }, LD = (n, s) => {
      n.dispatch("ResizeContent", s);
    }, oW = (n, s) => {
      n.dispatch("ScrollContent", s);
    }, R$ = (n, s) => {
      n.dispatch("TextColorChange", s);
    }, sW = (n, s) => {
      n.dispatch("AfterProgressState", { state: s });
    }, rW = (n, s) => n.dispatch("ResolveName", {
      name: s.nodeName.toLowerCase(),
      target: s
    }), aW = (n, s) => {
      n.dispatch("ToggleToolbarDrawer", { state: s });
    }, cW = (n, s) => {
      n.dispatch("StylesTextUpdate", s);
    }, N$ = (n, s) => {
      n.dispatch("AlignTextUpdate", s);
    }, lW = (n, s) => {
      n.dispatch("FontSizeTextUpdate", s);
    }, Vf = (n, s) => {
      n.dispatch("FontSizeInputTextUpdate", s);
    }, d4 = (n, s) => {
      n.dispatch("BlocksTextUpdate", s);
    }, iW = (n, s) => {
      n.dispatch("FontFamilyTextUpdate", s);
    }, uW = (n) => {
      n.dispatch("ToggleSidebar");
    }, M$ = (n) => {
      n.dispatch("ToggleView");
    }, HD = (n) => {
      n.dispatch("ContextToolbarClose");
    }, zD = (n) => {
      n.dispatch("ContextFormSlideBack");
    }, Bb = (n, s) => () => {
      n(), s();
    }, Oa = (n, s = St) => Op(n, "NodeChange", (a) => {
      a.setEnabled(n.selection.isEditable() && s());
    }), Xx = (n, s) => (a) => {
      const l = As(), d = () => {
        a.setActive(n.formatter.match(s));
        const g = n.formatter.formatChanged(s, a.setActive);
        l.set(g);
      };
      return n.initialized ? d() : n.once("init", d), () => {
        n.off("init", d), l.clear();
      };
    }, Qx = (n, s) => (a) => {
      const l = Oa(n)(a), d = Xx(n, s)(a);
      return () => {
        l(), d();
      };
    }, Op = (n, s, a) => (l) => {
      const d = () => a(l), g = () => {
        a(l), n.on(s, d);
      };
      return n.initialized ? g() : n.once("init", g), () => {
        n.off("init", g), n.off(s, d);
      };
    }, m4 = (n) => (s) => () => {
      n.undoManager.transact(() => {
        n.focus(), n.execCommand("mceToggleFormat", !1, s.format);
      });
    }, Cl = (n, s) => () => n.execCommand(s);
    var $b = tinymce.util.Tools.resolve("tinymce.util.LocalStorage");
    const P$ = {}, B$ = (n, s = 10) => {
      const a = $b.getItem(n), l = De(a) ? JSON.parse(a) : [], g = ((T) => s - T.length < 0 ? T.slice(0, s) : T)(l), h = (T) => {
        ue(g, T).each(C), g.unshift(T), g.length > s && g.pop(), $b.setItem(n, JSON.stringify(g));
      }, C = (T) => {
        g.splice(T, 1);
      };
      return {
        add: h,
        state: () => g.slice(0)
      };
    }, VD = (n) => Vt(P$, n).getOrThunk(() => {
      const s = `tinymce-custom-colors-${n}`, a = $b.getItem(s);
      if (pn(a)) {
        const d = $b.getItem("tinymce-custom-colors");
        $b.setItem(s, un(d) ? d : "[]");
      }
      const l = B$(s, 10);
      return P$[n] = l, l;
    }), dW = (n) => ye(VD(n).state(), (s) => ({
      type: "choiceitem",
      text: s,
      icon: "checkmark",
      value: s
    })), UD = (n, s) => {
      VD(n).add(s);
    }, f4 = "forecolor", jD = "hilitecolor", $$ = 5, mW = (n) => WD(n.map((s, a) => a % 2 === 0 ? "#" + ID(s).value : s)), WD = (n) => {
      const s = [];
      for (let a = 0; a < n.length; a += 2)
        s.push({
          text: n[a + 1],
          value: n[a],
          icon: "checkmark",
          type: "choiceitem"
        });
      return s;
    }, xl = (n) => (s) => s.options.get(n), ZD = "#000000", I$ = (n) => {
      const s = n.options.register, a = (g) => lt(g, De) ? { value: mW(g), valid: !0 } : { valid: !1, message: "Must be an array of strings." }, l = (g) => lt(g, De) ? { value: WD(g), valid: !0 } : { valid: !1, message: "Must be an array of strings." }, d = (g) => In(g) && g > 0 ? { value: g, valid: !0 } : { valid: !1, message: "Must be a positive number." };
      s("color_map", {
        processor: a,
        default: [
          "#BFEDD2",
          "Light Green",
          "#FBEEB8",
          "Light Yellow",
          "#F8CAC6",
          "Light Red",
          "#ECCAFA",
          "Light Purple",
          "#C2E0F4",
          "Light Blue",
          "#2DC26B",
          "Green",
          "#F1C40F",
          "Yellow",
          "#E03E2D",
          "Red",
          "#B96AD9",
          "Purple",
          "#3598DB",
          "Blue",
          "#169179",
          "Dark Turquoise",
          "#E67E23",
          "Orange",
          "#BA372A",
          "Dark Red",
          "#843FA1",
          "Dark Purple",
          "#236FA1",
          "Dark Blue",
          "#ECF0F1",
          "Light Gray",
          "#CED4D9",
          "Medium Gray",
          "#95A5A6",
          "Gray",
          "#7E8C8D",
          "Dark Gray",
          "#34495E",
          "Navy Blue",
          "#000000",
          "Black",
          "#ffffff",
          "White"
        ]
      }), s("color_map_raw", {
        processor: l
      }), s("color_map_background", {
        processor: a
      }), s("color_map_foreground", {
        processor: a
      }), s("color_cols", {
        processor: d,
        default: GD(n)
      }), s("color_cols_foreground", {
        processor: d,
        default: F$(n, f4)
      }), s("color_cols_background", {
        processor: d,
        default: F$(n, jD)
      }), s("custom_colors", {
        processor: "boolean",
        default: !0
      }), s("color_default_foreground", {
        processor: "string",
        default: ZD
      }), s("color_default_background", {
        processor: "string",
        default: ZD
      });
    }, g4 = (n, s) => s === f4 && n.options.isSet("color_map_foreground") ? xl("color_map_foreground")(n) : s === jD && n.options.isSet("color_map_background") ? xl("color_map_background")(n) : n.options.isSet("color_map_raw") ? xl("color_map_raw")(n) : xl("color_map")(n), GD = (n, s = "default") => Math.max($$, Math.ceil(Math.sqrt(g4(n, s).length))), F$ = (n, s) => {
      const a = xl("color_cols")(n), l = GD(n, s);
      return a === GD(n) ? l : a;
    }, L$ = (n, s = "default") => Math.round(s === f4 ? xl("color_cols_foreground")(n) : s === jD ? xl("color_cols_background")(n) : xl("color_cols")(n)), qD = xl("custom_colors"), fW = xl("color_default_foreground"), H$ = xl("color_default_background"), KD = "rgba(0, 0, 0, 0)", Uf = (n) => $D(n).exists((s) => s.alpha !== 0), YD = (n) => Ll(n, (s) => {
      if (mc(s)) {
        const a = gs(s, "background-color");
        return Br(Uf(a), a);
      } else
        return A.none();
    }).getOr(KD), XD = (n, s) => {
      const a = at.fromDom(n.selection.getStart()), l = s === "hilitecolor" ? YD(a) : gs(a, "color");
      return $D(l).map((d) => "#" + qx(d).value);
    }, z$ = (n, s, a) => {
      n.undoManager.transact(() => {
        n.focus(), n.formatter.apply(s, { value: a }), n.nodeChanged();
      });
    }, V$ = (n, s) => {
      n.undoManager.transact(() => {
        n.focus(), n.formatter.remove(s, { value: null }, void 0, !0), n.nodeChanged();
      });
    }, U$ = (n) => {
      n.addCommand("mceApplyTextcolor", (s, a) => {
        z$(n, s, a);
      }), n.addCommand("mceRemoveTextcolor", (s) => {
        V$(n, s);
      });
    }, h4 = (n) => {
      const s = "choiceitem", a = {
        type: s,
        text: "Remove color",
        icon: "color-swatch-remove-color",
        value: "remove"
      };
      return n ? [
        a,
        {
          type: s,
          text: "Custom color",
          icon: "color-picker",
          value: "custom"
        }
      ] : [a];
    }, p4 = (n, s, a, l) => {
      a === "custom" ? eR(n)((g) => {
        g.each((h) => {
          UD(s, h), n.execCommand("mceApplyTextcolor", s, h), l(h);
        });
      }, XD(n, s).getOr(ZD)) : a === "remove" ? (l(""), n.execCommand("mceRemoveTextcolor", s)) : (l(a), n.execCommand("mceApplyTextcolor", s, a));
    }, fy = (n, s, a) => n.concat(dW(s).concat(h4(a))), QD = (n, s, a) => (l) => {
      l(fy(n, s, a));
    }, b4 = (n, s, a) => {
      const l = s === "forecolor" ? "tox-icon-text-color__color" : "tox-icon-highlight-bg-color__color";
      n.setIconFill(l, a);
    }, j$ = (n, s) => {
      n.setTooltip(s);
    }, W$ = (n, s) => (a) => {
      const l = XD(n, s);
      return uc(l, a.toUpperCase());
    }, JD = (n, s, a) => {
      if (ha(a))
        return s === "forecolor" ? "Text color" : "Background color";
      const l = s === "forecolor" ? "Text color {0}" : "Background color {0}", d = fy(g4(n, s), s, !1), g = Lt(d, (h) => h.value === a).getOr({ text: "" }).text;
      return n.translate([l, n.translate(g)]);
    }, Z$ = (n, s, a, l) => {
      n.ui.registry.addSplitButton(s, {
        tooltip: JD(n, a, l.get()),
        chevronTooltip: s === "forecolor" ? "Text color menu" : "Background color menu",
        presets: "color",
        icon: s === "forecolor" ? "text-color" : "highlight-bg-color",
        select: W$(n, a),
        columns: L$(n, a),
        fetch: QD(g4(n, a), a, qD(n)),
        onAction: (d) => {
          p4(n, a, l.get(), U);
        },
        onItemAction: (d, g) => {
          p4(n, a, g, (h) => {
            l.set(h), R$(n, {
              name: s,
              color: h
            });
          });
        },
        onSetup: (d) => {
          b4(d, s, l.get());
          const g = (h) => {
            h.name === s && (b4(d, h.name, h.color), j$(d, JD(n, a, h.color)));
          };
          return n.on("TextColorChange", g), Bb(Oa(n)(d), () => {
            n.off("TextColorChange", g);
          });
        }
      });
    }, G$ = (n, s, a, l, d) => {
      n.ui.registry.addNestedMenuItem(s, {
        text: l,
        icon: s === "forecolor" ? "text-color" : "highlight-bg-color",
        onSetup: (g) => (j$(g, JD(n, a, d.get())), b4(g, s, d.get()), Oa(n)(g)),
        getSubmenuItems: () => [
          {
            type: "fancymenuitem",
            fancytype: "colorswatch",
            select: W$(n, a),
            initData: {
              storageKey: a
            },
            onAction: (g) => {
              p4(n, a, g.value, (h) => {
                d.set(h), R$(n, {
                  name: s,
                  color: h
                });
              });
            }
          }
        ]
      });
    }, eR = (n) => (s, a) => {
      let l = !1;
      const d = (C) => {
        const T = C.getData().colorpicker;
        l ? (s(A.from(T)), C.close()) : n.windowManager.alert(n.translate(["Invalid hex color code: {0}", T]));
      }, g = (C, x) => {
        x.name === "hex-valid" && (l = x.value);
      }, h = {
        colorpicker: a
      };
      n.windowManager.open({
        title: "Color Picker",
        size: "normal",
        body: {
          type: "panel",
          items: [
            {
              type: "colorpicker",
              name: "colorpicker",
              label: "Color"
            }
          ]
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: h,
        onAction: g,
        onSubmit: d,
        onClose: U,
        onCancel: () => {
          s(A.none());
        }
      });
    }, q$ = (n) => {
      U$(n);
      const s = fW(n), a = H$(n), l = Pt(s), d = Pt(a);
      Z$(n, "forecolor", "forecolor", l), Z$(n, "backcolor", "hilitecolor", d), G$(n, "forecolor", "forecolor", "Text color", l), G$(n, "backcolor", "hilitecolor", "Background color", d);
    }, gW = (n, s, a, l, d) => {
      const g = (x) => ({
        setActive: (T) => {
          eo.set(x, T);
        },
        isActive: () => eo.isOn(x),
        isEnabled: () => !Ft.isDisabled(x),
        setEnabled: (T) => Ft.set(x, !T)
      }), h = my({
        presets: "img",
        textContent: A.none(),
        htmlContent: A.none(),
        ariaLabel: n.tooltip,
        iconContent: A.some(n.url),
        labelContent: n.label,
        shortcutContent: A.none(),
        checkMark: A.some(AD(d.icons)),
        caret: A.none(),
        value: n.value
      }, d, !0), C = n.tooltip.map((x) => ps.config(d.tooltips.getConfig({
        tooltipText: d.translate(x)
      })));
      return Ho(Mb({
        context: n.context,
        data: oh(n),
        enabled: n.enabled,
        getApi: g,
        onAction: (x) => {
          s(n.value), x.setActive(!0);
        },
        onSetup: (x) => (x.setActive(a), U),
        triggersSubmenu: !1,
        itemBehaviours: [
          ...C.toArray()
        ]
      }, h, l, d), {
        toggling: {
          toggleClass: MO,
          toggleOnExecute: !1,
          selected: n.active,
          exclusive: !0
        }
      });
    }, v4 = (n, s, a, l, d, g, h, C) => {
      const x = Lx(s), _ = hW(s, a, l, d !== "color" ? "normal" : "color", g, h, C);
      return WO(n, x, _, l, {
        menuType: d
      });
    }, hW = (n, s, a, l, d, g, h) => Al(ye(n, (C) => C.type === "choiceitem" ? Ej(C).fold(Im, (x) => A.some(DD(x, a === 1, l, s, g(x.value), d, h, Lx(n)))) : C.type === "imageitem" ? d$(C).fold(Im, (x) => A.some(gW(x, s, g(x.value), d, h))) : C.type === "resetimage" ? bD(C).fold(Im, (x) => A.some(DD({
      ...x,
      text: x.tooltip,
      icon: A.some(x.icon),
      label: A.some(x.label)
    }, a === 1, l, s, g(x.value), d, h, Lx(n)))) : A.none())), Dp = (n, s) => {
      const a = Lf(s);
      return n === 1 ? { mode: "menu", moveOnTab: !0 } : n === "auto" ? {
        mode: "grid",
        selector: "." + a.item,
        initSize: {
          numColumns: 1,
          numRows: 1
        }
      } : {
        mode: "matrix",
        rowSelector: "." + {
          color: "tox-swatches__row",
          imageselector: "tox-image-selector__row",
          listpreview: "tox-collection__group",
          normal: "tox-collection__group"
        }[s],
        previousSelector: (d) => s === "color" ? Po(d.element, "[aria-checked=true]") : A.none()
      };
    }, pW = (n, s) => n === 1 ? {
      mode: "menu",
      moveOnTab: !1,
      selector: ".tox-collection__item"
    } : n === "auto" ? {
      mode: "flatgrid",
      selector: ".tox-collection__item",
      initSize: {
        numColumns: 1,
        numRows: 1
      }
    } : {
      mode: "matrix",
      selectors: {
        row: s === "color" ? ".tox-swatches__row" : ".tox-collection__group",
        cell: s === "color" ? `.${wp}` : `.${Bx}`
      }
    }, bW = (n, s) => {
      const a = K$(n, s), l = s.colorinput.getColorCols(n.initData.storageKey), d = "color", h = {
        ...v4(Ct("menu-value"), a, (C) => {
          n.onAction({ value: C });
        }, l, d, Wd.CLOSE_ON_EXECUTE, n.select.getOr(an), s.shared.providers),
        markers: Lf(d),
        movement: Dp(l, d),
        // TINY-10806: Avoid duplication of ARIA role="menu" in the accessibility tree for Color Swatch menu item.
        showMenuRole: !1
      };
      return {
        type: "widget",
        data: { value: Ct("widget-id") },
        dom: {
          tag: "div",
          classes: ["tox-fancymenuitem"]
        },
        autofocus: !0,
        components: [
          __.widget(qg.sketch(h))
        ]
      };
    }, K$ = (n, s) => {
      const a = n.initData.allowCustomColors && s.colorinput.hasCustomColors();
      return n.initData.colors.fold(() => fy(s.colorinput.getColors(n.initData.storageKey), n.initData.storageKey, a), (l) => l.concat(h4(a)));
    }, Y$ = (n, s) => {
      const a = "imageselector", l = n.initData.columns, g = {
        ...v4(Ct("menu-value"), n.initData.items, (h) => {
          n.onAction({ value: h });
        }, l, a, Wd.CLOSE_ON_EXECUTE, n.select.getOr(an), s.shared.providers),
        markers: Lf(a),
        movement: Dp(l, a),
        // TINY-10806: Avoid duplication of ARIA role="menu" in the accessibility tree for Image Selector menu item.
        showMenuRole: !1
      };
      return {
        type: "widget",
        data: { value: Ct("widget-id") },
        dom: {
          tag: "div",
          classes: ["tox-fancymenuitem", "tox-collection--toolbar"]
        },
        autofocus: !0,
        components: [
          __.widget(qg.sketch(g))
        ]
      };
    }, X$ = Ct("cell-over"), Q$ = Ct("cell-execute"), tR = (n) => (s, a) => n.shared.providers.translate(["{0} columns, {1} rows", a, s]), vW = (n, s, a) => {
      const l = (h) => tn(h, X$, { row: n, col: s }), d = (h) => tn(h, Q$, { row: n, col: s }), g = (h, C) => {
        C.stop(), d(h);
      };
      return p({
        dom: {
          tag: "div",
          attributes: {
            role: "button",
            "aria-label": a
          }
        },
        behaviours: nt([
          xn("insert-table-picker-cell", [
            Ie(Ul(), En.focus),
            Ie(wa(), d),
            Ie(Cg(), g),
            Ie(Fh(), g)
          ]),
          eo.config({
            toggleClass: "tox-insert-table-picker__selected",
            toggleOnExecute: !1
          }),
          En.config({ onFocus: l })
        ])
      });
    }, J$ = (n, s, a) => {
      const l = [];
      for (let d = 0; d < s; d++) {
        const g = [];
        for (let h = 0; h < a; h++) {
          const C = n(d + 1, h + 1);
          g.push(vW(d, h, C));
        }
        l.push(g);
      }
      return l;
    }, yW = (n, s, a, l, d) => {
      for (let g = 0; g < l; g++)
        for (let h = 0; h < d; h++)
          eo.set(n[g][h], g <= s && h <= a);
    }, CW = (n) => xe(n, (s) => ye(s, y)), eI = (n, s) => xs(`${s}x${n}`), nR = {
      inserttable: (n, s) => {
        const d = tR(s), g = J$(d, 10, 10), h = eI(0, 0), C = To({
          dom: {
            tag: "span",
            classes: ["tox-insert-table-picker__label"]
          },
          components: [h],
          behaviours: nt([
            An.config({})
          ])
        });
        return {
          type: "widget",
          data: { value: Ct("widget-id") },
          dom: {
            tag: "div",
            classes: ["tox-fancymenuitem"]
          },
          autofocus: !0,
          components: [__.widget({
            dom: {
              tag: "div",
              classes: ["tox-insert-table-picker"]
            },
            components: CW(g).concat(C.asSpec()),
            behaviours: nt([
              xn("insert-table-picker", [
                hs((x) => {
                  An.set(C.get(x), [h]);
                }),
                Qh(X$, (x, T, _) => {
                  const { row: N, col: L } = _.event;
                  yW(g, N, L, 10, 10), An.set(C.get(x), [eI(N + 1, L + 1)]);
                }),
                Qh(Q$, (x, T, _) => {
                  const { row: N, col: L } = _.event;
                  Wn(x, x0()), n.onAction({ numRows: N + 1, numColumns: L + 1 });
                })
              ]),
              Xt.config({
                initSize: {
                  numRows: 10,
                  numColumns: 10
                },
                mode: "flatgrid",
                selector: '[role="button"]'
              })
            ])
          })]
        };
      },
      colorswatch: bW,
      imageselect: Y$
    }, SW = (n, s) => Vt(nR, n.fancytype).map((a) => a(n, s)), wW = (n, s, a, l = !0, d = !1) => {
      const g = d ? Yj(a.icons) : uu(a.icons), h = (x) => ({
        isEnabled: () => !Ft.isDisabled(x),
        setEnabled: (T) => Ft.set(x, !T),
        setIconFill: (T, _) => {
          Po(x.element, `svg path[class="${T}"], rect[class="${T}"]`).each((N) => {
            ln(N, "fill", _);
          });
        },
        setTooltip: (T) => {
          const _ = a.translate(T);
          ln(x.element, "aria-label", _);
        }
      }), C = my({
        presets: "normal",
        iconContent: n.icon,
        textContent: n.text,
        htmlContent: A.none(),
        ariaLabel: n.text,
        labelContent: A.none(),
        caret: A.some(g),
        checkMark: A.none(),
        shortcutContent: n.shortcut
      }, a, l);
      return Mb({
        context: n.context,
        data: oh(n),
        getApi: h,
        enabled: n.enabled,
        onAction: U,
        onSetup: n.onSetup,
        triggersSubmenu: !0,
        itemBehaviours: []
      }, C, s, a);
    }, EW = (n, s, a, l = !0) => {
      const d = (h) => ({
        isEnabled: () => !Ft.isDisabled(h),
        setEnabled: (C) => Ft.set(h, !C)
      }), g = my({
        presets: "normal",
        iconContent: n.icon,
        textContent: n.text,
        htmlContent: A.none(),
        labelContent: A.none(),
        ariaLabel: n.text,
        caret: A.none(),
        checkMark: A.none(),
        shortcutContent: n.shortcut
      }, a, l);
      return Mb({
        context: n.context,
        data: oh(n),
        getApi: d,
        enabled: n.enabled,
        onAction: n.onAction,
        onSetup: n.onSetup,
        triggersSubmenu: !1,
        itemBehaviours: []
      }, g, s, a);
    }, TW = (n) => ({
      type: "separator",
      dom: {
        tag: "div",
        classes: [Bx, b6]
      },
      components: n.text.map(xs).toArray()
    }), tI = (n, s, a, l = !0) => {
      const d = (h) => ({
        setActive: (C) => {
          eo.set(h, C);
        },
        isActive: () => eo.isOn(h),
        isEnabled: () => !Ft.isDisabled(h),
        setEnabled: (C) => Ft.set(h, !C)
      }), g = my({
        iconContent: n.icon,
        textContent: n.text,
        htmlContent: A.none(),
        labelContent: A.none(),
        ariaLabel: n.text,
        checkMark: A.some(AD(a.icons)),
        caret: A.none(),
        shortcutContent: n.shortcut,
        presets: "normal",
        meta: n.meta
      }, a, l);
      return Ho(Mb({
        context: n.context,
        data: oh(n),
        enabled: n.enabled,
        getApi: d,
        onAction: n.onAction,
        onSetup: n.onSetup,
        triggersSubmenu: !1,
        itemBehaviours: []
      }, g, s, a), {
        toggling: {
          toggleClass: MO,
          toggleOnExecute: !1,
          selected: n.active
        },
        role: n.role.getOrUndefined()
      });
    }, nI = tW, oR = TW, kW = EW, AW = wW, _W = tI, OW = SW, DW = nW, RW = (n) => {
      switch (n.searchMode) {
        case "no-search":
          return {
            menuType: "normal"
          };
        default:
          return {
            menuType: "searchable",
            searchMode: n
          };
      }
    }, NW = (n) => {
      const s = _t.getValue(n), a = Ix(n).map(FO);
      Kl.refetch(s).get(() => {
        const l = Rn.getCoupled(s, "sandbox");
        a.each((d) => Ix(l).each((g) => tU(g, d)));
      });
    }, MW = (n, s) => {
      PW(n).each((a) => {
        ak(n, a.element, s.event.eventType, s.event.interactionEvent);
      });
    }, PW = (n) => Co.getState(n).bind(So.getHighlighted).bind(So.getHighlighted), sR = (n) => ar(n.element, ZT) ? A.some(n.element) : Po(n.element, "." + ZT), oI = (n, s, a) => {
      T6(n).each((l) => {
        k6(l, a), sR(s).each((g) => {
          Qr(g, "id").each((h) => ln(l.element, "aria-controls", h));
        });
      }), ln(a.element, "aria-selected", "true");
    }, BW = (n, s, a) => {
      ln(a.element, "aria-selected", "false");
    }, $W = (n) => {
      T6(n).each((s) => En.focus(s));
    }, Jx = (n) => Rn.getExistingCoupled(n, "sandbox").bind(Ix).map(FO).map((a) => a.fetchPattern).getOr("");
    var gy;
    (function(n) {
      n[n.ContentFocus = 0] = "ContentFocus", n[n.UiFocus = 1] = "UiFocus";
    })(gy || (gy = {}));
    const IW = (n, s, a, l, d) => {
      const g = a.shared.providers, h = (C) => d ? {
        ...C,
        shortcut: A.none(),
        icon: C.text.isSome() ? A.none() : C.icon
      } : C;
      switch (n.type) {
        case "menuitem":
          return Oj(n).fold(Im, (C) => A.some(kW(h(C), s, g, l)));
        case "nestedmenuitem":
          return Rj(n).fold(Im, (C) => A.some(AW(h(C), s, g, l, d)));
        case "togglemenuitem":
          return Mj(n).fold(Im, (C) => A.some(_W(h(C), s, g, l)));
        case "separator":
          return aj(n).fold(Im, (C) => A.some(oR(C)));
        case "fancymenuitem":
          return u$(n).fold(
            Im,
            // Fancy menu items don't have shortcuts or icons
            (C) => OW(C, a)
          );
        default:
          return console.error("Unknown item in general menu", n), A.none();
      }
    }, FW = (n, s, a, l, d, g, h) => {
      const C = l === 1, x = !C || Lx(n);
      return Al(ye(n, (T) => {
        switch (T.type) {
          case "separator":
            return lj(T).fold(Im, (_) => A.some(oR(_)));
          case "cardmenuitem":
            return gD(T).fold(Im, (_) => A.some(DW({
              ..._,
              // Intercept action
              onAction: (N) => {
                _.onAction(N), a(_.value, _.meta);
              }
            }, d, g, {
              itemBehaviours: v$(_.meta, g, A.none()),
              cardText: {
                matchText: s,
                highlightOn: h
              }
            })));
          case "autocompleteitem":
          default:
            return ij(T).fold(Im, (_) => A.some(nI(_, s, C, "normal", a, d, g, x)));
        }
      }));
    }, y4 = (n, s, a, l, d, g) => {
      const h = Lx(s), C = Al(ye(s, (_) => {
        const N = (j) => d ? !mo(j, "text") : h, L = (j) => IW(j, a, l, N(j), d);
        return _.type === "nestedmenuitem" && _.getSubmenuItems().length <= 0 ? L({ ..._, enabled: !1 }) : L(_);
      })), x = RW(g);
      return (d ? D6 : WO)(n, h, C, 1, x);
    }, rR = (n) => hb.singleData(n.value, n), aR = (n, s, a, l) => {
      const d = Dp(s, l), g = Lf(l);
      return {
        data: rR({
          ...n,
          movement: d,
          menuBehaviours: dy.unnamedEvents(s !== "auto" ? [] : [
            hs((h, C) => {
              xD(h, 4, g.item).each(({ numColumns: x, numRows: T }) => {
                Xt.setGridSize(h, T, x);
              });
            })
          ])
        }),
        menu: {
          markers: Lf(l),
          fakeFocus: a === gy.ContentFocus
        }
      };
    }, sI = (n) => w.create(at.fromDom(n.startContainer), n.startOffset, at.fromDom(n.endContainer), n.endOffset), LW = {
      register: (n, s) => {
        const a = Ct("autocompleter"), l = Pt(!1), d = Pt(!1), g = hn(), h = p(Us.sketch({
          dom: {
            tag: "div",
            classes: ["tox-autocompleter"],
            attributes: {
              id: a
            }
          },
          components: [],
          fireDismissalEventInstead: {},
          inlineBehaviours: nt([
            xn("dismissAutocompleter", [
              Ie(fm(), () => N()),
              Ie(T0(), (Y, le) => {
                Qr(le.event.target, "id").each((pe) => ln(at.fromDom(n.getBody()), "aria-activedescendant", pe));
              })
            ])
          ]),
          lazySink: s.getSink
        })), C = () => Us.isOpen(h), x = d.get, T = () => {
          if (C()) {
            Us.hide(h), n.dom.remove(a, !1);
            const Y = at.fromDom(n.getBody());
            Qr(Y, "aria-owns").filter((le) => le === a).each(() => {
              fs(Y, "aria-owns"), fs(Y, "aria-activedescendant");
            });
          }
        }, _ = () => Us.getContent(h).bind((Y) => Jc(Y.components(), 0)), N = () => n.execCommand("mceAutocompleterClose"), L = (Y) => {
          const le = ga(Y, (pe) => A.from(pe.columns)).getOr(1);
          return xe(Y, (pe) => {
            const Ee = pe.items;
            return FW(Ee, pe.matchText, (Oe, gt) => {
              const Ue = {
                hide: () => N(),
                reload: (Qe) => {
                  T(), n.execCommand("mceAutocompleterReload", !1, { fetchOptions: Qe });
                }
              };
              n.execCommand("mceAutocompleterRefreshActiveRange"), g.get().each((Qe) => {
                l.set(!0), pe.onAction(Ue, Qe, Oe, gt), l.set(!1);
              });
            }, le, Wd.BUBBLE_TO_SANDBOX, s, pe.highlightOn);
          });
        }, j = (Y, le) => {
          const pe = ga(Y, (Ee) => A.from(Ee.columns)).getOr(1);
          Us.showMenuAt(h, {
            anchor: {
              type: "selection",
              getSelection: () => g.get().map(sI),
              root: at.fromDom(n.getBody())
            }
          }, aR(
            WO("autocompleter-value", !0, le, pe, { menuType: "normal" }),
            pe,
            gy.ContentFocus,
            // Use the constant.
            "normal"
          )), _().each(So.highlightFirst);
        }, Z = (Y) => {
          const le = L(Y);
          le.length > 0 ? (j(Y, le), ln(at.fromDom(n.getBody()), "aria-owns", a), n.inline || ne()) : T();
        }, ne = () => {
          n.dom.get(a) && n.dom.remove(a, !1);
          const Y = n.getDoc().documentElement, le = n.selection.getNode(), pe = ph(h.element);
          Ss(pe, {
            border: "0",
            clip: "rect(0 0 0 0)",
            height: "1px",
            margin: "-1px",
            overflow: "hidden",
            padding: "0",
            position: "absolute",
            width: "1px",
            top: `${le.offsetTop}px`,
            left: `${le.offsetLeft}px`
          }), n.dom.add(Y, pe.dom), Po(pe, '[role="menu"]').each((Ee) => {
            Kn(Ee, "position"), Kn(Ee, "max-height");
          });
        };
        n.on("AutocompleterStart", ({ lookupData: Y }) => {
          d.set(!0), l.set(!1), Z(Y);
        }), n.on("AutocompleterUpdate", ({ lookupData: Y }) => Z(Y)), n.on("AutocompleterUpdateActiveRange", ({ range: Y }) => g.set(Y)), n.on("AutocompleterEnd", () => {
          T(), d.set(!1), l.set(!1), g.clear();
        });
        const ae = {
          cancelIfNecessary: N,
          isMenuOpen: C,
          isActive: x,
          isProcessingAction: l.get,
          getMenu: _
        };
        GV.setup(ae, n);
      }
    }, rI = (n, s) => ({
      dom: {
        tag: "div",
        classes: ["tox-bar", "tox-form__controls-h-stack"]
      },
      components: ye(n.items, s.interpreter)
    });
    var HW = tinymce.util.Tools.resolve("tinymce.html.Entities");
    const hy = (n, s, a, l) => {
      const d = aI(n, s, a, l);
      return Yn.sketch(d);
    }, zW = (n, s) => hy(n, s, [], []), aI = (n, s, a, l) => ({
      dom: lI(a),
      components: n.toArray().concat([s]),
      fieldBehaviours: nt(l)
    }), cI = () => lI([]), lI = (n) => ({
      tag: "div",
      classes: ["tox-form__group"].concat(n)
    }), sh = (n, s) => Yn.parts.label({
      dom: {
        tag: "label",
        classes: ["tox-label"]
      },
      components: [
        xs(s.translate(n))
      ]
    }), Sl = Ct("form-component-change"), iI = Ct("form-component-input"), Ib = Ct("form-close"), rh = Ct("form-cancel"), Zd = Ct("form-action"), eS = Ct("form-submit"), cR = Ct("form-block"), C4 = Ct("form-unblock"), uI = Ct("form-tabchange"), lR = Ct("form-resize"), VW = (n, s, a) => {
      const l = n.label.map((j) => sh(j, s)), d = s.icons(), g = (j) => d[j] ?? j, h = (j) => (Z, ne) => {
        xa(ne.event.target, "[data-collection-item-value]").each((ae) => {
          j(Z, ne, ae, Dr(ae, "data-collection-item-value"));
        });
      }, C = (j, Z) => {
        const ae = s.checkUiComponentContext("mode:design").shouldDisable || s.isDisabled() ? " tox-collection__item--state-disabled" : "", Y = ye(Z, (Ee) => {
          const Oe = Rc.translate(Ee.text), gt = n.columns === 1 ? `<div class="tox-collection__item-label">${Oe}</div>` : "", Ue = `<div class="tox-collection__item-icon">${g(Ee.icon)}</div>`, Qe = {
            _: " ",
            " - ": " ",
            "-": " "
          }, Ke = Oe.replace(/\_| \- |\-/g, (Qt) => Qe[Qt]);
          return `<div data-mce-tooltip="${Ke}" class="tox-collection__item${ae}" tabindex="-1" data-collection-item-value="${HW.encodeAllRaw(Ee.value)}" aria-label="${Ke}">${Ue}${gt}</div>`;
        }), le = n.columns !== "auto" && n.columns > 1 ? Fn(Y, n.columns) : [Y], pe = ye(le, (Ee) => `<div class="tox-collection__group">${Ee.join("")}</div>`);
        $l(j.element, pe.join(""));
      }, x = h((j, Z, ne, ae) => {
        Z.stop(), s.checkUiComponentContext("mode:design").shouldDisable || s.isDisabled() || tn(j, Zd, {
          name: n.name,
          value: ae
        });
      }), T = [
        Ie(Ul(), h((j, Z, ne) => {
          $r(ne, !0);
        })),
        Ie(Cg(), x),
        Ie(Fh(), x),
        Ie(Ki(), h((j, Z, ne) => {
          Po(j.element, "." + wb).each((ae) => {
            Ds(ae, wb);
          }), Uo(ne, wb);
        })),
        Ie(S2(), h((j) => {
          Po(j.element, "." + wb).each((Z) => {
            Ds(Z, wb), Os(Z);
          });
        })),
        Ef(h((j, Z, ne, ae) => {
          tn(j, Zd, {
            name: n.name,
            value: ae
          });
        }))
      ], _ = (j, Z) => ye(Lr(j.element, ".tox-collection__item"), Z), N = Yn.parts.field({
        dom: {
          tag: "div",
          // FIX: Read from columns
          classes: ["tox-collection"].concat(n.columns !== 1 ? ["tox-collection--grid"] : ["tox-collection--list"])
        },
        components: [],
        factory: { sketch: Yt },
        behaviours: nt([
          Ft.config({
            disabled: () => s.checkUiComponentContext(n.context).shouldDisable,
            onDisabled: (j) => {
              _(j, (Z) => {
                Uo(Z, "tox-collection__item--state-disabled"), ln(Z, "aria-disabled", !0);
              });
            },
            onEnabled: (j) => {
              _(j, (Z) => {
                Ds(Z, "tox-collection__item--state-disabled"), fs(Z, "aria-disabled");
              });
            }
          }),
          yr(() => s.checkUiComponentContext(n.context)),
          An.config({}),
          ps.config({
            ...s.tooltips.getConfig({
              tooltipText: "",
              onShow: (j) => {
                Po(j.element, "." + wb + "[data-mce-tooltip]").each((Z) => {
                  Qr(Z, "data-mce-tooltip").each((ne) => {
                    ps.setComponents(j, s.tooltips.getComponents({ tooltipText: ne }));
                  });
                });
              }
            }),
            mode: "children-keyboard-focus",
            anchor: (j) => ({
              type: "node",
              node: Po(j.element, "." + wb).orThunk(() => r0(".tox-collection__item")),
              root: j.element,
              layouts: {
                onLtr: oe([Tr, Rs, Mr, Ta, Er, ua]),
                onRtl: oe([Tr, Rs, Mr, Ta, Er, ua])
              },
              bubble: bl(0, -2, {})
            })
          }),
          _t.config({
            store: {
              mode: "memory",
              initialValue: a.getOr([])
            },
            onSetValue: (j, Z) => {
              C(j, Z), n.columns === "auto" && xD(j, 5, "tox-collection__item").each(({ numRows: ne, numColumns: ae }) => {
                Xt.setGridSize(j, ne, ae);
              }), Wn(j, lR);
            }
          }),
          is.config({}),
          Xt.config(pW(n.columns, "normal")),
          xn("collection-events", T)
        ]),
        eventOrder: {
          [wa()]: ["disabling", "alloy.base.behaviour", "collection-events"],
          [Ki()]: ["collection-events", "tooltipping"]
        }
      });
      return hy(l, N, ["tox-form__group--collection"], []);
    }, UW = (n, s) => Kl.sketch({
      dom: n.dom,
      components: n.components,
      toggleClass: "mce-active",
      dropdownBehaviours: nt([
        Lm.button(() => s.providers.isDisabled() || s.providers.checkUiComponentContext(n.context).shouldDisable),
        yr(() => s.providers.checkUiComponentContext(n.context)),
        Om.config({}),
        is.config({})
      ]),
      layouts: n.layouts,
      sandboxClasses: ["tox-dialog__popups"],
      lazySink: s.getSink,
      fetch: (a) => Zo.nu((l) => n.fetch(l)).map((l) => A.from(rR(Ho(v4(
        Ct("menu-value"),
        l,
        (d) => {
          n.onItemAction(a, d);
        },
        n.columns,
        n.presets,
        Wd.CLOSE_ON_EXECUTE,
        // No colour is ever selected on opening
        an,
        s.providers
      ), {
        movement: Dp(n.columns, n.presets)
      })))),
      parts: {
        menu: $x(!1, 1, n.presets)
      }
    }), x4 = Ct("color-input-change"), dI = Ct("color-swatch-change"), mI = Ct("color-picker-cancel"), jW = (n, s, a, l) => {
      const d = Yn.parts.field({
        factory: Ff,
        inputClasses: ["tox-textfield"],
        data: l,
        onSetValue: (T) => ru.run(T).get(U),
        inputBehaviours: nt([
          Ft.config({
            disabled: () => s.providers.isDisabled() || s.providers.checkUiComponentContext(n.context).shouldDisable
          }),
          yr(() => s.providers.checkUiComponentContext(n.context)),
          is.config({}),
          ru.config({
            invalidClass: "tox-textbox-field-invalid",
            getRoot: (T) => Li(T.element),
            notify: {
              onValid: (T) => {
                const _ = _t.getValue(T);
                tn(T, x4, {
                  color: _
                });
              }
            },
            validator: {
              validateOnLoad: !1,
              validate: (T) => {
                const _ = _t.getValue(T);
                if (_.length === 0)
                  return Zo.pure(Wt.value(!0));
                {
                  const N = at.fromTag("span");
                  gn(N, "background-color", _);
                  const L = Cs(N, "background-color").fold(
                    // TODO: Work out what we want to do here.
                    () => Wt.error("blah"),
                    (j) => Wt.value(_)
                  );
                  return Zo.pure(L);
                }
              }
            }
          })
        ]),
        selectOnFocus: !1
      }), g = n.label.map((T) => sh(T, s.providers)), h = (T, _) => {
        tn(T, dI, {
          value: _
        });
      }, C = (T, _) => {
        x.getOpt(T).each((N) => {
          _ === "custom" ? a.colorPicker((L) => {
            L.fold(() => Wn(N, mI), (j) => {
              h(N, j), UD(n.storageKey, j);
            });
          }, "#ffffff") : _ === "remove" ? h(N, "") : h(N, _);
        });
      }, x = To(UW({
        dom: {
          tag: "span",
          attributes: {
            "aria-label": s.providers.translate("Color swatch")
          }
        },
        layouts: {
          onRtl: () => [Er, Mr, Tr],
          onLtr: () => [Mr, Er, Tr]
        },
        components: [],
        fetch: QD(a.getColors(n.storageKey), n.storageKey, a.hasCustomColors()),
        columns: a.getColorCols(n.storageKey),
        presets: "color",
        onItemAction: C,
        context: n.context
      }, s));
      return Yn.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: g.toArray().concat([
          {
            dom: {
              tag: "div",
              classes: ["tox-color-input"]
            },
            components: [
              d,
              x.asSpec()
            ]
          }
        ]),
        fieldBehaviours: nt([
          xn("form-field-events", [
            Ie(x4, (T, _) => {
              x.getOpt(T).each((N) => {
                gn(N.element, "background-color", _.event.color);
              }), tn(T, Sl, { name: n.name });
            }),
            Ie(dI, (T, _) => {
              Yn.getField(T).each((N) => {
                _t.setValue(N, _.event.value), Fe.getCurrent(T).each(En.focus);
              });
            }),
            Ie(mI, (T, _) => {
              Yn.getField(T).each((N) => {
                Fe.getCurrent(T).each(En.focus);
              });
            })
          ])
        ])
      });
    }, Gd = {
      self: () => Fe.config({
        find: A.some
      }),
      memento: (n) => Fe.config({
        find: n.getOpt
      }),
      childAt: (n) => Fe.config({
        find: (s) => md(s.element, n).bind((a) => s.getSystem().getByDom(a).toOptional())
      })
    }, gI = on([
      we("preprocess", Yt),
      we("postprocess", Yt)
    ]), ZW = (n, s) => {
      const a = yc("RepresentingConfigs.memento processors", gI, s);
      return _t.config({
        store: {
          mode: "manual",
          getValue: (l) => {
            const d = n.get(l), g = _t.getValue(d);
            return a.postprocess(g);
          },
          setValue: (l, d) => {
            const g = a.preprocess(d), h = n.get(l);
            _t.setValue(h, g);
          }
        }
      });
    }, Fb = (n, s, a) => _t.config({
      store: {
        mode: "manual",
        ...n.map((l) => ({ initialValue: l })).getOr({}),
        getValue: s,
        setValue: a
      }
    }), hI = (n, s, a) => Fb(n, (l) => s(l.element), (l, d) => a(l.element, d)), GW = (n) => hI(n, Hi, $l), S4 = (n) => _t.config({
      store: {
        mode: "memory",
        initialValue: n
      }
    }), w4 = Ct("rgb-hex-update"), pI = Ct("slider-update"), bI = Ct("palette-update"), vI = (n, s) => {
      const a = Ud.parts.spectrum({
        dom: {
          tag: "div",
          classes: [s("hue-slider-spectrum")],
          attributes: {
            role: "presentation"
          }
        }
      }), l = Ud.parts.thumb({
        dom: {
          tag: "div",
          classes: [s("hue-slider-thumb")],
          attributes: {
            role: "presentation"
          }
        }
      });
      return Ud.sketch({
        dom: {
          tag: "div",
          classes: [s("hue-slider")],
          attributes: {
            role: "slider",
            "aria-valuemin": 0,
            "aria-valuemax": 360,
            "aria-valuenow": 120
          }
        },
        rounded: !1,
        model: {
          mode: "y",
          getInitialValue: oe(0)
        },
        components: [
          a,
          l
        ],
        sliderBehaviours: nt([
          En.config({})
        ]),
        onChange: (d, g, h) => {
          ln(d.element, "aria-valuenow", Math.floor(360 - h * 3.6)), tn(d, pI, {
            value: h
          });
        }
      });
    }, yI = Ct("valid-input"), CI = Ct("invalid-input"), xI = Ct("validating-input"), E4 = "colorcustom.rgb.", qW = {
      isEnabled: St,
      setEnabled: U,
      immediatelyShow: U,
      immediatelyHide: U
    }, KW = (n, s, a, l, d, g) => {
      const h = (ne, ae) => {
        const Y = ae.get();
        ne !== Y.isEnabled() && (Y.setEnabled(ne), ne ? Y.immediatelyShow() : Y.immediatelyHide());
      }, C = (ne, ae, Y) => ru.config({
        invalidClass: s("invalid"),
        notify: {
          onValidate: (le) => {
            tn(le, xI, {
              type: ne
            });
          },
          onValid: (le) => {
            h(!1, Y), tn(le, yI, {
              type: ne,
              value: _t.getValue(le)
            });
          },
          onInvalid: (le) => {
            h(!0, Y), tn(le, CI, {
              type: ne,
              value: _t.getValue(le)
            });
          }
        },
        validator: {
          validate: (le) => {
            const pe = _t.getValue(le), Ee = ae(pe) ? Wt.value(!0) : Wt.error(n("aria.input.invalid"));
            return Zo.pure(Ee);
          },
          validateOnLoad: !1
        }
      }), x = (ne, ae, Y, le, pe) => {
        const Ee = Pt(qW), Oe = n(E4 + "range"), gt = Yn.parts.label({
          dom: { tag: "label" },
          components: [xs(Y)]
        }), Ue = Yn.parts.field({
          data: pe,
          factory: Ff,
          inputAttributes: {
            type: "text",
            "aria-label": le,
            ...ae === "hex" ? { "aria-live": "polite" } : {}
          },
          inputClasses: [s("textfield")],
          // Have basic invalidating and tabstopping behaviour.
          inputBehaviours: nt([
            C(ae, ne, Ee),
            is.config({}),
            ps.config({
              ...d({
                tooltipText: "",
                onSetup: (_n) => {
                  Ee.set({
                    isEnabled: () => ps.isEnabled(_n),
                    setEnabled: (Ut) => ps.setEnabled(_n, Ut),
                    immediatelyShow: () => ps.immediateOpenClose(_n, !0),
                    immediatelyHide: () => ps.immediateOpenClose(_n, !1)
                  }), ps.setEnabled(_n, !1);
                },
                onShow: (_n, Ut) => {
                  ps.setComponents(_n, [
                    {
                      dom: {
                        tag: "p",
                        classes: [
                          s("rgb-warning-note")
                        ]
                      },
                      components: [xs(n(ae === "hex" ? "colorcustom.rgb.invalidHex" : "colorcustom.rgb.invalid"))]
                    }
                  ]);
                }
              })
            })
          ]),
          // If it was invalid, and the value was set, run validation against it.
          onSetValue: (_n) => {
            ru.isInvalid(_n) && ru.run(_n).get(U);
          }
        }), Qe = Ct("aria-invalid"), Ke = To(g("invalid", A.some(Qe), "warning")), Qt = To({
          dom: {
            tag: "div",
            classes: [s("invalid-icon")]
          },
          components: [
            Ke.asSpec()
          ]
        }), zt = [gt, Ue, Qt.asSpec()], jn = ae !== "hex" ? [Yn.parts["aria-descriptor"]({
          text: Oe
        })] : [], Jt = zt.concat(jn);
        return {
          dom: {
            tag: "div",
            attributes: {
              role: "presentation"
            },
            classes: [
              s("rgb-container")
            ]
          },
          components: Jt
        };
      }, T = (ne, ae) => {
        const Y = qx(ae);
        return bp.getField(ne, "hex").each((le) => {
          En.isFocused(le) || _t.setValue(ne, {
            hex: Y.value
          });
        }), Y;
      }, _ = (ne, ae) => {
        const Y = ae.red, le = ae.green, pe = ae.blue;
        _t.setValue(ne, { red: Y, green: le, blue: pe });
      }, N = To({
        dom: {
          tag: "div",
          classes: [s("rgba-preview")],
          styles: {
            "background-color": "white"
          },
          attributes: {
            role: "presentation"
          }
        }
      }), L = (ne, ae) => {
        N.getOpt(ne).each((Y) => {
          gn(Y.element, "background-color", "#" + ae.value);
        });
      };
      return su({
        factory: () => {
          const ne = {
            red: Pt(A.some(255)),
            green: Pt(A.some(255)),
            blue: Pt(A.some(255)),
            hex: Pt(A.some("ffffff"))
          }, ae = (Ut, Ve) => {
            const ct = Yx(Ve);
            _(Ut, ct), Ee(ct);
          }, Y = (Ut) => ne[Ut].get(), le = (Ut, Ve) => {
            ne[Ut].set(Ve);
          }, pe = () => Y("red").bind((Ut) => Y("green").bind((Ve) => Y("blue").map((ct) => fa(Ut, Ve, ct, 1)))), Ee = (Ut) => {
            const Ve = Ut.red, ct = Ut.green, mn = Ut.blue;
            le("red", A.some(Ve)), le("green", A.some(ct)), le("blue", A.some(mn));
          }, Oe = (Ut, Ve) => {
            const ct = Ve.event;
            ct.type !== "hex" ? le(ct.type, A.none()) : l(Ut);
          }, gt = (Ut, Ve) => {
            a(Ut);
            const ct = a4(Ve);
            le("hex", A.some(ct.value));
            const mn = Yx(ct);
            _(Ut, mn), Ee(mn), tn(Ut, w4, {
              hex: ct
            }), L(Ut, ct);
          }, Ue = (Ut, Ve, ct) => {
            const mn = parseInt(ct, 10);
            le(Ve, A.some(mn)), pe().each((Pn) => {
              const qt = T(Ut, Pn);
              tn(Ut, w4, {
                hex: qt
              }), L(Ut, qt);
            });
          }, Qe = (Ut) => Ut.type === "hex", Ke = (Ut, Ve) => {
            const ct = Ve.event;
            Qe(ct) ? gt(Ut, ct.value) : Ue(Ut, ct.type, ct.value);
          }, Qt = (Ut) => ({
            label: n(E4 + Ut + ".label"),
            description: n(E4 + Ut + ".description")
          }), zt = Qt("red"), jn = Qt("green"), Jt = Qt("blue"), _n = Qt("hex");
          return Ho(bp.sketch((Ut) => ({
            dom: {
              tag: "form",
              classes: [s("rgb-form")],
              attributes: { "aria-label": n("aria.color.picker") }
            },
            components: [
              Ut.field("red", Yn.sketch(x(i4, "red", zt.label, zt.description, 255))),
              Ut.field("green", Yn.sketch(x(i4, "green", jn.label, jn.description, 255))),
              Ut.field("blue", Yn.sketch(x(i4, "blue", Jt.label, Jt.description, 255))),
              Ut.field("hex", Yn.sketch(x(l4, "hex", _n.label, _n.description, "ffffff"))),
              N.asSpec()
            ],
            formBehaviours: nt([
              ru.config({
                invalidClass: s("form-invalid")
              }),
              xn("rgb-form-events", [
                Ie(yI, Ke),
                Ie(CI, Oe),
                Ie(xI, Oe)
              ])
            ])
          })), {
            apis: {
              updateHex: (Ut, Ve) => {
                _t.setValue(Ut, {
                  hex: Ve.value
                }), ae(Ut, Ve), L(Ut, Ve);
              }
            }
          });
        },
        name: "RgbForm",
        configFields: [],
        apis: {
          updateHex: (ne, ae, Y) => {
            ne.updateHex(ae, Y);
          }
        },
        extraApis: {}
      });
    }, YW = (n, s) => {
      const a = Ud.parts.spectrum({
        dom: {
          tag: "canvas",
          attributes: {
            role: "presentation"
          },
          classes: [s("sv-palette-spectrum")]
        }
      }), l = Ud.parts.thumb({
        dom: {
          tag: "div",
          attributes: {
            role: "presentation"
          },
          classes: [s("sv-palette-thumb")],
          innerHtml: `<div class=${s("sv-palette-inner-thumb")} role="presentation"></div>`
        }
      }), d = (T, _) => {
        const { width: N, height: L } = T, j = T.getContext("2d");
        if (j === null)
          return;
        j.fillStyle = _, j.fillRect(0, 0, N, L);
        const Z = j.createLinearGradient(0, 0, N, 0);
        Z.addColorStop(0, "rgba(255,255,255,1)"), Z.addColorStop(1, "rgba(255,255,255,0)"), j.fillStyle = Z, j.fillRect(0, 0, N, L);
        const ne = j.createLinearGradient(0, 0, 0, L);
        ne.addColorStop(0, "rgba(0,0,0,0)"), ne.addColorStop(1, "rgba(0,0,0,1)"), j.fillStyle = ne, j.fillRect(0, 0, N, L);
      }, g = (T, _) => {
        const N = T.components()[0].element.dom, L = _p(_, 100, 100), j = k$(L);
        d(N, A$(j));
      }, h = (T, _) => {
        const N = ND(Yx(_));
        Ud.setValue(T, { x: N.saturation, y: 100 - N.value }), ln(T.element, "aria-valuetext", n(["Saturation {0}%, Brightness {1}%", N.saturation, N.value]));
      };
      return su({
        factory: (T) => {
          const _ = oe({
            x: 0,
            y: 0
          }), N = (Z, ne, ae) => {
            In(ae) || ln(Z.element, "aria-valuetext", n(["Saturation {0}%, Brightness {1}%", Math.floor(ae.x), Math.floor(100 - ae.y)])), tn(Z, bI, {
              value: ae
            });
          }, L = (Z, ne, ae, Y) => {
            d(ae.element.dom, A$(_$));
          }, j = nt([
            Fe.config({
              find: A.some
            }),
            En.config({})
          ]);
          return Ud.sketch({
            dom: {
              tag: "div",
              attributes: {
                role: "slider",
                "aria-valuetext": n(["Saturation {0}%, Brightness {1}%", 0, 0])
              },
              classes: [s("sv-palette")]
            },
            model: {
              mode: "xy",
              getInitialValue: _
            },
            rounded: !1,
            components: [
              a,
              l
            ],
            onChange: N,
            onInit: L,
            sliderBehaviours: j
          });
        },
        name: "SaturationBrightnessPalette",
        configFields: [],
        apis: {
          setHue: (T, _, N) => {
            g(_, N);
          },
          setThumb: (T, _, N) => {
            h(_, N);
          }
        },
        extraApis: {}
      });
    }, SI = (n, s, a, l) => {
      const d = (h) => {
        const C = KW(n, s, h.onValidHex, h.onInvalidHex, a, l), x = YW(n, s), T = (Qe) => (100 - Qe) / 100 * 360, _ = (Qe) => 100 - Qe / 360 * 100, N = {
          paletteRgba: Pt(_$),
          paletteHue: Pt(0)
        }, L = To(vI(n, s)), j = To(x.sketch({})), Z = To(C.sketch({})), ne = (Qe, Ke, Qt) => {
          j.getOpt(Qe).each((zt) => {
            x.setHue(zt, Qt);
          });
        }, ae = (Qe, Ke) => {
          Z.getOpt(Qe).each((Qt) => {
            C.updateHex(Qt, Ke);
          });
        }, Y = (Qe, Ke, Qt) => {
          L.getOpt(Qe).each((zt) => {
            Ud.setValue(zt, _(Qt));
          });
        }, le = (Qe, Ke) => {
          j.getOpt(Qe).each((Qt) => {
            x.setThumb(Qt, Ke);
          });
        }, pe = (Qe, Ke) => {
          const Qt = Yx(Qe);
          N.paletteRgba.set(Qt), N.paletteHue.set(Ke);
        }, Ee = (Qe, Ke, Qt, zt) => {
          pe(Ke, Qt), He(zt, (jn) => {
            jn(Qe, Ke, Qt);
          });
        }, Oe = () => {
          const Qe = [ae];
          return (Ke, Qt) => {
            const zt = Qt.event.value, jn = N.paletteHue.get(), Jt = _p(jn, zt.x, 100 - zt.y), _n = zm(Jt);
            Ee(Ke, _n, jn, Qe);
          };
        }, gt = () => {
          const Qe = [ne, ae];
          return (Ke, Qt) => {
            const zt = T(Qt.event.value), jn = N.paletteRgba.get(), Jt = ND(jn), _n = _p(zt, Jt.saturation, Jt.value), Ut = zm(_n);
            Ee(Ke, Ut, zt, Qe);
          };
        }, Ue = () => {
          const Qe = [ne, Y, le];
          return (Ke, Qt) => {
            const zt = Qt.event.hex, jn = O$(zt);
            Ee(Ke, zt, jn.hue, Qe);
          };
        };
        return {
          uid: h.uid,
          dom: h.dom,
          components: [
            j.asSpec(),
            L.asSpec(),
            Z.asSpec()
          ],
          behaviours: nt([
            xn("colour-picker-events", [
              Ie(w4, Ue()),
              Ie(bI, Oe()),
              Ie(pI, gt())
            ]),
            Fe.config({
              find: (Qe) => Z.getOpt(Qe)
            }),
            Xt.config({
              mode: "acyclic"
            })
          ])
        };
      };
      return su({
        name: "ColourPicker",
        configFields: [
          Ze("dom"),
          we("onValidHex", U),
          we("onInvalidHex", U)
        ],
        factory: d
      });
    }, wI = {
      "colorcustom.rgb.red.label": "R",
      "colorcustom.rgb.red.description": "Red channel",
      "colorcustom.rgb.green.label": "G",
      "colorcustom.rgb.green.description": "Green channel",
      "colorcustom.rgb.blue.label": "B",
      "colorcustom.rgb.blue.description": "Blue channel",
      "colorcustom.rgb.hex.label": "#",
      "colorcustom.rgb.hex.description": "Hex color code",
      "colorcustom.rgb.range": "Range 0 to 255",
      "colorcustom.rgb.invalid": "Numbers only, 0 to 255",
      "colorcustom.rgb.invalidHex": "Hexadecimal only, 000000 to FFFFFF",
      "aria.color.picker": "Color Picker",
      "aria.input.invalid": "Invalid input"
    }, EI = (n) => (s) => De(s) ? n.translate(wI[s]) : n.translate(s), T4 = (n, s, a) => {
      const l = (T) => "tox-" + T, d = (T, _, N = T, L = T) => iu(N, {
        tag: "div",
        classes: ["tox-icon", "tox-control-wrap__status-icon-" + T],
        attributes: {
          title: s.translate(L),
          "aria-live": "polite",
          ..._.fold(() => ({}), (j) => ({ id: j }))
        }
      }, s.icons), g = SI(EI(s), l, s.tooltips.getConfig, d), h = (T) => {
        tn(T, Zd, { name: "hex-valid", value: !0 });
      }, C = (T) => {
        tn(T, Zd, { name: "hex-valid", value: !1 });
      }, x = To(g.sketch({
        dom: {
          tag: "div",
          classes: [l("color-picker-container")],
          attributes: {
            role: "presentation"
          }
        },
        onValidHex: h,
        onInvalidHex: C
      }));
      return {
        dom: {
          tag: "div"
        },
        components: [
          x.asSpec()
        ],
        behaviours: nt([
          // We'll allow invalid values
          Fb(a, (T) => {
            const _ = x.get(T);
            return Fe.getCurrent(_).bind((j) => _t.getValue(j).hex).map((j) => "#" + em(j, "#")).getOr("");
          }, (T, _) => {
            const N = /^#([a-fA-F0-9]{3}(?:[a-fA-F0-9]{3})?)/, L = A.from(N.exec(_)).bind((ne) => Jc(ne, 1)), j = x.get(T);
            Fe.getCurrent(j).fold(() => {
              console.log("Can not find form");
            }, (ne) => {
              _t.setValue(ne, {
                hex: L.getOr("")
              }), bp.getField(ne, "hex").each((ae) => {
                Wn(ae, Nu());
              });
            });
          }),
          Gd.self()
        ])
      };
    };
    var TI = tinymce.util.Tools.resolve("tinymce.Resource");
    const kI = (n) => mo(n, "init"), XW = (n) => {
      const s = hn(), a = To({
        dom: {
          tag: n.tag
        }
      }), l = hn(), d = !kI(n) && n.onFocus.isSome() ? [
        En.config({
          onFocus: (g) => {
            n.onFocus.each((h) => {
              h(g.element.dom);
            });
          }
        }),
        is.config({})
      ] : [];
      return {
        dom: {
          tag: "div",
          classes: ["tox-custom-editor"]
        },
        behaviours: nt([
          xn("custom-editor-events", [
            hs((g) => {
              a.getOpt(g).each((h) => {
                (kI(n) ? n.init(h.element.dom) : TI.load(n.scriptId, n.scriptUrl).then((C) => C(h.element.dom, n.settings))).then((C) => {
                  l.on((x) => {
                    C.setValue(x);
                  }), l.clear(), s.set(C);
                });
              });
            })
          ]),
          Fb(A.none(), () => s.get().fold(() => l.get().getOr(""), (g) => g.getValue()), (g, h) => {
            s.get().fold(() => l.set(h), (C) => C.setValue(h));
          }),
          Gd.self()
        ].concat(d)),
        components: [a.asSpec()]
      };
    };
    var jf = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const iR = Ct("browse.files.event"), QW = (n, s, a) => {
      const l = jf.explode(s.getOption("images_file_types")), d = (g) => a.fold(() => cn(l, (h) => nl(g.name.toLowerCase(), `.${h.toLowerCase()}`)), (h) => cn(h, (C) => nl(g.name.toLowerCase(), `.${C.toLowerCase()}`)));
      return Ln(jm(n), d);
    }, JW = (n, s, a) => {
      const l = (L, j) => {
        j.stop();
      }, d = (L) => (j, Z) => {
        He(L, (ne) => {
          ne(j, Z);
        });
      }, g = (L, j) => {
        if (!Ft.isDisabled(L)) {
          const Z = j.event.raw;
          tn(L, iR, { files: Z.dataTransfer?.files });
        }
      }, h = (L, j) => {
        const Z = j.event.raw.target;
        tn(L, iR, { files: Z.files });
      }, C = (L, j) => {
        j && (_t.setValue(L, QW(j, s, n.allowedFileExtensions)), tn(L, Sl, { name: n.name }));
      }, x = To({
        dom: {
          tag: "input",
          attributes: {
            type: "file",
            accept: n.allowedFileTypes.getOr("image/*")
          },
          styles: {
            display: "none"
          }
        },
        behaviours: nt([
          xn("input-file-events", [
            Pg(Cg()),
            Pg(Fh())
          ])
        ])
      }), T = n.label.map((L) => sh(L, s)), _ = Yn.parts.field({
        factory: oa,
        dom: {
          tag: "button",
          styles: {
            position: "relative"
          },
          classes: ["tox-button", "tox-button--secondary"]
        },
        components: [
          xs(s.translate(n.buttonLabel.getOr("Browse for an image"))),
          x.asSpec()
        ],
        action: (L) => {
          x.get(L).element.dom.click();
        },
        buttonBehaviours: nt([
          Gd.self(),
          S4(a.getOr([])),
          is.config({}),
          Lm.button(() => s.checkUiComponentContext(n.context).shouldDisable),
          yr(() => s.checkUiComponentContext(n.context))
        ])
      }), N = {
        dom: {
          tag: "div",
          classes: ["tox-dropzone-container"]
        },
        behaviours: nt([
          Ft.config({
            disabled: () => s.checkUiComponentContext(n.context).shouldDisable
          }),
          yr(() => s.checkUiComponentContext(n.context)),
          eo.config({
            toggleClass: "dragenter",
            toggleOnExecute: !1
          }),
          xn("dropzone-events", [
            Ie("dragenter", d([l, eo.toggle])),
            Ie("dragleave", d([l, eo.toggle])),
            Ie("dragover", l),
            Ie("drop", d([l, g])),
            Ie(yg(), h)
          ])
        ]),
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-dropzone"],
              styles: {}
            },
            components: [
              {
                dom: {
                  tag: "p"
                },
                components: [
                  xs(s.translate(n.dropAreaLabel.getOr("Drop an image here")))
                ]
              },
              _
            ]
          }
        ]
      };
      return hy(T, N, ["tox-form__group--stretched"], [xn("handle-files", [
        Ie(iR, (L, j) => {
          Yn.getField(L).each((Z) => {
            C(Z, j.event.files);
          });
        })
      ])]);
    }, eZ = (n, s) => ({
      dom: {
        tag: "div",
        classes: ["tox-form__grid", `tox-form__grid--${n.columns}col`]
      },
      components: ye(n.items, s.interpreter)
    }), k4 = Ct("alloy-fake-before-tabstop"), uR = Ct("alloy-fake-after-tabstop"), AI = (n) => ({
      dom: {
        tag: "div",
        styles: {
          width: "1px",
          height: "1px",
          outline: "none"
        },
        attributes: {
          tabindex: "0"
          // Capture native tabbing in the appropriate order
        },
        classes: n
      },
      behaviours: nt([
        En.config({ ignore: !0 }),
        is.config({})
      ])
    }), _I = (n, s) => ({
      dom: {
        tag: "div",
        classes: ["tox-navobj", ...n.getOr([])]
      },
      components: [
        AI([k4]),
        s,
        AI([uR])
      ],
      behaviours: nt([
        Gd.childAt(1)
      ])
    }), dR = (n, s) => {
      tn(n, na(), {
        raw: {
          which: 9,
          shiftKey: s
        }
      });
    }, OI = (n, s) => {
      const a = s.element;
      ar(a, k4) ? dR(n, !0) : ar(a, uR) && dR(n, !1);
    }, tS = (n) => dg(n, ["." + k4, "." + uR].join(","), an), A4 = Ct("update-dialog"), mR = Ct("update-title"), DI = Ct("update-body"), RI = Ct("update-footer"), yn = Ct("body-send-message"), Rp = Ct("dialog-focus-shifted"), _4 = Zs().browser, py = _4.isSafari(), NI = _4.isFirefox(), fR = py || NI, tZ = _4.isChromium(), MI = ({ scrollTop: n, scrollHeight: s, clientHeight: a }) => Math.ceil(n) + a >= s, PI = (n, s) => (
      // TINY-10128: The iframe body is occasionally null when we attempt to scroll, so instead of using body.scrollHeight, use a
      // fallback value of 99999999. To minimise the potential impact of future browser changes, this fallback is significantly smaller
      // than the minimum of the maximum value Window.scrollTo would take on supported browsers:
      // Chromium: > Number.MAX_SAFE_INTEGER
      // Safari: 2^31 - 1 = 2147483647
      // Firefox: 2147483583
      n.scrollTo(0, s === "bottom" ? 99999999 : s)
    ), nZ = (n, s) => {
      const a = n.body;
      return A.from(!/^<!DOCTYPE (html|HTML)/.test(s) && (!tZ && !py || un(a) && (a.scrollTop !== 0 || Math.abs(a.scrollHeight - a.clientHeight) > 1)) ? a : n.documentElement);
    }, BI = (n, s, a) => {
      const l = n.dom;
      A.from(l.contentDocument).fold(a, (d) => {
        let g = 0;
        const h = nZ(d, s).map((x) => (g = x.scrollTop, x)).forall(MI), C = () => {
          const x = l.contentWindow;
          un(x) && (h ? PI(x, "bottom") : !h && fR && g !== 0 && PI(x, g));
        };
        py && l.addEventListener("load", C, { once: !0 }), d.open(), d.write(s), d.close(), py || C();
      });
    }, $I = Br(fR, py ? 500 : 200).map((n) => $s(BI, n)), vX = (n, s) => {
      const a = Pt(n.getOr(""));
      return {
        getValue: (l) => (
          // Ideally we should fetch data from the iframe...innerHtml, this triggers Cors errors
          a.get()
        ),
        setValue: (l, d) => {
          if (a.get() !== d) {
            const g = l.element, h = () => ln(g, "srcdoc", d);
            s ? $I.fold(oe(BI), (C) => C.throttle)(g, d, h) : h();
          }
          a.set(d);
        }
      };
    }, nS = (n, s, a) => {
      const l = "tox-dialog__iframe", d = n.transparent ? [] : [`${l}--opaque`], g = n.border ? ["tox-navobj-bordered"] : [], h = {
        ...n.label.map((N) => ({ title: N })).getOr({}),
        ...a.map((N) => ({ srcdoc: N })).getOr({}),
        ...n.sandboxed ? { sandbox: "allow-scripts allow-same-origin" } : {}
      }, C = vX(a, n.streamContent), x = n.label.map((N) => sh(N, s)), T = (N) => _I(A.from(g), {
        // We need to use the part uid or the label and field won't be linked with ARIA
        uid: N.uid,
        dom: {
          tag: "iframe",
          attributes: h,
          classes: [
            l,
            ...d
          ]
        },
        behaviours: nt([
          is.config({}),
          En.config({}),
          Fb(a, C.getValue, C.setValue),
          Dc.config({
            channels: {
              [Rp]: {
                onReceive: (L, j) => {
                  j.newFocus.each((Z) => {
                    Li(L.element).each((ne) => {
                      (I(L.element, Z) ? Uo : Ds)(ne, "tox-navobj-bordered-focus");
                    });
                  });
                }
              }
            }
          })
        ])
      }), _ = Yn.parts.field({
        factory: { sketch: T }
      });
      return hy(x, _, ["tox-form__group--stretched"], []);
    }, gR = (n, s, a, l, d) => {
      const g = a * d, h = l * d, C = Math.max(0, n / 2 - g / 2), x = Math.max(0, s / 2 - h / 2);
      return {
        left: C.toString() + "px",
        top: x.toString() + "px",
        width: g.toString() + "px",
        height: h.toString() + "px"
      };
    }, II = (n, s, a) => {
      const l = la(n), d = hr(n);
      return Math.min(l / s, d / a, 1);
    }, sZ = (n, s) => {
      const a = Pt(s.getOr({ url: "" })), l = To({
        dom: {
          tag: "img",
          classes: ["tox-imagepreview__image"],
          attributes: s.map((x) => ({ src: x.url })).getOr({})
        }
      }), d = To({
        dom: {
          tag: "div",
          classes: ["tox-imagepreview__container"],
          attributes: {
            role: "presentation"
          }
        },
        components: [
          l.asSpec()
        ]
      }), g = (x, T) => {
        const _ = {
          url: T.url
        };
        T.zoom.each((L) => _.zoom = L), T.cachedWidth.each((L) => _.cachedWidth = L), T.cachedHeight.each((L) => _.cachedHeight = L), a.set(_);
        const N = () => {
          const { cachedWidth: L, cachedHeight: j, zoom: Z } = _;
          if (!Cn(L) && !Cn(j)) {
            if (Cn(Z)) {
              const ae = II(x.element, L, j);
              _.zoom = ae;
            }
            const ne = gR(la(x.element), hr(x.element), L, j, _.zoom);
            d.getOpt(x).each((ae) => {
              Ss(ae.element, ne);
            });
          }
        };
        l.getOpt(x).each((L) => {
          const j = L.element;
          T.url !== Dr(j, "src") && (ln(j, "src", T.url), Ds(x.element, "tox-imagepreview__loaded")), N(), cl(j).then((Z) => {
            x.getSystem().isConnected() && (Uo(x.element, "tox-imagepreview__loaded"), _.cachedWidth = Z.dom.naturalWidth, _.cachedHeight = Z.dom.naturalHeight, N());
          });
        });
      }, h = {};
      n.height.each((x) => h.height = x);
      const C = s.map((x) => ({
        url: x.url,
        zoom: A.from(x.zoom),
        cachedWidth: A.from(x.cachedWidth),
        cachedHeight: A.from(x.cachedHeight)
      }));
      return {
        dom: {
          tag: "div",
          classes: ["tox-imagepreview"],
          styles: h,
          attributes: {
            role: "presentation"
          }
        },
        components: [
          d.asSpec()
        ],
        behaviours: nt([
          Gd.self(),
          Fb(C, () => (
            /*
                        NOTE: This is intentionally returning the cached image width and height.
            
                        Including those details in the dialog data helps when `setData` only changes the URL, as
                        the old image must continue to be displayed at the old size until the new image has loaded.
                      */
            a.get()
          ), g)
        ])
      };
    }, rZ = (n, s, a) => {
      const l = "tox-label", d = n.align === "center" ? [`${l}--center`] : [], g = n.align === "end" ? [`${l}--end`] : [], h = To({
        dom: {
          tag: "label",
          classes: [l, ...d, ...g]
        },
        components: [
          xs(s.providers.translate(n.label))
        ]
      }), C = ye(n.items, s.interpreter);
      return {
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: [
          h.asSpec(),
          ...C
        ],
        behaviours: nt([
          Gd.self(),
          An.config({}),
          GW(A.none()),
          Xt.config({
            mode: "acyclic"
          }),
          xn("label", [
            hs((x) => {
              n.for.each((T) => {
                a(T).each((_) => {
                  h.getOpt(x).each((N) => {
                    const L = Dr(_.element, "id") ?? Ct("form-field");
                    ln(_.element, "id", L), ln(N.element, "for", L);
                  });
                });
              });
            })
          ])
        ])
      };
    }, hR = Ct("toolbar.button.execute"), aZ = (n) => Ef((s, a) => {
      Zx(n, s)((l) => {
        tn(s, hR, {
          buttonApi: l
        }), n.onAction(l);
      });
    }), Wf = Ct("common-button-display-events"), pR = {
      // TODO: use the constants provided by behaviours.
      [wa()]: ["disabling", "alloy.base.behaviour", "toggling", "toolbar-button-events", "tooltipping"],
      [Mu()]: [
        "toolbar-button-events",
        Wf
      ],
      [Ci()]: ["toolbar-button-events", "dropdown-events", "tooltipping"],
      [Zc()]: [
        "focusing",
        "alloy.base.behaviour",
        Wf
      ]
    }, O4 = (n) => gn(n.element, "width", gs(n.element, "width")), FI = (n, s, a) => iu(n, {
      tag: "span",
      classes: [
        "tox-icon",
        "tox-tbtn__icon-wrap"
        /* ToolbarButtonClasses.IconWrap */
      ],
      behaviours: a
    }, s), bR = (n, s) => FI(n, s, []), Np = (n, s) => FI(n, s, [An.config({})]), vR = (n, s, a) => ({
      dom: {
        tag: "span",
        classes: [`${s}__select-label`]
      },
      components: [
        xs(a.translate(n))
      ],
      behaviours: nt([
        An.config({})
      ])
    }), Ju = Ct("update-menu-text"), Lb = Ct("update-menu-icon"), D4 = Ct("update-tooltip-text"), yR = (n, s, a, l) => {
      const d = Pt(U), g = Pt(n.tooltip), h = n.text.map((ae) => To(vR(ae, s, a.providers))), C = n.icon.map((ae) => To(Np(ae, a.providers.icons))), x = (ae, Y) => {
        const le = _t.getValue(ae);
        return En.focus(le), tn(le, "keydown", {
          raw: Y.event.raw
        }), Kl.close(le), A.some(!0);
      }, T = n.role.fold(() => ({}), (ae) => ({ role: ae })), _ = A.from(n.listRole).map((ae) => ({ listRole: ae })).getOr({}), N = n.ariaLabel.fold(() => ({}), (ae) => ({
        "aria-label": a.providers.translate(ae)
      })), L = iu("chevron-down", {
        tag: "div",
        classes: [`${s}__select-chevron`]
      }, a.providers.icons), j = Ct("common-button-display-events"), Z = "dropdown-events";
      return To(Kl.sketch({
        ...n.uid ? { uid: n.uid } : {},
        ...T,
        ..._,
        dom: {
          tag: "button",
          classes: [s, `${s}--select`].concat(ye(n.classes, (ae) => `${s}--${ae}`)),
          attributes: {
            ...N,
            ...un(l) ? { "data-mce-name": l } : {}
          }
        },
        components: zf([
          C.map((ae) => ae.asSpec()),
          h.map((ae) => ae.asSpec()),
          A.some(L)
        ]),
        matchWidth: !0,
        useMinWidth: !0,
        // When the dropdown opens, if we are in search mode, then we want to
        // focus our searcher.
        onOpen: (ae, Y, le) => {
          n.searchable && $W(le);
        },
        dropdownBehaviours: nt([
          ...n.dropdownBehaviours,
          Lm.button(() => n.disabled || a.providers.checkUiComponentContext(n.context).shouldDisable),
          yr(() => a.providers.checkUiComponentContext(n.context)),
          // INVESTIGATE (TINY-9012): There was a old comment here about something not quite working, and that
          // we can still get the button focused. It was probably related to Unselecting.
          Om.config({}),
          An.config({}),
          ...n.tooltip.map((ae) => ps.config(a.providers.tooltips.getConfig({
            tooltipText: a.providers.translate(ae),
            onShow: (Y) => {
              if ($a(g.get(), n.tooltip, (le, pe) => pe !== le).getOr(!1)) {
                const le = a.providers.translate(g.get().getOr(""));
                ps.setComponents(Y, a.providers.tooltips.getComponents({ tooltipText: le }));
              }
            }
          }))).toArray(),
          // This is the generic way to make onSetup and onDestroy call as the component is attached /
          // detached from the page/DOM.
          xn(Z, [
            Hm(n, d),
            Ap(n, d)
          ]),
          xn(j, [
            hs((ae, Y) => {
              n.listRole !== "listbox" && O4(ae);
            })
          ]),
          xn("update-dropdown-width-variable", [
            Ie(Lh(), (ae, Y) => Kl.close(ae))
          ]),
          xn("menubutton-update-display-text", [
            // These handlers are just using Replacing to replace either the menu
            // text or the icon.
            Ie(Ju, (ae, Y) => {
              h.bind((le) => le.getOpt(ae)).each((le) => {
                An.set(le, [xs(a.providers.translate(Y.event.text))]);
              });
            }),
            Ie(Lb, (ae, Y) => {
              C.bind((le) => le.getOpt(ae)).each((le) => {
                An.set(le, [
                  Np(Y.event.icon, a.providers.icons)
                ]);
              });
            }),
            Ie(D4, (ae, Y) => {
              const le = a.providers.translate(Y.event.text);
              ln(ae.element, "aria-label", le), g.set(A.some(Y.event.text));
            })
          ])
        ]),
        eventOrder: Ho(pR, {
          // INVESTIGATE (TINY-9014): Explain why we need the events in this order.
          // Ideally, have a test that fails when they are in a different order if order
          // is important
          [Zc()]: ["focusing", "alloy.base.behaviour", "item-type-events", "normal-dropdown-events"],
          [Mu()]: [
            "toolbar-button-events",
            ps.name(),
            Z,
            j
          ]
        }),
        sandboxBehaviours: nt([
          Xt.config({
            mode: "special",
            onLeft: x,
            onRight: x
          }),
          xn("dropdown-sandbox-events", [
            Ie(S6, (ae, Y) => {
              NW(ae), Y.stop();
            }),
            Ie(w6, (ae, Y) => {
              MW(ae, Y), Y.stop();
            })
          ])
        ]),
        lazySink: a.getSink,
        toggleClass: `${s}--active`,
        parts: {
          menu: {
            ...$x(!1, n.columns, n.presets),
            // When the menu is "searchable", use fakeFocus so that keyboard
            // focus stays in the search field
            fakeFocus: n.searchable,
            // We don't want to update the  `aria-selected` on highlight or dehighlight for the `listbox` role because that is used to indicate the selected item
            ...n.listRole === "listbox" ? {} : {
              onHighlightItem: oI,
              onCollapseMenu: (ae, Y, le) => {
                So.getHighlighted(le).each((pe) => {
                  oI(ae, le, pe);
                });
              },
              onDehighlightItem: BW
            }
          }
        },
        getAnchorOverrides: () => ({
          maxHeightFunction: (ae, Y) => {
            Z2()(ae, Y - 10);
          }
        }),
        fetch: (ae) => Zo.nu(jt(n.fetch, ae))
      })).asSpec();
    }, R4 = (n) => De(n), LI = (n) => n.type === "separator", HI = (n) => mo(n, "getSubmenuItems"), cZ = {
      type: "separator"
    }, lZ = (n, s) => {
      const a = ao(n, (l, d) => R4(d) ? d === "" ? l : d === "|" ? l.length > 0 && !LI(l[l.length - 1]) ? l.concat([cZ]) : l : mo(s, d.toLowerCase()) ? l.concat([s[d.toLowerCase()]]) : l : l.concat([d]), []);
      return a.length > 0 && LI(a[a.length - 1]) && a.pop(), a;
    }, yX = (n, s) => {
      const a = n.getSubmenuItems(), l = zI(a, s), d = Ho(l.menus, { [n.value]: l.items }), g = Ho(l.expansions, { [n.value]: n.value });
      return {
        item: n,
        menus: d,
        expansions: g
      };
    }, iZ = (n) => {
      const s = Vt(n, "value").getOrThunk(() => Ct("generated-menu-item"));
      return Ho({ value: s }, n);
    }, zI = (n, s) => {
      const a = lZ(De(n) ? n.split(" ") : n, s);
      return oo(a, (l, d) => {
        if (HI(d)) {
          const g = iZ(d), h = yX(g, s);
          return {
            // Combine all of our current submenus and items with the new submenus created by
            // this item with nested subitems
            menus: Ho(l.menus, h.menus),
            // Add our parent item into the list of items in the *current menu*.
            items: [h.item, ...l.items],
            // Merge together our "this item opens this submenu" objects
            expansions: Ho(l.expansions, h.expansions)
          };
        } else
          return {
            ...l,
            items: [d, ...l.items]
          };
      }, {
        menus: {},
        expansions: {},
        items: []
      });
    }, CR = (n) => n.search.fold(() => ({ searchMode: "no-search" }), (s) => ({
      searchMode: "search-with-field",
      placeholder: s.placeholder
    })), uZ = (n) => n.search.fold(() => ({ searchMode: "no-search" }), (s) => ({ searchMode: "search-with-results" })), ah = (n, s, a, l) => {
      const d = Ct("primary-menu"), g = zI(n, a.shared.providers.menuItems());
      if (g.items.length === 0)
        return A.none();
      const h = CR(l), C = y4(d, g.items, s, a, l.isHorizontalMenu, h), x = uZ(l), T = Bs(g.menus, (N, L) => y4(
        L,
        N,
        s,
        a,
        // Currently, submenus cannot be horizontal menus (so always false)
        !1,
        x
      )), _ = Ho(T, ff(d, C));
      return A.from(hb.tieredData(d, _, g.expansions));
    }, oS = (n) => !mo(n, "items"), xR = "data-value", N4 = (n, s, a, l, d) => ye(a, (g) => oS(g) ? {
      type: "togglemenuitem",
      ...d ? {} : { role: "option" },
      text: g.text,
      value: g.value,
      active: g.value === l,
      onAction: () => {
        _t.setValue(n, g.value), tn(n, Sl, { name: s }), En.focus(n);
      }
    } : {
      type: "nestedmenuitem",
      text: g.text,
      getSubmenuItems: () => N4(n, s, g.items, l, d)
    }), SR = (n, s) => ga(n, (a) => oS(a) ? Br(a.value === s, a) : SR(a.items, s)), VI = (n, s, a) => {
      const l = cn(n.items, (T) => !oS(T)), d = s.shared.providers, g = a.bind((T) => SR(n.items, T)).orThunk(() => _o(n.items).filter(oS)), h = n.label.map((T) => sh(T, d)), C = Yn.parts.field({
        dom: {},
        factory: {
          sketch: (T) => yR({
            context: n.context,
            uid: T.uid,
            text: g.map((_) => _.text),
            icon: A.none(),
            tooltip: A.none(),
            role: Br(!l, "combobox"),
            ...l ? {} : { listRole: "listbox" },
            ariaLabel: n.label,
            fetch: (_, N) => {
              const L = N4(_, n.name, n.items, _t.getValue(_), l);
              N(ah(L, Wd.CLOSE_ON_EXECUTE, s, {
                isHorizontalMenu: !1,
                search: A.none()
              }));
            },
            onSetup: oe(U),
            getApi: oe({}),
            columns: 1,
            presets: "normal",
            classes: [],
            dropdownBehaviours: [
              is.config({}),
              Fb(g.map((_) => _.value), (_) => Dr(_.element, xR), (_, N) => {
                SR(n.items, N).each((L) => {
                  ln(_.element, xR, L.value), tn(_, Ju, { text: L.text });
                });
              })
            ]
          }, "tox-listbox", s.shared)
        }
      }), x = {
        dom: {
          tag: "div",
          classes: ["tox-listboxfield"]
        },
        components: [C]
      };
      return Yn.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: en([h.toArray(), [x]]),
        fieldBehaviours: nt([
          Ft.config({
            disabled: () => !n.enabled || d.checkUiComponentContext(n.context).shouldDisable,
            onDisabled: (T) => {
              Yn.getField(T).each(Ft.disable);
            },
            onEnabled: (T) => {
              Yn.getField(T).each(Ft.enable);
            }
          })
        ])
      });
    }, by = (n, s) => ({
      dom: {
        tag: "div",
        classes: n.classes
      },
      // All of the items passed through the form need to be put through the interpreter
      // with their form part preserved.
      components: ye(n.items, s.shared.interpreter)
    }), UI = (n, s, a) => {
      const l = ye(n.items, (x) => ({
        text: s.translate(x.text),
        value: x.value
      })), d = n.label.map((x) => sh(x, s)), g = Yn.parts.field({
        // TODO: Alloy should not allow dom changing of an HTML select!
        dom: {},
        ...a.map((x) => ({ data: x })).getOr({}),
        selectAttributes: {
          size: n.size
        },
        options: l,
        factory: T_,
        selectBehaviours: nt([
          Ft.config({
            disabled: () => !n.enabled || s.checkUiComponentContext(n.context).shouldDisable
          }),
          is.config({}),
          xn("selectbox-change", [
            Ie(yg(), (x, T) => {
              tn(x, Sl, { name: n.name });
            })
          ])
        ])
      }), h = n.size > 1 ? A.none() : A.some(iu("chevron-down", { tag: "div", classes: ["tox-selectfield__icon-js"] }, s.icons)), C = {
        dom: {
          tag: "div",
          classes: ["tox-selectfield"]
        },
        components: en([[g], h.toArray()])
      };
      return Yn.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: en([d.toArray(), [C]]),
        fieldBehaviours: nt([
          Ft.config({
            disabled: () => !n.enabled || s.checkUiComponentContext(n.context).shouldDisable,
            onDisabled: (x) => {
              Yn.getField(x).each(Ft.disable);
            },
            onEnabled: (x) => {
              Yn.getField(x).each(Ft.enable);
            }
          }),
          yr(() => s.checkUiComponentContext(n.context))
        ])
      });
    }, jI = (n) => {
      const s = {
        "": 0,
        px: 0,
        pt: 1,
        mm: 1,
        pc: 2,
        ex: 2,
        em: 2,
        ch: 2,
        rem: 2,
        cm: 3,
        in: 4,
        "%": 4
      }, a = (d) => d in s ? s[d] : 1;
      let l = n.value.toFixed(a(n.unit));
      return l.indexOf(".") !== -1 && (l = l.replace(/\.?0*$/, "")), l + n.unit;
    }, M4 = (n) => {
      const a = /^\s*(\d+(?:\.\d+)?)\s*(|cm|mm|in|px|pt|pc|em|ex|ch|rem|vw|vh|vmin|vmax|%)\s*$/.exec(n);
      if (a !== null) {
        const l = parseFloat(a[1]), d = a[2];
        return Wt.value({ value: l, unit: d });
      } else
        return Wt.error(n);
    }, WI = (n, s) => {
      const a = {
        "": 96,
        px: 96,
        pt: 72,
        cm: 2.54,
        pc: 12,
        mm: 25.4,
        in: 1
      }, l = (d) => mo(a, d);
      return n.unit === s ? A.some(n.value) : l(n.unit) && l(s) ? a[n.unit] === a[s] ? A.some(n.value) : A.some(n.value / a[n.unit] * a[s]) : A.none();
    }, vy = (n) => A.none(), dZ = (n, s) => (a) => WI(a, s).map((l) => ({ value: l * n, unit: s })), ZI = (n, s) => {
      const a = M4(n).toOptional(), l = M4(s).toOptional();
      return $a(a, l, (d, g) => WI(d, g.unit).map((h) => g.value / h).map((h) => dZ(h, g.unit)).getOr(vy)).getOr(vy);
    }, GI = (n, s) => {
      let a = vy;
      const l = Ct("ratio-event"), d = (ne) => iu(ne, { tag: "span", classes: ["tox-icon", "tox-lock-icon__" + ne] }, s.icons), g = () => !n.enabled || s.checkUiComponentContext(n.context).shouldDisable, h = yr(() => s.checkUiComponentContext(n.context)), C = n.label.getOr("Constrain proportions"), x = s.translate(C), T = vr.parts.lock({
        dom: {
          tag: "button",
          classes: ["tox-lock", "tox-button", "tox-button--naked", "tox-button--icon"],
          attributes: {
            "aria-label": x,
            "data-mce-name": C
          }
        },
        components: [
          d("lock"),
          d("unlock")
        ],
        buttonBehaviours: nt([
          Ft.config({ disabled: g }),
          h,
          is.config({}),
          ps.config(s.tooltips.getConfig({
            tooltipText: x
          }))
        ])
      }), _ = (ne) => ({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: ne
      }), N = (ne) => Yn.parts.field({
        factory: Ff,
        inputClasses: ["tox-textfield"],
        inputBehaviours: nt([
          Ft.config({ disabled: g }),
          h,
          is.config({}),
          xn("size-input-events", [
            Ie(Ki(), (ae, Y) => {
              tn(ae, l, { isField1: ne });
            }),
            Ie(yg(), (ae, Y) => {
              tn(ae, Sl, { name: n.name });
            })
          ])
        ]),
        selectOnFocus: !1
      }), L = (ne) => ({
        dom: {
          tag: "label",
          classes: ["tox-label"]
        },
        components: [
          xs(s.translate(ne))
        ]
      }), j = vr.parts.field1(_([Yn.parts.label(L("Width")), N(!0)])), Z = vr.parts.field2(_([Yn.parts.label(L("Height")), N(!1)]));
      return vr.sketch({
        dom: {
          tag: "div",
          classes: ["tox-form__group"]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-form__controls-h-stack"]
            },
            components: [
              // NOTE: Form coupled inputs to the FormField.sketch themselves.
              j,
              Z,
              _([
                L(tg),
                T
              ])
            ]
          }
        ],
        field1Name: "width",
        field2Name: "height",
        locked: !0,
        markers: {
          lockClass: "tox-locked"
        },
        onLockedChange: (ne, ae, Y) => {
          M4(_t.getValue(ne)).each((le) => {
            a(le).each((pe) => {
              _t.setValue(ae, jI(pe));
            });
          });
        },
        coupledFieldBehaviours: nt([
          Ft.config({
            disabled: g,
            onDisabled: (ne) => {
              vr.getField1(ne).bind(Yn.getField).each(Ft.disable), vr.getField2(ne).bind(Yn.getField).each(Ft.disable), vr.getLock(ne).each(Ft.disable);
            },
            onEnabled: (ne) => {
              vr.getField1(ne).bind(Yn.getField).each(Ft.enable), vr.getField2(ne).bind(Yn.getField).each(Ft.enable), vr.getLock(ne).each(Ft.enable);
            }
          }),
          yr(() => s.checkUiComponentContext("mode:design")),
          xn("size-input-events2", [
            Ie(l, (ne, ae) => {
              const Y = ae.event.isField1, le = Y ? vr.getField1(ne) : vr.getField2(ne), pe = Y ? vr.getField2(ne) : vr.getField1(ne), Ee = le.map(_t.getValue).getOr(""), Oe = pe.map(_t.getValue).getOr("");
              a = ZI(Ee, Oe);
            })
          ])
        ])
      });
    }, mZ = (n, s, a) => {
      const l = Ud.parts.label({
        dom: {
          tag: "label",
          classes: ["tox-label"]
        },
        components: [
          xs(s.translate(n.label))
        ]
      }), d = Ud.parts.spectrum({
        dom: {
          tag: "div",
          classes: ["tox-slider__rail"],
          attributes: {
            role: "presentation"
          }
        }
      }), g = Ud.parts.thumb({
        dom: {
          tag: "div",
          classes: ["tox-slider__handle"],
          attributes: {
            role: "presentation"
          }
        }
      });
      return Ud.sketch({
        dom: {
          tag: "div",
          classes: ["tox-slider"],
          attributes: {
            role: "presentation"
          }
        },
        model: {
          mode: "x",
          minX: n.min,
          maxX: n.max,
          getInitialValue: oe(a.getOrThunk(() => (Math.abs(n.max) - Math.abs(n.min)) / 2))
        },
        components: [
          l,
          d,
          g
        ],
        sliderBehaviours: nt([
          Gd.self(),
          En.config({})
        ]),
        onChoose: (h, C, x) => {
          tn(h, Sl, { name: n.name, value: x });
        },
        onChange: (h, C, x) => {
          tn(h, Sl, { name: n.name, value: x });
        }
      });
    }, fZ = (n, s) => {
      const a = (C) => ({
        dom: {
          tag: "th",
          innerHtml: s.translate(C)
        }
      }), l = (C) => ({
        dom: {
          tag: "thead"
        },
        components: [
          {
            dom: {
              tag: "tr"
            },
            components: ye(C, a)
          }
        ]
      }), d = (C) => ({ dom: { tag: "td", innerHtml: s.translate(C) } }), g = (C) => ({ dom: { tag: "tr" }, components: ye(C, d) }), h = (C) => ({ dom: { tag: "tbody" }, components: ye(C, g) });
      return {
        dom: {
          tag: "table",
          classes: ["tox-dialog__table"]
        },
        components: [
          l(n.header),
          h(n.cells)
        ],
        behaviours: nt([
          is.config({}),
          En.config({})
        ])
      };
    }, qI = (n, s) => {
      const a = n.label.map((Z) => sh(Z, s)), l = [
        Ft.config({
          disabled: () => n.disabled || s.checkUiComponentContext(n.context).shouldDisable
        }),
        yr(() => s.checkUiComponentContext(n.context)),
        Xt.config({
          mode: "execution",
          useEnter: n.multiline !== !0,
          useControlEnter: n.multiline === !0,
          execute: (Z) => (Wn(Z, eS), A.some(!0))
        }),
        xn("textfield-change", [
          Ie(Nu(), (Z, ne) => {
            tn(Z, Sl, { name: n.name });
          }),
          Ie(y0(), (Z, ne) => {
            tn(Z, Sl, { name: n.name });
          })
        ]),
        is.config({})
      ], d = n.validation.map((Z) => ru.config({
        getRoot: (ne) => Li(ne.element),
        invalidClass: "tox-invalid",
        validator: {
          validate: (ne) => {
            const ae = _t.getValue(ne), Y = Z.validator(ae);
            return Zo.pure(Y === !0 ? Wt.value(ae) : Wt.error(Y));
          },
          validateOnLoad: Z.validateOnLoad
        }
      })).toArray(), g = n.placeholder.fold(oe({}), (Z) => ({ placeholder: s.translate(Z) })), h = n.inputMode.fold(oe({}), (Z) => ({ inputmode: Z })), x = {
        ...n.spellcheck.fold(oe({}), (Z) => ({ spellcheck: Z })),
        ...g,
        ...h,
        "data-mce-name": n.name
      }, T = Yn.parts.field({
        tag: n.multiline === !0 ? "textarea" : "input",
        ...n.data.map((Z) => ({ data: Z })).getOr({}),
        inputAttributes: x,
        inputClasses: [n.classname],
        inputBehaviours: nt(en([
          l,
          d
        ])),
        selectOnFocus: !1,
        factory: Ff
      }), _ = n.multiline ? {
        dom: {
          tag: "div",
          classes: ["tox-textarea-wrap"]
        },
        components: [T]
      } : T, L = (n.flex ? ["tox-form__group--stretched"] : []).concat(n.maximized ? ["tox-form-group--maximize"] : []), j = [
        Ft.config({
          disabled: () => n.disabled || s.checkUiComponentContext(n.context).shouldDisable,
          onDisabled: (Z) => {
            Yn.getField(Z).each(Ft.disable);
          },
          onEnabled: (Z) => {
            Yn.getField(Z).each(Ft.enable);
          }
        }),
        yr(() => s.checkUiComponentContext(n.context))
      ];
      return hy(a, _, L, j);
    }, KI = (n, s, a) => qI({
      name: n.name,
      multiline: !1,
      label: n.label,
      inputMode: n.inputMode,
      placeholder: n.placeholder,
      flex: !1,
      disabled: !n.enabled,
      classname: "tox-textfield",
      validation: A.none(),
      maximized: n.maximized,
      data: a,
      context: n.context,
      spellcheck: A.none()
    }, s), gZ = (n, s, a) => qI({
      name: n.name,
      multiline: !0,
      label: n.label,
      inputMode: A.none(),
      // type attribute is not valid for textareas
      placeholder: n.placeholder,
      flex: !0,
      disabled: !n.enabled,
      classname: "tox-textarea",
      validation: A.none(),
      maximized: n.maximized,
      data: a,
      context: n.context,
      spellcheck: n.spellcheck
    }, s), YI = (n) => ({
      isEnabled: () => !Ft.isDisabled(n),
      setEnabled: (s) => Ft.set(n, !s),
      setActive: (s) => {
        const a = n.element;
        s ? (Uo(
          a,
          "tox-tbtn--enabled"
          /* ToolbarButtonClasses.Ticked */
        ), ln(a, "aria-pressed", !0)) : (Ds(
          a,
          "tox-tbtn--enabled"
          /* ToolbarButtonClasses.Ticked */
        ), fs(a, "aria-pressed"));
      },
      isActive: () => ar(
        n.element,
        "tox-tbtn--enabled"
        /* ToolbarButtonClasses.Ticked */
      ),
      setTooltip: (s) => {
        tn(n, D4, {
          text: s
        });
      },
      setText: (s) => {
        tn(n, Ju, {
          text: s
        });
      },
      setIcon: (s) => tn(n, Lb, {
        icon: s
      })
    }), sS = (n, s, a, l, d = !0, g) => {
      const h = n.buttonType === "bordered" ? ["bordered"] : [];
      return yR({
        text: n.text,
        icon: n.icon,
        tooltip: n.tooltip,
        ariaLabel: n.tooltip,
        searchable: n.search.isSome(),
        // https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-2/menubar-2.html
        role: l,
        fetch: (C, x) => {
          const T = {
            pattern: n.search.isSome() ? Jx(C) : ""
          };
          n.fetch((_) => {
            x(ah(_, Wd.CLOSE_ON_EXECUTE, a, {
              isHorizontalMenu: !1,
              // MenuButtons are the only dropdowns that support searchable (2022-08-16)
              search: n.search
            }));
          }, T, YI(C));
        },
        onSetup: n.onSetup,
        getApi: (C) => YI(C),
        columns: 1,
        presets: "normal",
        classes: h,
        dropdownBehaviours: [
          ...d ? [is.config({})] : []
        ],
        context: n.context
      }, s, a.shared, g);
    }, hZ = (n, s, a) => {
      const l = (g) => (h) => {
        const C = !h.isActive();
        h.setActive(C), g.storage.set(C), a.shared.getSink().each((x) => {
          s().getOpt(x).each((T) => {
            $r(T.element), tn(T, Zd, {
              name: g.name,
              value: g.storage.get()
            });
          });
        });
      }, d = (g) => (h) => {
        h.setActive(g.storage.get());
      };
      return (g) => {
        g(ye(n, (h) => {
          const C = h.text.fold(() => ({}), (x) => ({
            text: x
          }));
          return {
            type: h.type,
            active: !1,
            ...C,
            context: h.context,
            onAction: l(h),
            onSetup: d(h)
          };
        }));
      };
    }, XI = (n) => ({
      dom: {
        tag: "span",
        classes: ["tox-tree__label"],
        attributes: {
          "aria-label": n
        }
      },
      components: [
        xs(n)
      ]
    }), QI = (n, s, a) => {
      n.customStateIcon.each((l) => s.push(eF(l, a.shared.providers.icons, n.customStateIconTooltip.fold(() => [], (d) => [
        ps.config(a.shared.providers.tooltips.getConfig({
          tooltipText: d
        }))
      ]), ["tox-icon-custom-state"])));
    }, JI = Ct("leaf-label-event-id"), wR = ({ leaf: n, onLeafAction: s, visible: a, treeId: l, selectedId: d, backstage: g }) => {
      const h = n.menu.map((x) => sS(x, "tox-mbtn", g, A.none(), a)), C = [XI(n.title)];
      return QI(n, C, g), h.each((x) => C.push(x)), oa.sketch({
        dom: {
          tag: "div",
          classes: ["tox-tree--leaf__label", "tox-trbtn"].concat(a ? ["tox-tree--leaf__label--visible"] : [])
        },
        components: C,
        role: "treeitem",
        action: (x) => {
          s(n.id), x.getSystem().broadcastOn([`update-active-item-${l}`], {
            value: n.id
          });
        },
        eventOrder: {
          [na()]: [
            JI,
            "keying"
          ]
        },
        buttonBehaviours: nt([
          ...a ? [is.config({})] : [],
          eo.config({
            toggleClass: "tox-trbtn--enabled",
            toggleOnExecute: !1,
            aria: {
              mode: "selected"
            }
          }),
          Dc.config({
            channels: {
              [`update-active-item-${l}`]: {
                onReceive: (x, T) => {
                  (T.value === n.id ? eo.on : eo.off)(x);
                }
              }
            }
          }),
          xn(JI, [
            hs((x, T) => {
              d.each((_) => {
                (_ === n.id ? eo.on : eo.off)(x);
              });
            }),
            Ie(na(), (x, T) => {
              const _ = T.event.raw.code === "ArrowLeft", N = T.event.raw.code === "ArrowRight";
              _ ? (Fl(x.element, ".tox-tree--directory").each((L) => {
                x.getSystem().getByDom(L).each((j) => {
                  vd(L, ".tox-tree--directory__label").each((Z) => {
                    j.getSystem().getByDom(Z).each(En.focus);
                  });
                });
              }), T.stop()) : N && T.stop();
            })
          ])
        ])
      });
    }, eF = (n, s, a, l, d) => iu(n, {
      tag: "span",
      classes: [
        "tox-tree__icon-wrap",
        "tox-icon"
      ].concat(l || []),
      behaviours: a,
      attributes: d
    }, s), pZ = (n, s) => eF(n, s, []), tF = Ct("directory-label-event-id"), nF = ({ directory: n, visible: s, noChildren: a, backstage: l }) => {
      const d = n.menu.map((C) => sS(C, "tox-mbtn", l, A.none())), g = [
        {
          dom: {
            tag: "div",
            classes: ["tox-chevron"]
          },
          components: [
            pZ("chevron-right", l.shared.providers.icons)
          ]
        },
        XI(n.title)
      ];
      QI(n, g, l), d.each((C) => {
        g.push(C);
      });
      const h = (C) => {
        Fl(C.element, ".tox-tree--directory").each((x) => {
          C.getSystem().getByDom(x).each((T) => {
            const _ = !eo.isOn(T);
            eo.toggle(T), tn(C, "expand-tree-node", { expanded: _, node: n.id });
          });
        });
      };
      return oa.sketch({
        dom: {
          tag: "div",
          classes: ["tox-tree--directory__label", "tox-trbtn"].concat(s ? ["tox-tree--directory__label--visible"] : [])
        },
        components: g,
        action: h,
        eventOrder: {
          [na()]: [
            tF,
            "keying"
          ]
        },
        buttonBehaviours: nt([
          ...s ? [is.config({})] : [],
          xn(tF, [
            Ie(na(), (C, x) => {
              const T = x.event.raw.code === "ArrowRight", _ = x.event.raw.code === "ArrowLeft";
              T && a && x.stop(), (T || _) && Fl(C.element, ".tox-tree--directory").each((N) => {
                C.getSystem().getByDom(N).each((L) => {
                  !eo.isOn(L) && T || eo.isOn(L) && _ ? (h(C), x.stop()) : _ && !eo.isOn(L) && (Fl(L.element, ".tox-tree--directory").each((j) => {
                    vd(j, ".tox-tree--directory__label").each((Z) => {
                      L.getSystem().getByDom(Z).each(En.focus);
                    });
                  }), x.stop());
                });
              });
            })
          ])
        ])
      });
    }, bZ = ({ children: n, onLeafAction: s, visible: a, treeId: l, expandedIds: d, selectedId: g, backstage: h }) => ({
      dom: {
        tag: "div",
        classes: ["tox-tree--directory__children"]
      },
      components: n.map((C) => C.type === "leaf" ? wR({ leaf: C, selectedId: g, onLeafAction: s, visible: a, treeId: l, backstage: h }) : ER({ directory: C, expandedIds: d, selectedId: g, onLeafAction: s, labelTabstopping: a, treeId: l, backstage: h })),
      behaviours: nt([
        Kc.config({
          dimension: {
            property: "height"
          },
          closedClass: "tox-tree--directory__children--closed",
          openClass: "tox-tree--directory__children--open",
          growingClass: "tox-tree--directory__children--growing",
          shrinkingClass: "tox-tree--directory__children--shrinking",
          expanded: a
        }),
        An.config({})
      ])
    }), vZ = Ct("directory-event-id"), ER = ({ directory: n, onLeafAction: s, labelTabstopping: a, treeId: l, backstage: d, expandedIds: g, selectedId: h }) => {
      const { children: C } = n, x = Pt(g), T = (N) => C.map((L) => L.type === "leaf" ? wR({ leaf: L, selectedId: h, onLeafAction: s, visible: N, treeId: l, backstage: d }) : ER({ directory: L, expandedIds: x.get(), selectedId: h, onLeafAction: s, labelTabstopping: N, treeId: l, backstage: d })), _ = g.includes(n.id);
      return {
        dom: {
          tag: "div",
          classes: ["tox-tree--directory"],
          attributes: {
            role: "treeitem"
          }
        },
        components: [
          nF({ directory: n, visible: a, noChildren: n.children.length === 0, backstage: d }),
          bZ({ children: C, expandedIds: g, selectedId: h, onLeafAction: s, visible: _, treeId: l, backstage: d })
        ],
        behaviours: nt([
          xn(vZ, [
            hs((N, L) => {
              eo.set(N, _);
            }),
            Ie("expand-tree-node", (N, L) => {
              const { expanded: j, node: Z } = L.event;
              x.set(j ? [...x.get(), Z] : x.get().filter((ne) => ne !== Z));
            })
          ]),
          eo.config({
            ...n.children.length > 0 ? {
              aria: {
                mode: "expanded"
              }
            } : {},
            toggleClass: "tox-tree--directory--expanded",
            onToggled: (N, L) => {
              const j = N.components()[1], Z = T(L);
              L ? Kc.grow(j) : Kc.shrink(j), An.set(j, Z);
            }
          })
        ])
      };
    }, yZ = Ct("tree-event-id"), CZ = (n, s) => {
      const a = n.onLeafAction.getOr(U), l = n.onToggleExpand.getOr(U), d = n.defaultExpandedIds, g = Pt(d), h = Pt(n.defaultSelectedId), C = Ct("tree-id"), x = (T, _) => n.items.map((N) => N.type === "leaf" ? wR({ leaf: N, selectedId: T, onLeafAction: a, visible: !0, treeId: C, backstage: s }) : ER({ directory: N, selectedId: T, onLeafAction: a, expandedIds: _, labelTabstopping: !0, treeId: C, backstage: s }));
      return {
        dom: {
          tag: "div",
          classes: ["tox-tree"],
          attributes: {
            role: "tree"
          }
        },
        components: x(h.get(), g.get()),
        behaviours: nt([
          Xt.config({
            mode: "flow",
            selector: ".tox-tree--leaf__label--visible, .tox-tree--directory__label--visible",
            cycles: !1
          }),
          xn(yZ, [
            Ie("expand-tree-node", (T, _) => {
              const { expanded: N, node: L } = _.event;
              g.set(N ? [...g.get(), L] : g.get().filter((j) => j !== L)), l(g.get(), { expanded: N, node: L });
            })
          ]),
          Dc.config({
            channels: {
              [`update-active-item-${C}`]: {
                onReceive: (T, _) => {
                  h.set(A.some(_.value)), An.set(T, x(A.some(_.value), g.get()));
                }
              }
            }
          }),
          An.config({})
        ])
      };
    }, P4 = (n, s, a = [], l, d, g, h) => {
      const C = s.fold(() => ({}), (_) => ({
        action: _
      })), x = {
        buttonBehaviours: nt([
          Lm.item(() => !n.enabled || h.checkUiComponentContext(n.context).shouldDisable),
          yr(() => h.checkUiComponentContext(n.context)),
          is.config({}),
          ...g.map((_) => ps.config(h.tooltips.getConfig({
            tooltipText: h.translate(_)
          }))).toArray(),
          xn("button press", [
            q2("click")
          ])
        ].concat(a)),
        eventOrder: {
          click: ["button press", "alloy.base.behaviour"],
          mousedown: ["button press", "alloy.base.behaviour"]
        },
        ...C
      }, T = Ho(x, { dom: l });
      return Ho(T, { components: d });
    }, oF = (n, s, a, l = [], d) => {
      const g = n.tooltip.map((T) => ({
        "aria-label": a.translate(T)
      })).getOr({}), h = {
        tag: "button",
        classes: [
          "tox-tbtn"
          /* ToolbarButtonClasses.Button */
        ],
        attributes: { ...g, "data-mce-name": d }
      }, C = n.icon.map((T) => bR(T, a.icons)), x = zf([
        C
      ]);
      return P4(n, s, l, h, x, n.tooltip, a);
    }, TR = (n) => {
      switch (n) {
        case "primary":
          return ["tox-button"];
        case "toolbar":
          return ["tox-tbtn"];
        case "secondary":
        default:
          return ["tox-button", "tox-button--secondary"];
      }
    }, kR = (n, s, a, l = [], d = []) => {
      const g = a.translate(n.text), h = n.icon.map((j) => bR(j, a.icons)), C = [h.getOrThunk(() => xs(g))], x = n.buttonType.getOr(!n.primary && !n.borderless ? "secondary" : "primary"), N = {
        tag: "button",
        classes: [
          ...TR(x),
          ...h.isSome() ? ["tox-button--icon"] : [],
          ...n.borderless ? ["tox-button--naked"] : [],
          ...d
        ],
        attributes: {
          "aria-label": g,
          "data-mce-name": n.text
        }
      }, L = n.icon.map(oe(g));
      return P4(n, s, l, N, C, L, a);
    }, sF = (n, s, a, l = [], d = []) => {
      const g = kR(n, A.some(s), a, l, d);
      return oa.sketch(g);
    }, AR = (n, s) => (a) => {
      s === "custom" ? tn(a, Zd, {
        name: n,
        value: {}
      }) : s === "submit" ? Wn(a, eS) : s === "cancel" ? Wn(a, rh) : console.error("Unknown button type: ", s);
    }, rF = (n, s) => s === "menu", _R = (n, s) => s === "custom" || s === "cancel" || s === "submit", xZ = (n, s) => s === "togglebutton", SZ = (n, s, a) => {
      const l = n.icon.map((Y) => Np(Y, s.icons)).map(To), d = (Y) => {
        tn(Y, Zd, {
          name: n.name,
          value: {
            setIcon: (le) => {
              l.map((pe) => pe.getOpt(Y).each((Ee) => {
                An.set(Ee, [
                  Np(le, s.icons)
                ]);
              }));
            }
          }
        });
      }, g = n.buttonType.getOr(n.primary ? "primary" : "secondary"), h = {
        ...n,
        name: n.name ?? "",
        tooltip: n.tooltip,
        enabled: n.enabled ?? !1
      }, C = h.tooltip.or(n.text).map((Y) => ({
        "aria-label": s.translate(Y)
      })).getOr({}), x = TR(g ?? "secondary"), T = n.icon.isSome() && n.text.isSome(), _ = {
        tag: "button",
        classes: [
          ...x.concat(n.icon.isSome() ? ["tox-button--icon"] : []),
          ...n.active ? [
            "tox-button--enabled"
            /* ViewButtonClasses.Ticked */
          ] : [],
          ...T ? ["tox-button--icon-and-text"] : []
        ],
        attributes: {
          ...C,
          ...un(a) ? { "data-mce-name": a } : {}
        }
      }, N = [], L = s.translate(n.text.getOr("")), j = xs(L), ne = [
        ...zf([l.map((Y) => Y.asSpec())]),
        ...n.text.isSome() ? [j] : []
      ], ae = P4(h, A.some(d), N, _, ne, n.tooltip, s);
      return oa.sketch(ae);
    }, rS = (n, s, a) => {
      if (rF(n, s)) {
        const l = () => h, d = n, g = {
          ...n,
          buttonType: "default",
          type: "menubutton",
          // Currently, dialog-based menu buttons cannot be searchable.
          search: A.none(),
          onSetup: (C) => (C.setEnabled(n.enabled), U),
          fetch: hZ(d.items, l, a)
        }, h = To(sS(g, "tox-tbtn", a, A.none(), !0, n.text.or(n.tooltip).getOrUndefined()));
        return h.asSpec();
      } else if (_R(n, s)) {
        const l = AR(n.name, s), d = {
          ...n,
          context: s === "cancel" ? "any" : n.context,
          borderless: !1
        };
        return sF(d, l, a.shared.providers, []);
      } else {
        if (xZ(n, s))
          return SZ(n, a.shared.providers, n.text.or(n.tooltip).getOrUndefined());
        throw console.error("Unknown footer button type: ", s), new Error("Unknown footer button type");
      }
    }, wZ = (n, s) => {
      const a = AR(n.name, "custom");
      return zW(A.none(), Yn.parts.field({
        factory: oa,
        ...kR(n, A.some(a), s, [
          S4(""),
          Gd.self()
        ])
      }));
    }, aF = {
      type: "separator"
    }, EZ = (n) => ({
      type: "menuitem",
      value: n.url,
      text: n.title,
      meta: {
        attach: n.attach
      },
      onAction: U
    }), yy = (n, s) => ({
      type: "menuitem",
      value: s,
      text: n,
      meta: {
        attach: void 0
      },
      onAction: U
    }), TZ = (n) => ye(n, EZ), cF = (n, s) => Ln(s, (a) => a.type === n), lF = (n, s) => TZ(cF(n, s)), kZ = (n) => lF("header", n.targets), Vm = (n) => lF("anchor", n.targets), B4 = (n) => A.from(n.anchorTop).map((s) => yy("<top>", s)).toArray(), $4 = (n) => A.from(n.anchorBottom).map((s) => yy("<bottom>", s)).toArray(), AZ = (n) => ye(n, (s) => yy(s, s)), OR = (n) => ao(n, (s, a) => s.length === 0 || a.length === 0 ? s.concat(a) : s.concat(aF, a), []), DR = (n, s) => {
      const a = n.toLowerCase();
      return Ln(s, (l) => {
        const d = l.meta !== void 0 && l.meta.text !== void 0 ? l.meta.text : l.text, g = l.value ?? "";
        return ms(d.toLowerCase(), a) || ms(g.toLowerCase(), a);
      });
    }, RR = (n, s, a) => {
      const l = _t.getValue(s), d = l?.meta?.text ?? l.value;
      return a.getLinkInformation().fold(() => [], (h) => {
        const C = DR(d, AZ(a.getHistory(n)));
        return n === "file" ? OR([
          C,
          DR(d, kZ(h)),
          DR(d, en([
            B4(h),
            Vm(h),
            $4(h)
          ]))
        ]) : C;
      });
    }, NR = Ct("aria-invalid"), MR = (n, s, a, l) => {
      const d = s.shared.providers, g = (le) => {
        const pe = _t.getValue(le);
        a.addToHistory(pe.value, n.filetype);
      }, h = {
        ...l.map((le) => ({ initialData: le })).getOr({}),
        dismissOnBlur: !0,
        inputClasses: ["tox-textfield"],
        sandboxClasses: ["tox-dialog__popups"],
        inputAttributes: {
          type: "url"
        },
        minChars: 0,
        responseTime: 0,
        fetch: (le) => {
          const pe = RR(n.filetype, le, a), Ee = ah(pe, Wd.BUBBLE_TO_SANDBOX, s, {
            isHorizontalMenu: !1,
            search: A.none()
          });
          return Zo.pure(Ee);
        },
        getHotspot: (le) => Z.getOpt(le),
        onSetValue: (le, pe) => {
          le.hasConfigured(ru) && ru.run(le).get(U);
        },
        typeaheadBehaviours: nt([
          ...a.getValidationHandler().map((le) => ru.config({
            getRoot: (pe) => Li(pe.element),
            invalidClass: "tox-control-wrap--status-invalid",
            notify: {
              onInvalid: (pe, Ee) => {
                _.getOpt(pe).each((Oe) => {
                  ln(Oe.element, "title", d.translate(Ee));
                });
              }
            },
            validator: {
              validate: (pe) => {
                const Ee = _t.getValue(pe);
                return ad.nu((Oe) => {
                  le({ type: n.filetype, url: Ee.value }, (gt) => {
                    if (gt.status === "invalid") {
                      ln(pe.element, "aria-errormessage", NR);
                      const Ue = Wt.error(gt.message);
                      Oe(Ue);
                    } else {
                      fs(pe.element, "aria-errormessage");
                      const Ue = Wt.value(gt.message);
                      Oe(Ue);
                    }
                  });
                });
              },
              validateOnLoad: !1
            }
          })).toArray(),
          Ft.config({
            disabled: () => !n.enabled || d.checkUiComponentContext(n.context).shouldDisable
          }),
          is.config({}),
          xn(
            "urlinput-events",
            // We want to get fast feedback for the link dialog, but not sure about others
            [
              Ie(Nu(), (le) => {
                const pe = bc(le.element), Ee = pe.trim();
                Ee !== pe && fi(le.element, Ee), n.filetype === "file" && tn(le, Sl, { name: n.name });
              }),
              Ie(yg(), (le) => {
                tn(le, Sl, { name: n.name }), g(le);
              }),
              Ie(y0(), (le) => {
                tn(le, Sl, { name: n.name }), g(le);
              })
            ]
          )
        ]),
        eventOrder: {
          [Nu()]: ["streaming", "urlinput-events", "invalidating"]
        },
        model: {
          getDisplayText: (le) => le.value,
          selectsOver: !1,
          populateFromBrowse: !1
        },
        markers: {
          openClass: "tox-textfield--popup-open"
        },
        lazySink: s.shared.getSink,
        parts: {
          menu: $x(!1, 1, "normal")
        },
        onExecute: (le, pe, Ee) => {
          tn(pe, eS, {});
        },
        onItemExecute: (le, pe, Ee, Oe) => {
          g(le), tn(le, Sl, { name: n.name });
        }
      }, C = Yn.parts.field({
        ...h,
        factory: tO
      }), x = n.label.map((le) => sh(le, d)), _ = To(((le, pe, Ee = le, Oe = le) => iu(Ee, {
        tag: "div",
        classes: ["tox-icon", "tox-control-wrap__status-icon-" + le],
        attributes: {
          title: d.translate(Oe),
          "aria-live": "polite",
          ...pe.fold(() => ({}), (gt) => ({ id: gt }))
        }
      }, d.icons))("invalid", A.some(NR), "warning")), N = To({
        dom: {
          tag: "div",
          classes: ["tox-control-wrap__status-icon-wrap"]
        },
        components: [
          // Include the 'valid' and 'unknown' icons here only if they are to be displayed
          _.asSpec()
        ]
      }), L = a.getUrlPicker(n.filetype), j = Ct("browser.url.event"), Z = To({
        dom: {
          tag: "div",
          classes: ["tox-control-wrap"]
        },
        components: [C, N.asSpec()],
        behaviours: nt([
          Ft.config({
            disabled: () => !n.enabled || d.checkUiComponentContext(n.context).shouldDisable
          })
        ])
      }), ne = To(sF({
        context: n.context,
        name: n.name,
        icon: A.some("browse"),
        text: n.picker_text.or(n.label).getOr(""),
        enabled: n.enabled,
        primary: !1,
        buttonType: A.none(),
        borderless: !0
      }, (le) => Wn(le, j), d, [], ["tox-browse-url"])), ae = () => ({
        dom: {
          tag: "div",
          classes: ["tox-form__controls-h-stack"]
        },
        components: en([
          [Z.asSpec()],
          L.map(() => ne.asSpec()).toArray()
        ])
      }), Y = (le) => {
        Fe.getCurrent(le).each((pe) => {
          const Ee = _t.getValue(pe), Oe = {
            fieldname: n.name,
            ...Ee
          };
          L.each((gt) => {
            gt(Oe).get((Ue) => {
              _t.setValue(pe, Ue), tn(le, Sl, { name: n.name });
            });
          });
        });
      };
      return Yn.sketch({
        dom: cI(),
        components: x.toArray().concat([
          ae()
        ]),
        fieldBehaviours: nt([
          Ft.config({
            disabled: () => !n.enabled || d.checkUiComponentContext(n.context).shouldDisable,
            onDisabled: (le) => {
              Yn.getField(le).each(Ft.disable), ne.getOpt(le).each(Ft.disable);
            },
            onEnabled: (le) => {
              Yn.getField(le).each(Ft.enable), ne.getOpt(le).each(Ft.enable);
            }
          }),
          yr(() => d.checkUiComponentContext(n.context)),
          xn("url-input-events", [
            Ie(j, Y)
          ])
        ])
      });
    }, _Z = (n, s) => {
      const a = UV(n.icon, s.icons);
      return Am.sketch({
        dom: {
          tag: "div",
          attributes: {
            role: "alert"
          },
          classes: ["tox-notification", "tox-notification--in", `tox-notification--${n.level}`]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-notification__icon"],
              innerHtml: n.url ? void 0 : a
            },
            components: n.url ? [
              oa.sketch({
                dom: {
                  tag: "button",
                  classes: ["tox-button", "tox-button--naked", "tox-button--icon"],
                  innerHtml: a,
                  attributes: {
                    title: s.translate(n.iconTooltip)
                  }
                },
                // TODO: aria label this button!
                action: (l) => tn(l, Zd, { name: "alert-banner", value: n.url }),
                buttonBehaviours: nt([
                  _O()
                ])
              })
            ] : void 0
          },
          {
            dom: {
              tag: "div",
              classes: ["tox-notification__body"],
              // TODO: AP-247: Escape this text so that it can't contain script tags
              innerHtml: s.translate(n.text)
            }
          }
        ]
      });
    }, OZ = (n, s, a) => {
      const l = (x) => (x.element.dom.click(), A.some(!0)), d = Yn.parts.field({
        factory: { sketch: Yt },
        dom: {
          tag: "input",
          classes: ["tox-checkbox__input"],
          attributes: {
            type: "checkbox"
          }
        },
        behaviours: nt([
          Gd.self(),
          Ft.config({
            disabled: () => !n.enabled || s.checkUiComponentContext(n.context).shouldDisable,
            onDisabled: (x) => {
              Li(x.element).each((T) => Uo(T, "tox-checkbox--disabled"));
            },
            onEnabled: (x) => {
              Li(x.element).each((T) => Ds(T, "tox-checkbox--disabled"));
            }
          }),
          is.config({}),
          En.config({}),
          hI(a, s1, Ui),
          Xt.config({
            mode: "special",
            onEnter: l,
            onSpace: l,
            stopSpaceKeyup: !0
          }),
          xn("checkbox-events", [
            Ie(yg(), (x, T) => {
              tn(x, Sl, { name: n.name });
            })
          ])
        ])
      }), g = Yn.parts.label({
        dom: {
          tag: "span",
          classes: ["tox-checkbox__label"]
        },
        components: [
          xs(s.translate(n.label))
        ],
        behaviours: nt([
          Om.config({})
        ])
      }), h = (x) => iu(x === "checked" ? "selected" : "unselected", { tag: "span", classes: ["tox-icon", "tox-checkbox-icon__" + x] }, s.icons), C = To({
        dom: {
          tag: "div",
          classes: ["tox-checkbox__icons"]
        },
        components: [
          h("checked"),
          h("unchecked")
        ]
      });
      return Yn.sketch({
        dom: {
          tag: "label",
          classes: ["tox-checkbox"]
        },
        components: [
          d,
          C.asSpec(),
          g
        ],
        fieldBehaviours: nt([
          Ft.config({
            disabled: () => !n.enabled || s.checkUiComponentContext(n.context).shouldDisable
          }),
          yr(() => s.checkUiComponentContext(n.context))
        ])
      });
    }, iF = (n, s) => {
      const a = ["tox-form__group", ...n.stretched ? ["tox-form__group--stretched"] : []], l = xn("htmlpanel", [
        hs((d) => {
          n.onInit(d.element.dom);
        })
      ]);
      return n.presets === "presentation" ? Am.sketch({
        dom: {
          tag: "div",
          classes: a,
          innerHtml: n.html
        },
        containerBehaviours: nt([
          ps.config({
            ...s.tooltips.getConfig({
              tooltipText: "",
              onShow: (d) => {
                Po(d.element, "[data-mce-tooltip]:hover").orThunk(() => or(d.element)).each((g) => {
                  Qr(g, "data-mce-tooltip").each((h) => {
                    ps.setComponents(d, s.tooltips.getComponents({ tooltipText: h }));
                  });
                });
              }
            }),
            mode: "children-normal",
            anchor: (d) => ({
              type: "node",
              node: Po(d.element, "[data-mce-tooltip]:hover").orThunk(() => or(d.element).filter((g) => Qr(g, "data-mce-tooltip").isSome())),
              root: d.element,
              layouts: {
                onLtr: oe([Tr, Rs, Mr, Ta, Er, ua]),
                onRtl: oe([Tr, Rs, Mr, Ta, Er, ua])
              },
              bubble: bl(0, -2, {})
            })
          }),
          l
        ])
      }) : Am.sketch({
        dom: {
          tag: "div",
          classes: a,
          innerHtml: n.html,
          attributes: {
            role: "document"
          }
        },
        containerBehaviours: nt([
          is.config({}),
          En.config({}),
          l
        ])
      });
    }, ra = (n) => (s, a, l, d, g) => Vt(a, "name").fold(() => n(a, d, A.none(), g), (h) => s.field(h, n(a, d, Vt(l, h), g))), DZ = (n) => (s, a, l, d, g) => {
      const h = Ho(a, {
        source: "dynamic"
      });
      return ra(n)(s, h, l, d, g);
    }, PR = {
      bar: ra((n, s) => rI(n, s.shared)),
      collection: ra((n, s, a) => VW(n, s.shared.providers, a)),
      alertbanner: ra((n, s) => _Z(n, s.shared.providers)),
      input: ra((n, s, a) => KI(n, s.shared.providers, a)),
      textarea: ra((n, s, a) => gZ(n, s.shared.providers, a)),
      label: ra((n, s, a, l) => rZ(n, s.shared, l)),
      iframe: DZ((n, s, a) => nS(n, s.shared.providers, a)),
      button: ra((n, s) => wZ(n, s.shared.providers)),
      checkbox: ra((n, s, a) => OZ(n, s.shared.providers, a)),
      colorinput: ra((n, s, a) => jW(n, s.shared, s.colorinput, a)),
      colorpicker: ra((n, s, a) => T4(n, s.shared.providers, a)),
      // Not sure if this needs name.
      dropzone: ra((n, s, a) => JW(n, s.shared.providers, a)),
      grid: ra((n, s) => eZ(n, s.shared)),
      listbox: ra((n, s, a) => VI(n, s, a)),
      selectbox: ra((n, s, a) => UI(n, s.shared.providers, a)),
      sizeinput: ra((n, s) => GI(n, s.shared.providers)),
      slider: ra((n, s, a) => mZ(n, s.shared.providers, a)),
      urlinput: ra((n, s, a) => MR(n, s, s.urlinput, a)),
      customeditor: ra(XW),
      htmlpanel: ra((n, s) => iF(n, s.shared.providers)),
      imagepreview: ra((n, s, a) => sZ(n, a)),
      table: ra((n, s) => fZ(n, s.shared.providers)),
      tree: ra((n, s) => CZ(n, s)),
      panel: ra((n, s) => by(n, s))
    }, RZ = {
      // This is cast as we only actually want an alloy spec and don't need the actual part here
      field: (n, s) => s,
      record: oe([])
    }, uF = (n, s, a, l, d) => {
      const g = Ho(l, {
        // Add the interpreter based on the form parts.
        shared: {
          interpreter: (h) => I4(n, h, a, g, d)
        }
      });
      return I4(n, s, a, g, d);
    }, I4 = (n, s, a, l, d) => Vt(PR, s.type).fold(() => (console.error(`Unknown factory type "${s.type}", defaulting to container: `, s), s), (g) => g(n, s, a, l, d)), BR = (n, s, a, l) => I4(RZ, n, s, a, l), aS = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: [],
      alignRight: [],
      right: [],
      left: [],
      bottom: [],
      top: []
    }, NZ = (n, s, a) => {
      const d = {
        maxHeightFunction: Ng()
      }, g = () => ({
        type: "node",
        root: ci(mr(n())),
        node: A.from(n()),
        bubble: bl(12, 12, aS),
        layouts: {
          onRtl: () => [Tc],
          onLtr: () => [Rg]
        },
        overrides: d
      }), h = () => ({
        type: "hotspot",
        hotspot: s(),
        bubble: bl(-12, 12, aS),
        layouts: {
          onRtl: () => [Mr, Er, Tr],
          onLtr: () => [Er, Mr, Tr]
        },
        overrides: d
      });
      return () => a() ? g() : h();
    }, MZ = (n, s, a, l) => {
      const g = {
        maxHeightFunction: Ng()
      }, h = () => ({
        type: "node",
        root: ci(mr(s())),
        node: A.from(s()),
        bubble: bl(12, 12, aS),
        layouts: {
          onRtl: () => [La],
          onLtr: () => [La]
        },
        overrides: g
      }), C = () => n ? {
        type: "node",
        root: ci(mr(s())),
        node: A.from(s()),
        bubble: bl(0, -pr(s()), aS),
        layouts: {
          onRtl: () => [Rs],
          onLtr: () => [Rs]
        },
        overrides: g
      } : {
        type: "hotspot",
        hotspot: a(),
        bubble: bl(0, 0, aS),
        layouts: {
          onRtl: () => [Rs],
          onLtr: () => [Rs]
        },
        overrides: g
      };
      return () => l() ? h() : C();
    }, PZ = (n, s, a) => {
      const l = () => ({
        type: "node",
        root: ci(mr(n())),
        node: A.from(n()),
        layouts: {
          onRtl: () => [La],
          onLtr: () => [La]
        }
      }), d = () => ({
        type: "hotspot",
        hotspot: s(),
        layouts: {
          onRtl: () => [Tr],
          onLtr: () => [Tr]
        }
      });
      return () => a() ? l() : d();
    }, dF = (n, s) => () => ({
      type: "selection",
      root: s(),
      getSelection: () => {
        const a = n.selection.getRng(), l = n.model.table.getSelectedCells();
        if (l.length > 1) {
          const d = l[0], g = l[l.length - 1], h = {
            firstCell: at.fromDom(d),
            lastCell: at.fromDom(g)
          };
          return A.some(h);
        }
        return A.some(Hl.range(at.fromDom(a.startContainer), a.startOffset, at.fromDom(a.endContainer), a.endOffset));
      }
    }), BZ = (n) => (s) => ({
      type: "node",
      root: n(),
      node: s
    }), $Z = (n, s, a, l) => {
      const d = ey(n), g = () => at.fromDom(n.getBody()), h = () => at.fromDom(n.getContentAreaContainer()), C = () => d || !l();
      return {
        inlineDialog: NZ(h, s, C),
        inlineBottomDialog: MZ(n.inline, h, a, C),
        banner: PZ(h, s, C),
        cursor: dF(n, g),
        node: BZ(g)
      };
    }, IZ = (n) => (s, a) => {
      eR(n)(s, a);
    }, FZ = (n) => () => qD(n), LZ = (n) => (s) => g4(n, s), HZ = (n) => (s) => L$(n, s), zZ = (n) => ({
      colorPicker: IZ(n),
      hasCustomColors: FZ(n),
      getColors: LZ(n),
      getColorCols: HZ(n)
    }), VZ = (n) => () => zB(n), UZ = (n) => ({
      isDraggableModal: VZ(n)
    }), jZ = (n) => {
      const s = Pt(IT(n) ? "bottom" : "top");
      return {
        isPositionedAtTop: () => s.get() === "top",
        getDockingMode: s.get,
        setDockingMode: s.set
      };
    }, WZ = (n) => Un(n, "items"), mF = (n) => Un(n, "format"), $R = [
      {
        title: "Headings",
        items: [
          { title: "Heading 1", format: "h1" },
          { title: "Heading 2", format: "h2" },
          { title: "Heading 3", format: "h3" },
          { title: "Heading 4", format: "h4" },
          { title: "Heading 5", format: "h5" },
          { title: "Heading 6", format: "h6" }
        ]
      },
      {
        title: "Inline",
        items: [
          { title: "Bold", format: "bold" },
          { title: "Italic", format: "italic" },
          { title: "Underline", format: "underline" },
          { title: "Strikethrough", format: "strikethrough" },
          { title: "Superscript", format: "superscript" },
          { title: "Subscript", format: "subscript" },
          { title: "Code", format: "code" }
        ]
      },
      {
        title: "Blocks",
        items: [
          { title: "Paragraph", format: "p" },
          { title: "Blockquote", format: "blockquote" },
          { title: "Div", format: "div" },
          { title: "Pre", format: "pre" }
        ]
      },
      {
        title: "Align",
        items: [
          { title: "Left", format: "alignleft" },
          { title: "Center", format: "aligncenter" },
          { title: "Right", format: "alignright" },
          { title: "Justify", format: "alignjustify" }
        ]
      }
    ], fF = (n) => mo(n, "items"), F4 = (n) => mo(n, "block"), gF = (n) => mo(n, "inline"), ZZ = (n) => mo(n, "selector"), hF = (n) => ao(n, (s, a) => {
      if (fF(a)) {
        const l = hF(a.items);
        return {
          customFormats: s.customFormats.concat(l.customFormats),
          formats: s.formats.concat([{ title: a.title, items: l.formats }])
        };
      } else if (gF(a) || F4(a) || ZZ(a)) {
        const d = `custom-${De(a.name) ? a.name : a.title.toLowerCase()}`;
        return {
          customFormats: s.customFormats.concat([{ name: d, format: a }]),
          formats: s.formats.concat([{ title: a.title, format: d, icon: a.icon }])
        };
      } else
        return { ...s, formats: s.formats.concat(a) };
    }, { customFormats: [], formats: [] }), GZ = (n, s) => {
      const a = hF(s), l = (d) => {
        He(d, (g) => {
          n.formatter.has(g.name) || n.formatter.register(g.name, g.format);
        });
      };
      return n.formatter ? l(a.customFormats) : n.on("init", () => {
        l(a.customFormats);
      }), a.formats;
    }, pF = (n) => OB(n).map((s) => {
      const a = GZ(n, s);
      return DB(n) ? $R.concat(a) : a;
    }).getOr($R), qZ = (n) => {
      const s = xo(n);
      return s.length === 1 && bt(s, "title");
    }, bF = (n, s, a) => ({
      ...n,
      type: "formatter",
      isSelected: s(n.format),
      getStylePreview: a(n.format)
    }), vF = (n, s, a, l) => {
      const d = (x) => bF(x, a, l), g = (x) => {
        const T = C(x.items);
        return {
          ...x,
          type: "submenu",
          getStyleItems: oe(T)
        };
      }, h = (x) => {
        const T = De(x.name) ? x.name : Ct(x.title), _ = `custom-${T}`, N = {
          ...x,
          type: "formatter",
          format: _,
          isSelected: a(_),
          getStylePreview: l(_)
        };
        return n.formatter.register(T, N), N;
      }, C = (x) => ye(x, (T) => WZ(T) ? g(T) : mF(T) ? d(T) : qZ(T) ? { ...T, type: "separator" } : h(T));
      return C(s);
    }, yF = (n) => {
      const s = (C) => () => n.formatter.match(C), a = (C) => () => {
        const x = n.formatter.get(C);
        return x !== void 0 ? A.some({
          tag: x.length > 0 && (x[0].inline || x[0].block) || "div",
          styles: n.dom.parseStyle(n.formatter.getCssText(C))
        }) : A.none();
      }, l = Pt([]), d = Pt([]), g = Pt(!1);
      return n.on("PreInit", (C) => {
        const x = pF(n), T = vF(n, x, s, a);
        l.set(T);
      }), n.on("addStyleModifications", (C) => {
        const x = vF(n, C.items, s, a);
        d.set(x), g.set(C.replace);
      }), {
        getData: () => {
          const C = g.get() ? [] : l.get(), x = d.get();
          return C.concat(x);
        }
      };
    }, CF = (n) => {
      let l = 0;
      const d = () => l > 0, g = (C) => [
        {
          dom: {
            tag: "div",
            classes: ["tox-tooltip__body"]
          },
          components: [
            xs(C.tooltipText)
          ]
        }
      ];
      return {
        getConfig: (C) => ({
          delayForShow: () => d() ? 60 : 300,
          delayForHide: oe(300),
          exclusive: !0,
          lazySink: n,
          tooltipDom: {
            tag: "div",
            classes: ["tox-tooltip", "tox-tooltip--up"]
          },
          tooltipComponents: g(C),
          onShow: (x, T) => {
            l++, C.onShow && C.onShow(x, T);
          },
          onHide: (x, T) => {
            l--, C.onHide && C.onHide(x, T);
          },
          onSetup: C.onSetup
        }),
        getComponents: g
      };
    }, KZ = (n) => un(n) && n.nodeType === 1, xF = jf.trim, SF = (n) => (s) => !!(KZ(s) && (s.contentEditable === n || s.getAttribute("data-mce-contenteditable") === n)), YZ = SF("true"), XZ = SF("false"), Mp = (n, s, a, l, d) => ({
      type: n,
      title: s,
      url: a,
      level: l,
      attach: d
    }), wF = (n) => {
      let s = n;
      for (; s = s.parentNode; ) {
        const a = s.contentEditable;
        if (a && a !== "inherit")
          return YZ(s);
      }
      return !1;
    }, cS = (n, s) => ye(Lr(at.fromDom(s), n), (a) => a.dom), lS = (n) => n.innerText || n.textContent, EF = (n) => n.id ? n.id : Ct("h"), TF = (n) => n && n.nodeName === "A" && (n.id || n.name) !== void 0, kF = (n) => TF(n) && AF(n), QZ = (n) => n && /^(H[1-6])$/.test(n.nodeName), AF = (n) => wF(n) && !XZ(n), JZ = (n) => QZ(n) && AF(n), eG = (n) => QZ(n) ? parseInt(n.nodeName.substr(1), 10) : 0, tG = (n) => {
      const s = EF(n), a = () => {
        n.id = s;
      };
      return Mp("header", lS(n) ?? "", "#" + s, eG(n), a);
    }, nG = (n) => {
      const s = n.id || n.name, a = lS(n);
      return Mp("anchor", a || "#" + s, "#" + s, 0, U);
    }, oG = (n) => ye(Ln(n, JZ), tG), Cy = (n) => ye(Ln(n, kF), nG), iS = (n) => cS("h1,h2,h3,h4,h5,h6,a:not([href])", n), IR = (n) => xF(n.title).length > 0, sG = {
      find: (n) => {
        const s = iS(n);
        return Ln(oG(s).concat(Cy(s)), IR);
      }
    }, xy = "tinymce-url-history", _F = 5, Sy = (n) => De(n) && /^https?/.test(n), OF = (n) => $n(n) && n.length <= _F && We(n, Sy), DF = (n) => et(n) && cc(n, (s) => !OF(s)).isNone(), RF = () => {
      const n = $b.getItem(xy);
      if (n === null)
        return {};
      let s;
      try {
        s = JSON.parse(n);
      } catch (a) {
        if (a instanceof SyntaxError)
          return console.log("Local storage " + xy + " was not valid JSON", a), {};
        throw a;
      }
      return DF(s) ? s : (console.log("Local storage " + xy + " was not valid format", s), {});
    }, rG = (n) => {
      if (!DF(n))
        throw new Error(`Bad format for history:
` + JSON.stringify(n));
      $b.setItem(xy, JSON.stringify(n));
    }, aG = (n) => {
      const s = RF();
      return Vt(s, n).getOr([]);
    }, cG = (n, s) => {
      if (!Sy(n))
        return;
      const a = RF(), l = Vt(a, s).getOr([]), d = Ln(l, (g) => g !== n);
      a[s] = [n].concat(d).slice(0, _F), rG(a);
    }, NF = (n) => !!n, MF = (n) => Bs(jf.makeMap(n, /[, ]/), NF), L4 = (n) => A.from(FB(n)), FR = (n) => {
      const s = A.from(iO(n)).filter(NF).map(MF);
      return L4(n).fold(an, (a) => s.fold(St, (l) => xo(l).length > 0 ? l : !1));
    }, lG = (n, s) => {
      const a = FR(n);
      return vn(a) ? a ? L4(n) : A.none() : a[s] ? L4(n) : A.none();
    }, H4 = (n, s) => lG(n, s).map((a) => (l) => Zo.nu((d) => {
      const g = (C, x) => {
        if (!De(C))
          throw new Error("Expected value to be string");
        if (x !== void 0 && !et(x))
          throw new Error("Expected meta to be a object");
        d({ value: C, meta: x });
      }, h = {
        filetype: s,
        fieldname: l.fieldname,
        ...A.from(l.meta).getOr({})
      };
      a.call(n, g, l.value, h);
    })), uS = (n) => A.from(n).filter(De).getOrUndefined(), PF = (n) => uO(n) ? A.some({
      targets: sG.find(n.getBody()),
      anchorTop: uS(HB(n)),
      anchorBottom: uS(dO(n))
    }) : A.none(), iG = (n) => A.from(LB(n)), uG = (n) => ({
      getHistory: aG,
      addToHistory: cG,
      getLinkInformation: () => PF(n),
      getValidationHandler: () => iG(n),
      getUrlPicker: (s) => H4(n, s)
    }), dG = (n, s, a, l) => {
      const d = Pt(!1), g = jZ(s), h = {
        icons: () => s.ui.registry.getAll().icons,
        menuItems: () => s.ui.registry.getAll().menuItems,
        translate: Rc.translate,
        isDisabled: () => !s.ui.isEnabled(),
        getOption: s.options.get,
        tooltips: CF(n.dialog),
        checkUiComponentContext: (Y) => {
          if (NT(s))
            return {
              contextType: "disabled",
              shouldDisable: !0
            };
          const [le, pe = ""] = Y.split(":"), Ee = s.ui.registry.getAll().contexts, Oe = Vt(Ee, le).fold(
            // Fallback to 'mode:design' if key is not found
            () => Vt(Ee, "mode").map((gt) => gt("design")).getOr(!1),
            (gt) => pe.charAt(0) === "!" ? !gt(pe.slice(1)) : gt(pe)
          );
          return {
            contextType: le,
            shouldDisable: !Oe
          };
        }
      }, C = uG(s), x = yF(s), T = zZ(s), _ = UZ(s), N = () => d.get(), L = (Y) => d.set(Y), j = {
        shared: {
          providers: h,
          anchors: $Z(s, a, l, g.isPositionedAtTop),
          header: g
        },
        urlinput: C,
        styles: x,
        colorinput: T,
        dialog: _,
        isContextMenuOpen: N,
        setContextMenuState: L
      }, Z = (Y) => A.none(), ne = {
        ...j,
        shared: {
          ...j.shared,
          interpreter: (Y) => BR(Y, {}, ne, Z),
          getSink: n.popup
        }
      }, ae = {
        ...j,
        shared: {
          ...j.shared,
          interpreter: (Y) => BR(Y, {}, ae, Z),
          getSink: n.dialog
        }
      };
      return {
        popup: ne,
        dialog: ae
      };
    }, LR = {
      skipFocus: "ToggleToolbarDrawer skipFocus is deprecated see migration guide: https://www.tiny.cloud/docs/tinymce/latest/migration-from-7x/"
    }, mG = (n) => {
      console.warn(LR[n], new Error().stack);
    }, HR = (n, s, a) => {
      const l = (Ke, Qt) => {
        He([s, ...a], (zt) => {
          zt.broadcastEvent(Ke, Qt);
        });
      }, d = (Ke, Qt) => {
        He([s, ...a], (zt) => {
          zt.broadcastOn([Ke], Qt);
        });
      }, g = (Ke) => d(Ad(), { target: Ke.target }), h = (Ke) => {
        d(np(), {
          closedTooltip: () => {
            Ke.preventDefault();
          }
        });
      }, C = Xr(), x = Oo(C, "touchstart", g), T = Oo(C, "touchmove", (Ke) => l(KS(), Ke)), _ = Oo(C, "touchend", (Ke) => l(w2(), Ke)), N = Oo(C, "mousedown", g), L = Oo(C, "mouseup", (Ke) => {
        Ke.raw.button === 0 && d(ym(), { target: Ke.target });
      }), j = (Ke) => d(Ad(), { target: at.fromDom(Ke.target) }), Z = (Ke) => {
        Ke.button === 0 && d(ym(), { target: at.fromDom(Ke.target) });
      }, ne = () => {
        He(n.editorManager.get(), (Ke) => {
          n !== Ke && Ke.dispatch("DismissPopups", { relatedTarget: n });
        });
      }, ae = (Ke) => l(E2(), tc(Ke)), Y = (Ke) => {
        d(kr(), {}), l(Lh(), tc(Ke));
      }, le = mr(at.fromDom(n.getElement())), pe = rl(le, "scroll", (Ke) => {
        requestAnimationFrame(() => {
          const Qt = n.getContainer();
          if (Qt != null) {
            const jn = Yg(n, s.element).map((Jt) => [Jt.element, ...Jt.others]).getOr([]);
            cn(jn, (Jt) => I(Jt, Ke.target)) && (n.dispatch("ElementScroll", { target: Ke.target.dom }), l(XS(), Ke));
          }
        });
      }), Ee = () => d(kr(), {}), Oe = (Ke) => {
        Ke.state && d(Ad(), { target: at.fromDom(n.getContainer()) });
      }, gt = (Ke) => {
        d(Ad(), { target: at.fromDom(Ke.relatedTarget.getContainer()) });
      }, Ue = (Ke) => n.dispatch("focusin", Ke), Qe = (Ke) => n.dispatch("focusout", Ke);
      n.on("PostRender", () => {
        n.on("click", j), n.on("tap", j), n.on("mouseup", Z), n.on("mousedown", ne), n.on("ScrollWindow", ae), n.on("ResizeWindow", Y), n.on("ResizeEditor", Ee), n.on("AfterProgressState", Oe), n.on("DismissPopups", gt), n.on("CloseActiveTooltips", h), He([s, ...a], (Ke) => {
          Ke.element.dom.addEventListener("focusin", Ue), Ke.element.dom.addEventListener("focusout", Qe);
        });
      }), n.on("remove", () => {
        n.off("click", j), n.off("tap", j), n.off("mouseup", Z), n.off("mousedown", ne), n.off("ScrollWindow", ae), n.off("ResizeWindow", Y), n.off("ResizeEditor", Ee), n.off("AfterProgressState", Oe), n.off("DismissPopups", gt), n.off("CloseActiveTooltips", h), He([s, ...a], (Ke) => {
          Ke.element.dom.removeEventListener("focusin", Ue), Ke.element.dom.removeEventListener("focusout", Qe);
        }), N.unbind(), x.unbind(), T.unbind(), _.unbind(), L.unbind(), pe.unbind();
      }), n.on("detach", () => {
        He([s, ...a], mE), He([s, ...a], (Ke) => Ke.destroy());
      });
    }, fG = U, zR = an, BF = oe([]);
    var gG = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setup: fG,
      isDocked: zR,
      getBehaviours: BF
    });
    const VR = oe(Ct("toolbar-height-change")), Zf = {
      fadeInClass: "tox-editor-dock-fadein",
      fadeOutClass: "tox-editor-dock-fadeout",
      transitionClass: "tox-editor-dock-transition"
    }, $F = "tox-tinymce--toolbar-sticky-on", hG = "tox-tinymce--toolbar-sticky-off", SX = (n, s) => {
      const a = fc(s), d = sg(s).dom.innerHeight, g = Ls(a), h = at.fromDom(n.elm), C = cf(h), x = hr(h), T = C.y, _ = T + x, N = Ca(s), L = hr(s), j = N.top, Z = j + L, ne = Math.abs(j - g.top) < 2, ae = Math.abs(Z - (g.top + d)) < 2;
      if (ne && T < Z)
        _u(g.left, T - L, a);
      else if (ae && _ > j) {
        const Y = T - d + x + L;
        _u(g.left, Y, a);
      }
    }, dS = (n, s) => bt(Ns.getModes(n), s), UR = (n) => {
      const s = (l) => pr(l) + (parseInt(gs(l, "margin-top"), 10) || 0) + (parseInt(gs(l, "margin-bottom"), 10) || 0), a = n.element;
      Li(a).each((l) => {
        const d = "padding-" + Ns.getModes(n)[0];
        if (Ns.isDocked(n)) {
          const g = la(l);
          gn(a, "width", g + "px"), gn(l, d, s(a) + "px");
        } else
          Kn(a, "width"), Kn(l, d);
      });
    }, jR = (n, s) => {
      s ? (Ds(n, Zf.fadeOutClass), Zi(n, [Zf.transitionClass, Zf.fadeInClass])) : (Ds(n, Zf.fadeInClass), Zi(n, [Zf.fadeOutClass, Zf.transitionClass]));
    }, IF = (n, s) => {
      const a = at.fromDom(n.getContainer());
      s ? (Uo(a, $F), Ds(a, hG)) : (Uo(a, hG), Ds(a, $F));
    }, pG = (n, s) => {
      const a = fc(s);
      Ir(a).filter((l) => (
        // Don't try to refocus the same element
        !I(s, l)
      )).filter((l) => (
        // Only attempt to refocus if the current focus is the body or is in the header element
        I(l, at.fromDom(a.dom.body)) || ee(n, l)
      )).each(() => $r(s));
    }, bG = (n, s) => (
      // Check to see if an element is focused inside the header or inside the sink
      // and if so store the element so we can restore it later
      or(n).orThunk(() => s().toOptional().bind((a) => or(a.element)))
    ), vG = (n, s, a) => {
      n.inline || (s.header.isPositionedAtTop() || n.on("ResizeEditor", () => {
        a().each(Ns.reset);
      }), n.on("ResizeWindow ResizeEditor", () => {
        a().each(UR);
      }), n.on("SkinLoaded", () => {
        a().each((l) => {
          Ns.isDocked(l) ? Ns.reset(l) : Ns.refresh(l);
        });
      }), n.on("FullscreenStateChanged", () => {
        a().each(Ns.reset);
      })), n.on("AfterScrollIntoView", (l) => {
        a().each((d) => {
          Ns.refresh(d);
          const g = d.element;
          ku(g) && SX(l, g);
        });
      }), n.on("PostRender", () => {
        IF(n, !1);
      });
    }, yG = (n) => n().map(Ns.isDocked).getOr(!1), FF = () => [
      Dc.config({
        channels: {
          [VR()]: {
            onReceive: UR
          }
        }
      })
    ], LF = (n, s) => {
      const a = hn(), l = s.getSink, d = (C) => {
        l().each((x) => C(x.element));
      }, g = (C) => {
        n.inline || UR(C), IF(n, Ns.isDocked(C)), C.getSystem().broadcastOn([kr()], {}), l().each((x) => x.getSystem().broadcastOn([kr()], {}));
      }, h = n.inline ? [] : FF();
      return [
        En.config({}),
        Ns.config({
          contextual: {
            lazyContext: (C) => {
              const x = pr(C.element), T = n.inline ? n.getContentAreaContainer() : n.getContainer();
              return A.from(T).map((_) => {
                const N = wr(at.fromDom(_));
                return Yg(n, C.element).fold(() => {
                  const j = N.height - x, Z = N.y + (dS(C, "top") ? 0 : x);
                  return Rr(N.x, Z, N.width, j);
                }, (j) => {
                  const Z = cm(N, Cb(j)), ne = dS(C, "top") ? Z.y : Z.y + x;
                  return Rr(
                    Z.x,
                    // ASSUMPTION: The constrainedBounds removes the need for us to set this to 0px
                    // for docked mode. Also, docking in a scrolling environment will often be
                    // at the scroller top, not the window top
                    ne,
                    Z.width,
                    Z.height - x
                  );
                });
              });
            },
            onShow: () => {
              d((C) => jR(C, !0));
            },
            onShown: (C) => {
              d((x) => ia(x, [Zf.transitionClass, Zf.fadeInClass])), a.get().each((x) => {
                pG(C.element, x), a.clear();
              });
            },
            onHide: (C) => {
              bG(C.element, l).fold(a.clear, a.set), d((x) => jR(x, !1));
            },
            onHidden: () => {
              d((C) => ia(C, [Zf.transitionClass]));
            },
            ...Zf
          },
          lazyViewport: (C) => Yg(n, C.element).fold(() => {
            const T = Ia(), _ = $B(n), N = T.y + (dS(C, "top") && !t6(n) ? _ : 0), L = T.height - (dS(C, "bottom") ? _ : 0);
            return {
              bounds: Rr(T.x, N, T.width, L),
              optScrollEnv: A.none()
            };
          }, (T) => ({
            bounds: Cb(T),
            optScrollEnv: A.some({
              currentScrollTop: T.element.dom.scrollTop,
              scrollElmTop: Ca(T.element).top
            })
          })),
          modes: [s.header.getDockingMode()],
          onDocked: g,
          onUndocked: g
        }),
        ...h
      ];
    };
    var CG = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      setup: vG,
      isDocked: yG,
      getBehaviours: LF
    });
    const xG = (n) => {
      const s = n.editor, a = n.sticky ? LF : BF;
      return {
        uid: n.uid,
        dom: n.dom,
        components: n.components,
        behaviours: nt(a(s, n.sharedBackstage))
      };
    };
    var HF = su({
      factory: (n, s) => {
        const a = (d, g) => {
          const h = ye(g, (C) => {
            const x = {
              type: "menubutton",
              text: C.text,
              fetch: (_) => {
                _(C.getItems());
              },
              context: "any"
            }, T = rD(x).mapError((_) => Rh(_)).getOrDie();
            return sS(
              T,
              "tox-mbtn",
              s.backstage,
              // https://www.w3.org/TR/wai-aria-practices/examples/menubar/menubar-2/menubar-2.html
              A.some("menuitem")
            );
          });
          An.set(d, h);
        }, l = {
          focus: Xt.focusIn,
          setMenus: a
        };
        return {
          uid: n.uid,
          dom: n.dom,
          components: [],
          behaviours: nt([
            An.config({}),
            xn("menubar-events", [
              hs((d) => {
                n.onSetup(d);
              }),
              Ie(Ul(), (d, g) => {
                Po(
                  d.element,
                  ".tox-mbtn--active"
                  /* MenuButtonClasses.Active */
                ).each((h) => {
                  xa(
                    g.event.target,
                    ".tox-mbtn"
                    /* MenuButtonClasses.Button */
                  ).each((C) => {
                    I(h, C) || d.getSystem().getByDom(h).each((x) => {
                      d.getSystem().getByDom(C).each((T) => {
                        Kl.expand(T), Kl.close(x), En.focus(T);
                      });
                    });
                  });
                });
              }),
              Ie(w0(), (d, g) => {
                g.event.prevFocus.bind((h) => d.getSystem().getByDom(h).toOptional()).each((h) => {
                  g.event.newFocus.bind((C) => d.getSystem().getByDom(C).toOptional()).each((C) => {
                    Kl.isOpen(h) && (Kl.expand(C), Kl.close(h));
                  });
                });
              })
            ]),
            Xt.config({
              mode: "flow",
              selector: ".tox-mbtn",
              onEscape: (d) => (n.onEscape(d), A.some(!0))
            }),
            is.config({})
          ]),
          apis: l,
          domModification: {
            attributes: {
              role: "menubar"
            }
          }
        };
      },
      name: "silver.Menubar",
      configFields: [
        Ze("dom"),
        Ze("uid"),
        Ze("onEscape"),
        Ze("backstage"),
        we("onSetup", U)
      ],
      apis: {
        focus: (n, s) => {
          n.focus(s);
        },
        setMenus: (n, s, a) => {
          n.setMenus(s, a);
        }
      }
    });
    const zF = "💝 Get all features", VF = "https://www.tiny.cloud/tinymce-upgrade-to-cloud/?utm_campaign=self_hosted_upgrade_promo&utm_source=tiny&utm_medium=referral", SG = (n) => {
      const s = n.promotionLink ? [
        {
          dom: {
            tag: "a",
            attributes: {
              href: VF,
              rel: "noopener",
              target: "_blank",
              "aria-hidden": "true"
            },
            classes: ["tox-promotion-link"],
            innerHtml: zF
          }
        }
      ] : [];
      return {
        uid: n.uid,
        dom: n.dom,
        components: s
      };
    }, wG = (n) => {
      const { sidebars: s } = n.ui.registry.getAll();
      He(xo(s), (a) => {
        const l = s[a], d = () => uc(A.from(n.queryCommandValue("ToggleSidebar")), a);
        n.ui.registry.addToggleButton(a, {
          icon: l.icon,
          tooltip: l.tooltip,
          onAction: (g) => {
            n.execCommand("ToggleSidebar", !1, a), g.setActive(d());
          },
          onSetup: (g) => {
            g.setActive(d());
            const h = () => g.setActive(d());
            return n.on("ToggleSidebar", h), () => {
              n.off("ToggleSidebar", h);
            };
          },
          context: "any"
        });
      });
    }, du = (n) => ({
      element: () => n.element.dom
    }), EG = (n, s) => {
      const a = ye(xo(s), (l) => {
        const d = s[l], g = yi(vD(d));
        return {
          name: l,
          getApi: du,
          onSetup: g.onSetup,
          onShow: g.onShow,
          onHide: g.onHide
        };
      });
      return ye(a, (l) => {
        const d = Pt(U);
        return n.slot(l.name, {
          dom: {
            tag: "div",
            classes: ["tox-sidebar__pane"]
          },
          behaviours: dy.unnamedEvents([
            Hm(l, d),
            Ap(l, d),
            Ie(T2(), (g, h) => {
              const C = h.event;
              Lt(a, (T) => T.name === C.name).each((T) => {
                (C.visible ? T.onShow : T.onHide)(T.getApi(g));
              });
            })
          ])
        });
      });
    }, UF = (n) => ja.sketch((s) => ({
      dom: {
        tag: "div",
        classes: ["tox-sidebar__pane-container"]
      },
      components: EG(s, n),
      slotBehaviours: dy.unnamedEvents([
        hs((a) => ja.hideAllSlots(a))
      ])
    })), jF = (n, s, a) => {
      Fe.getCurrent(n).each((d) => {
        An.set(d, [UF(s)]);
        const g = a?.toLowerCase();
        De(g) && mo(s, g) && Fe.getCurrent(d).each((h) => {
          ja.showSlot(h, g), Kc.immediateGrow(d), Kn(d.element, "width"), z4(
            n.element,
            "region"
            /* SidebarStateRoleAttr.Grown */
          );
        });
      });
    }, z4 = (n, s) => {
      ln(n, "role", s);
    }, mS = (n, s) => {
      Fe.getCurrent(n).each((l) => {
        Fe.getCurrent(l).each((g) => {
          Kc.hasGrown(l) ? ja.isShowing(g, s) ? (Kc.shrink(l), z4(
            n.element,
            "presentation"
            /* SidebarStateRoleAttr.Shrunk */
          )) : (ja.hideAllSlots(g), ja.showSlot(g, s), z4(
            n.element,
            "region"
            /* SidebarStateRoleAttr.Grown */
          )) : (ja.hideAllSlots(g), ja.showSlot(g, s), Kc.grow(l), z4(
            n.element,
            "region"
            /* SidebarStateRoleAttr.Grown */
          ));
        });
      });
    }, TG = (n) => Fe.getCurrent(n).bind((a) => Kc.isGrowing(a) || Kc.hasGrown(a) ? Fe.getCurrent(a).bind((g) => Lt(ja.getSlotNames(g), (h) => ja.isShowing(g, h))) : A.none()), wy = Ct("FixSizeEvent"), WR = Ct("AutoSizeEvent"), V4 = (n) => ({
      uid: n.uid,
      dom: {
        tag: "div",
        classes: ["tox-sidebar"],
        attributes: {
          role: "presentation"
          /* SidebarStateRoleAttr.Shrunk */
        }
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-sidebar__slider"]
          },
          components: [
            // this will be replaced on setSidebar
          ],
          behaviours: nt([
            is.config({}),
            En.config({}),
            // TODO use Keying and use focusIn, but need to handle if sidebar contains nothing
            Kc.config({
              dimension: {
                property: "width"
              },
              closedClass: "tox-sidebar--sliding-closed",
              openClass: "tox-sidebar--sliding-open",
              shrinkingClass: "tox-sidebar--sliding-shrinking",
              growingClass: "tox-sidebar--sliding-growing",
              onShrunk: (s) => {
                Fe.getCurrent(s).each(ja.hideAllSlots), Wn(s, WR);
              },
              onGrown: (s) => {
                Wn(s, WR);
              },
              onStartGrow: (s) => {
                tn(s, wy, { width: Cs(s.element, "width").getOr("") });
              },
              onStartShrink: (s) => {
                tn(s, wy, { width: la(s.element) + "px" });
              }
            }),
            An.config({}),
            Fe.config({
              find: (s) => {
                const a = An.contents(s);
                return _o(a);
              }
            })
          ])
        }
      ],
      behaviours: nt([
        Gd.childAt(0),
        xn("sidebar-sliding-events", [
          Ie(wy, (s, a) => {
            gn(s.element, "width", a.event.width);
          }),
          Ie(WR, (s, a) => {
            Kn(s.element, "width");
          })
        ])
      ])
    }), kG = (n) => (s, a) => ({
      dom: {
        tag: "div",
        attributes: {
          "aria-label": n.translate("Loading..."),
          tabindex: "0"
        },
        classes: ["tox-throbber__busy-spinner"]
      },
      components: [
        {
          dom: Dm('<div class="tox-spinner"><div></div><div></div><div></div></div>')
        }
      ]
    }), WF = (n) => Fe.getCurrent(n).each((s) => $r(s.element, !0)), ed = (n, s) => {
      const a = "tabindex", l = `data-mce-${a}`;
      A.from(n.iframeElement).map(at.fromDom).each((d) => {
        s ? (Qr(d, a).each((g) => ln(d, l, g)), ln(d, a, -1)) : (fs(d, a), Qr(d, l).each((g) => {
          ln(d, a, g), fs(d, l);
        }));
      });
    }, AG = (n, s, a, l) => {
      const d = s.element;
      if (ed(n, a), a)
        Ge.block(s, kG(l)), Kn(d, "display"), fs(d, "aria-hidden"), n.hasFocus() && WF(s);
      else {
        const g = Fe.getCurrent(s).exists((h) => Bl(h.element));
        Ge.unblock(s), gn(d, "display", "none"), ln(d, "aria-hidden", "true"), g && n.focus();
      }
    }, U4 = (n) => ({
      uid: n.uid,
      dom: {
        tag: "div",
        attributes: {
          "aria-hidden": "true"
        },
        classes: ["tox-throbber"],
        styles: {
          display: "none"
        }
      },
      behaviours: nt([
        An.config({}),
        Ge.config({
          focus: !1
        }),
        Fe.config({
          find: (s) => _o(s.components())
        })
      ]),
      components: []
    }), ZF = (n) => n.type === "focusin", GF = (n) => ZF(n) ? (n.composed ? _o(n.composedPath()) : A.from(n.target)).map(at.fromDom).filter(mc).exists((a) => ar(a, "mce-pastebin")) : !1, _G = (n, s, a) => {
      const l = Pt(!1), d = hn(), g = (C) => {
        l.get() && !GF(C) && (C.preventDefault(), WF(s()), n.editorManager.setActive(n));
      };
      n.inline || n.on("PreInit", () => {
        n.dom.bind(n.getWin(), "focusin", g), n.on("BeforeExecCommand", (C) => {
          C.command.toLowerCase() === "mcefocus" && C.value !== !0 && g(C);
        });
      });
      const h = (C) => {
        C !== l.get() && (l.set(C), AG(n, s(), C, a.providers), sW(n, C));
      };
      n.on("ProgressState", (C) => {
        if (d.on(clearTimeout), In(C.time)) {
          const x = RT.setEditorTimeout(n, () => h(C.state), C.time);
          d.set(x);
        } else
          h(C.state), d.clear();
      });
    }, ZR = (n) => {
      const s = n.label.isNone() ? n.title.fold(() => ({}), (a) => ({ attributes: { "aria-label": a } })) : n.label.fold(() => ({}), (a) => ({ attributes: { "aria-label": a } }));
      return {
        dom: {
          tag: "div",
          classes: ["tox-toolbar__group"].concat(n.label.isSome() ? ["tox-toolbar__group_with_label"] : []),
          ...s
        },
        components: [
          ...n.label.map((a) => ({
            dom: {
              tag: "span",
              classes: ["tox-label", "tox-label--context-toolbar"]
            },
            components: [xs(a)]
          })).toArray(),
          OT.parts.items({})
        ],
        items: n.items,
        markers: {
          // nav within a group breaks if disabled buttons are first in their group so skip them
          itemSelector: ".tox-tbtn:not([disabled]), .tox-toolbar-nav-item:not([disabled]), .tox-number-input:not([disabled])"
        },
        tgroupBehaviours: nt([
          is.config({}),
          En.config({
            ignore: !0
          })
        ])
      };
    }, j4 = (n) => OT.sketch(ZR(n)), qF = (n, s) => {
      const a = hs((l) => {
        const d = ye(n.initGroups, j4);
        Rm.setGroups(l, d);
      });
      return nt([
        Lm.toolbarButton(() => n.providers.checkUiComponentContext("any").shouldDisable),
        yr(() => n.providers.checkUiComponentContext("any")),
        Xt.config({
          // Tabs between groups
          mode: s,
          onEscape: n.onEscape,
          visibilitySelector: ".tox-toolbar__overflow",
          selector: ".tox-toolbar__group"
        }),
        xn("toolbar-events", [a])
      ]);
    }, KF = (n) => {
      const s = n.cyclicKeying ? "cyclic" : "acyclic";
      return {
        uid: n.uid,
        dom: {
          tag: "div",
          classes: ["tox-toolbar-overlord"]
        },
        parts: {
          // This already knows it is a toolbar group
          "overflow-group": ZR({
            title: A.none(),
            label: A.none(),
            items: []
          }),
          "overflow-button": oF({
            context: "any",
            icon: A.some("more-drawer"),
            enabled: !0,
            tooltip: A.some("Reveal or hide additional toolbar items")
          }, A.none(), n.providers, [], "overflow-button")
        },
        splitToolbarBehaviours: qF(n, s)
      };
    }, OG = (n) => {
      const s = KF(n), a = 4, l = yB.parts.primary({
        dom: {
          tag: "div",
          classes: ["tox-toolbar__primary"]
        }
      });
      return yB.sketch({
        ...s,
        lazySink: n.getSink,
        getOverflowBounds: () => {
          const d = n.moreDrawerData.lazyHeader().element, g = cf(d), h = Zp(d), C = cf(h), x = Math.max(h.dom.scrollHeight, C.height);
          return Rr(g.x + a, C.y, g.width - a * 2, x);
        },
        parts: {
          ...s.parts,
          overflow: {
            dom: {
              tag: "div",
              classes: ["tox-toolbar__overflow"],
              attributes: n.attributes
            }
          }
        },
        components: [l],
        markers: {
          overflowToggledClass: "tox-tbtn--enabled"
          /* ToolbarButtonClasses.Ticked */
        },
        onOpened: (d) => n.onToggled(d, !0),
        onClosed: (d) => n.onToggled(d, !1)
      });
    }, DG = (n) => {
      const s = X_.parts.primary({
        dom: {
          tag: "div",
          classes: ["tox-toolbar__primary"]
        }
      }), a = X_.parts.overflow({
        dom: {
          tag: "div",
          classes: ["tox-toolbar__overflow"]
        }
      }), l = KF(n);
      return X_.sketch({
        ...l,
        components: [s, a],
        markers: {
          openClass: "tox-toolbar__overflow--open",
          closedClass: "tox-toolbar__overflow--closed",
          growingClass: "tox-toolbar__overflow--growing",
          shrinkingClass: "tox-toolbar__overflow--shrinking",
          overflowToggledClass: "tox-tbtn--enabled"
          /* ToolbarButtonClasses.Ticked */
        },
        onOpened: (d) => {
          d.getSystem().broadcastOn([VR()], { type: "opened" }), n.onToggled(d, !0);
        },
        onClosed: (d) => {
          d.getSystem().broadcastOn([VR()], { type: "closed" }), n.onToggled(d, !1);
        }
      });
    }, W4 = (n) => {
      const s = n.cyclicKeying ? "cyclic" : "acyclic";
      return Rm.sketch({
        uid: n.uid,
        dom: {
          tag: "div",
          classes: ["tox-toolbar"].concat(n.type === lu.scrolling ? ["tox-toolbar--scrolling"] : [])
        },
        components: [
          Rm.parts.groups({})
        ],
        toolbarBehaviours: qF(n, s)
      });
    }, RG = (n, s) => {
      const a = n.type === "togglebutton", l = n.icon.map((Y) => Np(Y, s.icons)).map(To), g = (Y) => {
        const le = (gt) => {
          l.map((Ue) => Ue.getOpt(Y).each((Qe) => {
            An.set(Qe, [
              Np(gt, s.icons)
            ]);
          }));
        }, pe = (gt) => {
          const Ue = Y.element;
          gt ? (Uo(
            Ue,
            "tox-button--enabled"
            /* ViewButtonClasses.Ticked */
          ), ln(Ue, "aria-pressed", !0)) : (Ds(
            Ue,
            "tox-button--enabled"
            /* ViewButtonClasses.Ticked */
          ), fs(Ue, "aria-pressed"));
        }, Ee = () => ar(
          Y.element,
          "tox-button--enabled"
          /* ViewButtonClasses.Ticked */
        ), Oe = () => $r(Y.element);
        if (a)
          return n.onAction({ setIcon: le, setActive: pe, isActive: Ee, focus: Oe });
        if (n.type === "button")
          return n.onAction({ setIcon: le });
      }, h = {
        ...n,
        name: a ? n.text.getOr(n.icon.getOr("")) : n.text ?? n.icon.getOr(""),
        primary: n.buttonType === "primary",
        buttonType: A.from(n.buttonType),
        tooltip: n.tooltip,
        icon: n.icon,
        enabled: !0,
        borderless: n.borderless
      }, C = TR(n.buttonType ?? "secondary"), x = a ? n.text.map(s.translate) : A.some(s.translate(n.text)), T = x.map(xs), _ = h.tooltip.or(x).map((Y) => ({
        "aria-label": s.translate(Y)
      })).getOr({}), N = l.map((Y) => Y.asSpec()), L = zf([N, T]), j = n.icon.isSome() && T.isSome(), Z = {
        tag: "button",
        classes: C.concat(...n.icon.isSome() && !j ? ["tox-button--icon"] : []).concat(...j ? ["tox-button--icon-and-text"] : []).concat(...n.borderless ? ["tox-button--naked"] : []).concat(...n.type === "togglebutton" && n.active ? [
          "tox-button--enabled"
          /* ViewButtonClasses.Ticked */
        ] : []),
        attributes: _
      }, ne = [], ae = P4(h, A.some(g), ne, Z, L, n.tooltip, s);
      return oa.sketch(ae);
    }, GR = (n, s) => RG(n, s), YF = (n, s) => ({
      dom: {
        tag: "div",
        classes: ["tox-view__toolbar__group"]
      },
      components: ye(n.buttons, (a) => GR(a, s))
    }), qR = Zs().deviceType, NG = qR.isPhone(), XF = qR.isTablet(), MG = (n) => {
      let s = !1;
      const a = ye(n.buttons, (l) => l.type === "group" ? (s = !0, YF(l, n.providers)) : GR(l, n.providers));
      return {
        uid: n.uid,
        dom: {
          tag: "div",
          classes: [
            s ? "tox-view__toolbar" : "tox-view__header",
            ...NG || XF ? ["tox-view--mobile", "tox-view--scrolling"] : []
          ]
        },
        behaviours: nt([
          En.config({}),
          Xt.config({
            mode: "flow",
            selector: "button, .tox-button",
            focusInside: Tg.OnEnterOrSpaceMode
          })
        ]),
        components: s ? a : [
          Am.sketch({
            dom: {
              tag: "div",
              classes: ["tox-view__header-start"]
            },
            components: []
          }),
          Am.sketch({
            dom: {
              tag: "div",
              classes: ["tox-view__header-end"]
            },
            components: a
          })
        ]
      };
    }, PG = (n) => ({
      uid: n.uid,
      behaviours: nt([
        En.config({}),
        is.config({})
      ]),
      dom: {
        tag: "div",
        classes: ["tox-view__pane"]
      }
    }), QF = (n, s, a, l) => {
      const d = {
        getPane: (g) => ma.getPart(g, n, "pane"),
        getOnShow: (g) => n.viewConfig.onShow,
        getOnHide: (g) => n.viewConfig.onHide
      };
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        behaviours: nt([
          En.config({}),
          Xt.config({
            mode: "cyclic",
            focusInside: Tg.OnEnterOrSpaceMode
          })
        ]),
        apis: d
      };
    };
    var Hb = yl({
      name: "silver.View",
      configFields: [
        Ze("viewConfig")
      ],
      partFields: [
        Ec({
          factory: {
            sketch: MG
          },
          schema: [
            Ze("buttons"),
            Ze("providers")
          ],
          name: "header"
        }),
        Ec({
          factory: {
            sketch: PG
          },
          schema: [],
          name: "pane"
        })
      ],
      factory: QF,
      apis: {
        getPane: (n, s) => n.getPane(s),
        getOnShow: (n, s) => n.getOnShow(s),
        getOnHide: (n, s) => n.getOnHide(s)
      }
    });
    const JF = (n, s, a) => rs(s, (l, d) => {
      const g = yi(Uj(l));
      return n.slot(d, Hb.sketch({
        dom: {
          tag: "div",
          classes: ["tox-view"]
        },
        viewConfig: g,
        components: [
          ...g.buttons.length > 0 ? [
            Hb.parts.header({
              buttons: g.buttons,
              providers: a
            })
          ] : [],
          Hb.parts.pane({})
        ]
      }));
    }), BG = (n, s) => ja.sketch((a) => ({
      dom: {
        tag: "div",
        classes: ["tox-view-wrap__slot-container"]
      },
      components: JF(a, n, s),
      slotBehaviours: dy.unnamedEvents([
        hs((l) => ja.hideAllSlots(l))
      ])
    })), e8 = (n) => Lt(ja.getSlotNames(n), (s) => ja.isShowing(n, s)), $G = (n) => {
      const s = n.element;
      gn(s, "display", "none"), ln(s, "aria-hidden", "true");
    }, t8 = (n) => {
      const s = n.element;
      Kn(s, "display"), fs(s, "aria-hidden");
    }, IG = (n) => ({
      getContainer: oe(n)
    }), n8 = (n, s, a) => {
      ja.getSlot(n, s).each((l) => {
        Hb.getPane(l).each((d) => {
          a(l)(IG(d.element.dom));
        });
      });
    }, FG = (n, s) => n8(n, s, Hb.getOnShow), LG = (n, s) => n8(n, s, Hb.getOnHide);
    var Z4 = su({
      factory: (n, s) => {
        const g = {
          setViews: (h, C) => {
            An.set(h, [BG(C, s.backstage.shared.providers)]);
          },
          whichView: (h) => Fe.getCurrent(h).bind(e8),
          toggleView: (h, C, x, T) => Fe.getCurrent(h).exists((_) => {
            const N = e8(_), L = N.exists((Z) => T === Z), j = ja.getSlot(_, T).isSome();
            return j && (ja.hideAllSlots(_), L ? ($G(h), C()) : (x(), t8(h), ja.showSlot(_, T), FG(_, T)), N.each((Z) => LG(_, Z))), j;
          })
        };
        return {
          uid: n.uid,
          dom: {
            tag: "div",
            classes: ["tox-view-wrap"],
            attributes: { "aria-hidden": "true" },
            styles: { display: "none" }
          },
          components: [
            // this will be replaced on setViews
          ],
          behaviours: nt([
            An.config({}),
            Fe.config({
              find: (h) => {
                const C = An.contents(h);
                return _o(C);
              }
            })
          ]),
          apis: g
        };
      },
      name: "silver.ViewWrapper",
      configFields: [
        Ze("backstage")
      ],
      apis: {
        setViews: (n, s, a) => n.setViews(s, a),
        toggleView: (n, s, a, l, d) => n.toggleView(s, a, l, d),
        whichView: (n, s) => n.whichView(s)
      }
    });
    const HG = (n, s, a) => {
      let l = !1;
      const d = (h) => {
        t2(h, ".tox-statusbar").each((C) => {
          gs(C, "display") === "none" && Dr(C, "aria-hidden") === "true" ? (Kn(C, "display"), fs(C, "aria-hidden")) : (gn(C, "display", "none"), ln(C, "aria-hidden", "true"));
        });
      }, g = {
        getSocket: (h) => ma.getPart(h, n, "socket"),
        setSidebar: (h, C, x) => {
          ma.getPart(h, n, "sidebar").each((T) => jF(T, C, x));
        },
        toggleSidebar: (h, C) => {
          ma.getPart(h, n, "sidebar").each((x) => mS(x, C));
        },
        whichSidebar: (h) => ma.getPart(h, n, "sidebar").bind(TG).getOrNull(),
        getHeader: (h) => ma.getPart(h, n, "header"),
        getToolbar: (h) => ma.getPart(h, n, "toolbar"),
        setToolbar: (h, C) => {
          ma.getPart(h, n, "toolbar").each((x) => {
            const T = ye(C, j4);
            x.getApis().setGroups(x, T);
          });
        },
        setToolbars: (h, C) => {
          ma.getPart(h, n, "multiple-toolbar").each((x) => {
            const T = ye(C, (_) => ye(_, j4));
            YM.setItems(x, T);
          });
        },
        refreshToolbar: (h) => {
          ma.getPart(h, n, "toolbar").each((x) => x.getApis().refresh(x));
        },
        toggleToolbarDrawer: (h) => {
          ma.getPart(h, n, "toolbar").each((C) => {
            tl(C.getApis().toggle, (x) => x(C));
          });
        },
        toggleToolbarDrawerWithoutFocusing: (h) => {
          ma.getPart(h, n, "toolbar").each((C) => {
            tl(C.getApis().toggleWithoutFocusing, (x) => x(C));
          });
        },
        isToolbarDrawerToggled: (h) => ma.getPart(h, n, "toolbar").bind((C) => A.from(C.getApis().isOpen).map((x) => x(C))).getOr(!1),
        getThrobber: (h) => ma.getPart(h, n, "throbber"),
        focusToolbar: (h) => {
          ma.getPart(h, n, "toolbar").orThunk(() => ma.getPart(h, n, "multiple-toolbar")).each((x) => {
            Xt.focusIn(x);
          });
        },
        setMenubar: (h, C) => {
          ma.getPart(h, n, "menubar").each((x) => {
            HF.setMenus(x, C);
          });
        },
        focusMenubar: (h) => {
          ma.getPart(h, n, "menubar").each((C) => {
            HF.focus(C);
          });
        },
        setViews: (h, C) => {
          ma.getPart(h, n, "viewWrapper").each((x) => {
            Z4.setViews(x, C);
          });
        },
        toggleView: (h, C) => ma.getPart(h, n, "viewWrapper").exists((x) => Z4.toggleView(x, () => g.showMainView(h), () => g.hideMainView(h), C)),
        whichView: (h) => ma.getPart(h, n, "viewWrapper").bind(Z4.whichView).getOrNull(),
        hideMainView: (h) => {
          l = g.isToolbarDrawerToggled(h), l && g.toggleToolbarDrawer(h), ma.getPart(h, n, "editorContainer").each((C) => {
            const x = C.element;
            d(x), gn(x, "display", "none"), ln(x, "aria-hidden", "true");
          });
        },
        showMainView: (h) => {
          l && g.toggleToolbarDrawer(h), ma.getPart(h, n, "editorContainer").each((C) => {
            const x = C.element;
            d(x), Kn(x, "display"), fs(x, "aria-hidden");
          });
        }
      };
      return {
        uid: n.uid,
        dom: n.dom,
        components: s,
        apis: g,
        behaviours: n.behaviours
      };
    }, zG = au.optional({
      factory: HF,
      name: "menubar",
      schema: [
        Ze("backstage")
      ]
    }), VG = (n) => n.type === lu.sliding ? DG : n.type === lu.floating ? OG : W4, UG = au.optional({
      factory: {
        sketch: (n) => YM.sketch({
          uid: n.uid,
          dom: n.dom,
          listBehaviours: nt([
            Xt.config({
              mode: "acyclic",
              selector: ".tox-toolbar"
            })
          ]),
          makeItem: () => W4({
            type: n.type,
            uid: Ct("multiple-toolbar-item"),
            cyclicKeying: !1,
            initGroups: [],
            providers: n.providers,
            onEscape: () => (n.onEscape(), A.some(!0))
          }),
          setupItem: (s, a, l, d) => {
            Rm.setGroups(a, l);
          },
          shell: !0
        })
      },
      name: "multiple-toolbar",
      schema: [
        Ze("dom"),
        Ze("onEscape")
      ]
    }), KR = au.optional({
      factory: {
        sketch: (n) => {
          const s = VG(n), a = {
            type: n.type,
            uid: n.uid,
            onEscape: () => (n.onEscape(), A.some(!0)),
            onToggled: (l, d) => n.onToolbarToggled(d),
            cyclicKeying: !1,
            initGroups: [],
            getSink: n.getSink,
            providers: n.providers,
            moreDrawerData: {
              lazyToolbar: n.lazyToolbar,
              lazyMoreButton: n.lazyMoreButton,
              lazyHeader: n.lazyHeader
            },
            attributes: n.attributes
          };
          return s(a);
        }
      },
      name: "toolbar",
      schema: [
        Ze("dom"),
        Ze("onEscape"),
        Ze("getSink")
      ]
    }), jG = au.optional({
      factory: {
        sketch: xG
      },
      name: "header",
      schema: [
        Ze("dom")
      ]
    }), WG = au.optional({
      factory: {
        sketch: SG
      },
      name: "promotion",
      schema: [
        Ze("dom"),
        Ze("promotionLink")
      ]
    }), o8 = au.optional({
      // factory: Fun.identity,
      name: "socket",
      schema: [
        Ze("dom")
      ]
    }), s8 = au.optional({
      factory: {
        sketch: V4
      },
      name: "sidebar",
      schema: [
        Ze("dom")
      ]
    }), ZG = au.optional({
      factory: {
        sketch: U4
      },
      name: "throbber",
      schema: [
        Ze("dom")
      ]
    }), GG = au.optional({
      factory: Z4,
      name: "viewWrapper",
      schema: [
        Ze("backstage")
      ]
    }), qG = (n) => ({
      uid: n.uid,
      dom: {
        tag: "div",
        classes: ["tox-editor-container"]
      },
      components: n.components
    }), KG = au.optional({
      factory: {
        sketch: qG
      },
      name: "editorContainer",
      schema: []
    });
    var es = yl({
      name: "OuterContainer",
      factory: HG,
      configFields: [
        Ze("dom"),
        Ze("behaviours")
      ],
      partFields: [
        jG,
        zG,
        KR,
        UG,
        o8,
        s8,
        WG,
        ZG,
        GG,
        KG
      ],
      apis: {
        getSocket: (n, s) => n.getSocket(s),
        setSidebar: (n, s, a, l) => {
          n.setSidebar(s, a, l);
        },
        toggleSidebar: (n, s, a) => {
          n.toggleSidebar(s, a);
        },
        whichSidebar: (n, s) => n.whichSidebar(s),
        getHeader: (n, s) => n.getHeader(s),
        getToolbar: (n, s) => n.getToolbar(s),
        setToolbar: (n, s, a) => {
          n.setToolbar(s, a);
        },
        setToolbars: (n, s, a) => {
          n.setToolbars(s, a);
        },
        refreshToolbar: (n, s) => n.refreshToolbar(s),
        toggleToolbarDrawer: (n, s) => {
          n.toggleToolbarDrawer(s);
        },
        toggleToolbarDrawerWithoutFocusing: (n, s) => {
          n.toggleToolbarDrawerWithoutFocusing(s);
        },
        isToolbarDrawerToggled: (n, s) => n.isToolbarDrawerToggled(s),
        getThrobber: (n, s) => n.getThrobber(s),
        // FIX: Dupe
        setMenubar: (n, s, a) => {
          n.setMenubar(s, a);
        },
        focusMenubar: (n, s) => {
          n.focusMenubar(s);
        },
        focusToolbar: (n, s) => {
          n.focusToolbar(s);
        },
        setViews: (n, s, a) => {
          n.setViews(s, a);
        },
        toggleView: (n, s, a) => n.toggleView(s, a),
        whichView: (n, s) => n.whichView(s)
      }
    });
    const YG = "file edit view insert format tools table help", YR = {
      file: { title: "File", items: "newdocument restoredraft | preview | importword exportpdf exportword | export print | deleteallconversations" },
      edit: { title: "Edit", items: "undo redo | cut copy paste pastetext | selectall | searchreplace" },
      view: { title: "View", items: "code suggestededits revisionhistory | visualaid visualchars visualblocks | spellchecker | preview fullscreen | showcomments" },
      insert: { title: "Insert", items: "image video link media addcomment pageembed inserttemplate codesample inserttable accordion math | charmap emoticons hr | pagebreak nonbreaking anchor tableofcontents footnotes | mergetags | insertdatetime" },
      format: { title: "Format", items: "bold italic underline strikethrough superscript subscript codeformat | styles blocks fontfamily fontsize align lineheight | forecolor backcolor | language | removeformat" },
      tools: { title: "Tools", items: "aidialog aishortcuts | spellchecker spellcheckerlanguage | autocorrect capitalization | a11ycheck code typography wordcount addtemplate" },
      table: { title: "Table", items: "inserttable | cell row column | advtablesort | tableprops deletetable" },
      help: { title: "Help", items: "help" }
    }, G4 = (n, s, a) => {
      const l = NB(a).split(/[ ,]/);
      return {
        text: n.title,
        getItems: () => xe(n.items, (d) => {
          const g = d.toLowerCase();
          return g.trim().length === 0 ? [] : cn(l, (h) => h === g) ? [] : g === "separator" || g === "|" ? [{
            type: "separator"
          }] : s.menuItems[g] ? [s.menuItems[g]] : [];
        })
      };
    }, fS = (n) => n.split(" "), r8 = (n, s) => {
      const a = { ...YR, ...s.menus }, l = xo(s.menus).length > 0, d = s.menubar === void 0 || s.menubar === !0 ? fS(YG) : fS(s.menubar === !1 ? "" : s.menubar), g = Ln(d, (C) => {
        const x = mo(YR, C);
        return l ? x || Vt(s.menus, C).exists((T) => mo(T, "items")) : x;
      }), h = ye(g, (C) => {
        const x = a[C];
        return G4({ title: x.title, items: fS(x.items) }, s, n);
      });
      return Ln(h, (C) => {
        const x = (T) => De(T) || T.type !== "separator";
        return C.getItems().length > 0 && cn(C.getItems(), x);
      });
    }, XG = (n) => {
      const s = () => {
        n._skinLoaded = !0, D$(n);
      };
      return () => {
        n.initialized ? s() : n.on("init", s);
      };
    }, a8 = (n, s) => () => u4(n, { message: s }), QG = (n) => {
      const s = kx(n);
      return s ? A.from(s) : A.none();
    }, c8 = (n, s, a) => (n.on("remove", () => a.unload(s)), a.load(s)), q4 = (n, s, a, l) => (n.on("remove", () => l.unloadRawCss(s)), l.loadRawCss(s, a)), l8 = (n, s) => "ui/" + n + "/" + s, JG = (n) => A.from(tinymce.Resource.get(n)).filter(De), XR = (n, s, a = "") => {
      const l = QG(n).map((g) => l8(g, `${s}.css`)), d = l.bind(JG);
      return $a(l, d, (g, h) => ({ _kind: "load-raw", key: g, css: h })).getOrThunk(() => {
        const g = n.editorManager.suffix;
        return { _kind: "load-stylesheet", url: a + `/${s}${g}.css` };
      });
    }, QR = (n, s) => {
      const a = n.ui.styleSheetLoader, l = XR(n, "skin", s);
      switch (l._kind) {
        case "load-raw":
          const { key: d, css: g } = l;
          return q4(n, d, g, a), Promise.resolve();
        case "load-stylesheet":
          const { url: h } = l;
          return c8(n, h, a);
        default:
          return Promise.resolve();
      }
    }, eq = (n, s) => {
      if (li(at.fromDom(n.getElement()))) {
        const l = qv.DOM.styleSheetLoader, d = XR(n, "skin.shadowdom", s);
        switch (d._kind) {
          case "load-raw":
            const { key: g, css: h } = d;
            return q4(n, g, h, l), Promise.resolve();
          case "load-stylesheet":
            const { url: C } = d;
            return c8(n, C, l);
          default:
            return Promise.resolve();
        }
      } else
        return Promise.resolve();
    }, tq = (n, s, a) => {
      const d = XR(n, s ? "content.inline" : "content", a);
      switch (d._kind) {
        case "load-raw":
          const { key: g, css: h } = d;
          return s ? q4(n, g, h, n.ui.styleSheetLoader) : n.on("PostRender", () => {
            q4(n, g, h, n.dom.styleSheetLoader);
          }), Promise.resolve();
        case "load-stylesheet":
          const { url: C } = d;
          return a && n.contentCSS.push(C), Promise.resolve();
        default:
          return Promise.resolve();
      }
    }, i8 = async (n, s) => {
      const a = fO(s);
      if (await tq(s, n, a), !Ax(s) && De(a))
        return Promise.all([
          QR(s, a),
          eq(s, a)
        ]).then();
    }, u8 = (n, s) => i8(n, s).then(XG(s), a8(s, "Skin could not be loaded")), d8 = jt(u8, !1), nq = jt(u8, !0), JR = (n) => ({
      isEnabled: () => !Ft.isDisabled(n),
      setEnabled: (s) => Ft.set(n, !s),
      setText: (s) => tn(n, Ju, {
        text: s
      }),
      setIcon: (s) => tn(n, Lb, {
        icon: s
      })
    }), oq = (n) => ({
      setActive: (s) => {
        eo.set(n, s);
      },
      isActive: () => eo.isOn(n),
      isEnabled: () => !Ft.isDisabled(n),
      setEnabled: (s) => Ft.set(n, !s),
      setText: (s) => tn(n, Ju, {
        text: s
      }),
      setIcon: (s) => tn(n, Lb, {
        icon: s
      })
    }), sq = (n, s) => n.map((a) => ({
      "aria-label": s.translate(a)
    })).getOr({}), rq = Ct("focus-button"), K4 = (n, s, a, l, d, g, h) => {
      const C = s.map((T) => To(vR(T, "tox-tbtn", d))), x = n.map((T) => To(Np(T, d.icons)));
      return {
        dom: {
          tag: "button",
          classes: [
            "tox-tbtn"
            /* ToolbarButtonClasses.Button */
          ].concat(s.isSome() ? [
            "tox-tbtn--select"
            /* ToolbarButtonClasses.MatchWidth */
          ] : []),
          attributes: {
            ...sq(a, d),
            ...un(h) ? { "data-mce-name": h } : {}
          }
        },
        components: zf([
          x.map((T) => T.asSpec()),
          C.map((T) => T.asSpec())
        ]),
        eventOrder: {
          [Zc()]: [
            "focusing",
            "alloy.base.behaviour",
            Wf
          ],
          [Mu()]: [Wf, "toolbar-group-button-events"],
          [Ci()]: [Wf, "toolbar-group-button-events", "tooltipping"]
        },
        buttonBehaviours: nt([
          Lm.toolbarButton(() => d.checkUiComponentContext(g).shouldDisable),
          yr(() => d.checkUiComponentContext(g)),
          xn(Wf, [
            hs((T, _) => O4(T)),
            Ie(Ju, (T, _) => {
              C.bind((N) => N.getOpt(T)).each((N) => {
                An.set(N, [xs(d.translate(_.event.text))]);
              });
            }),
            Ie(Lb, (T, _) => {
              x.bind((N) => N.getOpt(T)).each((N) => {
                An.set(N, [Np(_.event.icon, d.icons)]);
              });
            }),
            Ie(Zc(), (T, _) => {
              _.event.prevent(), Wn(T, rq);
            })
          ])
        ].concat(l.getOr([])))
      };
    }, aq = (n, s, a, l, d) => {
      const g = s.shared, h = Pt(U), C = {
        toolbarButtonBehaviours: [],
        getApi: JR,
        onSetup: n.onSetup
      }, x = [
        xn("toolbar-group-button-events", [
          Hm(C, h),
          Ap(C, h)
        ]),
        ...n.tooltip.map((T) => ps.config(s.shared.providers.tooltips.getConfig({
          tooltipText: s.shared.providers.translate(T)
        }))).toArray()
      ];
      return Kg.sketch({
        lazySink: g.getSink,
        fetch: () => Zo.nu((T) => {
          T(ye(a(n.items), j4));
        }),
        markers: {
          toggledClass: "tox-tbtn--enabled"
          /* ToolbarButtonClasses.Ticked */
        },
        parts: {
          button: K4(n.icon, n.text, n.tooltip, A.some(x), g.providers, n.context, d),
          toolbar: {
            dom: {
              tag: "div",
              classes: ["tox-toolbar__overflow"],
              attributes: l
            }
          }
        }
      });
    }, m8 = (n, s, a, l) => {
      const d = Pt(U), g = K4(n.icon, n.text, n.tooltip, A.none(), a, n.context, l);
      return oa.sketch({
        dom: g.dom,
        components: g.components,
        eventOrder: pR,
        buttonBehaviours: {
          ...nt([
            xn("toolbar-button-events", [
              aZ({
                onAction: n.onAction,
                getApi: s.getApi
              }),
              Hm(s, d),
              Ap(s, d)
            ]),
            ...n.tooltip.map((h) => ps.config(a.tooltips.getConfig({
              tooltipText: a.translate(h) + n.shortcut.map((C) => ` (${ED(C)})`).getOr("")
            }))).toArray(),
            // Enable toolbar buttons by default
            Lm.toolbarButton(() => !n.enabled || a.checkUiComponentContext(n.context).shouldDisable),
            yr(() => a.checkUiComponentContext(n.context))
          ].concat(s.toolbarButtonBehaviours)),
          // Here we add the commonButtonDisplayEvent behaviour from the structure so we can listen
          // to updateMenuIcon and updateMenuText events and run the defined callbacks as they are
          // defined in the renderCommonStructure function and fix the size of the button onAttached.
          [Wf]: g.buttonBehaviours?.[Wf]
        }
      });
    }, cq = (n, s, a) => gS(n, s, [], a), gS = (n, s, a, l) => m8(n, {
      toolbarButtonBehaviours: a.length > 0 ? [
        // TODO: May have to pass through eventOrder if events start clashing
        xn("toolbarButtonWith", a)
      ] : [],
      getApi: JR,
      onSetup: n.onSetup
    }, s, l), eN = (n, s, a) => f8(n, s, [], a), f8 = (n, s, a, l) => m8(n, {
      toolbarButtonBehaviours: [
        An.config({}),
        eo.config({ toggleClass: "tox-tbtn--enabled", aria: { mode: "pressed" }, toggleOnExecute: !1 })
      ].concat(a.length > 0 ? [
        // TODO: May have to pass through eventOrder if events start clashing
        xn("toolbarToggleButtonWith", a)
      ] : []),
      getApi: oq,
      onSetup: n.onSetup
    }, s, l), lq = (n, s, a) => (l) => Zo.nu((d) => s.fetch(d)).map((d) => A.from(rR(Ho(v4(Ct("menu-value"), d, (g) => {
      s.onItemAction(n(l), g);
    }, s.columns, s.presets, Wd.CLOSE_ON_EXECUTE, s.select.getOr(an), a), {
      movement: Dp(s.columns, s.presets),
      menuBehaviours: dy.unnamedEvents(s.columns !== "auto" ? [] : [
        hs((g, h) => {
          xD(g, 4, BO(s.presets)).each(({ numRows: C, numColumns: x }) => {
            Xt.setGridSize(g, C, x);
          });
        })
      ])
    })))), iq = (n, s, a) => (l) => {
      const d = l.getSystem(), g = l.element, h = () => {
        const x = ar(g, "tox-split-button__chevron"), T = x ? Ic(g).bind((N) => d.getByDom(N).toOptional()) : A.some(l), _ = x ? A.some(l) : Kp(g).bind((N) => d.getByDom(N).toOptional().filter((L) => ar(L.element, "tox-split-button__chevron")));
        return { mainOpt: T, chevronOpt: _ };
      }, C = (x) => {
        const { mainOpt: T, chevronOpt: _ } = h();
        T.each(x), _.each(x);
      };
      return {
        isEnabled: () => {
          const { mainOpt: x } = h();
          return x.exists((T) => !Ft.isDisabled(T));
        },
        setEnabled: (x) => C((T) => Ft.set(T, !x)),
        setText: (x) => {
          const { mainOpt: T } = h();
          T.each((_) => tn(_, Ju, { text: x }));
        },
        setIcon: (x) => {
          const { mainOpt: T } = h();
          T.each((_) => tn(_, Lb, { icon: x }));
        },
        setIconFill: (x, T) => C((_) => {
          Po(_.element, `svg path[class="${x}"], rect[class="${x}"]`).each((N) => {
            ln(N, "fill", T);
          });
        }),
        isActive: () => {
          const { mainOpt: x } = h();
          return x.exists((T) => eo.isOn(T));
        },
        setActive: (x) => {
          const { mainOpt: T } = h();
          T.each((_) => eo.set(_, x));
        },
        setTooltip: (x) => {
          n.set(x);
          const { mainOpt: T, chevronOpt: _ } = h();
          T.each((L) => ln(L.element, "aria-label", s.providers.translate(x)));
          const N = a.chevronTooltip.map((L) => s.providers.translate(L)).getOr(s.providers.translate(x));
          _.each((L) => ln(L.element, "aria-label", N));
        }
      };
    }, uq = (n, s, a) => {
      const l = Pt(U), d = Pt(n.tooltip.getOr("")), g = iq(d, s, n), h = Ct("tox-split-menu"), C = Pt(!1), x = () => ({
        "aria-haspopup": "menu",
        "aria-expanded": String(C.get()),
        "aria-controls": h
      }), T = () => n.tooltip.map((ne) => s.providers.translate(ne)).getOr(s.providers.translate("Text color")), _ = () => n.chevronTooltip.map((ne) => s.providers.translate(ne)).getOrThunk(() => {
        const ne = T();
        return s.providers.translate(["{0} menu", ne]);
      }), N = (ne, ae) => {
        C.set(ne), ln(ae.element, "aria-expanded", String(ne));
      }, L = Kl.sketch({
        dom: {
          tag: "button",
          classes: ["tox-tbtn", "tox-split-button__chevron"],
          innerHtml: UV("chevron-down", s.providers.icons),
          attributes: {
            "aria-label": _(),
            ...un(a) ? { "data-mce-name": a + "-chevron" } : {},
            ...x()
          }
        },
        components: [],
        toggleClass: "tox-tbtn--enabled",
        dropdownBehaviours: nt([
          xn("split-dropdown-events", [
            hs((ne, ae) => O4(ne)),
            Hm({ getApi: g, onSetup: n.onSetup }, l),
            Ie("alloy-dropdown-open", (ne) => N(!0, ne)),
            Ie("alloy-dropdown-close", (ne) => N(!1, ne))
          ]),
          Lm.toolbarButton(() => s.providers.checkUiComponentContext(n.context).shouldDisable),
          yr(() => s.providers.checkUiComponentContext(n.context)),
          Om.config({}),
          ps.config(s.providers.tooltips.getConfig({
            tooltipText: _(),
            onShow: (ne) => {
              if (d.get() !== n.tooltip.getOr("")) {
                const ae = n.chevronTooltip.map((Y) => s.providers.translate(Y)).getOr(`${s.providers.translate(d.get())} menu`);
                ps.setComponents(ne, s.providers.tooltips.getComponents({ tooltipText: ae }));
              }
            }
          }))
        ]),
        lazySink: s.getSink,
        fetch: lq(g, n, s.providers),
        getHotspot: (ne) => Ic(ne.element).bind((ae) => ne.getSystem().getByDom(ae).toOptional()),
        onOpen: (ne, ae, Y) => {
          So.highlightBy(Y, (le) => ar(le.element, "tox-collection__item--active")), So.getHighlighted(Y).each(Xt.focusIn);
        },
        parts: {
          menu: {
            ...$x(!1, n.columns, n.presets),
            dom: {
              ...$x(!1, n.columns, n.presets).dom,
              tag: "div",
              attributes: {
                id: h
              }
            }
          }
        }
      }), j = K4(n.icon, n.text, A.none(), A.some([
        eo.config({
          toggleClass: "tox-tbtn--enabled",
          aria: n.presets === "color" ? { mode: "none" } : { mode: "pressed" },
          toggleOnExecute: !1
        }),
        ...n.tooltip.isSome() ? [
          ps.config(s.providers.tooltips.getConfig({
            tooltipText: s.providers.translate(n.tooltip.getOr("")),
            onShow: (ne) => {
              if (d.get() !== n.tooltip.getOr("")) {
                const ae = s.providers.translate(d.get());
                ps.setComponents(ne, s.providers.tooltips.getComponents({ tooltipText: ae }));
              }
            }
          }))
        ] : []
      ]), s.providers, n.context, a);
      return [oa.sketch({
        dom: {
          ...j.dom,
          classes: [
            "tox-tbtn",
            "tox-split-button__main"
          ].concat(n.text.isSome() ? [
            "tox-tbtn--select"
            /* ToolbarButtonClasses.MatchWidth */
          ] : []),
          attributes: {
            "aria-label": T(),
            ...un(a) ? { "data-mce-name": a } : {}
          }
        },
        components: j.components,
        eventOrder: j.eventOrder,
        buttonBehaviours: j.buttonBehaviours,
        action: (ne) => {
          if (n.onAction) {
            const ae = g(ne);
            ae.isEnabled() && n.onAction(ae);
          }
        }
      }), L];
    }, dq = ".tox-toolbar-slider__input,.tox-toolbar-textfield", g8 = (n) => {
      Us.getContent(n).each((s) => {
        Po(s.element, dq).fold(() => Xt.focusIn(s), $r);
      });
    }, mq = (n) => or(n.element).each((s) => {
      Fl(s, '[tabindex="-1"]').each((a) => {
        $r(a);
      });
    }), h8 = Ct("forward-slide"), Y4 = Ct("backward-slide"), X4 = Ct("change-slide-event"), Ey = "tox-pop--resizing", tN = (n) => {
      const s = Pt([]);
      return {
        sketch: Us.sketch({
          dom: {
            tag: "div",
            classes: ["tox-pop"]
          },
          fireDismissalEventInstead: {
            event: "doNotDismissYet"
          },
          onShow: (l) => {
            s.set([]), Us.getContent(l).each((d) => {
              Kn(d.element, "visibility");
            }), Ds(l.element, Ey), Kn(l.element, "width");
          },
          onHide: () => {
            s.set([]), n.onHide();
          },
          inlineBehaviours: nt([
            xn("context-toolbar-events", [
              Jh(v0(), (l, d) => {
                d.event.raw.propertyName === "width" && (Ds(l.element, Ey), Kn(l.element, "width"));
              }),
              Ie(X4, (l, d) => {
                const g = l.element;
                Kn(g, "width");
                const h = la(g), C = or(l.element).isSome();
                Kn(g, "left"), Kn(g, "right"), Kn(g, "max-width"), Us.setContent(l, d.event.contents), Uo(g, Ey);
                const x = la(g);
                gn(g, "transition", "none"), Us.reposition(l), Kn(g, "transition"), gn(g, "width", h + "px"), d.event.focus.fold(() => {
                  C && g8(l);
                }, (T) => {
                  Ir(mr(l.element)).fold(() => $r(T), (_) => {
                    I(_, T) || n.focusElement(T);
                  });
                }), setTimeout(() => {
                  gn(l.element, "width", x + "px");
                }, 0);
              }),
              Ie(h8, (l, d) => {
                Us.getContent(l).each((g) => {
                  s.set(s.get().concat([
                    {
                      bar: g,
                      focus: Ir(mr(l.element))
                    }
                  ]));
                }), tn(l, X4, {
                  contents: d.event.forwardContents,
                  focus: A.none()
                });
              }),
              Ie(Y4, (l, d) => {
                n.onBack(), Ql(s.get()).each((g) => {
                  s.set(s.get().slice(0, s.get().length - 1)), tn(l, X4, {
                    // Because we are using premade, we should have access to the same element
                    // to give focus (although it isn't working)
                    contents: y(g.bar),
                    focus: g.focus
                  });
                });
              })
            ]),
            Xt.config({
              mode: "special",
              onEscape: (l) => Ql(s.get()).fold(() => (
                // Escape just focuses the content. It no longer closes the toolbar.
                n.onEscape()
              ), (d) => (Wn(l, Y4), A.some(!0)))
            })
          ]),
          lazySink: () => Wt.value(n.sink)
        }),
        inSubtoolbar: () => s.get().length > 0
      };
    }, p8 = (n, s) => {
      const a = yi(Hf({
        type: "button",
        icon: "chevron-left",
        tooltip: "Back",
        onAction: U
      }));
      return gS(a, s.shared.providers, [
        Ie(hR, (l) => {
          Wn(l, Y4);
        })
      ]);
    }, td = (n, s, a) => ha(a) ? n.translate(s) : n.translate([s, n.translate(a)]), b8 = (n, s) => {
      const a = (h, C, x, T) => {
        const _ = n.shared.providers.translate(h.title);
        if (h.type === "separator")
          return A.some({
            type: "separator",
            text: _
          });
        if (h.type === "submenu") {
          const N = xe(h.getStyleItems(), (L) => l(L, C, T));
          return C === 0 && N.length <= 0 ? A.none() : A.some({
            type: "nestedmenuitem",
            text: _,
            enabled: N.length > 0,
            getSubmenuItems: () => xe(h.getStyleItems(), (L) => l(L, C, T))
          });
        } else
          return A.some({
            // ONLY TOGGLEMENUITEMS HANDLE STYLE META.
            // See ToggleMenuItem and ItemStructure for how it's handled.
            // If this type ever changes, we'll need to change that too
            type: "togglemenuitem",
            text: _,
            icon: h.icon,
            active: h.isSelected(T),
            enabled: !x,
            onAction: s.onAction(h),
            ...h.getStylePreview().fold(() => ({}), (N) => ({ meta: { style: N } }))
          });
      }, l = (h, C, x) => {
        const T = h.type === "formatter" && s.isInvalid(h);
        return C === 0 ? T ? [] : a(h, C, !1, x).toArray() : a(h, C, T, x).toArray();
      }, d = (h) => {
        const C = s.getCurrentValue(), x = s.shouldHide ? 0 : 1;
        return xe(h, (T) => l(T, x, C));
      };
      return {
        validateItems: d,
        getFetch: (h, C) => (x, T) => {
          const _ = C(), N = d(_), L = ah(N, Wd.CLOSE_ON_EXECUTE, h, {
            isHorizontalMenu: !1,
            search: A.none()
          });
          T(L);
        }
      };
    }, Ty = (n, s) => {
      const a = s.dataset, l = a.type === "basic" ? () => ye(a.data, (d) => bF(d, s.isSelectedFor, s.getPreviewFor)) : a.getData;
      return {
        items: b8(n, s),
        getStyleItems: l
      };
    }, hS = (n, s, a, l, d, g) => {
      const { items: h, getStyleItems: C } = Ty(s, a), x = Pt(a.tooltip), T = (N) => ({
        getComponent: oe(N),
        setTooltip: (L) => {
          const j = s.shared.providers.translate(L);
          ln(N.element, "aria-label", j), x.set(L);
        }
      }), _ = (N) => {
        const L = (j) => N.setTooltip(td(n, l(j.value), j.value));
        return n.on(d, L), Bb(Op(n, "NodeChange", (j) => {
          const Z = j.getComponent();
          a.updateText(Z), Ft.set(j.getComponent(), !n.selection.isEditable() || C().length === 0);
        })(N), () => n.off(d, L));
      };
      return yR({
        context: "mode:design",
        text: a.icon.isSome() ? A.none() : a.text,
        icon: a.icon,
        ariaLabel: A.some(a.tooltip),
        tooltip: A.none(),
        // TINY-10474 - Using own tooltip config
        role: A.none(),
        fetch: h.getFetch(s, C),
        onSetup: _,
        getApi: T,
        columns: 1,
        presets: "normal",
        classes: a.icon.isSome() ? [] : ["bespoke"],
        dropdownBehaviours: [
          ps.config({
            ...s.shared.providers.tooltips.getConfig({
              tooltipText: s.shared.providers.translate(a.tooltip),
              onShow: (N) => {
                if (a.tooltip !== x.get()) {
                  const L = s.shared.providers.translate(x.get());
                  ps.setComponents(N, s.shared.providers.tooltips.getComponents({ tooltipText: L }));
                }
              }
            })
          })
        ]
      }, "tox-tbtn", s.shared, g);
    }, fq = (n) => ye(n, (s) => {
      let a = s, l = s;
      const d = s.split("=");
      return d.length > 1 && (a = d[0], l = d[1]), { title: a, format: l };
    }), gq = (n) => ({
      type: "basic",
      data: n
    });
    var ky;
    (function(n) {
      n[n.SemiColon = 0] = "SemiColon", n[n.Space = 1] = "Space";
    })(ky || (ky = {}));
    const hq = (n, s) => s === ky.SemiColon ? n.replace(/;$/, "").split(";") : n.split(" "), nN = (n, s, a) => {
      const l = n.options.get(s);
      return {
        type: "basic",
        data: fq(hq(l, a))
      };
    }, v8 = "Align", y8 = oe("Alignment {0}"), C8 = "left", pS = [
      { title: "Left", icon: "align-left", format: "alignleft", command: "JustifyLeft" },
      { title: "Center", icon: "align-center", format: "aligncenter", command: "JustifyCenter" },
      { title: "Right", icon: "align-right", format: "alignright", command: "JustifyRight" },
      { title: "Justify", icon: "align-justify", format: "alignjustify", command: "JustifyFull" }
    ], x8 = (n) => {
      const s = () => Lt(pS, (C) => n.formatter.match(C.format)), a = (C) => () => n.formatter.match(C), l = (C) => A.none, d = (C) => {
        const T = s().fold(oe(C8), (_) => _.title.toLowerCase());
        tn(C, Lb, {
          icon: `align-${T}`
        }), N$(n, { value: T });
      }, g = gq(pS), h = (C) => () => Lt(pS, (x) => x.format === C.format).each((x) => n.execCommand(x.command));
      return {
        tooltip: td(n, y8(), C8),
        text: A.none(),
        icon: A.some("align-left"),
        isSelectedFor: a,
        getCurrentValue: A.none,
        getPreviewFor: l,
        onAction: h,
        updateText: d,
        dataset: g,
        shouldHide: !1,
        isInvalid: (C) => !n.formatter.canApply(C.format)
      };
    }, pq = (n, s) => hS(n, s, x8(n), y8, "AlignTextUpdate", "align"), bq = (n, s) => {
      const a = Ty(s, x8(n));
      n.ui.registry.addNestedMenuItem("align", {
        text: s.shared.providers.translate(v8),
        onSetup: Oa(n),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    }, S8 = (n, s) => {
      const a = s(), l = ye(a, (d) => d.format);
      return A.from(n.formatter.closest(l)).bind((d) => Lt(a, (g) => g.format === d));
    }, vq = "Blocks", w8 = oe("Block {0}"), Q4 = "Paragraph", oN = (n) => {
      const s = (g) => () => n.formatter.match(g), a = (g) => () => {
        const h = n.formatter.get(g);
        return h ? A.some({
          tag: h.length > 0 && (h[0].inline || h[0].block) || "div",
          styles: n.dom.parseStyle(n.formatter.getCssText(g))
        }) : A.none();
      }, l = (g) => {
        const C = S8(n, () => d.data).fold(oe(Q4), (x) => x.title);
        tn(g, Ju, {
          text: C
        }), d4(n, { value: C });
      }, d = nN(n, "block_formats", ky.SemiColon);
      return {
        tooltip: td(n, w8(), Q4),
        text: A.some(Q4),
        icon: A.none(),
        isSelectedFor: s,
        getCurrentValue: A.none,
        getPreviewFor: a,
        onAction: m4(n),
        updateText: l,
        dataset: d,
        shouldHide: !1,
        isInvalid: (g) => !n.formatter.canApply(g.format)
      };
    }, E8 = (n, s) => hS(n, s, oN(n), w8, "BlocksTextUpdate", "blocks"), yq = (n, s) => {
      const a = Ty(s, oN(n));
      n.ui.registry.addNestedMenuItem("blocks", {
        text: vq,
        onSetup: Oa(n),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    }, T8 = "Fonts", k8 = oe("Font {0}"), sN = "System Font", Cq = ["-apple-system", "Segoe UI", "Roboto", "Helvetica Neue", "sans-serif"], rN = (n) => {
      const s = n.split(/\s*,\s*/);
      return ye(s, (a) => a.replace(/^['"]+|['"]+$/g, ""));
    }, A8 = (n, s) => s.length > 0 && We(s, (a) => n.indexOf(a.toLowerCase()) > -1), _8 = (n, s) => {
      if (n.indexOf("-apple-system") === 0 || s.length > 0) {
        const a = rN(n.toLowerCase());
        return A8(a, Cq) || A8(a, s);
      } else
        return !1;
    }, O8 = (n) => {
      const s = () => {
        const x = (Z) => Z ? rN(Z)[0] : "", T = n.queryCommandValue("FontName"), _ = C.data, N = T ? T.toLowerCase() : "", L = KB(n);
        return { matchOpt: Lt(_, (Z) => {
          const ne = Z.format;
          return ne.toLowerCase() === N || x(ne).toLowerCase() === x(N).toLowerCase();
        }).orThunk(() => Br(_8(N, L), {
          title: sN,
          format: N
        })), font: T };
      }, a = (x) => (T) => T.exists((_) => _.format === x), l = () => {
        const { matchOpt: x } = s();
        return x;
      }, d = (x) => () => A.some({
        tag: "div",
        styles: x.indexOf("dings") === -1 ? { "font-family": x } : {}
      }), g = (x) => () => {
        n.undoManager.transact(() => {
          n.focus(), n.execCommand("FontName", !1, x.format);
        });
      }, h = (x) => {
        const { matchOpt: T, font: _ } = s(), N = T.fold(oe(_), (L) => L.title);
        tn(x, Ju, {
          text: N
        }), iW(n, { value: N });
      }, C = nN(n, "font_family_formats", ky.SemiColon);
      return {
        tooltip: td(n, k8(), sN),
        text: A.some(sN),
        icon: A.none(),
        isSelectedFor: a,
        getCurrentValue: l,
        getPreviewFor: d,
        onAction: g,
        updateText: h,
        dataset: C,
        shouldHide: !1,
        isInvalid: an
      };
    }, xq = (n, s) => hS(n, s, O8(n), k8, "FontFamilyTextUpdate", "fontfamily"), Sq = (n, s) => {
      const a = Ty(s, O8(n));
      n.ui.registry.addNestedMenuItem("fontfamily", {
        text: s.shared.providers.translate(T8),
        onSetup: Oa(n),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    };
    var J4 = tinymce.util.Tools.resolve("tinymce.util.VK");
    const wq = (n, s, a, l) => {
      let d = A.none();
      const g = (pe) => pe.map((Ee) => _t.getValue(Ee)).getOr(""), h = Op(n, "NodeChange SwitchMode DisabledStateChange", (pe) => {
        const Ee = pe.getComponent();
        d = A.some(Ee), a.updateInputValue(Ee), Ft.set(Ee, !n.selection.isEditable() || NT(n));
      }), C = (pe) => ({ getComponent: oe(pe) }), x = Pt(U), T = Ct("custom-number-input-events"), _ = (pe, Ee, Oe) => {
        const gt = g(d), Ue = a.getNewValue(gt, pe), Qe = gt.length - `${Ue}`.length, Ke = d.map((zt) => zt.element.dom.selectionStart - Qe), Qt = d.map((zt) => zt.element.dom.selectionEnd - Qe);
        a.onAction(Ue, Oe), d.each((zt) => {
          _t.setValue(zt, Ue), Ee && (Ke.each((jn) => zt.element.dom.selectionStart = jn), Qt.each((jn) => zt.element.dom.selectionEnd = jn));
        });
      }, N = (pe, Ee) => _((Oe, gt) => Oe - gt, pe, Ee), L = (pe, Ee) => _((Oe, gt) => Oe + gt, pe, Ee), j = (pe) => Li(pe.element).fold(A.none, (Ee) => ($r(Ee), A.some(!0))), Z = (pe) => Bl(pe.element) ? (Qn(pe.element).each((Ee) => $r(Ee)), A.some(!0)) : A.none(), ne = (pe, Ee, Oe, gt) => {
        const Ue = Pt(U), Qe = s.shared.providers.translate(Oe), Ke = Ct("altExecuting"), Qt = Op(n, "NodeChange SwitchMode DisabledStateChange", (jn) => {
          Ft.set(jn.getComponent(), !n.selection.isEditable() || NT(n));
        }), zt = (jn) => {
          Ft.isDisabled(jn) || pe(!0);
        };
        return oa.sketch({
          dom: {
            tag: "button",
            attributes: {
              "aria-label": Qe,
              "data-mce-name": Ee
            },
            classes: gt.concat(Ee)
          },
          components: [
            bR(Ee, s.shared.providers.icons)
          ],
          buttonBehaviours: nt([
            Ft.config({}),
            ps.config(s.shared.providers.tooltips.getConfig({
              tooltipText: Qe
            })),
            xn(Ke, [
              Hm({ onSetup: Qt, getApi: C }, Ue),
              Ap({ getApi: C }, Ue),
              Ie(na(), (jn, Jt) => {
                (Jt.event.raw.keyCode === J4.SPACEBAR || Jt.event.raw.keyCode === J4.ENTER) && (Ft.isDisabled(jn) || pe(!1));
              }),
              Ie(Cg(), zt),
              Ie(gf(), zt)
            ])
          ]),
          eventOrder: {
            [na()]: [Ke, "keying"],
            [Cg()]: [Ke, "alloy.base.behaviour"],
            [gf()]: [Ke, "alloy.base.behaviour"],
            [Mu()]: ["alloy.base.behaviour", Ke, "tooltipping"],
            [Ci()]: [Ke, "tooltipping"]
          }
        });
      }, ae = To(ne((pe) => N(!1, pe), "minus", "Decrease font size", [])), Y = To(ne((pe) => L(!1, pe), "plus", "Increase font size", [])), le = To({
        dom: {
          tag: "div",
          classes: ["tox-input-wrapper"]
        },
        components: [
          Ff.sketch({
            inputBehaviours: nt([
              Ft.config({}),
              xn(T, [
                Hm({ onSetup: h, getApi: C }, x),
                Ap({ getApi: C }, x)
              ]),
              xn("input-update-display-text", [
                Ie(Ju, (pe, Ee) => {
                  _t.setValue(pe, Ee.event.text);
                }),
                Ie(S2(), (pe) => {
                  a.onAction(_t.getValue(pe));
                }),
                Ie(yg(), (pe) => {
                  a.onAction(_t.getValue(pe));
                })
              ]),
              Xt.config({
                mode: "special",
                onEnter: (pe) => (_(Yt, !0, !0), A.some(!0)),
                onEscape: j,
                onUp: (pe) => (L(!0, !1), A.some(!0)),
                onDown: (pe) => (N(!0, !1), A.some(!0)),
                onLeft: (pe, Ee) => (Ee.cut(), A.none()),
                onRight: (pe, Ee) => (Ee.cut(), A.none())
              })
            ])
          })
        ],
        behaviours: nt([
          En.config({}),
          Xt.config({
            mode: "special",
            onEnter: Z,
            onSpace: Z,
            onEscape: j
          }),
          xn("input-wrapper-events", [
            Ie(Ul(), (pe) => {
              He([ae, Y], (Ee) => {
                const Oe = at.fromDom(Ee.get(pe).element.dom);
                Bl(Oe) && Os(Oe);
              });
            })
          ])
        ])
      });
      return {
        dom: {
          tag: "div",
          classes: ["tox-number-input"],
          attributes: {
            ...un(l) ? { "data-mce-name": l } : {}
          }
        },
        components: [
          ae.asSpec(),
          le.asSpec(),
          Y.asSpec()
        ],
        behaviours: nt([
          En.config({}),
          Xt.config({
            mode: "flow",
            focusInside: Tg.OnEnterOrSpaceMode,
            cycles: !1,
            selector: "button, .tox-input-wrapper",
            onEscape: (pe) => Bl(pe.element) ? A.none() : ($r(pe.element), A.some(!0))
          })
        ])
      };
    }, Eq = "Font sizes", D8 = oe("Font size {0}"), aN = "12pt", Tq = {
      "8pt": "1",
      "10pt": "2",
      "12pt": "3",
      "14pt": "4",
      "18pt": "5",
      "24pt": "6",
      "36pt": "7"
    }, kq = {
      "xx-small": "7pt",
      "x-small": "8pt",
      small: "10pt",
      medium: "12pt",
      large: "14pt",
      "x-large": "18pt",
      "xx-large": "24pt"
    }, Aq = (n, s) => {
      const a = Math.pow(10, s);
      return Math.round(n * a) / a;
    }, _q = (n, s) => /[0-9.]+px$/.test(n) ? Aq(parseInt(n, 10) * 72 / 96, s || 0) + "pt" : Vt(kq, n).getOr(n), Oq = (n) => Vt(Tq, n).getOr(""), R8 = (n) => {
      const s = () => {
        let x = A.none();
        const T = C.data, _ = n.queryCommandValue("FontSize");
        if (_)
          for (let N = 3; x.isNone() && N >= 0; N--) {
            const L = _q(_, N), j = Oq(L);
            x = Lt(T, (Z) => Z.format === _ || Z.format === L || Z.format === j);
          }
        return { matchOpt: x, size: _ };
      }, a = (x) => (T) => T.exists((_) => _.format === x), l = () => {
        const { matchOpt: x } = s();
        return x;
      }, d = oe(A.none), g = (x) => () => {
        n.undoManager.transact(() => {
          n.focus(), n.execCommand("FontSize", !1, x.format);
        });
      }, h = (x) => {
        const { matchOpt: T, size: _ } = s(), N = T.fold(oe(_), (L) => L.title);
        tn(x, Ju, {
          text: N
        }), lW(n, { value: N });
      }, C = nN(n, "font_size_formats", ky.Space);
      return {
        tooltip: td(n, D8(), aN),
        text: A.some(aN),
        icon: A.none(),
        isSelectedFor: a,
        getPreviewFor: d,
        getCurrentValue: l,
        onAction: g,
        updateText: h,
        dataset: C,
        shouldHide: !1,
        isInvalid: an
      };
    }, Dq = (n, s) => hS(n, s, R8(n), D8, "FontSizeTextUpdate", "fontsize"), N8 = (n) => {
      const s = { step: 1 };
      return {
        em: { step: 0.1 },
        cm: { step: 0.1 },
        in: { step: 0.1 },
        pc: { step: 0.1 },
        ch: { step: 0.1 },
        rem: { step: 0.1 }
      }[n] ?? s;
    }, Rq = 16, Nq = (n) => n >= 0, M8 = (n) => {
      const s = () => n.queryCommandValue("FontSize");
      return {
        updateInputValue: (l) => tn(l, Ju, {
          text: s()
        }),
        onAction: (l, d) => n.execCommand("FontSize", !1, l, { skip_focus: !d }),
        getNewValue: (l, d) => {
          vo(l, ["unsupportedLength", "empty"]);
          const g = s(), h = vo(l, ["unsupportedLength", "empty"]).or(vo(g, ["unsupportedLength", "empty"])), C = h.map((L) => L.value).getOr(Rq), x = $T(n), T = h.map((L) => L.unit).filter((L) => L !== "").getOr(x), _ = d(C, N8(T).step), N = `${Nq(_) ? _ : C}${T}`;
          return N !== g && Vf(n, { value: N }), N;
        }
      };
    }, Mq = (n, s) => wq(n, s, M8(n), "fontsizeinput"), P8 = (n, s) => {
      const a = Ty(s, R8(n));
      n.ui.registry.addNestedMenuItem("fontsize", {
        text: Eq,
        onSetup: Oa(n),
        getSubmenuItems: () => a.items.validateItems(a.getStyleItems())
      });
    }, B8 = "Formats", $8 = (n) => ha(n) ? "Formats" : "Format {0}", I8 = (n, s) => {
      const a = "Formats", l = (h) => () => n.formatter.match(h), d = (h) => () => {
        const C = n.formatter.get(h);
        return C !== void 0 ? A.some({
          tag: C.length > 0 && (C[0].inline || C[0].block) || "div",
          styles: n.dom.parseStyle(n.formatter.getCssText(h))
        }) : A.none();
      }, g = (h) => {
        const C = (N) => WZ(N) ? xe(N.items, C) : mF(N) ? [{ title: N.title, format: N.format }] : [], x = xe(pF(n), C), _ = S8(n, oe(x)).fold(oe({
          title: a,
          tooltipLabel: ""
        }), (N) => ({
          title: N.title,
          tooltipLabel: N.title
        }));
        tn(h, Ju, {
          text: _.title
        }), cW(n, { value: _.tooltipLabel });
      };
      return {
        tooltip: td(n, $8(""), ""),
        text: A.some(a),
        icon: A.none(),
        isSelectedFor: l,
        getCurrentValue: A.none,
        getPreviewFor: d,
        onAction: m4(n),
        updateText: g,
        shouldHide: cO(n),
        isInvalid: (h) => !n.formatter.canApply(h.format),
        dataset: s
      };
    }, Pq = (n, s) => {
      const a = { type: "advanced", ...s.styles };
      return hS(n, s, I8(n, a), $8, "StylesTextUpdate", "styles");
    }, Ay = (n, s) => {
      const a = { type: "advanced", ...s.styles }, l = Ty(s, I8(n, a));
      n.ui.registry.addNestedMenuItem("styles", {
        text: B8,
        onSetup: Oa(n, () => l.getStyleItems().length > 0),
        getSubmenuItems: () => l.items.validateItems(l.getStyleItems())
      });
    }, Bq = [
      {
        name: "history",
        items: ["undo", "redo"]
      },
      {
        name: "ai",
        items: ["aidialog", "aishortcuts"]
      },
      {
        name: "styles",
        items: ["styles"]
      },
      {
        name: "formatting",
        items: ["bold", "italic"]
      },
      {
        name: "alignment",
        items: ["alignleft", "aligncenter", "alignright", "alignjustify"]
      },
      {
        name: "indentation",
        items: ["outdent", "indent"]
      },
      {
        name: "permanent pen",
        items: ["permanentpen"]
      },
      {
        name: "comments",
        items: ["addcomment"]
      }
    ], bS = (n, s) => (a, l, d, g) => {
      const h = n(a).mapError((C) => Rh(C)).getOrDie();
      return s(h, l, d, g);
    }, $q = {
      button: bS(Hf, (n, s, a, l) => cq(n, s.shared.providers, l)),
      togglebutton: bS(uD, (n, s, a, l) => eN(n, s.shared.providers, l)),
      menubutton: bS(rD, (n, s, a, l) => sS(n, "tox-tbtn", s, A.none(), !1, l)),
      splitbutton: bS(Ij, (n, s, a, l) => uq(n, s.shared, l)),
      grouptoolbarbutton: bS(yD, (n, s, a, l) => {
        const d = a.ui.registry.getAll().buttons, g = (C) => e3(a, { buttons: d, toolbar: C, allowToolbarGroups: !1 }, s, A.none()), h = {
          [G0]: s.shared.header.isPositionedAtTop() ? bm.TopToBottom : bm.BottomToTop
        };
        switch (yb(a)) {
          case lu.floating:
            return aq(n, s, g, h, l);
          default:
            throw new Error("Toolbar groups are only supported when using floating toolbar mode");
        }
      })
    }, Iq = (n, s, a, l) => Vt($q, n.type).fold(() => (console.error("skipping button defined by", n), A.none()), (d) => A.some(d(n, s, a, l))), F8 = {
      styles: Pq,
      fontsize: Dq,
      fontsizeinput: Mq,
      fontfamily: xq,
      blocks: E8,
      align: pq,
      navigateback: p8
    }, Fq = (n) => {
      const s = ye(Bq, (a) => {
        const l = Ln(a.items, (d) => mo(n, d) || mo(F8, d));
        return {
          name: a.name,
          items: l
        };
      });
      return Ln(s, (a) => a.items.length > 0);
    }, Lq = (n) => {
      const s = n.split("|");
      return ye(s, (a) => ({
        items: a.trim().split(" ")
      }));
    }, Hq = (n) => lt(n, (s) => (mo(s, "name") || mo(s, "label")) && mo(s, "items")), cN = (n) => {
      const s = n.toolbar, a = n.buttons;
      return s === !1 ? [] : s === void 0 || s === !0 ? Fq(a) : De(s) ? Lq(s) : Hq(s) ? s : (console.error("Toolbar type should be string, string[], boolean or ToolbarGroup[]"), []);
    }, zq = (n, s, a, l, d, g) => Vt(s, a.toLowerCase()).orThunk(() => g.bind((h) => ga(h, (C) => Vt(s, C + a.toLowerCase())))).fold(
      () => Vt(F8, a.toLowerCase()).map((h) => h(n, d)),
      // TODO: Add back after TINY-3232 is implemented
      // .orThunk(() => {
      //   console.error('No representation for toolbarItem: ' + toolbarItem);
      //   return Optional.none();
      // ),
      (h) => h.type === "grouptoolbarbutton" && !l ? (console.warn(`Ignoring the '${a}' toolbar button. Group toolbar buttons are only supported when using floating toolbar mode and cannot be nested.`), A.none()) : Iq(h, d, n, a.toLowerCase())
    ), e3 = (n, s, a, l) => {
      const d = cN(s), g = ye(d, (h) => {
        const C = xe(h.items, (x) => x.trim().length === 0 ? [] : zq(n, s.buttons, x, s.allowToolbarGroups, a, l).map((T) => Array.isArray(T) ? T : [T]).getOr([]));
        return {
          title: A.from(n.translate(h.name)),
          label: Br(h.label !== void 0, n.translate(h.label)),
          items: C
        };
      });
      return Ln(g, (h) => h.items.length > 0);
    }, lN = (n, s, a, l) => {
      const d = s.mainUi.outerContainer, g = a.toolbar, h = a.buttons;
      if (lt(g, De)) {
        const C = g.map((x) => {
          const T = { toolbar: x, buttons: h, allowToolbarGroups: a.allowToolbarGroups };
          return e3(n, T, l, A.none());
        });
        es.setToolbars(d, C);
      } else
        es.setToolbar(d, e3(n, a, l, A.none()));
    }, iN = Zs(), Vq = iN.os.isiOS() && iN.os.version.major <= 12, Uq = (n, s) => {
      const { uiMotherships: a } = s, l = n.dom;
      let d = n.getWin();
      const g = n.getDoc().documentElement, h = Pt(Mo(d.innerWidth, d.innerHeight)), C = Pt(Mo(g.offsetWidth, g.offsetHeight)), x = () => {
        const L = h.get();
        (L.left !== d.innerWidth || L.top !== d.innerHeight) && (h.set(Mo(d.innerWidth, d.innerHeight)), LD(n));
      }, T = () => {
        const L = n.getDoc().documentElement, j = C.get();
        (j.left !== L.offsetWidth || j.top !== L.offsetHeight) && (C.set(Mo(L.offsetWidth, L.offsetHeight)), LD(n));
      }, _ = (L) => {
        oW(n, L);
      };
      l.bind(d, "resize", x), l.bind(d, "scroll", _);
      const N = rl(at.fromDom(n.getBody()), "load", T);
      n.on("hide", () => {
        He(a, (L) => {
          gn(L.element, "display", "none");
        });
      }), n.on("show", () => {
        He(a, (L) => {
          Kn(L.element, "display");
        });
      }), n.on("NodeChange", T), n.on("remove", () => {
        N.unbind(), l.unbind(d, "resize", x), l.unbind(d, "scroll", _), d = null;
      });
    }, jq = (n, s, a) => {
      Sp(n) && ou(a.mainUi.mothership.element, a.popupUi.mothership), eb(s, a.dialogUi.mothership);
    };
    var Wq = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      render: (n, s, a, l, d) => {
        const { mainUi: g, uiMotherships: h } = s, C = Pt(0), x = g.outerContainer;
        d8(n);
        const T = at.fromDom(d.targetNode), _ = ci(mr(T));
        ou(T, g.mothership), jq(n, _, s), n.on("PostRender", () => {
          es.setSidebar(x, a.sidebar, ZB(n)), es.setViews(x, a.views);
        }), n.on("SkinLoaded", () => {
          lN(n, s, a, l), C.set(n.getWin().innerWidth), es.setMenubar(x, r8(n, a)), Uq(n, s);
        });
        const N = es.getSocket(x).getOrDie("Could not find expected socket element");
        if (Vq) {
          Ss(N.element, {
            overflow: "scroll",
            "-webkit-overflow-scrolling": "touch"
            // required for ios < 13 content scrolling
          });
          const ne = eg(() => {
            n.dispatch("ScrollContent");
          }, 20), ae = Oo(N.element, "scroll", ne.throttle);
          n.on("remove", ae.unbind);
        }
        f$(n, s), n.addCommand("ToggleSidebar", (ne, ae) => {
          es.toggleSidebar(x, ae), uW(n);
        }), n.addQueryValueHandler("ToggleSidebar", () => es.whichSidebar(x) ?? ""), n.addCommand("ToggleView", (ne, ae) => {
          if (es.toggleView(x, ae)) {
            const Y = x.element;
            g.mothership.broadcastOn([Ad()], { target: Y }), He(h, (le) => {
              le.broadcastOn([Ad()], { target: Y });
            }), Mt(es.whichView(x)) && (n.focus(), n.nodeChanged(), es.refreshToolbar(x)), M$(n);
          }
        }), n.addQueryValueHandler("ToggleView", () => es.whichView(x) ?? "");
        const L = yb(n), j = () => {
          es.refreshToolbar(s.mainUi.outerContainer);
        };
        (L === lu.sliding || L === lu.floating) && n.on("ResizeWindow ResizeEditor ResizeContent", () => {
          const ne = n.getWin().innerWidth;
          ne !== C.get() && (j(), C.set(ne));
        });
        const Z = {
          setEnabled: (ne) => {
            Gx(s, ne ? "setEnabled" : "setDisabled");
          },
          isEnabled: () => !Ft.isDisabled(x)
        };
        return {
          iframeContainer: N.element.dom,
          editorContainer: x.element.dom,
          api: Z
        };
      }
    });
    const Zq = (n) => /^[0-9\.]+(|px)$/i.test("" + n) ? A.some(parseInt("" + n, 10)) : A.none(), t3 = (n) => In(n) ? n + "px" : n, n3 = (n, s, a) => {
      const l = s.filter((g) => n < g), d = a.filter((g) => n > g);
      return l.or(d).getOr(n);
    }, Gq = (n, s) => {
      if (typeof s == "number")
        return A.from(s);
      const a = /^([0-9.]+)(pt|em|px)$/.exec(s.trim());
      if (a) {
        const l = a[2], d = Number.parseFloat(a[1]);
        if (Number.isNaN(d) || d < 0)
          return A.none();
        if (l === "em")
          return A.from(d * Number.parseFloat(window.getComputedStyle(n.dom).fontSize));
        if (l === "pt")
          return A.from(d * (72 / 96));
        if (l === "px")
          return A.from(d);
      }
      return A.none();
    }, qq = (n) => {
      const s = Gq(at.fromDom(n.targetElm), nO(n)), a = rO(n), l = aO(n);
      return s.map((d) => n3(d, a, l));
    }, Kq = (n) => qq(n).getOr(nO(n)), vS = (n) => {
      const s = oO(n), a = sO(n), l = MT(n);
      return Zq(s).map((d) => n3(d, a, l));
    }, Yq = (n) => vS(n).getOr(oO(n)), { ToolbarLocation: _y, ToolbarMode: yS } = SV, L8 = 40, Xq = (n, s, a, l, d) => {
      const { mainUi: g, uiMotherships: h } = a, C = qv.DOM, x = ey(n), T = ty(n), _ = MT(n).or(vS(n)), N = l.shared.header, L = N.isPositionedAtTop, j = 150, Z = yb(n), ne = Z === yS.sliding || Z === yS.floating, ae = Pt(!1), Y = () => ae.get() && !n.removed, le = (Ut) => ne ? Ut.fold(oe(0), (Ve) => (
        // If we have an overflow toolbar, we need to offset the positioning by the height of the overflow toolbar
        Ve.components().length > 1 ? hr(Ve.components()[1].element) : 0
      )) : 0, pe = (Ut) => {
        switch (lO(n)) {
          case _y.auto:
            const Ve = es.getToolbar(g.outerContainer), ct = le(Ve), mn = hr(Ut.element) - ct, Pn = wr(s);
            if (Pn.y > mn)
              return "top";
            {
              const Nn = Zp(s), Xo = Math.max(Nn.dom.scrollHeight, hr(Nn));
              return Pn.bottom < Xo - mn || Ia().bottom < Pn.bottom - mn ? "bottom" : "top";
            }
          case _y.bottom:
            return "bottom";
          case _y.top:
          default:
            return "top";
        }
      }, Ee = (Ut) => {
        d.on((Ve) => {
          Ns.setModes(Ve, [Ut]), N.setDockingMode(Ut);
          const ct = L() ? bm.TopToBottom : bm.BottomToTop;
          ln(Ve.element, G0, ct);
        });
      }, Oe = () => {
        d.on((Ut) => {
          const Ve = _.getOrThunk(() => Sh().width - pc(s).left - 10);
          gn(Ut.element, "max-width", Ve + "px");
        });
      }, gt = (Ut, Ve) => {
        d.on((ct) => {
          const mn = es.getToolbar(g.outerContainer), Pn = le(mn), qt = wr(s), Nn = Ue(n, g.outerContainer.element), Xo = () => Nn.fold(() => qt.x, (Da) => {
            const mu = wr(Da);
            return I(Da, Lc()) ? qt.x : qt.x - mu.x;
          }), ko = () => Nn.fold(() => L() ? Math.max(qt.y - hr(ct.element) + Pn, 0) : qt.bottom, (Da) => {
            const mu = wr(Da), Wa = Da.dom.scrollTop ?? 0, Pp = I(Da, Lc()) ? Math.max(qt.y - hr(ct.element) + Pn, 0) : qt.y - mu.y + Wa - hr(ct.element) + Pn;
            return L() ? Pp : qt.bottom;
          }), ac = Xo(), Ms = Br(
            Ut,
            // This width can be used for calculating the "width" when resolving issues with flex-wrapping being triggered at the window width, despite scroll space being available to the right.
            Math.ceil(g.outerContainer.element.dom.getBoundingClientRect().width)
          ).filter((Da) => Da > j).map((Da) => {
            const mu = Ve.getOr(Ls()), Wa = window.innerWidth - (ac - mu.left), nd = Math.max(Math.min(Da, Wa), j);
            return Wa < Da && gn(g.outerContainer.element, "width", nd + "px"), {
              width: nd + "px"
            };
          }).getOr({ width: "max-content" }), Yl = {
            position: "absolute",
            left: Math.round(ac) + "px",
            top: ko() + "px"
          };
          Ss(g.outerContainer.element, {
            ...Yl,
            ...Ms
          });
        });
      }, Ue = (Ut, Ve) => Sp(Ut) ? lf(Ve) : A.none(), Qe = () => {
        He(h, (Ut) => {
          Ut.broadcastOn([kr()], {});
        });
      }, Ke = () => !x && (Ca(g.outerContainer.element).left + Au(g.outerContainer.element) >= window.innerWidth - L8 || Cs(g.outerContainer.element, "width").isSome()) ? (gn(g.outerContainer.element, "position", "absolute"), gn(g.outerContainer.element, "left", "0px"), Kn(g.outerContainer.element, "width"), !0) : !1, Qt = (Ut) => {
        if (!Y())
          return;
        x || Oe();
        const Ve = Ls(), ct = x ? !1 : Ke();
        if (ne && es.refreshToolbar(g.outerContainer), !x) {
          const mn = Ls(), Pn = Br(Ve.left !== mn.left, Ve);
          gt(ct, Pn), Pn.each((qt) => {
            _u(qt.left, mn.top);
          });
        }
        T && d.on(Ut), Qe();
      }, zt = () => x || !T || !Y() ? !1 : d.get().exists((Ut) => {
        const Ve = N.getDockingMode(), ct = pe(Ut);
        return ct !== Ve ? (Ee(ct), !0) : !1;
      });
      return {
        isVisible: Y,
        isPositionedAtTop: L,
        show: () => {
          ae.set(!0), gn(g.outerContainer.element, "display", "flex"), C.addClass(n.getBody(), "mce-edit-focus"), He(h, (Ut) => {
            Kn(Ut.element, "display");
          }), zt(), Sp(n) ? Qt((Ut) => Ns.isDocked(Ut) ? Ns.reset(Ut) : Ns.refresh(Ut)) : Qt(Ns.refresh);
        },
        hide: () => {
          ae.set(!1), gn(g.outerContainer.element, "display", "none"), C.removeClass(n.getBody(), "mce-edit-focus"), He(h, (Ut) => {
            gn(Ut.element, "display", "none");
          });
        },
        update: Qt,
        updateMode: () => {
          zt() && Qt(Ns.reset);
        },
        repositionPopups: Qe
      };
    }, H8 = (n, s) => {
      const a = wr(n);
      return {
        pos: s ? a.y : a.bottom,
        bounds: a
      };
    }, Qq = (n, s, a, l) => {
      const d = Pt(H8(s, a.isPositionedAtTop())), g = (T) => {
        const { pos: _, bounds: N } = H8(s, a.isPositionedAtTop()), { pos: L, bounds: j } = d.get(), Z = N.height !== j.height || N.width !== j.width;
        d.set({ pos: _, bounds: N }), Z && LD(n, T), a.isVisible() && (L !== _ ? a.update(Ns.reset) : Z && (a.updateMode(), a.repositionPopups()));
      };
      l || (n.on("activate", a.show), n.on("deactivate", a.hide)), n.on("SkinLoaded ResizeWindow", () => a.update(Ns.reset)), n.on("NodeChange keydown", (T) => {
        requestAnimationFrame(() => g(T));
      });
      let h = 0;
      const C = Xa(() => a.update(Ns.refresh), 33);
      n.on("ScrollWindow", () => {
        const T = Ls().left;
        T !== h && (h = T, C.throttle()), a.updateMode();
      }), Sp(n) && n.on("ElementScroll", (T) => {
        a.update(Ns.refresh);
      });
      const x = As();
      x.set(rl(at.fromDom(n.getBody()), "load", (T) => g(T.raw))), n.on("remove", () => {
        x.clear();
      });
    };
    var Jq = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      render: (n, s, a, l, d) => {
        const { mainUi: g } = s, h = hn(), C = at.fromDom(d.targetNode), x = Xq(n, C, s, l, h), T = BB(n);
        nq(n);
        const _ = () => {
          if (h.isSet()) {
            x.show();
            return;
          }
          h.set(es.getHeader(g.outerContainer).getOrDie());
          const L = gO(n);
          Sp(n) ? (ou(C, g.mothership), ou(C, s.popupUi.mothership)) : eb(L, g.mothership), eb(L, s.dialogUi.mothership);
          const j = () => {
            lN(n, s, a, l), es.setMenubar(g.outerContainer, r8(n, a)), x.show(), Qq(n, C, x, T), n.nodeChanged();
          };
          T ? n.once("SkinLoaded", j) : j();
        };
        n.on("show", _), n.on("hide", x.hide), T || (n.on("focus", _), n.on("blur", x.hide)), n.on("init", () => {
          (n.hasFocus() || T) && _();
        }), f$(n, s);
        const N = {
          show: _,
          hide: x.hide,
          setEnabled: (L) => {
            Gx(s, L ? "setEnabled" : "setDisabled");
          },
          isEnabled: () => !Ft.isDisabled(g.outerContainer)
        };
        return {
          editorContainer: g.outerContainer.element.dom,
          api: N
        };
      }
    });
    const o3 = () => {
      const n = hn(), s = hn(), a = hn();
      return {
        dialogUi: n,
        popupUi: s,
        mainUi: a,
        getUiMotherships: () => {
          const g = n.get().map((C) => C.mothership), h = s.get().map((C) => C.mothership);
          return g.fold(() => h.toArray(), (C) => h.fold(() => [C], (x) => I(C.element, x.element) ? [C] : [C, x]));
        },
        lazyGetInOuterOrDie: (g, h) => () => a.get().bind((C) => h(C.outerContainer)).getOrDie(`Could not find ${g} element in OuterContainer`)
      };
    }, z8 = "contexttoolbar-show", uN = "contexttoolbar-hide", s3 = (n, s, a) => ({
      setInputEnabled: (l) => {
        !l && a && $r(a), Ft.set(n, !l);
      },
      isInputEnabled: () => !Ft.isDisabled(n),
      hide: () => {
        Wn(n, x0());
      },
      back: () => {
        Wn(n, Y4);
      },
      getValue: () => s.get().getOrThunk(() => _t.getValue(n)),
      setValue: (l) => {
        n.getSystem().isConnected() ? _t.setValue(n, l) : s.set(l);
      }
    }), CS = (n, s, a) => {
      const d = gc(n.element).bind((g) => n.getSystem().getByDom(g).toOptional());
      return s3(d.getOr(n), s, a);
    }, V8 = (n, s, a) => Ie(hR, (l, d) => {
      const g = n.get(l), h = s3(g, a, l.element);
      s.onAction(h, d.event.buttonApi);
    }), U8 = (n, s, a, l) => {
      const { primary: d, ...g } = s.original, h = yi(Hf({
        ...g,
        type: "button",
        onAction: U
      }));
      return gS(h, a, [
        V8(n, s, l)
      ]);
    }, eK = (n, s, a, l) => {
      const { primary: d, ...g } = s.original, h = yi(uD({
        ...g,
        type: "togglebutton",
        onAction: U
      }));
      return f8(h, a, [
        V8(n, s, l)
      ]);
    }, tK = (n) => n.type === "contextformtogglebutton", nK = (n, s, a, l) => tK(s) ? eK(n, s, a, l) : U8(n, s, a, l), j8 = (n, s, a, l) => {
      const d = ye(s, (C) => To(nK(n, C, a, l)));
      return {
        asSpecs: () => ye(d, (C) => C.asSpec()),
        findPrimary: (C) => ga(s, (x, T) => x.primary ? A.from(d[T]).bind((_) => _.getOpt(C)).filter(X(Ft.isDisabled)) : A.none())
      };
    }, oK = (n, s, a, l) => {
      const { width: d, height: g } = n.initValue();
      let h = vy;
      const C = Ct("ratio-event"), x = (Ue) => s3(Ue, l), T = (Ue) => iu(Ue, { tag: "span", classes: ["tox-icon", "tox-lock-icon__" + Ue] }, s.icons), _ = () => !1, N = n.label.getOr("Constrain proportions"), L = s.translate(N), j = vr.parts.lock({
        dom: {
          tag: "button",
          classes: ["tox-lock", "tox-lock-context-form-size-input", "tox-button", "tox-button--naked", "tox-button--icon"],
          attributes: {
            "aria-label": L,
            "data-mce-name": N
          }
        },
        components: [
          T("lock"),
          T("unlock")
        ],
        buttonBehaviours: nt([
          Ft.config({ disabled: _ }),
          is.config({}),
          ps.config(s.tooltips.getConfig({
            tooltipText: L
          }))
        ])
      }), Z = (Ue) => ({
        dom: {
          tag: "div",
          classes: ["tox-context-form__group"]
        },
        components: Ue
      }), ne = (Ue) => Fl(Ue.element, "div.tox-focusable-wrapper").fold(A.none, (Ke) => ($r(Ke), A.some(!0))), ae = (Ue) => Yn.parts.field({
        factory: Ff,
        inputClasses: ["tox-textfield", "tox-toolbar-textfield", "tox-textfield-size"],
        data: Ue ? d : g,
        inputBehaviours: nt([
          Ft.config({ disabled: _ }),
          is.config({}),
          xn("size-input-toolbar-events", [
            Ie(Ki(), (Qe, Ke) => {
              tn(Qe, C, { isField1: Ue });
            })
          ]),
          Xt.config({ mode: "special", onEnter: a, onEscape: ne })
        ]),
        selectOnFocus: !1
      }), Y = (Ue) => ({
        dom: {
          tag: "label",
          classes: ["tox-label"]
        },
        components: [
          xs(s.translate(Ue))
        ]
      }), le = (Ue) => ({
        dom: {
          tag: "div",
          classes: ["tox-focusable-wrapper", "tox-toolbar-nav-item"]
        },
        components: [Ue],
        behaviours: nt([
          is.config({}),
          En.config({}),
          Xt.config({
            mode: "special",
            onEnter: (Qe) => Po(Qe.element, "input").fold(A.none, (Qt) => ($r(Qt), A.some(!0)))
          })
        ])
      }), pe = le(vr.parts.field1(Z([Yn.parts.label(Y("Width:")), ae(!0)]))), Ee = le(vr.parts.field2(Z([Yn.parts.label(Y("Height:")), ae(!1)]))), Oe = Pt(U), gt = [
        Hm({
          onBeforeSetup: (Ue) => Po(Ue.element, "input").each($r),
          onSetup: n.onSetup,
          getApi: x
        }, Oe),
        o4({ getApi: x }, Oe, l)
      ];
      return vr.sketch({
        dom: {
          tag: "div",
          classes: ["tox-context-form__group"]
        },
        components: [
          // NOTE: Form coupled inputs to the FormField.sketch themselves.
          pe,
          Z([
            j
          ]),
          Ee
        ],
        field1Name: "width",
        field2Name: "height",
        locked: !0,
        markers: {
          lockClass: "tox-locked"
        },
        onLockedChange: (Ue, Qe, Ke) => {
          M4(_t.getValue(Ue)).each((Qt) => {
            h(Qt).each((zt) => {
              _t.setValue(Qe, jI(zt));
            });
          });
        },
        onInput: (Ue) => Wn(Ue, iI),
        coupledFieldBehaviours: nt([
          En.config({}),
          Xt.config({
            mode: "flow",
            focusInside: Tg.OnEnterOrSpaceMode,
            cycles: !1,
            selector: "button, .tox-focusable-wrapper"
          }),
          Ft.config({
            disabled: _,
            onDisabled: (Ue) => {
              vr.getField1(Ue).bind(Yn.getField).each(Ft.disable), vr.getField2(Ue).bind(Yn.getField).each(Ft.disable), vr.getLock(Ue).each(Ft.disable);
            },
            onEnabled: (Ue) => {
              vr.getField1(Ue).bind(Yn.getField).each(Ft.enable), vr.getField2(Ue).bind(Yn.getField).each(Ft.enable), vr.getLock(Ue).each(Ft.enable);
            }
          }),
          yr(() => s.checkUiComponentContext("mode:design")),
          xn("size-input-toolbar-events2", [
            Ie(C, (Ue, Qe) => {
              const Ke = Qe.event.isField1, Qt = Ke ? vr.getField1(Ue) : vr.getField2(Ue), zt = Ke ? vr.getField2(Ue) : vr.getField1(Ue), jn = Qt.map(_t.getValue).getOr(""), Jt = zt.map(_t.getValue).getOr("");
              h = ZI(jn, Jt);
            }),
            Ie(iI, (Ue) => n.onInput(x(Ue))),
            ...gt
          ])
        ])
      });
    }, Oy = (n, s, a) => Yn.sketch({
      dom: {
        tag: "div",
        classes: ["tox-context-form__group"]
      },
      components: [...n.toArray(), s],
      fieldBehaviours: nt([
        Ft.config({
          disabled: () => a.checkUiComponentContext("mode:design").shouldDisable,
          onDisabled: (l) => {
            mq(l), Yn.getField(l).each(Ft.disable);
          },
          onEnabled: (l) => {
            Yn.getField(l).each(Ft.enable);
          }
        })
      ])
    }), sK = (n, s, a, l) => {
      const d = Pt(U), g = (x) => CS(x, l), h = n.label.map((x) => Yn.parts.label({
        dom: { tag: "label", classes: ["tox-label"] },
        components: [xs(s.translate(x))]
      })), C = Yn.parts.field({
        factory: Ff,
        type: "range",
        inputClasses: ["tox-toolbar-slider__input", "tox-toolbar-nav-item"],
        inputAttributes: {
          min: String(n.min()),
          max: String(n.max())
        },
        data: n.initValue().toString(),
        fromInputValue: (x) => Pc(x).getOr(n.min()),
        toInputValue: (x) => String(x),
        inputBehaviours: nt([
          Ft.config({
            disabled: () => s.checkUiComponentContext("mode:design").shouldDisable
          }),
          yr(() => s.checkUiComponentContext("mode:design")),
          Xt.config({
            mode: "special",
            onEnter: a,
            // These two lines need to be tested. They are about left and right bypassing
            // any keyboard handling, and allowing left and right to be processed by the input
            // Maybe this should go in an alloy sketch for Input?
            onLeft: (x, T) => (T.cut(), A.none()),
            onRight: (x, T) => (T.cut(), A.none())
          }),
          xn("slider-events", [
            Hm({
              onSetup: n.onSetup,
              getApi: g,
              onBeforeSetup: Xt.focusIn
            }, d),
            o4({ getApi: g }, d, l),
            Ie(Nu(), (x) => {
              n.onInput(g(x));
            })
          ])
        ])
      });
      return Oy(h, C, s);
    }, rK = (n, s, a, l) => {
      const d = Pt(U), g = (_) => CS(_, l), h = n.label.map((_) => Yn.parts.label({
        dom: { tag: "label", classes: ["tox-label"] },
        components: [xs(s.translate(_))]
      })), x = {
        ...n.placeholder.map((_) => ({ placeholder: s.translate(_) })).getOr({})
      }, T = Yn.parts.field({
        factory: Ff,
        inputClasses: ["tox-toolbar-textfield", "tox-toolbar-nav-item"],
        inputAttributes: x,
        data: n.initValue(),
        selectOnFocus: !0,
        inputBehaviours: nt([
          Ft.config({
            disabled: () => s.checkUiComponentContext("mode:design").shouldDisable
          }),
          yr(() => s.checkUiComponentContext("mode:design")),
          Xt.config({
            mode: "special",
            onEnter: a,
            // These two lines need to be tested. They are about left and right bypassing
            // any keyboard handling, and allowing left and right to be processed by the input
            // Maybe this should go in an alloy sketch for Input?
            onLeft: (_, N) => (N.cut(), A.none()),
            onRight: (_, N) => (N.cut(), A.none())
          }),
          xn("input-events", [
            Hm({
              onSetup: n.onSetup,
              getApi: (_) => Fl(_.element, ".tox-toolbar").bind((L) => Po(L, "button:enabled")).fold(() => CS(_, l), (L) => CS(_, l, L)),
              onBeforeSetup: Xt.focusIn
            }, d),
            o4({ getApi: g }, d, l),
            Ie(Nu(), (_) => {
              n.onInput(g(_));
            })
          ])
        ])
      });
      return Oy(h, T, s);
    }, dN = (n, s, a) => {
      const l = hn(), g = To(n(a, (T) => C.findPrimary(T).orThunk(() => x.findPrimary(T)).map((_) => (Yh(_), !0)), l)), h = ro(s.commands, (T) => T.align === "start"), C = j8(g, h.pass, a, l), x = j8(g, h.fail, a, l);
      return Ln([
        {
          title: A.none(),
          label: A.none(),
          items: C.asSpecs()
        },
        {
          title: A.none(),
          label: A.none(),
          items: [g.asSpec()]
        },
        {
          title: A.none(),
          label: A.none(),
          items: x.asSpecs()
        }
      ], (T) => T.items.length > 0);
    }, mN = (n, s) => {
      switch (n.type) {
        case "contextform":
          return dN(jt(rK, n), n, s);
        case "contextsliderform":
          return dN(jt(sK, n), n, s);
        case "contextsizeinputform":
          return dN(jt(oK, n), n, s);
      }
    }, W8 = {
      renderContextForm: (n, s, a) => W4({
        type: n,
        uid: Ct("context-toolbar"),
        initGroups: mN(s, a),
        onEscape: A.none,
        cyclicKeying: !0,
        providers: a
      }),
      buildInitGroups: mN
    }, Z8 = (n, s, a) => s.bottom - n.y >= a && n.bottom - s.y >= a, aK = (n) => {
      const s = n.getBoundingClientRect();
      if (s.height <= 0 && s.width <= 0) {
        const a = Xm(at.fromDom(n.startContainer), n.startOffset).element;
        return (dd(a) ? gc(a) : A.some(a)).filter(mc).map((d) => d.dom.getBoundingClientRect()).getOr(s);
      } else
        return s;
    }, fN = (n) => {
      const s = n.selection.getRng(), a = aK(s);
      if (n.inline) {
        const l = Ls();
        return Rr(l.left + a.left, l.top + a.top, a.width, a.height);
      } else {
        const l = cf(at.fromDom(n.getBody()));
        return Rr(l.x + a.left, l.y + a.top, a.width, a.height);
      }
    }, cK = (n, s) => s.filter((a) => bo(a) && te(a)).map(cf).getOrThunk(() => fN(n)), lK = (n, s, a) => {
      const l = Math.max(n.x + a, s.x), d = Math.min(n.right - a, s.right);
      return { x: l, width: d - l };
    }, xS = (n, s, a, l, d, g) => {
      const h = at.fromDom(n.getContainer()), C = Po(h, ".tox-editor-header").getOr(h), x = wr(C), T = x.y >= s.bottom, _ = l && !T;
      if (n.inline && _)
        return {
          y: Math.max(x.bottom + g, a.y),
          bottom: a.bottom
        };
      if (n.inline && !_)
        return {
          y: a.y,
          bottom: Math.min(x.y - g, a.bottom)
        };
      const N = d === "line" ? wr(h) : s;
      return _ ? {
        y: Math.max(x.bottom + g, a.y),
        bottom: Math.min(N.bottom - g, a.bottom)
      } : {
        y: Math.max(N.y + g, a.y),
        bottom: Math.min(x.y - g, a.bottom)
      };
    }, gN = (n, s, a, l = 0) => {
      const d = Sh(window), g = wr(at.fromDom(n.getContentAreaContainer())), h = Qv(n) || Jv(n) || xp(n), { x: C, width: x } = lK(g, d, l);
      if (n.inline && !h)
        return Rr(C, d.y, x, d.height);
      {
        const T = s.header.isPositionedAtTop(), { y: _, bottom: N } = xS(n, g, d, T, a, l);
        return Rr(C, _, x, N - _);
      }
    }, r3 = 12, G8 = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: ["tox-pop--align-left"],
      alignRight: ["tox-pop--align-right"],
      right: ["tox-pop--right"],
      left: ["tox-pop--left"],
      bottom: ["tox-pop--bottom"],
      top: ["tox-pop--top"],
      inset: ["tox-pop--inset"]
    }, hN = {
      maxHeightFunction: Ng(),
      maxWidthFunction: I1()
    }, pN = (n, s) => {
      const a = n.selection.getRng(), l = Xm(at.fromDom(a.startContainer), a.startOffset);
      return a.startContainer === a.endContainer && a.startOffset === a.endOffset - 1 && I(l.element, s);
    }, q8 = (n, s, a) => {
      const l = Cs(n, "position");
      gn(n, "position", s);
      const d = a(n);
      return l.each((g) => gn(n, "position", g)), d;
    }, bN = (n) => n === "node", iK = (n, s, a, l, d) => {
      const g = fN(n), h = l.lastElement().exists((C) => I(a, C));
      if (pN(n, a))
        return h ? kc : La;
      if (h)
        return q8(s, l.getMode(), () => Z8(g, wr(s), -20) && !l.isReposition() ? Fu : kc);
      {
        const C = l.getMode() === "fixed" ? d.y + Ls().top : d.y, x = hr(s) + r3;
        return C + x <= g.y ? La : Gh;
      }
    }, Dy = (n, s, a, l) => {
      const d = (x) => (T, _, N, L, j) => {
        const Z = iK(n, L, x, a, j), ne = {
          ...T,
          y: j.y,
          height: j.height
        };
        return {
          ...Z(ne, _, N, L, j),
          // Ensure this is always the preferred option if no outside layouts fit
          alwaysFit: !0
        };
      }, g = (x) => bN(l) ? [d(x)] : [];
      return s ? {
        onLtr: (x) => [Tr, Mr, Er, Ta, ua, Rs].concat(g(x)),
        onRtl: (x) => [Tr, Er, Mr, ua, Ta, Rs].concat(g(x))
      } : {
        onLtr: (x) => [Rs, Tr, Ta, Mr, ua, Er].concat(g(x)),
        onRtl: (x) => [Rs, Tr, ua, Er, Ta, Mr].concat(g(x))
      };
    }, a3 = (n, s, a, l) => s === "line" ? {
      bubble: bl(r3, 0, G8),
      layouts: {
        onLtr: () => [jh],
        onRtl: () => [H2]
      },
      overrides: hN
    } : {
      // Ensure that inset layouts use a 1px bubble since we're hiding the bubble arrow
      bubble: bl(0, r3, G8, 1 / r3),
      layouts: Dy(n, a, l, s),
      overrides: hN
    }, Ry = (n, s) => {
      const a = Ln(s, (g) => g.predicate(n.dom)), { pass: l, fail: d } = ro(a, (g) => g.type === "contexttoolbar");
      return {
        contextToolbars: l,
        contextForms: d
      };
    }, vN = (n) => {
      if (n.length <= 1)
        return n;
      {
        const s = (g) => cn(n, (h) => h.position === g), a = (g) => Ln(n, (h) => h.position === g), l = s("selection"), d = s("node");
        if (l || d)
          if (d && l) {
            const g = a("node"), h = ye(a("selection"), (C) => ({ ...C, position: "node" }));
            return g.concat(h);
          } else
            return a(l ? "selection" : "node");
        else
          return a("line");
      }
    }, yN = (n) => {
      if (n.length <= 1)
        return n;
      {
        const s = (l) => Lt(n, (d) => d.position === l);
        return s("selection").orThunk(() => s("node")).orThunk(() => s("line")).map((l) => l.position).fold(() => [], (l) => Ln(n, (d) => d.position === l));
      }
    }, K8 = (n, s, a) => {
      const l = Ry(n, s);
      if (l.contextForms.length > 0)
        return A.some({ elem: n, toolbars: [l.contextForms[0]] });
      {
        const d = Ry(n, a);
        if (d.contextForms.length > 0)
          return A.some({ elem: n, toolbars: [d.contextForms[0]] });
        if (l.contextToolbars.length > 0 || d.contextToolbars.length > 0) {
          const g = vN(l.contextToolbars.concat(d.contextToolbars));
          return A.some({ elem: n, toolbars: g });
        } else
          return A.none();
      }
    }, c3 = (n, s, a) => n(s) ? A.none() : l0(s, (l) => {
      if (mc(l)) {
        const { contextToolbars: d, contextForms: g } = Ry(l, a.inNodeScope), h = g.length > 0 ? g : yN(d);
        return h.length > 0 ? A.some({ elem: l, toolbars: h }) : A.none();
      } else
        return A.none();
    }, n), Y8 = (n, s) => {
      const a = at.fromDom(s.getBody()), l = (h) => I(h, a), d = (h) => !l(h) && !ee(a, h), g = at.fromDom(s.selection.getNode());
      return d(g) ? A.none() : K8(g, n.inNodeScope, n.inEditorScope).orThunk(() => c3(l, g, n));
    }, X8 = (n, s) => {
      const a = {}, l = [], d = [], g = {}, h = {}, C = (_, N) => {
        const L = yi(pj(N));
        a[_] = L, L.launch.map((j) => {
          g["form:" + _] = {
            ...N.launch,
            type: j.type === "contextformtogglebutton" ? "togglebutton" : "button",
            onAction: () => {
              s(L);
            }
          };
        }), L.scope === "editor" ? d.push(L) : l.push(L), h[_] = L;
      }, x = (_, N) => {
        vj(N).each((L) => {
          L.launch.isSome() && (g["toolbar:" + _] = {
            ...N.launch,
            type: "button",
            onAction: () => {
              s(L);
            }
          }), N.scope === "editor" ? d.push(L) : l.push(L), h[_] = L;
        });
      }, T = xo(n);
      return He(T, (_) => {
        const N = n[_];
        N.type === "contextform" || N.type === "contextsliderform" || N.type === "contextsizeinputform" ? C(_, N) : N.type === "contexttoolbar" && x(_, N);
      }), {
        forms: a,
        inNodeScope: l,
        inEditorScope: d,
        lookupTable: h,
        formNavigators: g
      };
    }, SS = "tox-pop--transition", uK = (n) => n === J4.ENTER || n === J4.SPACEBAR, Q8 = (n, s, a, l) => {
      const d = l.backstage, g = d.shared, h = Zs().deviceType.isTouch, C = hn(), x = hn(), T = hn(), _ = tN({
        sink: a,
        onEscape: () => (n.focus(), HD(n), A.some(!0)),
        onHide: () => {
          HD(n);
        },
        onBack: () => {
          zD(n);
        },
        focusElement: (Jt) => {
          n.getBody().contains(Jt.dom) ? n.focus() : $r(Jt);
        }
      }), N = p(_.sketch), L = () => {
        const Jt = T.get().getOr("node"), _n = bN(Jt) ? 1 : 0;
        return gN(n, g, Jt, _n);
      }, j = () => !n.removed && !(h() && d.isContextMenuOpen()), Z = (Jt) => uc($a(Jt, C.get(), I), !0), ne = () => {
        if (j()) {
          const Jt = L(), _n = uc(T.get(), "node") ? cK(n, C.get()) : fN(n);
          return Jt.height <= 0 || !Z8(_n, Jt, 0.01);
        } else
          return !0;
      }, ae = () => {
        C.clear(), x.clear(), T.clear(), Us.hide(N);
      }, Y = () => {
        if (Us.isOpen(N)) {
          const Jt = N.element;
          Kn(Jt, "display"), ne() ? gn(Jt, "display", "none") : (x.set(
            0
            /* TriggerCause.Reposition */
          ), Us.reposition(N));
        }
      }, le = (Jt) => ({
        dom: {
          tag: "div",
          classes: ["tox-pop__dialog"]
        },
        components: [Jt],
        behaviours: nt([
          Xt.config({
            mode: "acyclic"
          }),
          xn("pop-dialog-wrap-events", [
            hs((_n) => {
              n.shortcuts.add("ctrl+F9", "focus statusbar", () => Xt.focusIn(_n));
            }),
            eu((_n) => {
              n.shortcuts.remove("ctrl+F9");
            })
          ])
        ])
      }), pe = (Jt) => {
        const _n = Ue([Jt]);
        tn(N, h8, {
          forwardContents: le(_n)
        });
      }, Ee = Bc(() => X8(s, pe)), Oe = (Jt, _n) => e3(n, { buttons: Jt, toolbar: _n.items, allowToolbarGroups: !1 }, l.backstage, A.some(["form:", "toolbar:"])), gt = (Jt, _n) => W8.buildInitGroups(Jt, _n), Ue = (Jt) => {
        const { buttons: _n } = n.ui.registry.getAll(), Ut = Ee(), Ve = { ..._n, ...Ut.formNavigators }, ct = yb(n) === lu.scrolling ? lu.scrolling : lu.default, mn = en(ye(Jt, (Pn) => Pn.type === "contexttoolbar" ? Oe(Ve, mD(Pn)) : gt(Pn, g.providers)));
        return W4({
          type: ct,
          uid: Ct("context-toolbar"),
          initGroups: mn,
          onEscape: A.none,
          cyclicKeying: !0,
          providers: g.providers
        });
      }, Qe = (Jt, _n) => {
        const Ut = Jt === "node" ? g.anchors.node(_n) : g.anchors.cursor(), Ve = a3(n, Jt, h(), {
          lastElement: C.get,
          isReposition: () => uc(
            x.get(),
            0
            /* TriggerCause.Reposition */
          ),
          getMode: () => Oc.getMode(a)
        });
        return Ho(Ut, Ve);
      }, Ke = (Jt, _n) => {
        if (jn.cancel(), !j())
          return;
        const Ut = Ue(Jt), Ve = Jt[0].position, ct = Qe(Ve, _n);
        T.set(Ve), x.set(
          1
          /* TriggerCause.NewAnchor */
        );
        const mn = N.element;
        Kn(mn, "display"), Z(_n) || (Ds(mn, SS), Oc.reset(a, N)), Us.showWithinBounds(N, le(Ut), {
          anchor: ct,
          transition: {
            classes: [SS],
            mode: "placement"
          }
        }, () => A.some(L())), _n.fold(C.clear, C.set), ne() && gn(mn, "display", "none");
      }, Qt = () => {
        gn(N.element, "transition", "none"), Y(), Kn(N.element, "transition");
      };
      let zt = !1;
      const jn = Xa(() => {
        if (!(!n.hasFocus() || n.removed || zt))
          if (ar(N.element, SS))
            jn.throttle();
          else {
            const Jt = Ee();
            Y8(Jt, n).fold(ae, (_n) => {
              Ke(_n.toolbars, A.some(_n.elem));
            });
          }
      }, 17);
      n.on("init", () => {
        n.on("remove", ae), n.on("ScrollContent ScrollWindow ObjectResized ResizeEditor longpress", Y), n.on("click focus SetContent", jn.throttle), n.on("keyup", (Jt) => {
          (!uK(Jt.keyCode) || !_.inSubtoolbar()) && jn.throttle();
        }), n.on(uN, ae), n.on(z8, (Jt) => {
          const _n = Ee();
          Vt(_n.lookupTable, Jt.toolbarKey).each((Ut) => {
            Ke([Ut], Br(Jt.target !== n, Jt.target)), g8(N);
          });
        }), n.on("focusout", (Jt) => {
          RT.setEditorTimeout(n, () => {
            or(a.element).isNone() && or(N.element).isNone() && !n.hasFocus() && ae();
          }, 0);
        }), n.on("SwitchMode", () => {
          n.mode.isReadOnly() && ae();
        }), n.on("DisabledStateChange", (Jt) => {
          Jt.state && ae();
        }), n.on("ExecCommand", ({ command: Jt }) => {
          Jt.toLowerCase() === "toggleview" && ae();
        }), n.on("AfterProgressState", (Jt) => {
          Jt.state ? ae() : n.hasFocus() && jn.throttle();
        }), n.on("dragstart", () => {
          zt = !0;
        }), n.on("dragend drop", () => {
          zt = !1;
        }), n.on("NodeChange", (Jt) => {
          _.inSubtoolbar() ? Qt() : or(N.element).fold(jn.throttle, U);
        });
      });
    }, dK = (n) => {
      He([
        { name: "alignleft", text: "Align left", cmd: "JustifyLeft", icon: "align-left" },
        { name: "aligncenter", text: "Align center", cmd: "JustifyCenter", icon: "align-center" },
        { name: "alignright", text: "Align right", cmd: "JustifyRight", icon: "align-right" },
        { name: "alignjustify", text: "Justify", cmd: "JustifyFull", icon: "align-justify" }
      ], (a) => {
        n.ui.registry.addToggleButton(a.name, {
          tooltip: a.text,
          icon: a.icon,
          onAction: Cl(n, a.cmd),
          onSetup: Qx(n, a.name)
        });
      }), n.ui.registry.addButton("alignnone", {
        tooltip: "No alignment",
        icon: "align-none",
        onSetup: Oa(n),
        onAction: Cl(n, "JustifyNone")
      });
    }, J8 = (n, s) => {
      const a = () => {
        const l = s.getOptions(n), d = s.getCurrent(n).map(s.hash), g = hn();
        return ye(l, (h) => ({
          type: "togglemenuitem",
          text: s.display(h),
          onSetup: (C) => {
            const x = (_) => {
              _ && (g.on((N) => N.setActive(!1)), g.set(C)), C.setActive(_);
            };
            x(uc(d, s.hash(h)));
            const T = s.watcher(n, h, x);
            return () => {
              g.clear(), T();
            };
          },
          onAction: () => s.setCurrent(n, h)
        }));
      };
      n.ui.registry.addMenuButton(s.name, {
        tooltip: s.text,
        icon: s.icon,
        fetch: (l) => l(a()),
        onSetup: s.onToolbarSetup
      }), n.ui.registry.addNestedMenuItem(s.name, {
        type: "nestedmenuitem",
        text: s.text,
        getSubmenuItems: a,
        onSetup: s.onMenuSetup
      });
    }, l3 = (n) => ({
      name: "lineheight",
      text: "Line height",
      icon: "line-height",
      getOptions: YB,
      hash: (s) => Hs(s, ["fixed", "relative", "empty"]).getOr(s),
      display: Yt,
      watcher: (s, a, l) => s.formatter.formatChanged("lineheight", l, !1, { value: a }).unbind,
      getCurrent: (s) => A.from(s.queryCommandValue("LineHeight")),
      setCurrent: (s, a) => s.execCommand("LineHeight", !1, a),
      onToolbarSetup: Oa(n),
      onMenuSetup: Oa(n)
    }), eL = (n) => A.from(RB(n)).map((a) => ({
      name: "language",
      text: "Language",
      icon: "language",
      getOptions: oe(a),
      hash: (l) => Cn(l.customCode) ? l.code : `${l.code}/${l.customCode}`,
      display: (l) => l.title,
      watcher: (l, d, g) => l.formatter.formatChanged("lang", g, !1, { value: d.code, customValue: d.customCode ?? null }).unbind,
      getCurrent: (l) => {
        const d = at.fromDom(l.selection.getNode());
        return Ll(d, (g) => A.some(g).filter(mc).bind((h) => Qr(h, "lang").map((x) => {
          const T = Qr(h, "data-mce-lang").getOrUndefined();
          return { code: x, customCode: T, title: "" };
        })));
      },
      setCurrent: (l, d) => l.execCommand("Lang", !1, d),
      onToolbarSetup: (l) => {
        const d = As();
        return l.setActive(n.formatter.match("lang", {}, void 0, !0)), d.set(n.formatter.formatChanged("lang", l.setActive, !0)), Bb(d.clear, Oa(n)(l));
      },
      onMenuSetup: Oa(n)
    })), mK = (n) => {
      J8(n, l3(n)), eL(n).each((s) => J8(n, s));
    }, fK = (n, s) => {
      bq(n, s), Sq(n, s), Ay(n, s), yq(n, s), P8(n, s);
    }, gK = (n) => {
      n.ui.registry.addContext("editable", () => n.selection.isEditable()), n.ui.registry.addContext("mode", (s) => n.mode.get() === s), n.ui.registry.addContext("any", St), n.ui.registry.addContext("formatting", (s) => n.formatter.canApply(s)), n.ui.registry.addContext("insert", (s) => n.schema.isValidChild(n.selection.getNode().tagName, s));
    }, hK = (n) => Op(n, "NodeChange", (s) => {
      s.setEnabled(n.queryCommandState("outdent") && n.selection.isEditable());
    }), pK = (n) => {
      n.ui.registry.addButton("outdent", {
        tooltip: "Decrease indent",
        icon: "outdent",
        onSetup: hK(n),
        onAction: Cl(n, "outdent")
      }), n.ui.registry.addButton("indent", {
        tooltip: "Increase indent",
        icon: "indent",
        onSetup: Oa(n, () => n.queryCommandState("indent")),
        onAction: Cl(n, "indent")
      });
    }, tL = (n) => {
      pK(n);
    }, CN = (n, s) => (a) => {
      a.setActive(s.get());
      const l = (d) => {
        s.set(d.state), a.setActive(d.state);
      };
      return n.on("PastePlainTextToggle", l), Bb(() => n.off("PastePlainTextToggle", l), Oa(n)(a));
    }, nL = (n) => {
      const s = Pt(WB(n)), a = () => n.execCommand("mceTogglePlainTextPaste");
      n.ui.registry.addToggleButton("pastetext", {
        active: !1,
        icon: "paste-text",
        tooltip: "Paste as text",
        onAction: a,
        onSetup: CN(n, s)
      }), n.ui.registry.addToggleMenuItem("pastetext", {
        text: "Paste as text",
        icon: "paste-text",
        onAction: a,
        onSetup: CN(n, s)
      });
    }, i3 = (n, s) => () => {
      n.execCommand("mceToggleFormat", !1, s);
    }, bK = (n) => {
      jf.each([
        { name: "bold", text: "Bold", icon: "bold", shortcut: "Meta+B" },
        { name: "italic", text: "Italic", icon: "italic", shortcut: "Meta+I" },
        { name: "underline", text: "Underline", icon: "underline", shortcut: "Meta+U" },
        { name: "strikethrough", text: "Strikethrough", icon: "strike-through" },
        { name: "subscript", text: "Subscript", icon: "subscript" },
        { name: "superscript", text: "Superscript", icon: "superscript" }
      ], (s, a) => {
        n.ui.registry.addToggleButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onSetup: Qx(n, s.name),
          onAction: i3(n, s.name),
          shortcut: s.shortcut
        });
      });
      for (let s = 1; s <= 6; s++) {
        const a = "h" + s, l = `Access+${s}`;
        n.ui.registry.addToggleButton(a, {
          text: a.toUpperCase(),
          tooltip: "Heading " + s,
          onSetup: Qx(n, a),
          onAction: i3(n, a),
          shortcut: l
        });
      }
    }, oL = (n) => {
      jf.each([
        { name: "copy", text: "Copy", action: "Copy", icon: "copy", context: "any" },
        { name: "help", text: "Help", action: "mceHelp", icon: "help", shortcut: "Alt+0", context: "any" },
        { name: "selectall", text: "Select all", action: "SelectAll", icon: "select-all", shortcut: "Meta+A", context: "any" },
        { name: "newdocument", text: "New document", action: "mceNewDocument", icon: "new-document" },
        { name: "print", text: "Print", action: "mcePrint", icon: "print", shortcut: "Meta+P", context: "any" }
      ], (s) => {
        n.ui.registry.addButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onAction: Cl(n, s.action),
          shortcut: s.shortcut,
          context: s.context
        });
      }), jf.each([
        { name: "cut", text: "Cut", action: "Cut", icon: "cut" },
        { name: "paste", text: "Paste", action: "Paste", icon: "paste" },
        // visualaid was here but also exists in VisualAid.ts?
        { name: "removeformat", text: "Clear formatting", action: "RemoveFormat", icon: "remove-formatting" },
        { name: "remove", text: "Remove", action: "Delete", icon: "remove" },
        { name: "hr", text: "Horizontal line", action: "InsertHorizontalRule", icon: "horizontal-rule" }
      ], (s) => {
        n.ui.registry.addButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onSetup: Oa(n),
          onAction: Cl(n, s.action)
        });
      });
    }, sL = (n) => {
      jf.each([
        { name: "blockquote", text: "Blockquote", action: "mceBlockQuote", icon: "quote" }
      ], (s) => {
        n.ui.registry.addToggleButton(s.name, {
          tooltip: s.text,
          icon: s.icon,
          onAction: Cl(n, s.action),
          onSetup: Qx(n, s.name)
        });
      });
    }, vK = (n) => {
      bK(n), oL(n), sL(n);
    }, AX = (n) => {
      jf.each([
        { name: "newdocument", text: "New document", action: "mceNewDocument", icon: "new-document" },
        { name: "copy", text: "Copy", action: "Copy", icon: "copy", shortcut: "Meta+C", context: "any" },
        { name: "selectall", text: "Select all", action: "SelectAll", icon: "select-all", shortcut: "Meta+A", context: "any" },
        { name: "print", text: "Print...", action: "mcePrint", icon: "print", shortcut: "Meta+P", context: "any" }
      ], (s) => {
        n.ui.registry.addMenuItem(s.name, {
          text: s.text,
          icon: s.icon,
          shortcut: s.shortcut,
          onAction: Cl(n, s.action),
          context: s.context
        });
      }), jf.each([
        { name: "bold", text: "Bold", action: "Bold", icon: "bold", shortcut: "Meta+B" },
        { name: "italic", text: "Italic", action: "Italic", icon: "italic", shortcut: "Meta+I" },
        { name: "underline", text: "Underline", action: "Underline", icon: "underline", shortcut: "Meta+U" },
        { name: "strikethrough", text: "Strikethrough", action: "Strikethrough", icon: "strike-through" },
        { name: "subscript", text: "Subscript", action: "Subscript", icon: "subscript" },
        { name: "superscript", text: "Superscript", action: "Superscript", icon: "superscript" },
        { name: "removeformat", text: "Clear formatting", action: "RemoveFormat", icon: "remove-formatting" },
        { name: "cut", text: "Cut", action: "Cut", icon: "cut", shortcut: "Meta+X" },
        { name: "paste", text: "Paste", action: "Paste", icon: "paste", shortcut: "Meta+V" },
        { name: "hr", text: "Horizontal line", action: "InsertHorizontalRule", icon: "horizontal-rule" }
      ], (s) => {
        n.ui.registry.addMenuItem(s.name, {
          text: s.text,
          icon: s.icon,
          shortcut: s.shortcut,
          onSetup: Oa(n),
          onAction: Cl(n, s.action)
        });
      }), n.ui.registry.addMenuItem("codeformat", {
        text: "Code",
        icon: "sourcecode",
        onSetup: Oa(n),
        onAction: i3(n, "code")
      });
    }, yK = (n) => {
      vK(n), AX(n);
    }, u3 = (n, s) => Op(n, "Undo Redo AddUndo TypingUndo ClearUndos SwitchMode", (a) => {
      a.setEnabled(!n.mode.isReadOnly() && n.undoManager[s]());
    }), CK = (n) => {
      n.ui.registry.addMenuItem("undo", {
        text: "Undo",
        icon: "undo",
        shortcut: "Meta+Z",
        onSetup: u3(n, "hasUndo"),
        onAction: Cl(n, "undo")
      }), n.ui.registry.addMenuItem("redo", {
        text: "Redo",
        icon: "redo",
        shortcut: "Meta+Y",
        onSetup: u3(n, "hasRedo"),
        onAction: Cl(n, "redo")
      });
    }, xK = (n) => {
      n.ui.registry.addButton("undo", {
        tooltip: "Undo",
        icon: "undo",
        enabled: !1,
        onSetup: u3(n, "hasUndo"),
        onAction: Cl(n, "undo"),
        shortcut: "Meta+Z"
      }), n.ui.registry.addButton("redo", {
        tooltip: "Redo",
        icon: "redo",
        enabled: !1,
        onSetup: u3(n, "hasRedo"),
        onAction: Cl(n, "redo"),
        shortcut: "Meta+Y"
      });
    }, SK = (n) => {
      CK(n), xK(n);
    }, wK = (n) => Op(n, "VisualAid", (s) => {
      s.setActive(n.hasVisual);
    }), EK = (n) => {
      n.ui.registry.addToggleMenuItem("visualaid", {
        text: "Visual aids",
        onSetup: wK(n),
        onAction: Cl(n, "mceToggleVisualAid"),
        context: "any"
      });
    }, TK = (n) => {
      n.ui.registry.addButton("visualaid", {
        tooltip: "Visual aids",
        text: "Visual aids",
        onAction: Cl(n, "mceToggleVisualAid"),
        context: "any"
      });
    }, kK = (n) => {
      TK(n), EK(n);
    }, AK = (n, s) => {
      dK(n), yK(n), fK(n, s), SK(n), q$(n), kK(n), tL(n), mK(n), nL(n), gK(n);
    }, _K = (n) => De(n) ? n.split(/[ ,]/) : n, rL = (n) => (s) => s.options.get(n), OK = (n) => {
      const s = n.options.register;
      s("contextmenu_avoid_overlap", {
        processor: "string",
        default: ""
      }), s("contextmenu_never_use_native", {
        processor: "boolean",
        default: !1
      }), s("contextmenu", {
        processor: (a) => a === !1 ? { value: [], valid: !0 } : De(a) || lt(a, De) ? { value: _K(a), valid: !0 } : { valid: !1, message: "Must be false or a string." },
        default: "link linkchecker image editimage table spellchecker configurepermanentpen"
      });
    }, xN = rL("contextmenu_never_use_native"), DK = rL("contextmenu_avoid_overlap"), RK = (n) => aL(n).length === 0, aL = (n) => {
      const s = n.ui.registry.getAll().contextMenus, a = n.options.get("contextmenu");
      return n.options.isSet("contextmenu") ? a : Ln(a, (l) => mo(s, l));
    }, wS = (n, s) => ({
      type: "makeshift",
      x: n,
      y: s
    }), NK = (n, s, a) => wS(n.x + s, n.y + a), SN = (n) => n.type === "longpress" || n.type.indexOf("touch") === 0, wN = (n) => {
      if (SN(n)) {
        const s = n.touches[0];
        return wS(s.pageX, s.pageY);
      } else
        return wS(n.pageX, n.pageY);
    }, MK = (n) => {
      if (SN(n)) {
        const s = n.touches[0];
        return wS(s.clientX, s.clientY);
      } else
        return wS(n.clientX, n.clientY);
    }, cL = (n, s) => {
      const a = qv.DOM.getPos(n);
      return NK(s, a.x, a.y);
    }, PK = (n, s) => s.type === "contextmenu" || s.type === "longpress" ? n.inline ? wN(s) : cL(n.getContentAreaContainer(), MK(s)) : lL(n), lL = (n) => ({
      type: "selection",
      root: at.fromDom(n.selection.getNode())
    }), BK = (n) => ({
      type: "node",
      node: A.some(at.fromDom(n.selection.getNode())),
      root: at.fromDom(n.getBody())
    }), iL = (n, s, a) => {
      switch (a) {
        case "node":
          return BK(n);
        case "point":
          return PK(n, s);
        case "selection":
          return lL(n);
      }
    }, $K = (n, s, a, l, d, g) => {
      const h = a(), C = iL(n, s, g);
      ah(h, Wd.CLOSE_ON_EXECUTE, l, {
        isHorizontalMenu: !1,
        search: A.none()
      }).map((x) => {
        s.preventDefault(), Us.showMenuAt(d, { anchor: C }, {
          menu: {
            markers: Lf("normal")
          },
          data: x
        });
      });
    }, EN = {
      onLtr: () => [
        Tr,
        Mr,
        Er,
        Ta,
        ua,
        Rs,
        La,
        Gh,
        Tc,
        Z0,
        Rg,
        B1
      ],
      onRtl: () => [
        Tr,
        Er,
        Mr,
        ua,
        Ta,
        Rs,
        La,
        Gh,
        Rg,
        B1,
        Tc,
        Z0
      ]
    }, IK = 12, FK = {
      valignCentre: [],
      alignCentre: [],
      alignLeft: ["tox-pop--align-left"],
      alignRight: ["tox-pop--align-right"],
      right: ["tox-pop--right"],
      left: ["tox-pop--left"],
      bottom: ["tox-pop--bottom"],
      top: ["tox-pop--top"]
    }, TN = (n, s) => {
      const a = n.selection;
      if (a.isCollapsed() || s.touches.length < 1)
        return !1;
      {
        const l = s.touches[0], d = a.getRng();
        return gg(n.getWin(), Hl.domRange(d)).exists((h) => h.left <= l.clientX && h.right >= l.clientX && h.top <= l.clientY && h.bottom >= l.clientY);
      }
    }, uL = (n) => {
      const s = n.selection.getRng(), a = () => {
        RT.setEditorTimeout(n, () => {
          n.selection.setRng(s);
        }, 10), g();
      };
      n.once("touchend", a);
      const l = (h) => {
        h.preventDefault(), h.stopImmediatePropagation();
      };
      n.on("mousedown", l, !0);
      const d = () => g();
      n.once("longpresscancel", d);
      const g = () => {
        n.off("touchend", a), n.off("longpresscancel", d), n.off("mousedown", l);
      };
    }, dL = (n, s, a) => {
      const l = iL(n, s, a);
      return {
        bubble: bl(0, a === "point" ? IK : 0, FK),
        layouts: EN,
        overrides: {
          maxWidthFunction: I1(),
          maxHeightFunction: Ng()
        },
        ...l
      };
    }, LK = (n, s, a, l, d, g, h) => {
      const C = dL(n, s, g);
      ah(a, Wd.CLOSE_ON_EXECUTE, l, {
        // MobileContextMenus are the *only* horizontal menus currently (2022-08-16)
        isHorizontalMenu: !0,
        search: A.none()
      }).map((x) => {
        s.preventDefault();
        const T = h ? Ha.HighlightMenuAndItem : Ha.HighlightNone;
        Us.showMenuWithinBounds(d, { anchor: C }, {
          menu: {
            markers: Lf("normal"),
            highlightOnOpen: T
          },
          data: x,
          type: "horizontal"
        }, () => A.some(gN(n, l.shared, g === "node" ? "node" : "selection"))), n.dispatch(uN);
      });
    }, HK = (n, s, a, l, d, g) => {
      const h = Zs(), C = h.os.isiOS(), x = h.os.isMacOS(), T = h.os.isAndroid(), _ = h.deviceType.isTouch(), N = () => !(T || C || x && _), L = () => {
        const j = a();
        LK(n, s, j, l, d, g, N());
      };
      if ((x || C) && g !== "node") {
        const j = () => {
          uL(n), L();
        };
        TN(n, s) ? j() : (n.once("selectionchange", j), n.once("touchend", () => n.off("selectionchange", j)));
      } else
        L();
    }, mL = (n) => De(n) ? n === "|" : n.type === "separator", kN = {
      type: "separator"
    }, fL = (n) => {
      const s = (a) => ({
        text: a.text,
        icon: a.icon,
        enabled: a.enabled,
        shortcut: a.shortcut
      });
      if (De(n))
        return n;
      switch (n.type) {
        case "separator":
          return kN;
        case "submenu":
          return {
            type: "nestedmenuitem",
            ...s(n),
            getSubmenuItems: () => {
              const l = n.getSubmenuItems();
              return De(l) ? l : ye(l, fL);
            }
          };
        default:
          const a = n;
          return {
            type: "menuitem",
            ...s(a),
            // disconnect the function from the menu item API bridge defines
            onAction: Ye(a.onAction)
          };
      }
    }, d3 = (n, s) => {
      if (s.length === 0)
        return n;
      const l = Ql(n).filter((d) => !mL(d)).fold(() => [], (d) => [kN]);
      return n.concat(l).concat(s).concat([kN]);
    }, zK = (n, s, a) => {
      const l = ao(s, (d, g) => Vt(n, g.toLowerCase()).map((h) => {
        const C = h.update(a);
        if (De(C) && ni(vt(C)))
          return d3(d, C.split(" "));
        if ($n(C) && C.length > 0) {
          const x = ye(C, fL);
          return d3(d, x);
        } else
          return d;
      }).getOrThunk(() => d.concat([g])), []);
      return l.length > 0 && mL(l[l.length - 1]) && l.pop(), l;
    }, gL = (n, s) => s.ctrlKey && !xN(n), VK = (n) => n.type === "longpress" || mo(n, "touches"), hL = (n, s) => (
      // Different browsers trigger the context menu from keyboards differently, so need to check various different things here.
      // If a longpress touch event, always treat it as a pointer event
      // Chrome: button = 0, pointerType = undefined & target = the selection range node
      // Firefox: button = 0, pointerType = undefined & target = body
      // Safari: N/A (Mac's don't expose a contextmenu keyboard shortcut)
      !VK(s) && (s.button !== 2 || s.target === n.getBody() && s.pointerType === "")
    ), m3 = (n, s) => hL(n, s) ? n.selection.getStart(!0) : s.target, UK = (n, s) => {
      const a = DK(n), l = hL(n, s) ? "selection" : "point";
      if (ni(a)) {
        const d = m3(n, s);
        return dg(at.fromDom(d), a) ? "node" : l;
      } else
        return l;
    }, pL = (n, s, a) => {
      const d = Zs().deviceType.isTouch, g = p(Us.sketch({
        dom: {
          tag: "div"
        },
        lazySink: s,
        onEscape: () => n.focus(),
        onShow: () => a.setContextMenuState(!0),
        onHide: () => a.setContextMenuState(!1),
        fireDismissalEventInstead: {},
        inlineBehaviours: nt([
          xn("dismissContextMenu", [
            Ie(fm(), (x, T) => {
              Co.close(x), n.focus();
            })
          ])
        ])
      })), h = () => Us.hide(g), C = (x) => {
        if (xN(n) && x.preventDefault(), gL(n, x) || RK(n))
          return;
        const T = UK(n, x), _ = () => {
          const L = m3(n, x), j = n.ui.registry.getAll(), Z = aL(n);
          return zK(j.contextMenus, Z, L);
        };
        (d() ? HK : $K)(n, x, _, a, g, T);
      };
      n.on("init", () => {
        const x = "ResizeEditor ScrollContent ScrollWindow longpresscancel" + (d() ? "" : " ResizeWindow");
        n.on(x, h), n.on("longpress contextmenu", C);
      });
    }, ES = 40, f3 = ES / 2, bL = (n, s, a, l, d, g) => n.fold(() => Wg.snap({
      sensor: Pd(a - f3, l - f3),
      range: Mo(d, g),
      output: Pd(A.some(a), A.some(l)),
      extra: {
        td: s
      }
    }), (h) => {
      const C = a - f3, x = l - f3, T = ES, _ = ES, N = h.element.dom.getBoundingClientRect();
      return Wg.snap({
        sensor: Pd(C, x),
        range: Mo(T, _),
        output: Pd(A.some(a - N.width / 2), A.some(l - N.height / 2)),
        extra: {
          td: s
        }
      });
    }), vL = (n, s, a) => {
      const l = (d, g) => d.exists((h) => I(h, g));
      return {
        getSnapPoints: n,
        leftAttr: "data-drag-left",
        topAttr: "data-drag-top",
        onSensor: (d, g) => {
          const h = g.td;
          l(s.get(), h) || (s.set(h), a(h));
        },
        mustSnap: !0
      };
    }, yL = (n) => To(oa.sketch({
      dom: {
        tag: "div",
        classes: ["tox-selector"]
      },
      buttonBehaviours: nt([
        Wg.config({
          mode: "mouseOrTouch",
          blockerClass: "blocker",
          snaps: n
        }),
        Om.config({})
      ]),
      eventOrder: {
        // Because this is a button, allow dragging. It will stop clicking.
        mousedown: ["dragging", "alloy.base.behaviour"],
        touchstart: ["dragging", "alloy.base.behaviour"]
      }
    })), jK = (n, s) => {
      const a = Pt([]), l = Pt([]), d = Pt(!1), g = hn(), h = hn(), C = (Ue) => {
        const Qe = cf(Ue);
        return bL(j.getOpt(s), Ue, Qe.x, Qe.y, Qe.width, Qe.height);
      }, x = () => (
        // const body = SugarBody.body();
        // const debugs = SelectorFilter.descendants(body, '.top-left-snap-debug');
        // Arr.each(debugs, (debugArea) => {
        //   Remove.remove(debugArea);
        // });
        ye(a.get(), (Ue) => C(Ue))
      ), T = (Ue) => {
        const Qe = cf(Ue);
        return bL(Z.getOpt(s), Ue, Qe.right, Qe.bottom, Qe.width, Qe.height);
      }, _ = () => (
        // const body = SugarBody.body();
        // const debugs = SelectorFilter.descendants(body, '.bottom-right-snap-debug');
        // Arr.each(debugs, (debugArea) => {
        //   Remove.remove(debugArea);
        // });
        ye(l.get(), (Ue) => T(Ue))
      ), N = vL(x, g, (Ue) => {
        h.get().each((Qe) => {
          n.dispatch("TableSelectorChange", { start: Ue, finish: Qe });
        });
      }), L = vL(_, h, (Ue) => {
        g.get().each((Qe) => {
          n.dispatch("TableSelectorChange", { start: Qe, finish: Ue });
        });
      }), j = yL(N), Z = yL(L), ne = p(j.asSpec()), ae = p(Z.asSpec()), Y = (Ue, Qe, Ke, Qt) => {
        const zt = Qe.dom.getBoundingClientRect();
        Kn(Ue.element, "display");
        const jn = sg(at.fromDom(n.getBody())).dom.innerHeight, Jt = Ke(zt), _n = Qt(zt, jn);
        (Jt || _n) && gn(Ue.element, "display", "none");
      }, le = (Ue, Qe, Ke, Qt) => {
        const zt = Ke(Qe);
        Wg.snapTo(Ue, zt), Y(Ue, Qe, (_n) => _n[Qt] < 0, (_n, Ut) => _n[Qt] > Ut);
      }, pe = (Ue) => le(ne, Ue, C, "top"), Ee = () => g.get().each(pe), Oe = (Ue) => le(ae, Ue, T, "bottom"), gt = () => h.get().each(Oe);
      if (Zs().deviceType.isTouch()) {
        const Ue = (Qe) => ye(Qe, at.fromDom);
        n.on("TableSelectionChange", (Qe) => {
          d.get() || (xm(s, ne), xm(s, ae), d.set(!0));
          const Ke = at.fromDom(Qe.start), Qt = at.fromDom(Qe.finish);
          g.set(Ke), h.set(Qt), A.from(Qe.otherCells).each((zt) => {
            a.set(Ue(zt.upOrLeftCells)), l.set(Ue(zt.downOrRightCells)), pe(Ke), Oe(Qt);
          });
        }), n.on("ResizeEditor ResizeWindow ScrollContent", () => {
          Ee(), gt();
        }), n.on("TableSelectionClear", () => {
          d.get() && (wm(ne), wm(ae), d.set(!1)), g.clear(), h.clear();
        });
      }
    };
    var CL = `<svg height="16" viewBox="0 0 80 16" width="80" xmlns="http://www.w3.org/2000/svg"><g opacity=".8"><path d="m80 3.537v-2.202h-7.976v11.585h7.976v-2.25h-5.474v-2.621h4.812v-2.069h-4.812v-2.443zm-10.647 6.929c-.493.217-1.13.337-1.864.337s-1.276-.156-1.805-.47a3.732 3.732 0 0 1 -1.3-1.298c-.324-.554-.48-1.191-.48-1.877s.156-1.335.48-1.877a3.635 3.635 0 0 1 1.3-1.299 3.466 3.466 0 0 1 1.805-.481c.65 0 .914.06 1.263.18.36.12.698.277.986.47.289.192.578.384.842.6l.12.085v-2.586l-.023-.024c-.385-.35-.855-.614-1.384-.818-.53-.205-1.155-.313-1.877-.313-.721 0-1.6.144-2.333.445a5.773 5.773 0 0 0 -1.937 1.251 5.929 5.929 0 0 0 -1.324 1.9c-.324.735-.48 1.565-.48 2.455s.156 1.72.48 2.454c.325.734.758 1.383 1.324 1.913.553.53 1.215.938 1.937 1.25a6.286 6.286 0 0 0 2.333.434c.819 0 1.384-.108 1.961-.313.59-.216 1.083-.505 1.468-.866l.024-.024v-2.49l-.12.096c-.41.337-.878.626-1.396.866zm-14.869-4.15-4.8-5.04-.024-.025h-.902v11.67h2.502v-6.847l2.827 3.08.385.409.397-.41 2.791-3.067v6.845h2.502v-11.679h-.902l-4.788 5.052z"/><path clip-rule="evenodd" d="m15.543 5.137c0-3.032-2.466-5.113-4.957-5.137-.36 0-.745.024-1.094.096-.157.024-3.85.758-3.85.758-3.032.602-4.62 2.466-4.704 4.788-.024.89-.024 4.27-.024 4.27.036 3.165 2.406 5.138 5.017 5.126.337 0 1.119-.109 1.287-.145.144-.024.385-.084.746-.144.661-.12 1.684-.325 3.067-.602 2.37-.409 4.103-2.009 4.44-4.33.156-1.023.084-4.692.084-4.692zm-3.213 3.308-2.346.457v2.31l-5.859 1.143v-5.75l2.346-.458v3.441l3.513-.686v-3.44l-3.513.685v-2.297l5.859-1.143v5.75zm20.09-3.296-.083-1.023h-2.13v8.794h2.346v-4.884c0-1.107.95-1.985 2.057-1.997 1.095 0 1.901.89 1.901 1.997v4.884h2.346v-5.245c-.012-2.105-1.588-3.777-3.67-3.765a3.764 3.764 0 0 0 -2.778 1.25l.012-.011zm-6.014-4.102 2.346-.458v2.298l-2.346.457z" fill-rule="evenodd"/><path d="m28.752 4.126h-2.346v8.794h2.346z"/><path clip-rule="evenodd" d="m43.777 15.483 4.043-11.357h-2.418l-1.54 4.355-.445 1.324-.36-1.324-1.54-4.355h-2.418l3.151 8.794-1.083 3.08zm-21.028-5.51c0 .722.541 1.034.878 1.034s.638-.048.95-.144l.518 1.708c-.217.145-.879.518-2.13.518a2.565 2.565 0 0 1 -2.562-2.587c-.024-1.082-.024-2.49 0-4.21h-1.54v-2.142h1.54v-1.912l2.346-.458v2.37h2.201v2.142h-2.2v3.693-.012z" fill-rule="evenodd"/></g></svg>
`;
    const WK = (n) => n.nodeName === "BR" || !!n.getAttribute("data-mce-bogus") || n.getAttribute("data-mce-type") === "bookmark", ZK = (n, s, a) => {
      const l = s.delimiter ?? "›", d = (x, T, _) => oa.sketch({
        dom: {
          tag: "div",
          classes: ["tox-statusbar__path-item"],
          attributes: {
            "data-index": _
          }
        },
        components: [
          xs(x)
        ],
        action: (N) => {
          n.focus(), n.selection.select(T), n.nodeChanged();
        },
        buttonBehaviours: nt([
          ps.config({
            ...a.tooltips.getConfig({
              tooltipText: a.translate(["Select the {0} element", T.nodeName.toLowerCase()]),
              onShow: (N, L) => {
                zl(N.element, L.element);
              },
              onHide: (N) => {
                c2(N.element);
              }
            })
          }),
          Lm.button(a.isDisabled),
          yr(() => a.checkUiComponentContext("any"))
        ])
      }), g = () => ({
        dom: {
          tag: "div",
          classes: ["tox-statusbar__path-divider"],
          attributes: {
            "aria-hidden": !0
          }
        },
        components: [
          xs(` ${l} `)
        ]
      }), h = (x) => ao(x, (T, _, N) => {
        const L = d(_.name, _.element, N);
        return N === 0 ? T.concat([L]) : T.concat([g(), L]);
      }, []), C = (x) => {
        const T = [];
        let _ = x.length;
        for (; _-- > 0; ) {
          const N = x[_];
          if (N.nodeType === 1 && !WK(N)) {
            const L = rW(n, N);
            if (L.isDefaultPrevented() || T.push({ name: L.name, element: N }), L.isPropagationStopped())
              break;
          }
        }
        return T;
      };
      return {
        dom: {
          tag: "div",
          classes: ["tox-statusbar__path"],
          attributes: {
            role: "navigation"
          }
        },
        behaviours: nt([
          Xt.config({
            mode: "flow",
            selector: "div[role=button]"
          }),
          Ft.config({
            disabled: a.isDisabled
          }),
          yr(() => a.checkUiComponentContext("any")),
          is.config({}),
          An.config({}),
          xn("elementPathEvents", [
            hs((x, T) => {
              n.shortcuts.add("alt+F11", "focus statusbar elementpath", () => Xt.focusIn(x)), n.on("NodeChange", (_) => {
                const N = C(_.parents), L = N.length > 0 ? h(N) : [];
                An.set(x, L);
              });
            })
          ])
        ]),
        components: []
      };
    };
    var Gf;
    (function(n) {
      n[n.None = 0] = "None", n[n.Both = 1] = "Both", n[n.Vertical = 2] = "Vertical";
    })(Gf || (Gf = {}));
    const xL = (n) => {
      const s = at.fromDom(n.getContainer()), a = hr(s), l = la(s);
      return {
        height: a,
        width: l
      };
    }, GK = (n, s, a, l) => {
      const d = n3(l.height + s.top, rO(n), aO(n));
      return a === Gf.Both ? {
        height: d,
        width: n3(l.width + s.left, sO(n), MT(n))
      } : { height: d };
    }, SL = (n, s, a) => {
      const l = at.fromDom(n.getContainer()), d = xL(n), g = GK(n, s, a, d);
      return ds(g, (h, C) => {
        In(h) && gn(l, C, t3(h));
      }), FD(n), g;
    }, qK = (n) => {
      const s = jB(n);
      return s === !1 ? Gf.None : s === "both" ? Gf.Both : Gf.Vertical;
    }, KK = (n, s) => s === Gf.Both ? Rc.translate(["Editor's height: {0} pixels, Editor's width: {1} pixels", n.height, n.width]) : Rc.translate(["Editor's height: {0} pixels", n.height]), AN = (n, s, a) => {
      ln(n.element, "aria-valuetext", KK(s, a));
    }, g3 = (n, s, a, l, d) => {
      const h = Mo(l * 20, d * 20), C = SL(n, h, a);
      return AN(s, C, a), A.some(!0);
    }, wL = (n, s) => {
      const a = qK(n);
      if (a === Gf.None)
        return A.none();
      const l = a === Gf.Both ? Rc.translate("Press the arrow keys to resize the editor.") : Rc.translate("Press the Up and Down arrow keys to resize the editor."), d = a === Gf.Both ? "tox-statusbar__resize-cursor-both" : "tox-statusbar__resize-cursor-default";
      return A.some(iu("resize-handle", {
        tag: "div",
        classes: ["tox-statusbar__resize-handle", d],
        attributes: {
          "aria-label": s.translate(l),
          "data-mce-name": "resize-handle",
          role: "separator"
        },
        behaviours: [
          Wg.config({
            mode: "mouse",
            repositionTarget: !1,
            onDrag: (g, h, C) => {
              const x = SL(n, C, a);
              AN(g, x, a);
            },
            blockerClass: "tox-blocker"
          }),
          Xt.config({
            mode: "special",
            onLeft: (g) => g3(n, g, a, -1, 0),
            onRight: (g) => g3(n, g, a, 1, 0),
            onUp: (g) => g3(n, g, a, 0, -1),
            onDown: (g) => g3(n, g, a, 0, 1)
          }),
          is.config({}),
          En.config({}),
          ps.config(s.tooltips.getConfig({
            tooltipText: s.translate("Resize")
          })),
          xn("set-aria-valuetext", [
            hs((g) => {
              const h = () => {
                AN(g, xL(n), a);
              };
              n._skinLoaded ? h() : n.once("SkinLoaded", h);
            })
          ])
        ],
        eventOrder: {
          [Mu()]: ["add-focusable", "set-aria-valuetext"]
        }
      }, s.icons));
    }, YK = (n, s) => {
      const a = (l, d, g) => An.set(l, [xs(s.translate(["{0} " + g, d[g]]))]);
      return oa.sketch({
        dom: {
          // The tag for word count was changed to 'button' as Jaws does not read out spans.
          // Word count is just a toggle and changes modes between words and characters.
          tag: "button",
          classes: ["tox-statusbar__wordcount"]
        },
        components: [],
        buttonBehaviours: nt([
          Lm.button(s.isDisabled),
          yr(() => s.checkUiComponentContext("any")),
          is.config({}),
          An.config({}),
          _t.config({
            store: {
              mode: "memory",
              initialValue: {
                mode: "words",
                count: { words: 0, characters: 0 }
              }
            }
          }),
          xn("wordcount-events", [
            Ef((l) => {
              const d = _t.getValue(l), g = d.mode === "words" ? "characters" : "words";
              _t.setValue(l, { mode: g, count: d.count }), a(l, d.count, g);
            }),
            hs((l) => {
              n.on("wordCountUpdate", (d) => {
                const { mode: g } = _t.getValue(l);
                _t.setValue(l, { mode: g, count: d.wordCount }), a(l, d.wordCount, g);
              });
            })
          ])
        ]),
        eventOrder: {
          [wa()]: ["disabling", "alloy.base.behaviour", "wordcount-events"]
        }
      });
    }, EL = (n, s) => {
      const a = () => ({
        dom: {
          tag: "span",
          classes: ["tox-statusbar__branding"]
        },
        components: [
          {
            dom: {
              tag: "a",
              attributes: {
                href: "https://www.tiny.cloud/powered-by-tiny?utm_campaign=poweredby&utm_source=tiny&utm_medium=referral&utm_content=v7",
                rel: "noopener",
                target: "_blank",
                "aria-label": n.translate(["Build with {0}", "TinyMCE"])
              },
              innerHtml: n.translate(["Build with {0}", CL.trim()])
            },
            behaviours: nt([
              En.config({})
            ])
          }
        ]
      }), l = () => {
        const C = ED("Alt+0");
        return {
          dom: {
            tag: "div",
            classes: ["tox-statusbar__help-text"]
          },
          components: [
            xs(Rc.translate(["Press {0} for help", C]))
          ]
        };
      }, d = () => {
        const C = [];
        return n.hasPlugin("wordcount") && C.push(YK(n, s)), mO(n) && C.push(a()), {
          dom: {
            tag: "div",
            classes: ["tox-statusbar__right-container"]
          },
          components: C
        };
      }, g = () => {
        const C = [], x = qB(n), T = UB(n), _ = mO(n) || n.hasPlugin("wordcount"), N = () => {
          const L = "tox-statusbar__text-container--flex-start", j = "tox-statusbar__text-container--flex-end", Z = "tox-statusbar__text-container--space-around";
          if (x) {
            const ne = "tox-statusbar__text-container-3-cols";
            return !_ && !T ? [ne, Z] : _ && !T ? [ne, j] : [ne, L];
          }
          return [_ && !T ? j : L];
        };
        return T && C.push(ZK(n, {}, s)), x && C.push(l()), _ && C.push(d()), C.length > 0 ? [{
          dom: {
            tag: "div",
            classes: ["tox-statusbar__text-container", ...N()]
          },
          components: C
        }] : [];
      };
      return {
        dom: {
          tag: "div",
          classes: ["tox-statusbar"]
        },
        components: (() => {
          const C = g(), x = wL(n, s);
          return C.concat(x.toArray());
        })()
      };
    }, TL = (n, s) => s.get().getOrDie(`UI for ${n} has not been rendered`), XK = (n, s) => {
      const a = n.inline, l = a ? Jq : Wq, d = ty(n) ? CG : gG, g = o3(), h = hn(), C = hn(), x = hn(), L = Zs().deviceType.isTouch() ? ["tox-platform-touch"] : [], j = IT(n), Z = yb(n), ne = To({
        dom: {
          tag: "div",
          classes: ["tox-anchorbar"]
        }
      }), ae = To({
        dom: {
          tag: "div",
          classes: ["tox-bottom-anchorbar"]
        }
      }), Y = () => g.mainUi.get().map((qt) => qt.outerContainer).bind(es.getHeader), le = () => Wt.fromOption(g.dialogUi.get().map((qt) => qt.sink), "UI has not been rendered"), pe = () => Wt.fromOption(g.popupUi.get().map((qt) => qt.sink), "(popup) UI has not been rendered"), Ee = g.lazyGetInOuterOrDie("anchor bar", ne.getOpt), Oe = g.lazyGetInOuterOrDie("bottom anchor bar", ae.getOpt), gt = g.lazyGetInOuterOrDie("toolbar", es.getToolbar), Ue = g.lazyGetInOuterOrDie("throbber", es.getThrobber), Qe = dG({
        popup: pe,
        dialog: le
      }, n, Ee, Oe), Ke = () => {
        const qt = {
          attributes: {
            [G0]: j ? bm.BottomToTop : bm.TopToBottom
          }
        }, Nn = es.parts.menubar({
          dom: {
            tag: "div",
            classes: ["tox-menubar"]
          },
          // TINY-9223: The menu bar should scroll with the editor.
          backstage: Qe.popup,
          onEscape: () => {
            n.focus();
          }
        }), Xo = es.parts.toolbar({
          dom: {
            tag: "div",
            classes: ["tox-toolbar"]
          },
          getSink: Qe.popup.shared.getSink,
          providers: Qe.popup.shared.providers,
          onEscape: () => {
            n.focus();
          },
          onToolbarToggled: (qf) => {
            aW(n, qf);
          },
          type: Z,
          lazyToolbar: gt,
          lazyHeader: () => Y().getOrDie("Could not find header element"),
          ...qt
        }), ko = es.parts["multiple-toolbar"]({
          dom: {
            tag: "div",
            classes: ["tox-toolbar-overlord"]
          },
          providers: Qe.popup.shared.providers,
          onEscape: () => {
            n.focus();
          },
          type: Z
        }), ac = xp(n), Ms = Jv(n), Yl = Qv(n), Da = GB(n), mu = Qt(Da), Wa = ac || Ms || Yl, nd = () => ac ? [ko] : Ms ? [Xo] : [], Pp = [mu, Nn];
        return es.parts.header({
          dom: {
            tag: "div",
            classes: ["tox-editor-header"].concat(Wa ? [] : ["tox-editor-header--empty"]),
            ...qt
          },
          components: en([
            Yl ? Pp : [],
            nd(),
            // fixed_toolbar_container anchors to the editable area, else add an anchor bar
            ey(n) ? [] : [ne.asSpec()]
          ]),
          sticky: ty(n),
          editor: n,
          // TINY-9223: If using a sticky toolbar, which sink should it really go in?
          sharedBackstage: Qe.popup.shared
        });
      }, Qt = (qt) => es.parts.promotion({
        dom: {
          tag: "div",
          classes: ["tox-promotion"]
        },
        promotionLink: qt
      }), zt = () => {
        const qt = es.parts.socket({
          dom: {
            tag: "div",
            classes: ["tox-edit-area"]
          }
        }), Nn = es.parts.sidebar({
          dom: {
            tag: "div",
            classes: ["tox-sidebar"]
          }
        });
        return {
          dom: {
            tag: "div",
            classes: ["tox-sidebar-wrap"]
          },
          components: [
            qt,
            Nn
          ]
        };
      }, jn = () => {
        const qt = gO(n), Nn = I(Lc(), qt) && gs(qt, "display") === "grid", Xo = {
          dom: {
            tag: "div",
            classes: ["tox", "tox-silver-sink", "tox-tinymce-aux"].concat(L),
            attributes: {
              ...Rc.isRtl() ? { dir: "rtl" } : {}
            }
          },
          behaviours: nt([
            Oc.config({
              useFixed: () => d.isDocked(Y)
            })
          ])
        }, ko = {
          dom: {
            styles: { width: document.body.clientWidth + "px" }
          },
          events: Ts([
            Ie(Lh(), (Yl) => {
              gn(Yl.element, "width", document.body.clientWidth + "px");
            })
          ])
        }, ac = p(Ho(Xo, Nn ? ko : {})), Ms = s_(ac);
        return C.set(Ms), { sink: ac, mothership: Ms };
      }, Jt = () => {
        const qt = {
          dom: {
            tag: "div",
            classes: ["tox", "tox-silver-sink", "tox-silver-popup-sink", "tox-tinymce-aux"].concat(L),
            attributes: {
              ...Rc.isRtl() ? { dir: "rtl" } : {}
            }
          },
          behaviours: nt([
            Oc.config({
              useFixed: () => d.isDocked(Y),
              // TINY-9226: We want to limit the popup sink's bounds based on its scrolling environment. We don't
              // want it to try to position things outside of its scrolling viewport, because they will
              // just appear offscreen (hidden by the current scroll values)
              getBounds: () => s.getPopupSinkBounds()
            })
          ])
        }, Nn = p(qt), Xo = s_(Nn);
        return x.set(Xo), { sink: Nn, mothership: Xo };
      }, _n = () => {
        const qt = Ke(), Nn = zt(), Xo = es.parts.throbber({
          dom: {
            tag: "div",
            classes: ["tox-throbber"]
          },
          backstage: Qe.popup
        }), ko = es.parts.viewWrapper({
          backstage: Qe.popup
        }), ac = VB(n) && !a ? A.some(EL(n, Qe.popup.shared.providers)) : A.none(), Ms = en([
          j ? [] : [qt],
          // Inline mode does not have a socket/sidebar
          a ? [] : [Nn],
          j ? [qt] : []
        ]), Yl = es.parts.editorContainer({
          components: en([
            Ms,
            a ? [] : [ae.asSpec()]
          ])
        }), Da = hO(n), mu = {
          role: "application",
          ...Rc.isRtl() ? { dir: "rtl" } : {},
          ...Da ? { "aria-hidden": "true" } : {}
        }, Wa = p(es.sketch({
          dom: {
            tag: "div",
            classes: ["tox", "tox-tinymce"].concat(a ? ["tox-tinymce-inline"] : []).concat(j ? ["tox-tinymce--toolbar-bottom"] : []).concat(L),
            styles: {
              // This is overridden by the skin, it helps avoid FOUC
              visibility: "hidden",
              // Hide the container if needed, but don't use "display: none" so that it still has a position
              ...Da ? { opacity: "0", border: "0" } : {}
            },
            attributes: mu
          },
          components: [
            Yl,
            // Inline mode does not have a status bar
            ...a ? [] : [ko, ...ac.toArray()],
            Xo
          ],
          behaviours: nt([
            yr(() => Qe.popup.shared.providers.checkUiComponentContext("any")),
            Ft.config({
              disableClass: "tox-tinymce--disabled"
            }),
            Xt.config({
              mode: "cyclic",
              selector: ".tox-menubar, .tox-toolbar, .tox-toolbar__primary, .tox-toolbar__overflow--open, .tox-sidebar__overflow--open, .tox-statusbar__path, .tox-statusbar__wordcount, .tox-statusbar__branding a, .tox-statusbar__resize-handle"
            })
          ])
        })), nd = s_(Wa);
        return h.set(nd), { mothership: nd, outerContainer: Wa };
      }, Ut = (qt) => {
        const Nn = t3(Kq(n)), Xo = t3(Yq(n));
        return n.inline || (Qm("div", "width", Xo) && gn(qt.element, "width", Xo), Qm("div", "height", Nn) ? gn(qt.element, "height", Nn) : gn(qt.element, "height", "400px")), Nn;
      }, Ve = (qt) => {
        n.addShortcut("alt+F9", "focus menubar", () => {
          es.focusMenubar(qt);
        }), n.addShortcut("alt+F10", "focus toolbar", () => {
          es.focusToolbar(qt);
        }), n.addCommand("ToggleToolbarDrawer", (Nn, Xo, ko) => {
          Xo?.skipFocus ? (mG("skipFocus"), es.toggleToolbarDrawerWithoutFocusing(qt)) : ko?.skip_focus ? es.toggleToolbarDrawerWithoutFocusing(qt) : es.toggleToolbarDrawer(qt);
        }), n.addQueryStateHandler("ToggleToolbarDrawer", () => es.isToolbarDrawerToggled(qt)), n.on("blur", () => {
          yb(n) === lu.floating && es.isToolbarDrawerToggled(qt) && es.toggleToolbarDrawerWithoutFocusing(qt);
        });
      }, ct = (qt) => {
        const { mainUi: Nn, popupUi: Xo, uiMotherships: ko } = qt;
        Bs(MB(n), (Kf, kS) => {
          n.ui.registry.addGroupToolbarButton(kS, Kf);
        });
        const { buttons: ac, menuItems: Ms, contextToolbars: Yl, sidebars: Da, views: mu } = n.ui.registry.getAll(), Wa = _x(n), nd = {
          menuItems: Ms,
          menus: QB(n),
          menubar: IB(n),
          toolbar: Wa.getOrThunk(() => BT(n)),
          allowToolbarGroups: Z === lu.floating,
          buttons: ac,
          sidebar: Da,
          views: mu
        };
        Ve(Nn.outerContainer), HR(n, Nn.mothership, ko), d.setup(n, Qe.popup.shared, Y), AK(n, Qe.popup), pL(n, Qe.popup.shared.getSink, Qe.popup), wG(n), _G(n, Ue, Qe.popup.shared), Q8(n, Yl, Xo.sink, { backstage: Qe.popup }), jK(n, Xo.sink);
        const Pp = n.getElement(), qf = Ut(Nn.outerContainer), Ny = { targetNode: Pp, height: qf };
        return l.render(n, qt, nd, Qe.popup, Ny);
      }, mn = (qt) => (x.set(qt.mothership), qt), Pn = () => {
        const qt = _n(), Nn = jn(), Xo = Sp(n) ? Jt() : mn(Nn);
        g.dialogUi.set(Nn), g.popupUi.set(Xo), g.mainUi.set(qt);
        const ko = {
          popupUi: Xo,
          dialogUi: Nn,
          mainUi: qt,
          uiMotherships: g.getUiMotherships()
        };
        return ct(ko);
      };
      return {
        popups: {
          backstage: Qe.popup,
          getMothership: () => TL("popups", x)
        },
        dialogs: {
          backstage: Qe.dialog,
          getMothership: () => TL("dialogs", C)
        },
        renderUI: Pn
      };
    }, kL = (n) => {
      const s = [], a = {};
      return ds(n, (l, d) => {
        l.fold(() => {
          s.push(d);
        }, (g) => {
          a[d] = g;
        });
      }), s.length > 0 ? Wt.error(s) : Wt.value(a);
    }, zb = (n, s, a, l) => {
      const d = To(bp.sketch((g) => ({
        dom: {
          tag: "div",
          classes: ["tox-form"].concat(n.classes)
        },
        // All of the items passed through the form need to be put through the interpreter
        // with their form part preserved.
        components: ye(n.items, (h) => uF(g, h, s, a, l))
      })));
      return {
        dom: {
          tag: "div",
          classes: ["tox-dialog__body"]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-dialog__body-content"]
            },
            components: [
              d.asSpec()
            ]
          }
        ],
        behaviours: nt([
          Xt.config({
            mode: "acyclic",
            useTabstopAt: X(tS)
          }),
          Gd.memento(d),
          ZW(d, {
            postprocess: (g) => kL(g).fold((h) => (console.error(h), {}), Yt)
          }),
          xn("dialog-body-panel", [
            // TINY-10101: This is to cater for the case where clicks are made into the dialog instead using keyboard navigation, as FocusShifted would not be triggered in that case.
            Ie(Ki(), (g, h) => {
              g.getSystem().broadcastOn([Rp], {
                newFocus: A.some(h.event.target)
              });
            })
          ])
        ])
      };
    }, AL = (n, s, a) => ye(n, (l, d) => {
      An.set(a, n[d].view());
      const g = s.dom.getBoundingClientRect();
      return An.set(a, []), g.height;
    }), QK = (n) => _o(Io(n, (s, a) => s > a ? -1 : s < a ? 1 : 0)), JK = (n, s, a) => {
      const l = Zp(n).dom, d = Fl(n, ".tox-dialog-wrap").getOr(n), g = gs(d, "position") === "fixed";
      let h;
      g ? h = Math.max(l.clientHeight, window.innerHeight) : h = Math.max(l.offsetHeight, l.scrollHeight);
      const C = hr(s), T = s.dom.offsetLeft >= a.dom.offsetLeft + la(a) ? Math.max(hr(a), C) : C, _ = parseInt(gs(n, "margin-top"), 10) || 0, N = parseInt(gs(n, "margin-bottom"), 10) || 0, j = hr(n) + _ + N - T;
      return h - j;
    }, eY = (n, s) => {
      _o(n).each((a) => vb.showTab(s, a.value));
    }, _L = (n, s) => {
      gn(n, "height", s + "px"), gn(n, "flex-basis", s + "px");
    }, h3 = (n, s, a) => {
      Fl(n, '[role="dialog"]').each((l) => {
        Po(l, '[role="tablist"]').each((d) => {
          a.get().map((g) => (gn(s, "height", "0"), gn(s, "flex-basis", "0"), Math.min(g, JK(l, s, d)))).each((g) => {
            _L(s, g);
          });
        });
      });
    }, p3 = (n) => Po(n, '[role="tabpanel"]'), tY = (n) => {
      const s = hn();
      return {
        extraEvents: [
          hs((d) => {
            const g = d.element;
            p3(g).each((h) => {
              gn(h, "visibility", "hidden"), d.getSystem().getByDom(h).toOptional().each((C) => {
                const x = AL(n, h, C);
                QK(x).fold(s.clear, s.set);
              }), h3(g, h, s), Kn(h, "visibility"), eY(n, d), requestAnimationFrame(() => {
                h3(g, h, s);
              });
            });
          }),
          Ie(Lh(), (d) => {
            const g = d.element;
            p3(g).each((h) => {
              h3(g, h, s);
            });
          }),
          Ie(lR, (d, g) => {
            const h = d.element;
            p3(h).each((C) => {
              const x = Ir(mr(C));
              gn(C, "visibility", "hidden");
              const T = Cs(C, "height").map((L) => parseInt(L, 10));
              Kn(C, "height"), Kn(C, "flex-basis");
              const _ = C.dom.getBoundingClientRect().height;
              T.forall((L) => _ > L) ? (s.set(_), h3(h, C, s)) : T.each((L) => {
                _L(C, L);
              }), Kn(C, "visibility"), x.each($r);
            });
          })
        ],
        selectFirst: !1
      };
    }, OL = "send-data-to-section", DL = "send-data-to-view", nY = (n, s, a, l) => {
      const d = Pt({}), g = (_) => {
        const N = _t.getValue(_), L = kL(N).getOr({}), j = d.get(), Z = Ho(j, L);
        d.set(Z);
      }, h = (_) => {
        const N = d.get();
        _t.setValue(_, N);
      }, C = Pt(null), x = ye(n.tabs, (_) => ({
        value: _.name,
        dom: {
          tag: "div",
          classes: ["tox-dialog__body-nav-item"]
        },
        components: [
          xs(a.shared.providers.translate(_.title))
        ],
        view: () => [
          // Dupe with SilverDialog
          bp.sketch((N) => ({
            dom: {
              tag: "div",
              classes: ["tox-form"]
            },
            components: ye(_.items, (L) => uF(N, L, s, a, l)),
            formBehaviours: nt([
              Xt.config({
                mode: "acyclic",
                useTabstopAt: X(tS)
              }),
              xn("TabView.form.events", [
                hs(h),
                eu(g)
              ]),
              Dc.config({
                channels: Ph([
                  {
                    key: OL,
                    value: {
                      onReceive: g
                    }
                  },
                  {
                    key: DL,
                    value: {
                      onReceive: h
                    }
                  }
                ])
              })
            ])
          }))
        ]
      })), T = tY(x);
      return vb.sketch({
        dom: {
          tag: "div",
          classes: ["tox-dialog__body"]
        },
        onChangeTab: (_, N, L) => {
          const j = _t.getValue(N);
          tn(_, uI, {
            name: j,
            oldName: C.get()
          }), C.set(j);
        },
        tabs: x,
        components: [
          vb.parts.tabbar({
            dom: {
              tag: "div",
              classes: ["tox-dialog__body-nav"]
            },
            components: [
              SB.parts.tabs({})
            ],
            markers: {
              tabClass: "tox-tab",
              selectedClass: "tox-dialog__body-nav-item--active"
            },
            tabbarBehaviours: nt([
              is.config({})
            ])
          }),
          vb.parts.tabview({
            dom: {
              tag: "div",
              classes: ["tox-dialog__body-content"]
            }
          })
        ],
        selectFirst: T.selectFirst,
        tabSectionBehaviours: nt([
          xn("tabpanel", T.extraEvents),
          Xt.config({
            mode: "acyclic"
          }),
          // INVESTIGATE: Is this necessary? Probably used by getCompByName.
          Fe.config({
            // TODO: Think about this
            find: (_) => _o(vb.getViewItems(_))
          }),
          Fb(A.none(), (_) => (_.getSystem().broadcastOn([OL], {}), d.get()), (_, N) => {
            d.set(N), _.getSystem().broadcastOn([DL], {});
          })
        ])
      });
    }, RL = (n, s, a, l, d, g) => {
      const h = (T) => {
        const _ = T.body;
        switch (_.type) {
          case "tabpanel":
            return [
              nY(_, T.initialData, l, g)
            ];
          default:
            return [
              zb(_, T.initialData, l, g)
            ];
        }
      }, C = (T, _) => A.some({
        isTabPanel: () => _.body.type === "tabpanel"
      }), x = {
        "aria-live": "polite"
      };
      return {
        dom: {
          tag: "div",
          classes: ["tox-dialog__content-js"],
          attributes: {
            ...a.map((T) => ({ id: T })).getOr({}),
            ...d ? x : {}
          }
        },
        components: [],
        behaviours: nt([
          Gd.childAt(0),
          ql.config({
            channel: `${DI}-${s}`,
            updateState: C,
            renderComponents: h,
            initialData: n
          })
        ])
      };
    }, oY = (n, s, a, l, d, g) => RL(n, s, A.some(a), l, d, g), sY = (n, s, a, l) => {
      const d = RL(n, s, A.none(), a, !1, l);
      return sa.parts.body(d);
    }, NL = (n) => {
      const s = {
        dom: {
          tag: "div",
          classes: ["tox-dialog__content-js"]
        },
        components: [
          {
            dom: {
              tag: "div",
              classes: ["tox-dialog__body-iframe"]
            },
            components: [
              _I(A.none(), {
                dom: {
                  tag: "iframe",
                  attributes: {
                    src: n.url
                  }
                },
                behaviours: nt([
                  is.config({}),
                  En.config({})
                ])
              })
            ]
          }
        ],
        behaviours: nt([
          Xt.config({
            mode: "acyclic",
            useTabstopAt: X(tS)
          })
        ])
      };
      return sa.parts.body(s);
    }, rY = Kv.deviceType.isTouch(), ML = (n, s) => ({
      dom: {
        tag: "div",
        styles: { display: "none" },
        classes: ["tox-dialog__header"]
      },
      components: [
        n,
        s
      ]
    }), PL = (n, s) => sa.parts.close(
      // Need to find a way to make it clear in the docs whether parts can be sketches
      oa.sketch({
        dom: {
          tag: "button",
          classes: ["tox-button", "tox-button--icon", "tox-button--naked"],
          attributes: {
            type: "button",
            "aria-label": s.translate("Close")
          }
        },
        action: n,
        buttonBehaviours: nt([
          is.config({})
        ])
      })
    ), BL = () => sa.parts.title({
      dom: {
        tag: "div",
        classes: ["tox-dialog__title"],
        innerHtml: "",
        styles: {
          display: "none"
        }
      }
    }), $L = (n, s) => sa.parts.body({
      dom: {
        tag: "div",
        classes: ["tox-dialog__body"]
      },
      components: [
        {
          dom: {
            tag: "div",
            classes: ["tox-dialog__body-content"]
          },
          components: [
            {
              dom: Dm(`<p>${Px(s.translate(n))}</p>`)
            }
          ]
        }
      ]
    }), b3 = (n) => sa.parts.footer({
      dom: {
        tag: "div",
        classes: ["tox-dialog__footer"]
      },
      components: n
    }), IL = (n, s) => [
      Am.sketch({
        dom: {
          tag: "div",
          classes: ["tox-dialog__footer-start"]
        },
        components: n
      }),
      Am.sketch({
        dom: {
          tag: "div",
          classes: ["tox-dialog__footer-end"]
        },
        components: s
      })
    ], _N = (n) => {
      const s = "tox-dialog", a = s + "-wrap", l = a + "__backdrop", d = s + "__disable-scroll";
      return sa.sketch({
        lazySink: n.lazySink,
        onEscape: (g) => (n.onEscape(g), A.some(!0)),
        useTabstopAt: (g) => !tS(g),
        firstTabstop: n.firstTabstop,
        dom: {
          tag: "div",
          classes: [s].concat(n.extraClasses),
          styles: {
            position: "relative",
            ...n.extraStyles
          }
        },
        components: [
          n.header,
          n.body,
          ...n.footer.toArray()
        ],
        parts: {
          blocker: {
            dom: Dm(`<div class="${a}"></div>`),
            components: [
              {
                dom: {
                  tag: "div",
                  classes: rY ? [l, l + "--opaque"] : [l]
                }
              }
            ]
          }
        },
        dragBlockClass: a,
        modalBehaviours: nt([
          En.config({}),
          xn("dialog-events", n.dialogEvents.concat([
            // Note: `runOnSource` here will only listen to the event at the outer component level.
            // Using just `run` instead will cause an infinite loop as `focusIn` would fire a `focusin` which would then get responded to and so forth.
            Jh(Ki(), (g, h) => {
              Ge.isBlocked(g) ? U() : Xt.focusIn(g);
            }),
            Ie(w0(), (g, h) => {
              g.getSystem().broadcastOn([Rp], {
                newFocus: h.event.newFocus
              });
            })
          ])),
          xn("scroll-lock", [
            hs(() => {
              Uo(Lc(), d);
            }),
            eu(() => {
              Ds(Lc(), d);
            })
          ]),
          ...n.extraBehaviours
        ]),
        eventOrder: {
          [wa()]: ["dialog-events"],
          [Mu()]: ["scroll-lock", "dialog-events", "alloy.base.behaviour"],
          [Ci()]: ["alloy.base.behaviour", "dialog-events", "scroll-lock"],
          ...n.eventOrder
        }
      });
    }, FL = (n) => oa.sketch({
      dom: {
        tag: "button",
        classes: ["tox-button", "tox-button--icon", "tox-button--naked"],
        attributes: {
          type: "button",
          "aria-label": n.translate("Close"),
          "data-mce-name": "close"
        }
      },
      buttonBehaviours: nt([
        is.config({}),
        ps.config(n.tooltips.getConfig({
          tooltipText: n.translate("Close")
        }))
      ]),
      components: [
        iu("close", { tag: "span", classes: ["tox-icon"] }, n.icons)
      ],
      action: (s) => {
        Wn(s, rh);
      }
    }), LL = (n, s, a, l) => {
      const d = (g) => [xs(l.translate(g.title))];
      return {
        dom: {
          tag: "h1",
          classes: ["tox-dialog__title"],
          attributes: {
            ...a.map((g) => ({ id: g })).getOr({})
          }
        },
        components: [],
        behaviours: nt([
          ql.config({
            channel: `${mR}-${s}`,
            initialData: n,
            renderComponents: d
          })
        ])
      };
    }, HL = () => ({
      dom: Dm('<div class="tox-dialog__draghandle"></div>')
    }), aY = (n, s, a, l) => Am.sketch({
      dom: Dm('<div class="tox-dialog__header"></div>'),
      components: [
        LL(n, s, A.some(a), l),
        HL(),
        FL(l)
      ],
      containerBehaviours: nt([
        Wg.config({
          mode: "mouse",
          blockerClass: "blocker",
          getTarget: (d) => xa(d, '[role="dialog"]').getOrDie(),
          snaps: {
            getSnapPoints: () => [],
            leftAttr: "data-drag-left",
            topAttr: "data-drag-top"
          },
          onDrag: (d, g) => {
            d.getSystem().broadcastOn([kr()], { target: g });
          }
        })
      ])
    }), cY = (n, s, a) => {
      const l = sa.parts.title(LL(n, s, A.none(), a)), d = sa.parts.draghandle(HL()), g = sa.parts.close(FL(a)), h = [l].concat(n.draggable ? [d] : []).concat([g]);
      return Am.sketch({
        dom: Dm('<div class="tox-dialog__header"></div>'),
        components: h
      });
    }, zL = (n, s, a) => cY({
      title: a.shared.providers.translate(n),
      draggable: a.dialog.isDraggableModal()
    }, s, a.shared.providers), ON = (n, s, a, l) => ({
      dom: {
        tag: "div",
        classes: ["tox-dialog__busy-spinner"],
        attributes: {
          "aria-label": a.translate(n)
        },
        styles: {
          left: "0px",
          right: "0px",
          bottom: "0px",
          top: `${l.getOr(0)}px`,
          position: "absolute"
        }
      },
      behaviours: s,
      components: [{
        dom: Dm('<div class="tox-spinner"><div></div><div></div><div></div></div>')
      }]
    }), DN = (n, s, a) => ({
      onClose: () => a.closeWindow(),
      onBlock: (l) => {
        const d = Po(n().element, ".tox-dialog__header").map((g) => hr(g));
        sa.setBusy(n(), (g, h) => ON(l.message, h, s, d));
      },
      onUnblock: () => {
        sa.setIdle(n());
      }
    }), VL = "tox-dialog--fullscreen", Vb = "tox-dialog--width-lg", RN = "tox-dialog--width-md", v3 = (n) => {
      switch (n) {
        case "large":
          return A.some(Vb);
        case "medium":
          return A.some(RN);
        default:
          return A.none();
      }
    }, y3 = (n, s) => {
      const a = at.fromDom(s.element.dom);
      ar(a, VL) || (ia(a, [Vb, RN]), v3(n).each((l) => Uo(a, l)));
    }, UL = (n, s) => {
      const a = at.fromDom(n.element.dom), l = c1(a), d = Lt(l, (g) => g === Vb || g === RN).or(v3(s));
      Ou(a, [VL, ...d.toArray()]);
    }, jL = (n, s, a) => p(_N({
      ...n,
      firstTabstop: 1,
      lazySink: a.shared.getSink,
      extraBehaviours: [
        S4({}),
        ...n.extraBehaviours
      ],
      onEscape: (l) => {
        Wn(l, rh);
      },
      dialogEvents: s,
      eventOrder: {
        [mm()]: [ql.name(), Dc.name()],
        [Mu()]: ["scroll-lock", ql.name(), "messages", "dialog-events", "alloy.base.behaviour"],
        [Ci()]: ["alloy.base.behaviour", "dialog-events", "messages", ql.name(), "scroll-lock"]
      }
    })), NN = (n, s = {}) => {
      const a = (l) => {
        const d = ye(l.items, (g) => {
          const h = Vt(s, g.name).getOr(Pt(!1));
          return {
            ...g,
            storage: h
          };
        });
        return {
          ...l,
          items: d
        };
      };
      return ye(n, (l) => l.type === "menu" ? a(l) : l);
    }, WL = (n) => ao(n, (s, a) => a.type === "menu" ? ao(a.items, (d, g) => (d[g.name] = g.storage, d), s) : s, {}), ZL = (n, s) => [
      // When focus moves onto a tab-placeholder, skip to the next thing in the tab sequence
      Qh(Ki(), OI),
      // TODO: Test if disabled first.
      n(Ib, (a, l, d, g) => {
        Bl(g.element) && Ir(mr(g.element)).each(Os), s.onClose(), l.onClose();
      }),
      // TODO: Test if disabled first.
      n(rh, (a, l, d, g) => {
        l.onCancel(a), Wn(g, Ib);
      }),
      Ie(C4, (a, l) => s.onUnblock()),
      Ie(cR, (a, l) => s.onBlock(l.event))
    ], lY = (n, s) => {
      const a = (d, g) => Ie(d, (h, C) => {
        l(h, (x, T) => {
          g(n(), x, C.event, h);
        });
      }), l = (d, g) => {
        ql.getState(d).get().each((h) => {
          g(h, d);
        });
      };
      return [
        ...ZL(a, s),
        a(Zd, (d, g, h) => {
          g.onAction(d, { name: h.name });
        })
      ];
    }, GL = (n, s, a) => {
      const l = (g, h) => Ie(g, (C, x) => {
        d(C, (T, _) => {
          h(n(), T, x.event, C);
        });
      }), d = (g, h) => {
        ql.getState(g).get().each((C) => {
          h(C.internalDialog, g);
        });
      };
      return [
        ...ZL(l, s),
        l(eS, (g, h) => h.onSubmit(g)),
        l(Sl, (g, h, C) => {
          h.onChange(g, { name: C.name });
        }),
        l(Zd, (g, h, C, x) => {
          const T = () => x.getSystem().isConnected() ? Xt.focusIn(x) : void 0, _ = (j) => Jr(j, "disabled") || Qr(j, "aria-disabled").exists((Z) => Z === "true"), N = mr(x.element), L = Ir(N);
          h.onAction(g, { name: C.name, value: C.value }), Ir(N).fold(T, (j) => {
            _(j) || L.exists((Z) => ee(j, Z) && _(Z)) ? T() : a().toOptional().filter((Z) => !ee(Z.element, j)).each(T);
          });
        }),
        l(uI, (g, h, C) => {
          h.onTabChange(g, { newTabName: C.name, oldTabName: C.oldName });
        }),
        // When the dialog is being closed, store the current state of the form
        eu((g) => {
          const h = n();
          _t.setValue(g, h.getData());
        })
      ];
    }, iY = (n, s) => rS(n, n.type, s), uY = (n, s, a) => Lt(s, (l) => l.name === a).bind((l) => l.memento.getOpt(n)), dY = (n, s) => {
      const a = s.map((C) => C.footerButtons).getOr([]), l = ro(a, (C) => C.align === "start"), d = (C, x) => Am.sketch({
        dom: {
          tag: "div",
          classes: [`tox-dialog__footer-${C}`]
        },
        components: ye(x, (T) => T.memento.asSpec())
      }), g = d("start", l.pass), h = d("end", l.fail);
      return [g, h];
    }, qL = (n, s, a) => {
      const l = (d, g) => {
        const h = ye(g.buttons, (x) => {
          const T = To(iY(x, a));
          return {
            name: x.name,
            align: x.align,
            memento: T
          };
        }), C = (x) => uY(d, h, x);
        return A.some({
          lookupByName: C,
          footerButtons: h
        });
      };
      return {
        dom: Dm('<div class="tox-dialog__footer"></div>'),
        components: [],
        behaviours: nt([
          ql.config({
            channel: `${RI}-${s}`,
            initialData: n,
            updateState: l,
            renderComponents: dY
          })
        ])
      };
    }, mY = (n, s, a) => qL(n, s, a), KL = (n, s, a) => sa.parts.footer(qL(n, s, a)), C3 = (n, s) => {
      if (n.getRoot().getSystem().isConnected()) {
        const l = Fe.getCurrent(n.getFormWrapper()).getOr(n.getFormWrapper());
        return bp.getField(l, s).orThunk(() => n.getFooter().bind((h) => ql.getState(h).get()).bind((h) => h.lookupByName(s)));
      } else
        return A.none();
    }, fY = (n, s) => {
      const a = n.getRoot();
      return ql.getState(a).get().map((l) => yi(Fs("data", l.dataValidator, s))).getOr(s);
    }, YL = (n, s, a) => {
      const l = (Z) => {
        const ne = n.getRoot();
        ne.getSystem().isConnected() && Z(ne);
      }, j = {
        getData: () => {
          const Z = n.getRoot(), ne = Z.getSystem().isConnected() ? n.getFormWrapper() : Z, ae = _t.getValue(ne), Y = Bs(a, (le) => le.get());
          return {
            ...ae,
            ...Y
          };
        },
        setData: (Z) => {
          l((ne) => {
            const ae = j.getData(), Y = Ho(ae, Z), le = fY(n, Y), pe = n.getFormWrapper();
            _t.setValue(pe, le), ds(a, (Ee, Oe) => {
              mo(Y, Oe) && Ee.set(Y[Oe]);
            });
          });
        },
        setEnabled: (Z, ne) => {
          C3(n, Z).each(ne ? Ft.enable : Ft.disable);
        },
        focus: (Z) => {
          C3(n, Z).each(En.focus);
        },
        block: (Z) => {
          if (!De(Z))
            throw new Error("The dialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
          l((ne) => {
            tn(ne, cR, { message: Z });
          });
        },
        unblock: () => {
          l((Z) => {
            Wn(Z, C4);
          });
        },
        showTab: (Z) => {
          l((ne) => {
            const ae = n.getBody();
            ql.getState(ae).get().exists((le) => le.isTabPanel()) && Fe.getCurrent(ae).each((le) => {
              vb.showTab(le, Z);
            });
          });
        },
        redial: (Z) => {
          l((ne) => {
            const ae = n.getId(), Y = s(Z), le = NN(Y.internalDialog.buttons, a);
            ne.getSystem().broadcastOn([`${A4}-${ae}`], Y), ne.getSystem().broadcastOn([`${mR}-${ae}`], Y.internalDialog), ne.getSystem().broadcastOn([`${DI}-${ae}`], Y.internalDialog), ne.getSystem().broadcastOn([`${RI}-${ae}`], {
              ...Y.internalDialog,
              buttons: le
            }), j.setData(Y.initialData);
          });
        },
        close: () => {
          l((Z) => {
            Wn(Z, Ib);
          });
        },
        toggleFullscreen: n.toggleFullscreen
      };
      return j;
    }, gY = (n, s, a) => {
      const l = Ct("dialog"), d = n.internalDialog, g = zL(d.title, l, a), h = Pt(d.size), C = (pe) => C3(Y, pe), x = v3(h.get()).toArray(), T = (pe, Ee) => (h.set(Ee.internalDialog.size), y3(Ee.internalDialog.size, pe), A.some(Ee)), _ = sY({
        body: d.body,
        initialData: d.initialData
      }, l, a, C), N = NN(d.buttons), L = WL(N), j = Br(N.length !== 0, KL({ buttons: N }, l, a)), Z = GL(() => le, DN(() => ae, a.shared.providers, s), a.shared.getSink), ne = {
        id: l,
        header: g,
        body: _,
        footer: j,
        extraClasses: x,
        extraBehaviours: [
          ql.config({
            channel: `${A4}-${l}`,
            updateState: T,
            initialData: n
          })
        ],
        extraStyles: {}
      }, ae = jL(ne, Z, a), Y = (() => {
        const pe = () => {
          const Oe = sa.getBody(ae);
          return Fe.getCurrent(Oe).getOr(Oe);
        }, Ee = () => {
          UL(ae, h.get());
        };
        return {
          getId: oe(l),
          getRoot: oe(ae),
          getBody: () => sa.getBody(ae),
          getFooter: () => sa.getFooter(ae),
          getFormWrapper: pe,
          toggleFullscreen: Ee
        };
      })(), le = YL(Y, s.redial, L);
      return {
        dialog: ae,
        instanceApi: le
      };
    }, TS = (n, s, a, l = !1, d) => {
      const g = Ct("dialog"), h = Ct("dialog-label"), C = Ct("dialog-content"), x = n.internalDialog, T = (Ke) => C3(Ue, Ke), _ = Pt(x.size), N = v3(_.get()).toArray(), L = (Ke, Qt) => (_.set(Qt.internalDialog.size), y3(Qt.internalDialog.size, Ke), d(), A.some(Qt)), j = To(aY({
        title: x.title,
        draggable: !0
      }, g, h, a.shared.providers)), Z = To(oY({
        body: x.body,
        initialData: x.initialData
      }, g, C, a, l, T)), ne = NN(x.buttons), ae = WL(ne), Y = Br(ne.length !== 0, To(mY({
        buttons: ne
      }, g, a))), le = GL(() => Qe, {
        onBlock: (Ke) => {
          Ge.block(Oe, (Qt, zt) => {
            const jn = j.getOpt(Oe).map((Jt) => hr(Jt.element));
            return ON(Ke.message, zt, a.shared.providers, jn);
          });
        },
        onUnblock: () => {
          Ge.unblock(Oe);
        },
        onClose: () => s.closeWindow()
      }, a.shared.getSink), pe = "tox-dialog-inline", Ee = Zs().os, Oe = p({
        dom: {
          tag: "div",
          classes: ["tox-dialog", pe, ...N],
          attributes: {
            role: "dialog",
            // TINY-10808 - Workaround to address the dialog header not being announced on VoiceOver with aria-labelledby, ideally we should use the aria-labelledby
            ...Ee.isMacOS() ? { "aria-label": x.title } : { "aria-labelledby": h }
          }
        },
        eventOrder: {
          [mm()]: [ql.name(), Dc.name()],
          [wa()]: ["execute-on-form"],
          [Mu()]: ["reflecting", "execute-on-form"]
        },
        // Dupe with SilverDialog.
        behaviours: nt([
          Xt.config({
            mode: "cyclic",
            onEscape: (Ke) => (Wn(Ke, Ib), A.some(!0)),
            useTabstopAt: (Ke) => !tS(Ke) && (Nl(Ke) !== "button" || Dr(Ke, "disabled") !== "disabled"),
            firstTabstop: 1
          }),
          ql.config({
            channel: `${A4}-${g}`,
            updateState: L,
            initialData: n
          }),
          En.config({}),
          xn("execute-on-form", le.concat([
            // Note: `runOnSource` here will only listen to the event at the outer component level.
            // Using just `run` instead will cause an infinite loop as `focusIn` would fire a `focusin` which would then get responded to and so forth.
            Jh(Ki(), (Ke, Qt) => {
              Xt.focusIn(Ke);
            }),
            Ie(w0(), (Ke, Qt) => {
              Ke.getSystem().broadcastOn([Rp], {
                newFocus: Qt.event.newFocus
              });
            })
          ])),
          Ge.config({ getRoot: () => A.some(Oe) }),
          An.config({}),
          S4({})
        ]),
        components: [
          j.asSpec(),
          Z.asSpec(),
          ...Y.map((Ke) => Ke.asSpec()).toArray()
        ]
      }), gt = () => {
        UL(Oe, _.get());
      }, Ue = {
        getId: oe(g),
        getRoot: oe(Oe),
        getFooter: () => Y.map((Ke) => Ke.get(Oe)),
        getBody: () => Z.get(Oe),
        getFormWrapper: () => {
          const Ke = Z.get(Oe);
          return Fe.getCurrent(Ke).getOr(Ke);
        },
        toggleFullscreen: gt
      }, Qe = YL(Ue, s.redial, ae);
      return {
        dialog: Oe,
        instanceApi: Qe
      };
    };
    var MN = tinymce.util.Tools.resolve("tinymce.util.URI");
    const hY = (n) => {
      const s = (h) => {
        n.getSystem().isConnected() && h(n);
      };
      return {
        block: (h) => {
          if (!De(h))
            throw new Error("The urlDialogInstanceAPI.block function should be passed a blocking message of type string as an argument");
          s((C) => {
            tn(C, cR, { message: h });
          });
        },
        unblock: () => {
          s((h) => {
            Wn(h, C4);
          });
        },
        close: () => {
          s((h) => {
            Wn(h, Ib);
          });
        },
        sendMessage: (h) => {
          s((C) => {
            C.getSystem().broadcastOn([yn], h);
          });
        }
      };
    }, pY = ["insertContent", "setContent", "execCommand", "close", "block", "unblock"], XL = (n) => et(n) && pY.indexOf(n.mceAction) !== -1, bY = (n) => !XL(n) && et(n) && mo(n, "mceAction"), vY = (n, s, a) => {
      switch (a.mceAction) {
        case "insertContent":
          n.insertContent(a.content);
          break;
        case "setContent":
          n.setContent(a.content);
          break;
        case "execCommand":
          const l = vn(a.ui) ? a.ui : !1;
          n.execCommand(a.cmd, l, a.value);
          break;
        case "close":
          s.close();
          break;
        case "block":
          s.block(a.message);
          break;
        case "unblock":
          s.unblock();
          break;
      }
    }, QL = (n, s, a, l) => {
      const d = Ct("dialog"), g = zL(n.title, d, l), h = NL(n), C = n.buttons.bind((pe) => pe.length === 0 ? A.none() : A.some(KL({ buttons: pe }, d, l))), x = lY(() => le, DN(() => Y, l.shared.providers, s)), T = {
        ...n.height.fold(() => ({}), (pe) => ({ height: pe + "px", "max-height": pe + "px" })),
        ...n.width.fold(() => ({}), (pe) => ({ width: pe + "px", "max-width": pe + "px" }))
      }, _ = n.width.isNone() && n.height.isNone() ? ["tox-dialog--width-lg"] : [], N = new MN(n.url, { base_uri: new MN(window.location.href) }), L = `${N.protocol}://${N.host}${N.port ? ":" + N.port : ""}`, j = As(), Z = (pe, Ee) => A.some(Ee), ne = [
        // Because this doesn't define `renderComponents`, all this does is update the state.
        // We use the state for the initialData. The other parts (body etc.) render the
        // components based on what reflecting receives.
        ql.config({
          channel: `${A4}-${d}`,
          updateState: Z,
          initialData: n
        }),
        xn("messages", [
          // When the dialog is opened, bind a window message listener for the spec url
          hs(() => {
            const pe = Oo(at.fromDom(window), "message", (Ee) => {
              if (N.isSameOrigin(new MN(Ee.raw.origin))) {
                const Oe = Ee.raw.data;
                XL(Oe) ? vY(a, le, Oe) : bY(Oe) && n.onMessage(le, Oe);
              }
            });
            j.set(pe);
          }),
          // When the dialog is closed, unbind the window message listener
          eu(j.clear)
        ]),
        Dc.config({
          channels: {
            [yn]: {
              onReceive: (pe, Ee) => {
                Po(pe.element, "iframe").each((Oe) => {
                  const gt = Oe.dom.contentWindow;
                  un(gt) && gt.postMessage(Ee, L);
                });
              }
            }
          }
        })
      ], Y = jL({
        id: d,
        header: g,
        body: h,
        footer: C,
        extraClasses: _,
        extraBehaviours: ne,
        extraStyles: T
      }, x, l), le = hY(Y);
      return {
        dialog: Y,
        instanceApi: le
      };
    }, yY = (n) => {
      const s = n.shared;
      return {
        open: (l, d) => {
          const g = () => {
            sa.hide(T), d();
          }, h = To(rS({
            context: "any",
            name: "close-alert",
            text: "OK",
            primary: !0,
            buttonType: A.some("primary"),
            align: "end",
            enabled: !0,
            icon: A.none()
          }, "cancel", n)), C = BL(), x = PL(g, s.providers), T = p(_N({
            lazySink: () => s.getSink(),
            header: ML(C, x),
            body: $L(l, s.providers),
            footer: A.some(b3(IL([], [
              h.asSpec()
            ]))),
            onEscape: g,
            extraClasses: ["tox-alert-dialog"],
            extraBehaviours: [],
            extraStyles: {},
            dialogEvents: [
              Ie(rh, g)
            ],
            eventOrder: {}
          }));
          sa.show(T);
          const _ = h.get(T);
          En.focus(_);
        }
      };
    }, CY = (n) => {
      const s = n.shared;
      return {
        open: (l, d) => {
          const g = (L) => {
            sa.hide(_), d(L);
          }, h = To(rS({
            context: "any",
            name: "yes",
            text: "Yes",
            primary: !0,
            buttonType: A.some("primary"),
            align: "end",
            enabled: !0,
            icon: A.none()
          }, "submit", n)), C = rS({
            context: "any",
            name: "no",
            text: "No",
            primary: !1,
            buttonType: A.some("secondary"),
            align: "end",
            enabled: !0,
            icon: A.none()
          }, "cancel", n), x = BL(), T = PL(() => g(!1), s.providers), _ = p(_N({
            lazySink: () => s.getSink(),
            header: ML(x, T),
            body: $L(l, s.providers),
            footer: A.some(b3(IL([], [
              C,
              h.asSpec()
            ]))),
            onEscape: () => g(!1),
            extraClasses: ["tox-confirm-dialog"],
            extraBehaviours: [],
            extraStyles: {},
            dialogEvents: [
              Ie(rh, () => g(!1)),
              Ie(eS, () => g(!0))
            ],
            eventOrder: {}
          }));
          sa.show(_);
          const N = h.get(_);
          En.focus(N);
        }
      };
    }, JL = (n, s) => yi(Fs("data", s, n)), e7 = (n) => dg(n, ".tox-alert-dialog") || dg(n, ".tox-confirm-dialog"), xY = (n, s, a, l) => s && a ? [] : [
      Ns.config({
        contextual: {
          lazyContext: () => A.some(wr(at.fromDom(n.getContentAreaContainer()))),
          fadeInClass: "tox-dialog-dock-fadein",
          fadeOutClass: "tox-dialog-dock-fadeout",
          transitionClass: "tox-dialog-dock-transition",
          onHide: l
        },
        modes: ["top"],
        lazyViewport: (d) => Yg(n, d.element).map((h) => ({
          bounds: Cb(h),
          optScrollEnv: A.some({
            currentScrollTop: h.element.dom.scrollTop,
            scrollElmTop: Ca(h.element).top
          })
        })).getOrThunk(() => ({
          bounds: Ia(),
          optScrollEnv: A.none()
        }))
      })
    ], PN = (n) => {
      const s = n.editor, a = ty(s), l = yY(n.backstages.dialog), d = CY(n.backstages.dialog), g = (Z, ne, ae) => {
        if (!Cn(ne)) {
          if (ne.inline === "toolbar")
            return T(Z, n.backstages.popup.shared.anchors.inlineDialog(), ae, ne);
          if (ne.inline === "bottom")
            return _(Z, n.backstages.popup.shared.anchors.inlineBottomDialog(), ae, ne);
          if (ne.inline === "cursor")
            return T(Z, n.backstages.popup.shared.anchors.cursor(), ae, ne);
        }
        return x(Z, ae);
      }, h = (Z, ne) => C(Z, ne), C = (Z, ne) => {
        const ae = (Y) => {
          const le = QL(Y, {
            closeWindow: () => {
              sa.hide(le.dialog), ne(le.instanceApi);
            }
          }, s, n.backstages.dialog);
          return sa.show(le.dialog), le.instanceApi;
        };
        return Rb.openUrl(ae, Z);
      }, x = (Z, ne) => {
        const ae = (Y, le, pe) => {
          const Ee = le, gt = gY({
            dataValidator: pe,
            initialData: Ee,
            internalDialog: Y
          }, {
            redial: Rb.redial,
            closeWindow: () => {
              sa.hide(gt.dialog), ne(gt.instanceApi);
            }
          }, n.backstages.dialog);
          return sa.show(gt.dialog), gt.instanceApi.setData(Ee), gt.instanceApi;
        };
        return Rb.open(ae, Z);
      }, T = (Z, ne, ae, Y) => {
        const le = (pe, Ee, Oe) => {
          const gt = JL(Ee, Oe), Ue = hn(), Qe = n.backstages.popup.shared.header.isPositionedAtTop(), Ke = {
            dataValidator: Oe,
            initialData: gt,
            internalDialog: pe
          }, Qt = () => Ue.on((Ve) => {
            Us.reposition(Ve), (!a || !Qe) && Ns.refresh(Ve);
          }), zt = TS(Ke, {
            redial: Rb.redial,
            closeWindow: () => {
              Ue.on(Us.hide), s.off("ResizeEditor", Qt), s.off("ScrollWindow", jn), Ue.clear(), ae(zt.instanceApi);
            }
          }, n.backstages.popup, Y.ariaAttrs, Qt), jn = () => zt.dialog.getSystem().broadcastOn([kr()], { target: zt.dialog.element }), Jt = () => zt.dialog.getSystem().broadcastOn([Ad()], { target: zt.dialog.element }), _n = p(Us.sketch({
            lazySink: n.backstages.popup.shared.getSink,
            dom: {
              tag: "div",
              classes: []
            },
            // Fires the default dismiss event.
            fireDismissalEventInstead: Y.persistent ? { event: "doNotDismissYet" } : {},
            // TINY-9412: The docking behaviour for inline dialogs is inconsistent
            // for toolbar_location: bottom. We need to clarify exactly what the behaviour
            // should be. The intent here might have been that they shouldn't automatically
            // reposition at all because they aren't visually connected to the toolbar
            // (i.e. inline "toolbar" dialogs still display at the top, even when the
            // toolbar_location is bottom), but it's unclear.
            ...Qe ? {} : { fireRepositionEventInstead: {} },
            inlineBehaviours: nt([
              xn("window-manager-inline-events", [
                Ie(fm(), (Ve, ct) => {
                  Wn(zt.dialog, rh);
                })
              ]),
              ...xY(s, a, Qe, Jt)
            ]),
            // Treat alert or confirm dialogs as part of the inline dialog
            isExtraPart: (Ve, ct) => e7(ct)
          }));
          Ue.set(_n);
          const Ut = () => {
            const Ve = s.inline ? Lc() : at.fromDom(s.getContainer()), ct = wr(Ve);
            return A.some(ct);
          };
          return Us.showWithinBounds(_n, y(zt.dialog), { anchor: ne }, Ut), (!a || !Qe) && (Ns.refresh(_n), s.on("ResizeEditor", Qt)), s.on("ScrollWindow", jn), zt.instanceApi.setData(gt), Xt.focusIn(zt.dialog), zt.instanceApi;
        };
        return Rb.open(le, Z);
      }, _ = (Z, ne, ae, Y) => {
        const le = (pe, Ee, Oe) => {
          const gt = JL(Ee, Oe), Ue = hn(), Qe = n.backstages.popup.shared.header.isPositionedAtTop(), Ke = {
            dataValidator: Oe,
            initialData: gt,
            internalDialog: pe
          }, Qt = () => Ue.on((_n) => {
            Us.reposition(_n), Ns.refresh(_n);
          }), zt = TS(Ke, {
            redial: Rb.redial,
            closeWindow: () => {
              Ue.on(Us.hide), s.off("ResizeEditor ScrollWindow ElementScroll", Qt), Ue.clear(), ae(zt.instanceApi);
            }
          }, n.backstages.popup, Y.ariaAttrs, Qt), jn = p(Us.sketch({
            lazySink: n.backstages.popup.shared.getSink,
            dom: {
              tag: "div",
              classes: []
            },
            // Fires the default dismiss event.
            fireDismissalEventInstead: Y.persistent ? { event: "doNotDismissYet" } : {},
            ...Qe ? {} : { fireRepositionEventInstead: {} },
            inlineBehaviours: nt([
              xn("window-manager-inline-events", [
                Ie(fm(), (_n, Ut) => {
                  Wn(zt.dialog, rh);
                })
              ]),
              Ns.config({
                contextual: {
                  lazyContext: () => A.some(wr(at.fromDom(s.getContentAreaContainer()))),
                  fadeInClass: "tox-dialog-dock-fadein",
                  fadeOutClass: "tox-dialog-dock-fadeout",
                  transitionClass: "tox-dialog-dock-transition"
                },
                modes: ["top", "bottom"],
                lazyViewport: (_n) => Yg(s, _n.element).map((Ve) => ({
                  bounds: Cb(Ve),
                  optScrollEnv: A.some({
                    currentScrollTop: Ve.element.dom.scrollTop,
                    scrollElmTop: Ca(Ve.element).top
                  })
                })).getOrThunk(() => ({
                  bounds: Ia(),
                  optScrollEnv: A.none()
                }))
              })
            ]),
            // Treat alert or confirm dialogs as part of the inline dialog
            isExtraPart: (_n, Ut) => e7(Ut)
          }));
          Ue.set(jn);
          const Jt = () => n.backstages.popup.shared.getSink().toOptional().bind((_n) => {
            const Ut = Yg(s, _n.element), Ve = 15, ct = Ut.map((qt) => Cb(qt)).getOr(Ia()), mn = wr(at.fromDom(s.getContentAreaContainer())), Pn = cm(mn, ct);
            return A.some(Rr(Pn.x, Pn.y, Pn.width, Pn.height - Ve));
          });
          return Us.showWithinBounds(jn, y(zt.dialog), { anchor: ne }, Jt), Ns.refresh(jn), s.on("ResizeEditor ScrollWindow ElementScroll ResizeWindow", Qt), zt.instanceApi.setData(gt), Xt.focusIn(zt.dialog), zt.instanceApi;
        };
        return Rb.open(le, Z);
      };
      return {
        open: g,
        openUrl: h,
        alert: (Z, ne) => {
          l.open(Z, ne);
        },
        close: (Z) => {
          Z.close();
        },
        confirm: (Z, ne) => {
          d.open(Z, ne);
        }
      };
    }, t7 = (n) => {
      AB(n), I$(n), OK(n);
    };
    var SY = () => {
      kB.add("silver", (n) => {
        t7(n);
        let s = () => Ia();
        const { dialogs: a, popups: l, renderUI: d } = XK(n, {
          // consult the mutable variable to find out the bounds for the popup sink. When renderUI is
          // called, this mutable variable might be reassigned
          getPopupSinkBounds: () => s()
        }), g = () => {
          const _ = d();
          return Yg(n, l.getMothership().element).each((L) => {
            s = () => Cb(L);
          }), _;
        };
        LW.register(n, l.backstage.shared);
        const h = PN({
          editor: n,
          backstages: {
            popup: l.backstage,
            dialog: a.backstage
          }
        }), C = hn(), x = () => ZV(n, { backstage: l.backstage }, l.getMothership(), C), T = () => Po(at.fromDom(n.getContainer()), ".tox-promotion").map((_) => _.dom).getOrNull();
        return {
          renderUI: g,
          getWindowManagerImpl: oe(h),
          getNotificationManagerImpl: x,
          getPromotionElement: T
        };
      });
    };
    SY();
  }()), eQ;
}
var nQ;
function hJ() {
  return nQ || (nQ = 1, gJ()), JX;
}
hJ();
var oQ = {}, sQ = {}, rQ;
function pJ() {
  return rQ || (rQ = 1, function() {
    var V = tinymce.util.Tools.resolve("tinymce.ModelManager");
    const me = (i, m, p) => p(i, m.prototype) ? !0 : i.constructor?.name === m.name, pt = (i) => {
      const m = typeof i;
      return i === null ? "null" : m === "object" && Array.isArray(i) ? "array" : m === "object" && me(i, String, (p, y) => y.isPrototypeOf(p)) ? "string" : m;
    }, rt = (i) => (m) => pt(m) === i, Nt = (i) => (m) => typeof m === i, mt = (i) => (m) => i === m, nn = rt("string"), De = rt("object"), et = rt("array"), Tt = mt(null), $n = Nt("boolean"), Mt = mt(void 0), vn = (i) => i == null, Cn = (i) => !vn(i), pn = Nt("function"), un = Nt("number"), Xe = () => {
    }, In = (i, m) => (...p) => i(m.apply(null, p)), lt = (i, m) => (p) => i(m(p)), U = (i) => () => i, Ye = (i) => i, On = (i, m) => i === m;
    function Ot(i, ...m) {
      return (...p) => {
        const y = m.concat(p);
        return i.apply(null, y);
      };
    }
    const oe = (i) => (m) => !i(m), Yt = (i) => () => {
      throw new Error(i);
    }, Gn = (i) => i(), jt = U(!1), X = U(!0);
    class se {
      tag;
      value;
      // Sneaky optimisation: every instance of Optional.none is identical, so just
      // reuse the same object
      static singletonNone = new se(!1);
      // The internal representation has a `tag` and a `value`, but both are
      // private: able to be console.logged, but not able to be accessed by code
      constructor(m, p) {
        this.tag = m, this.value = p;
      }
      // --- Identities ---
      /**
       * Creates a new `Optional<T>` that **does** contain a value.
       */
      static some(m) {
        return new se(!0, m);
      }
      /**
       * Create a new `Optional<T>` that **does not** contain a value. `T` can be
       * any type because we don't actually have a `T`.
       */
      static none() {
        return se.singletonNone;
      }
      /**
       * Perform a transform on an `Optional` type. Regardless of whether this
       * `Optional` contains a value or not, `fold` will return a value of type `U`.
       * If this `Optional` does not contain a value, the `U` will be created by
       * calling `onNone`. If this `Optional` does contain a value, the `U` will be
       * created by calling `onSome`.
       *
       * For the FP enthusiasts in the room, this function:
       * 1. Could be used to implement all of the functions below
       * 2. Forms a catamorphism
       */
      fold(m, p) {
        return this.tag ? p(this.value) : m();
      }
      /**
       * Determine if this `Optional` object contains a value.
       */
      isSome() {
        return this.tag;
      }
      /**
       * Determine if this `Optional` object **does not** contain a value.
       */
      isNone() {
        return !this.tag;
      }
      // --- Functor (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value. If
       * you provide a function to turn a T into a U, this is the function you use
       * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
       * a value then the output will also contain a value (that value being the
       * output of `mapper(this.value)`), and if this **does not** contain a value
       * then neither will the output.
       */
      map(m) {
        return this.tag ? se.some(m(this.value)) : se.none();
      }
      // --- Monad (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value.
       * Unlike `map`, here the transform itself also returns an `Optional`.
       */
      bind(m) {
        return this.tag ? m(this.value) : se.none();
      }
      // --- Traversable (name stolen from Haskell / maths) ---
      /**
       * For a given predicate, this function finds out if there **exists** a value
       * inside this `Optional` object that meets the predicate. In practice, this
       * means that for `Optional`s that do not contain a value it returns false (as
       * no predicate-meeting value exists).
       */
      exists(m) {
        return this.tag && m(this.value);
      }
      /**
       * For a given predicate, this function finds out if **all** the values inside
       * this `Optional` object meet the predicate. In practice, this means that
       * for `Optional`s that do not contain a value it returns true (as all 0
       * objects do meet the predicate).
       */
      forall(m) {
        return !this.tag || m(this.value);
      }
      filter(m) {
        return !this.tag || m(this.value) ? this : se.none();
      }
      // --- Getters ---
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.
       */
      getOr(m) {
        return this.tag ? this.value : m;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.  Unlike `getOr`, in this method the `replacement` object is also
       * `Optional` - meaning that this method will always return an `Optional`.
       */
      or(m) {
        return this.tag ? this : m;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value. Unlike `getOr`, in this method the `replacement` value is
       * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
       * pass a function which (if called) will **return** the `value` you want to
       * use.
       */
      getOrThunk(m) {
        return this.tag ? this.value : m();
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided Optional object does not contain a
       * value.
       *
       * Unlike `or`, in this method the `replacement` value is "thunked" - that is
       * to say that you don't pass a value to `orThunk`, you pass a function which
       * (if called) will **return** the `value` you want to use.
       *
       * Unlike `getOrThunk`, in this method the `replacement` value is also
       * `Optional`, meaning that this method will always return an `Optional`.
       */
      orThunk(m) {
        return this.tag ? this : m();
      }
      /**
       * Get the value out of the inside of the `Optional` object, throwing an
       * exception if the provided `Optional` object does not contain a value.
       *
       * WARNING:
       * You should only be using this function if you know that the `Optional`
       * object **is not** empty (otherwise you're throwing exceptions in production
       * code, which is bad).
       *
       * In tests this is more acceptable.
       *
       * Prefer other methods to this, such as `.each`.
       */
      getOrDie(m) {
        if (this.tag)
          return this.value;
        throw new Error(m ?? "Called getOrDie on None");
      }
      // --- Interop with null and undefined ---
      /**
       * Creates an `Optional` value from a nullable (or undefined-able) input.
       * Null, or undefined, is converted to `None`, and anything else is converted
       * to `Some`.
       */
      static from(m) {
        return Cn(m) ? se.some(m) : se.none();
      }
      /**
       * Converts an `Optional` to a nullable type, by getting the value if it
       * exists, or returning `null` if it does not.
       */
      getOrNull() {
        return this.tag ? this.value : null;
      }
      /**
       * Converts an `Optional` to an undefined-able type, by getting the value if
       * it exists, or returning `undefined` if it does not.
       */
      getOrUndefined() {
        return this.value;
      }
      // --- Utilities ---
      /**
       * If the `Optional` contains a value, perform an action on that value.
       * Unlike the rest of the methods on this type, `.each` has side-effects. If
       * you want to transform an `Optional<T>` **into** something, then this is not
       * the method for you. If you want to use an `Optional<T>` to **do**
       * something, then this is the method for you - provided you're okay with not
       * doing anything in the case where the `Optional` doesn't have a value inside
       * it. If you're not sure whether your use-case fits into transforming
       * **into** something or **doing** something, check whether it has a return
       * value. If it does, you should be performing a transform.
       */
      each(m) {
        this.tag && m(this.value);
      }
      /**
       * Turn the `Optional` object into an array that contains all of the values
       * stored inside the `Optional`. In practice, this means the output will have
       * either 0 or 1 elements.
       */
      toArray() {
        return this.tag ? [this.value] : [];
      }
      /**
       * Turn the `Optional` object into a string for debugging or printing. Not
       * recommended for production code, but good for debugging. Also note that
       * these days an `Optional` object can be logged to the console directly, and
       * its inner value (if it exists) will be visible.
       */
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    const ns = Array.prototype.slice, an = Array.prototype.indexOf, St = Array.prototype.push, A = (i, m) => an.call(i, m), No = (i, m) => A(i, m) > -1, ot = (i, m) => {
      for (let p = 0, y = i.length; p < y; p++) {
        const E = i[p];
        if (m(E, p))
          return !0;
      }
      return !1;
    }, jo = (i, m) => {
      const p = [];
      for (let y = 0; y < i; y++)
        p.push(m(y));
      return p;
    }, he = (i, m) => {
      const p = i.length, y = new Array(p);
      for (let E = 0; E < p; E++) {
        const D = i[E];
        y[E] = m(D, E);
      }
      return y;
    }, ue = (i, m) => {
      for (let p = 0, y = i.length; p < y; p++) {
        const E = i[p];
        m(E, p);
      }
    }, bt = (i, m) => {
      for (let p = i.length - 1; p >= 0; p--) {
        const y = i[p];
        m(y, p);
      }
    }, cn = (i, m) => {
      const p = [], y = [];
      for (let E = 0, D = i.length; E < D; E++) {
        const $ = i[E];
        (m($, E) ? p : y).push($);
      }
      return { pass: p, fail: y };
    }, fn = (i, m) => {
      const p = [];
      for (let y = 0, E = i.length; y < E; y++) {
        const D = i[y];
        m(D, y) && p.push(D);
      }
      return p;
    }, Fn = (i, m, p) => (bt(i, (y, E) => {
      p = m(p, y, E);
    }), p), ye = (i, m, p) => (ue(i, (y, E) => {
      p = m(p, y, E);
    }), p), He = (i, m, p) => {
      for (let y = 0, E = i.length; y < E; y++) {
        const D = i[y];
        if (m(D, y))
          return se.some(D);
        if (p(D, y))
          break;
      }
      return se.none();
    }, P = (i, m) => He(i, m, jt), ro = (i, m) => {
      for (let p = 0, y = i.length; p < y; p++) {
        const E = i[p];
        if (m(E, p))
          return se.some(p);
      }
      return se.none();
    }, Ln = (i) => {
      const m = [];
      for (let p = 0, y = i.length; p < y; ++p) {
        if (!et(i[p]))
          throw new Error("Arr.flatten item " + p + " was not an array, input: " + i);
        St.apply(m, i[p]);
      }
      return m;
    }, oo = (i, m) => Ln(he(i, m)), ao = (i, m) => {
      for (let p = 0, y = i.length; p < y; ++p) {
        const E = i[p];
        if (m(E, p) !== !0)
          return !1;
      }
      return !0;
    }, ur = (i) => {
      const m = ns.call(i, 0);
      return m.reverse(), m;
    }, Lt = (i, m) => {
      const p = {};
      for (let y = 0, E = i.length; y < E; y++) {
        const D = i[y];
        p[String(D)] = m(D, y);
      }
      return p;
    }, po = (i, m) => {
      const p = ns.call(i, 0);
      return p.sort(m), p;
    }, en = (i, m) => m >= 0 && m < i.length ? se.some(i[m]) : se.none(), xe = (i) => en(i, 0), We = (i) => en(i, i.length - 1), st = (i, m) => {
      for (let p = 0; p < i.length; p++) {
        const y = m(i[p], p);
        if (y.isSome())
          return y;
      }
      return se.none();
    }, ze = Object.keys, no = Object.hasOwnProperty, qn = (i, m) => {
      const p = ze(i);
      for (let y = 0, E = p.length; y < E; y++) {
        const D = p[y], $ = i[D];
        m($, D);
      }
    }, Io = (i, m) => Jc(i, (p, y) => ({
      k: y,
      v: m(p, y)
    })), Jc = (i, m) => {
      const p = {};
      return qn(i, (y, E) => {
        const D = m(y, E);
        p[D.k] = D.v;
      }), p;
    }, _o = (i) => (m, p) => {
      i[p] = m;
    }, Ql = (i, m, p, y) => {
      qn(i, (E, D) => {
        (m(E, D) ? p : y)(E, D);
      });
    }, jm = (i, m) => {
      const p = {};
      return Ql(i, m, _o(p), Xe), p;
    }, ga = (i, m) => {
      const p = [];
      return qn(i, (y, E) => {
        p.push(m(y, E));
      }), p;
    }, xo = (i) => ga(i, Ye), qa = (i, m) => ds(i, m) ? se.from(i[m]) : se.none(), ds = (i, m) => no.call(i, m), Bs = (i, m) => ds(i, m) && i[m] !== void 0 && i[m] !== null, vu = (i) => {
      for (const m in i)
        if (no.call(i, m))
          return !1;
      return !0;
    }, Gr = {
      generate: (i) => {
        if (!et(i))
          throw new Error("cases must be an array");
        if (i.length === 0)
          throw new Error("there must be at least one case");
        const m = [], p = {};
        return ue(i, (y, E) => {
          const D = ze(y);
          if (D.length !== 1)
            throw new Error("one and only one name per case");
          const $ = D[0], z = y[$];
          if (p[$] !== void 0)
            throw new Error("duplicate key detected:" + $);
          if ($ === "cata")
            throw new Error("cannot have a case named cata (sorry)");
          if (!et(z))
            throw new Error("case arguments must be an array");
          m.push($), p[$] = (...K) => {
            const ce = K.length;
            if (ce !== z.length)
              throw new Error("Wrong number of arguments to case " + $ + ". Expected " + z.length + " (" + z + "), got " + ce);
            return {
              fold: (...Ge) => {
                if (Ge.length !== i.length)
                  throw new Error("Wrong number of arguments to fold. Expected " + i.length + ", got " + Ge.length);
                return Ge[E].apply(null, K);
              },
              match: (Ge) => {
                const kt = ze(Ge);
                if (m.length !== kt.length)
                  throw new Error("Wrong number of arguments to match. Expected: " + m.join(",") + `
Actual: ` + kt.join(","));
                if (!ao(m, (Gt) => No(kt, Gt)))
                  throw new Error("Not all branches were specified when using match. Specified: " + kt.join(", ") + `
Required: ` + m.join(", "));
                return Ge[$].apply(null, K);
              },
              // NOTE: Only for debugging.
              log: (Ge) => {
                console.log(Ge, {
                  constructors: m,
                  constructor: $,
                  params: K
                });
              }
            };
          };
        }), p;
      }
    }, js = (i) => {
      let m = i;
      return {
        get: () => m,
        set: (E) => {
          m = E;
        }
      };
    }, dr = (i) => i.slice(0).sort(), rs = (i, m) => {
      throw new Error("All required keys (" + dr(i).join(", ") + ") were not specified. Specified keys were: " + dr(m).join(", ") + ".");
    }, cc = (i) => {
      throw new Error("Unsupported keys for object: " + dr(i).join(", "));
    }, Ka = (i, m) => {
      if (!et(m))
        throw new Error("The " + i + " fields must be an array. Was: " + m + ".");
      ue(m, (p) => {
        if (!nn(p))
          throw new Error("The value " + p + " in the " + i + " fields was not a string.");
      });
    }, Vt = (i, m) => {
      throw new Error("All values need to be of type: " + m + ". Keys (" + dr(i).join(", ") + ") were not.");
    }, mo = (i) => {
      const m = dr(i);
      P(m, (y, E) => E < m.length - 1 && y === m[E + 1]).each((y) => {
        throw new Error("The field: " + y + " occurs more than once in the combined fields: [" + m.join(", ") + "].");
      });
    }, Un = (i, m) => lc(i, m, {
      validate: pn,
      label: "function"
    }), lc = (i, m, p) => {
      if (m.length === 0)
        throw new Error("You must specify at least one required field.");
      return Ka("required", m), mo(m), (y) => {
        const E = ze(y);
        ao(m, (z) => No(E, z)) || rs(m, E), i(m, E);
        const $ = fn(m, (z) => !p.validate(y[z], z));
        return $.length > 0 && Vt($, p.label), y;
      };
    }, Ma = (i, m) => {
      const p = fn(m, (y) => !No(i, y));
      p.length > 0 && cc(p);
    }, Pt = (i) => Un(Ma, i), Di = (i) => {
      const m = (D) => D(i), p = U(i), y = () => E, E = {
        // Debug info
        tag: !0,
        inner: i,
        // Actual Result methods
        fold: (D, $) => $(i),
        isValue: X,
        isError: jt,
        map: (D) => ic.value(D(i)),
        mapError: y,
        bind: m,
        exists: m,
        forall: m,
        getOr: p,
        or: y,
        getOrThunk: p,
        orThunk: y,
        getOrDie: p,
        each: (D) => {
          D(i);
        },
        toOptional: () => se.some(i)
      };
      return E;
    }, as = (i) => {
      const m = () => p, p = {
        // Debug info
        tag: !1,
        inner: i,
        // Actual Result methods
        fold: (y, E) => y(i),
        isValue: jt,
        isError: X,
        map: m,
        mapError: (y) => ic.error(y(i)),
        bind: m,
        exists: jt,
        forall: X,
        getOr: Ye,
        or: Ye,
        getOrThunk: Gn,
        orThunk: Gn,
        getOrDie: Yt(String(i)),
        each: Xe,
        toOptional: se.none
      };
      return p;
    }, ic = {
      value: Di,
      error: as,
      fromOption: (i, m) => i.fold(() => as(m), Di)
    }, Pa = typeof window < "u" ? window : Function("return this;")(), Wo = (i) => {
      const m = i.replace(/\./g, "-");
      return {
        resolve: (y) => m + "-" + y
      };
    }, kn = (i, m, p = On) => i.exists((y) => p(y, m)), Zo = (i) => {
      const m = [], p = (y) => {
        m.push(y);
      };
      for (let y = 0; y < i.length; y++)
        i[y].each(p);
      return m;
    }, rd = (i, m) => i != null ? m(i) : se.none(), yu = (i, m) => i ? se.some(m) : se.none(), el = (i, m) => {
      let p = m ?? Pa;
      for (let y = 0; y < i.length && p !== void 0 && p !== null; ++y)
        p = p[i[y]];
      return p;
    }, Wt = (i, m) => {
      const p = i.split(".");
      return el(p, m);
    }, Ba = (i) => {
      const m = js(se.none()), p = () => m.get().each(i);
      return {
        clear: () => {
          p(), m.set(se.none());
        },
        isSet: () => m.get().isSome(),
        get: () => m.get(),
        set: (z) => {
          p(), m.set(se.some(z));
        }
      };
    }, Or = () => {
      const i = Ba(Xe);
      return {
        ...i,
        on: (p) => i.get().each(p)
      };
    }, Wm = (i, m) => i.substring(m), xr = (i, m, p) => m === "" || i.length >= m.length && i.substr(p, p + m.length) === m, Qd = (i, m) => Ni(i, m) ? Wm(i, m.length) : i, os = (i, m, p = 0, y) => {
      const E = i.indexOf(m, p);
      return E !== -1 ? Mt(y) ? !0 : E + m.length <= y : !1;
    }, Ni = (i, m) => xr(i, m, 0), ad = (i, m) => xr(i, m, i.length - m.length), Nc = ((i) => (m) => m.replace(i, ""))(/^\s+|\s+$/g), nr = (i) => i.length > 0, Mi = (i) => {
      const m = parseFloat(i);
      return isNaN(m) ? se.none() : se.some(m);
    }, Cu = (i, m) => {
      let p = null;
      const y = () => {
        Tt(p) || (clearTimeout(p), p = null);
      };
      return {
        cancel: y,
        throttle: (...D) => {
          y(), p = setTimeout(() => {
            p = null, i.apply(null, D);
          }, m);
        }
      };
    }, Ct = (i) => {
      let m = !1, p;
      return (...y) => (m || (m = !0, p = i.apply(null, y)), p);
    }, Ya = " ", xu = ["tfoot", "thead", "tbody", "colgroup"], kl = (i) => No(xu, i), Ho = (i, m) => ({
      rows: i,
      columns: m
    }), cd = (i, m) => ({
      row: i,
      column: m
    }), uc = (i, m, p) => ({
      element: i,
      rowspan: m,
      colspan: p
    }), Xs = (i, m, p, y) => ({
      element: i,
      rowspan: m,
      colspan: p,
      isNew: y
    }), Al = (i, m, p, y, E, D) => ({
      element: i,
      rowspan: m,
      colspan: p,
      row: y,
      column: E,
      isLocked: D
    }), ld = (i, m, p) => ({
      element: i,
      cells: m,
      section: p
    }), $a = (i, m, p, y) => ({
      element: i,
      cells: m,
      section: p,
      isNew: y
    }), Pr = (i, m, p) => ({
      element: i,
      isNew: m,
      isLocked: p
    }), tl = (i, m, p, y) => ({
      element: i,
      cells: m,
      section: p,
      isNew: y
    }), Br = (i, m, p, y) => ({
      startRow: i,
      startCol: m,
      finishRow: p,
      finishCol: y
    }), mh = (i, m, p) => ({
      element: i,
      colspan: m,
      column: p
    }), Jd = (i, m) => ({
      element: i,
      columns: m
    }), Mc = (i, m, p) => {
      const y = i.cells, E = y.slice(0, m), D = y.slice(m), $ = E.concat(p).concat(D);
      return Zm(i, $);
    }, _l = (i, m, p) => Mc(i, m, [p]), ei = (i, m, p) => {
      const y = i.cells;
      y[m] = p;
    }, Zm = (i, m) => tl(i.element, m, i.section, i.isNew), As = (i, m) => {
      const p = i.cells, y = he(p, m);
      return tl(i.element, y, i.section, i.isNew);
    }, hn = (i, m) => i.cells[m], qr = (i, m) => hn(i, m).element, Kr = (i) => i.cells.length, _s = (i) => {
      const m = cn(i, (p) => p.section === "colgroup");
      return {
        rows: m.fail,
        cols: m.pass
      };
    }, em = (i, m, p) => {
      const y = he(i.cells, p);
      return tl(m(i.element), y, i.section, !0);
    }, Pi = (i, m) => {
      const y = (m || document).createElement("div");
      if (y.innerHTML = i, !y.hasChildNodes() || y.childNodes.length > 1) {
        const E = "HTML does not have a single root node";
        throw console.error(E, i), new Error(E);
      }
      return nl(y.childNodes[0]);
    }, ms = (i, m) => {
      const y = (m || document).createElement(i);
      return nl(y);
    }, ti = (i, m) => {
      const y = (m || document).createTextNode(i);
      return nl(y);
    }, nl = (i) => {
      if (i == null)
        throw new Error("Node cannot be null or undefined");
      return {
        dom: i
      };
    }, vt = {
      fromHtml: Pi,
      fromTag: ms,
      fromText: ti,
      fromDom: nl,
      fromPoint: (i, m, p) => se.from(i.dom.elementFromPoint(m, p)).map(nl)
    }, ni = (i, m) => {
      const p = i.document.createRange();
      return p.selectNode(m.dom), p;
    }, ha = (i, m) => {
      const p = i.document.createRange();
      return Pc(p, m), p;
    }, Pc = (i, m) => i.selectNodeContents(m.dom), $s = (i, m) => {
      m.fold((p) => {
        i.setStartBefore(p.dom);
      }, (p, y) => {
        i.setStart(p.dom, y);
      }, (p) => {
        i.setStartAfter(p.dom);
      });
    }, eg = (i, m) => {
      m.fold((p) => {
        i.setEndBefore(p.dom);
      }, (p, y) => {
        i.setEnd(p.dom, y);
      }, (p) => {
        i.setEndAfter(p.dom);
      });
    }, Xa = (i, m, p) => {
      const y = i.document.createRange();
      return $s(y, m), eg(y, p), y;
    }, Bc = (i, m, p, y, E) => {
      const D = i.document.createRange();
      return D.setStart(m.dom, p), D.setEnd(y.dom, E), D;
    }, Gm = (i) => ({
      left: i.left,
      top: i.top,
      right: i.right,
      bottom: i.bottom,
      width: i.width,
      height: i.height
    }), tg = (i) => {
      const m = i.getClientRects(), p = m.length > 0 ? m[0] : i.getBoundingClientRect();
      return p.width > 0 || p.height > 0 ? se.some(p).map(Gm) : se.none();
    }, oi = Gr.generate([
      { ltr: ["start", "soffset", "finish", "foffset"] },
      { rtl: ["start", "soffset", "finish", "foffset"] }
    ]), ng = (i, m, p) => m(vt.fromDom(p.startContainer), p.startOffset, vt.fromDom(p.endContainer), p.endOffset), Su = (i, m) => m.match({
      domRange: (p) => ({
        ltr: U(p),
        rtl: se.none
      }),
      relative: (p, y) => ({
        ltr: Ct(() => Xa(i, p, y)),
        rtl: Ct(() => se.some(Xa(i, y, p)))
      }),
      exact: (p, y, E, D) => ({
        ltr: Ct(() => Bc(i, p, y, E, D)),
        rtl: Ct(() => se.some(Bc(i, E, D, p, y)))
      })
    }), si = (i, m) => {
      const p = m.ltr();
      return p.collapsed ? m.rtl().filter((E) => E.collapsed === !1).map((E) => (
        // We need to use "reversed" here, because the original only has one point (collapsed)
        oi.rtl(vt.fromDom(E.endContainer), E.endOffset, vt.fromDom(E.startContainer), E.startOffset)
      )).getOrThunk(() => ng(i, oi.ltr, p)) : ng(i, oi.ltr, p);
    }, wu = (i, m) => {
      const p = Su(i, m);
      return si(i, p);
    }, at = (i, m) => wu(i, m).match({
      ltr: (y, E, D, $) => {
        const z = i.document.createRange();
        return z.setStart(y.dom, E), z.setEnd(D.dom, $), z;
      },
      rtl: (y, E, D, $) => {
        const z = i.document.createRange();
        return z.setStart(D.dom, $), z.setEnd(y.dom, E), z;
      }
    });
    oi.ltr, oi.rtl;
    const Bi = 8, tm = 9, ol = 11, dc = 1, id = 3, pa = (i, m) => {
      const p = i.dom;
      if (p.nodeType !== dc)
        return !1;
      {
        const y = p;
        if (y.matches !== void 0)
          return y.matches(m);
        if (y.msMatchesSelector !== void 0)
          return y.msMatchesSelector(m);
        if (y.webkitMatchesSelector !== void 0)
          return y.webkitMatchesSelector(m);
        if (y.mozMatchesSelector !== void 0)
          return y.mozMatchesSelector(m);
        throw new Error("Browser lacks native selectors");
      }
    }, Ol = (i) => (
      // Only elements, documents and shadow roots support querySelector
      // shadow root element type is DOCUMENT_FRAGMENT
      i.nodeType !== dc && i.nodeType !== tm && i.nodeType !== ol || // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
      i.childElementCount === 0
    ), $i = (i, m) => {
      const p = m === void 0 ? document : m.dom;
      return Ol(p) ? [] : he(p.querySelectorAll(i), vt.fromDom);
    }, ri = (i, m) => {
      const p = m === void 0 ? document : m.dom;
      return Ol(p) ? se.none() : se.from(p.querySelector(i)).map(vt.fromDom);
    }, zo = (i, m) => i.dom === m.dom, ud = (i, m) => {
      const p = i.dom, y = m.dom;
      return p === y ? !1 : p.contains(y);
    }, B = pa, G = (i, m, p, y) => {
      const E = i.isiOS() && /ipad/i.test(p) === !0, D = i.isiOS() && !E, $ = i.isiOS() || i.isAndroid(), z = $ || y("(pointer:coarse)"), K = E || !D && $ && y("(min-device-width:768px)"), ce = D || $ && !K, Ce = m.isSafari() && i.isiOS() && /safari/i.test(p) === !1, Ge = !ce && !K && !Ce;
      return {
        isiPad: U(E),
        isiPhone: U(D),
        isTablet: U(K),
        isPhone: U(ce),
        isTouch: U(z),
        isAndroid: i.isAndroid,
        isiOS: i.isiOS,
        isWebView: U(Ce),
        isDesktop: U(Ge)
      };
    }, re = (i, m) => {
      for (let p = 0; p < i.length; p++) {
        const y = i[p];
        if (y.test(m))
          return y;
      }
    }, Pe = (i, m) => {
      const p = re(i, m);
      if (!p)
        return { major: 0, minor: 0 };
      const y = (E) => Number(m.replace(p, "$" + E));
      return Vo(y(1), y(2));
    }, Ht = (i, m) => {
      const p = String(m).toLowerCase();
      return i.length === 0 ? Jn() : Pe(i, p);
    }, Jn = () => Vo(0, 0), Vo = (i, m) => ({ major: i, minor: m }), Sr = {
      nu: Vo,
      detect: Ht,
      unknown: Jn
    }, Yr = (i, m) => st(m.brands, (p) => {
      const y = p.brand.toLowerCase();
      return P(i, (E) => y === E.brand?.toLowerCase()).map((E) => ({
        current: E.name,
        version: Sr.nu(parseInt(p.version, 10), 0)
      }));
    }), Qa = (i, m) => {
      const p = String(m).toLowerCase();
      return P(i, (y) => y.search(p));
    }, I = (i, m) => Qa(i, m).map((p) => {
      const y = Sr.detect(p.versionRegexes, m);
      return {
        current: p.name,
        version: y
      };
    }), ee = (i, m) => Qa(i, m).map((p) => {
      const y = Sr.detect(p.versionRegexes, m);
      return {
        current: p.name,
        version: y
      };
    }), fe = /.*?version\/\ ?([0-9]+)\.([0-9]+).*/, _e = (i) => (m) => os(m, i), it = [
      // This is legacy Edge
      {
        name: "Edge",
        versionRegexes: [/.*?edge\/ ?([0-9]+)\.([0-9]+)$/],
        search: (i) => os(i, "edge/") && os(i, "chrome") && os(i, "safari") && os(i, "applewebkit")
      },
      // This is Google Chrome and Chromium Edge
      {
        name: "Chromium",
        brand: "Chromium",
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/, fe],
        search: (i) => os(i, "chrome") && !os(i, "chromeframe")
      },
      {
        name: "IE",
        versionRegexes: [/.*?msie\ ?([0-9]+)\.([0-9]+).*/, /.*?rv:([0-9]+)\.([0-9]+).*/],
        search: (i) => os(i, "msie") || os(i, "trident")
      },
      // INVESTIGATE: Is this still the Opera user agent?
      {
        name: "Opera",
        versionRegexes: [fe, /.*?opera\/([0-9]+)\.([0-9]+).*/],
        search: _e("opera")
      },
      {
        name: "Firefox",
        versionRegexes: [/.*?firefox\/\ ?([0-9]+)\.([0-9]+).*/],
        search: _e("firefox")
      },
      {
        name: "Safari",
        versionRegexes: [fe, /.*?cpu os ([0-9]+)_([0-9]+).*/],
        search: (i) => (os(i, "safari") || os(i, "mobile/")) && os(i, "applewebkit")
      }
    ], It = [
      {
        name: "Windows",
        search: _e("win"),
        versionRegexes: [/.*?windows\ nt\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "iOS",
        search: (i) => os(i, "iphone") || os(i, "ipad"),
        versionRegexes: [/.*?version\/\ ?([0-9]+)\.([0-9]+).*/, /.*cpu os ([0-9]+)_([0-9]+).*/, /.*cpu iphone os ([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Android",
        search: _e("android"),
        versionRegexes: [/.*?android\ ?([0-9]+)\.([0-9]+).*/]
      },
      {
        name: "macOS",
        search: _e("mac os x"),
        versionRegexes: [/.*?mac\ os\ x\ ?([0-9]+)_([0-9]+).*/]
      },
      {
        name: "Linux",
        search: _e("linux"),
        versionRegexes: []
      },
      {
        name: "Solaris",
        search: _e("sunos"),
        versionRegexes: []
      },
      {
        name: "FreeBSD",
        search: _e("freebsd"),
        versionRegexes: []
      },
      {
        name: "ChromeOS",
        search: _e("cros"),
        versionRegexes: [/.*?chrome\/([0-9]+)\.([0-9]+).*/]
      }
    ], Mn = {
      browsers: U(it),
      oses: U(It)
    }, wo = "Edge", co = "Chromium", ba = "IE", Ws = "Opera", Eu = "Firefox", qm = "Safari", nm = () => Dl({
      current: void 0,
      version: Sr.unknown()
    }), Dl = (i) => {
      const m = i.current, p = i.version, y = (E) => () => m === E;
      return {
        current: m,
        version: p,
        isEdge: y(wo),
        isChromium: y(co),
        // NOTE: isIe just looks too weird
        isIE: y(ba),
        isOpera: y(Ws),
        isFirefox: y(Eu),
        isSafari: y(qm)
      };
    }, Yb = {
      unknown: nm,
      nu: Dl
    }, Xb = "Windows", Fp = "iOS", Rl = "Android", Qb = "Linux", Jb = "macOS", jy = "Solaris", Ii = "FreeBSD", Wy = "ChromeOS", Zy = () => Lp({
      current: void 0,
      version: Sr.unknown()
    }), Lp = (i) => {
      const m = i.current, p = i.version, y = (E) => () => m === E;
      return {
        current: m,
        version: p,
        isWindows: y(Xb),
        // TODO: Fix capitalisation
        isiOS: y(Fp),
        isAndroid: y(Rl),
        isMacOS: y(Jb),
        isLinux: y(Qb),
        isSolaris: y(jy),
        isFreeBSD: y(Ii),
        isChromeOS: y(Wy)
      };
    }, Hp = {
      unknown: Zy,
      nu: Lp
    }, Gy = {
      detect: (i, m, p) => {
        const y = Mn.browsers(), E = Mn.oses(), D = m.bind((K) => Yr(y, K)).orThunk(() => I(y, i)).fold(Yb.unknown, Yb.nu), $ = ee(E, i).fold(Hp.unknown, Hp.nu), z = G($, D, i, p);
        return {
          browser: D,
          os: $,
          deviceType: z
        };
      }
    }, zp = (i) => window.matchMedia(i).matches;
    let Fi = Ct(() => Gy.detect(window.navigator.userAgent, se.from(window.navigator.userAgentData), zp));
    const sl = () => Fi(), om = (i, m) => Wt(i, m), qy = (i, m) => {
      const p = om(i, m);
      if (p == null)
        throw new Error(i + " not available on this browser");
      return p;
    }, fo = Object.getPrototypeOf, Ky = (i) => qy("HTMLElement", i), fh = (i) => {
      const m = Wt("ownerDocument.defaultView", i);
      return De(i) && (Ky(m).prototype.isPrototypeOf(i) || /^HTML\w*Element$/.test(fo(i).constructor.name));
    }, Qs = (i) => i.dom.nodeName.toLowerCase(), MS = (i) => i.dom.nodeType, Vp = (i) => (m) => MS(m) === i, PS = (i) => MS(i) === Bi || Qs(i) === "#comment", e0 = (i) => Zs(i) && fh(i.dom), Zs = Vp(dc), sm = Vp(id), Yy = Vp(tm), Je = Vp(ol), $c = (i) => (m) => Zs(m) && Qs(m) === i, og = (i) => vt.fromDom(i.dom.ownerDocument), Nl = (i) => Yy(i) ? i : og(i), Km = (i) => vt.fromDom(Nl(i).dom.documentElement), Up = (i) => vt.fromDom(Nl(i).dom.defaultView), te = (i) => se.from(i.dom.parentNode).map(vt.fromDom), mc = (i) => se.from(i.dom.parentElement).map(vt.fromDom), dd = (i, m) => {
      const p = pn(m) ? m : jt;
      let y = i.dom;
      const E = [];
      for (; y.parentNode !== null && y.parentNode !== void 0; ) {
        const D = y.parentNode, $ = vt.fromDom(D);
        if (E.push($), p($) === !0)
          break;
        y = D;
      }
      return E;
    }, jp = (i) => se.from(i.dom.previousSibling).map(vt.fromDom), Ym = (i) => se.from(i.dom.nextSibling).map(vt.fromDom), va = (i) => he(i.dom.childNodes, vt.fromDom), fc = (i, m) => {
      const p = i.dom.childNodes;
      return se.from(p[m]).map(vt.fromDom);
    }, Wp = (i) => fc(i, 0), Zp = (i, m, p, y) => {
      const D = og(i).dom.createRange();
      return D.setStart(i.dom, m), D.setEnd(p.dom, y), D;
    }, sg = (i, m, p, y) => {
      const E = Zp(i, m, p, y), D = zo(i, p) && m === y;
      return E.collapsed && !D;
    }, gc = (i) => Je(i) && Cn(i.dom.host), Gp = (i) => vt.fromDom(i.dom.getRootNode()), Li = (i) => (
      // Can't use SugarBody.body without causing a circular module reference (since SugarBody.inBody uses SugarShadowDom)
      gc(i) ? i : vt.fromDom(Nl(i).dom.body)
    ), rg = (i) => {
      const m = Gp(i);
      return gc(m) ? se.some(m) : se.none();
    }, qp = (i) => vt.fromDom(i.dom.host), Ic = (i) => {
      if (Cn(i.target)) {
        const m = vt.fromDom(i.target);
        if (Zs(m) && Kp(m) && i.composed && i.composedPath) {
          const p = i.composedPath();
          if (p)
            return xe(p);
        }
      }
      return se.from(i.target);
    }, Kp = (i) => Cn(i.dom.shadowRoot), ai = (i, m, p, y, E, D, $) => ({
      target: i,
      x: m,
      y: p,
      stop: y,
      prevent: E,
      kill: D,
      raw: $
    }), md = (i) => {
      const m = vt.fromDom(Ic(i).getOr(i.target)), p = () => i.stopPropagation(), y = () => i.preventDefault(), E = In(y, p);
      return ai(m, i.clientX, i.clientY, p, y, E, i);
    }, Qn = (i, m) => (p) => {
      i(p) && m(md(p));
    }, Ja = (i, m, p, y, E) => {
      const D = Qn(p, y);
      return i.dom.addEventListener(m, D, E), {
        unbind: Ot(t0, i, m, D, E)
      };
    }, Xm = (i, m, p, y) => Ja(i, m, p, y, !1), t0 = (i, m, p, y) => {
      i.dom.removeEventListener(m, p, y);
    }, Hn = X, Tu = (i, m, p) => Xm(i, m, Hn, p), mr = md, ci = (i, m) => {
      te(i).each((y) => {
        y.dom.insertBefore(m.dom, i.dom);
      });
    }, li = (i, m) => {
      Ym(i).fold(() => {
        te(i).each((E) => {
          Eo(E, m);
        });
      }, (y) => {
        ci(y, m);
      });
    }, Is = (i, m) => {
      Wp(i).fold(() => {
        Eo(i, m);
      }, (y) => {
        i.dom.insertBefore(m.dom, y.dom);
      });
    }, Eo = (i, m) => {
      i.dom.appendChild(m.dom);
    }, Xy = (i, m, p) => {
      fc(i, p).fold(() => {
        Eo(i, m);
      }, (y) => {
        ci(y, m);
      });
    }, Qy = (i, m) => {
      ci(i, m), Eo(m, i);
    }, fr = (i, m) => {
      ue(m, (p, y) => {
        const E = y === 0 ? i : m[y - 1];
        li(E, p);
      });
    }, Ml = (i, m) => {
      ue(m, (p) => {
        Eo(i, p);
      });
    }, Pl = (i, m, p) => {
      if (nn(p) || $n(p) || un(p))
        i.setAttribute(m, p + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", m, ":: Value ", p, ":: Element ", i), new Error("Attribute value was not simple");
    }, gr = (i, m, p) => {
      Pl(i.dom, m, p);
    }, ii = (i, m) => {
      const p = i.dom;
      qn(m, (y, E) => {
        Pl(p, E, y);
      });
    }, ec = (i, m) => {
      qn(m, (p, y) => {
        p.fold(() => {
          Oo(i, y);
        }, (E) => {
          Pl(i.dom, y, E);
        });
      });
    }, Fc = (i, m) => {
      const p = i.dom.getAttribute(m);
      return p === null ? void 0 : p;
    }, ya = (i, m) => se.from(Fc(i, m)), Oo = (i, m) => {
      i.dom.removeAttribute(m);
    }, rl = (i) => ye(i.dom.attributes, (m, p) => (m[p.name] = p.value, m), {}), tc = (i) => {
      i.dom.textContent = "", ue(va(i), (m) => {
        Xr(m);
      });
    }, Xr = (i) => {
      const m = i.dom;
      m.parentNode !== null && m.parentNode.removeChild(m);
    }, $r = (i) => {
      const m = va(i);
      m.length > 0 && fr(i, m), Xr(i);
    }, Os = (i, m) => vt.fromDom(i.dom.cloneNode(m)), Bl = (i) => Os(i, !1), Ir = (i) => Os(i, !0), or = (i, m) => {
      const p = vt.fromTag(m), y = rl(i);
      return ii(p, y), p;
    }, fd = (i, m) => {
      const p = or(i, m), y = va(Ir(i));
      return Ml(p, y), p;
    }, Yp = (i, m) => {
      const p = or(i, m);
      li(i, p);
      const y = va(i);
      return Ml(p, y), Xr(i), p;
    }, gh = (i, m) => {
      const y = document.createElement("div");
      return y.innerHTML = i, va(vt.fromDom(y));
    }, Fr = (i) => he(i, vt.fromDom), Xp = (i) => i.dom.innerHTML, n0 = (i) => {
      const m = vt.fromTag("div"), p = vt.fromDom(i.dom.cloneNode(!0));
      return Eo(m, p), Xp(m);
    }, rm = (i) => i.style !== void 0 && pn(i.style.getPropertyValue), ln = (i) => {
      const m = sm(i) ? i.dom.parentNode : i.dom;
      if (m == null || m.ownerDocument === null)
        return !1;
      const p = m.ownerDocument;
      return rg(vt.fromDom(m)).fold(() => p.body.contains(m), lt(ln, qp));
    }, Qp = (i) => {
      const m = i.dom.body;
      if (m == null)
        throw new Error("Body is not available yet");
      return vt.fromDom(m);
    }, Dr = (i, m, p) => {
      if (!nn(p))
        throw console.error("Invalid call to CSS.set. Property ", m, ":: Value ", p, ":: Element ", i), new Error("CSS value must be a string: " + p);
      rm(i) && i.style.setProperty(m, p);
    }, Qr = (i, m) => {
      rm(i) && i.style.removeProperty(m);
    }, Jr = (i, m, p) => {
      const y = i.dom;
      Dr(y, m, p);
    }, fs = (i, m) => {
      const p = i.dom;
      qn(m, (y, E) => {
        Dr(p, E, y);
      });
    }, gd = (i, m) => {
      const p = i.dom, E = window.getComputedStyle(p).getPropertyValue(m);
      return E === "" && !ln(i) ? hh(p, m) : E;
    }, hh = (i, m) => rm(i) ? i.style.getPropertyValue(m) : "", al = (i, m) => {
      const p = i.dom, y = hh(p, m);
      return se.from(y).filter((E) => E.length > 0);
    }, ui = (i, m) => {
      const p = i.dom;
      Qr(p, m), kn(ya(i, "style").map(Nc), "") && Oo(i, "style");
    }, ag = (i, m) => {
      const p = i.dom, y = m.dom;
      rm(p) && rm(y) && (y.style.cssText = p.style.cssText);
    }, ph = (i, m) => {
      const p = (z, K) => {
        if (!un(K) && !K.match(/^[0-9]+$/))
          throw new Error(i + ".set accepts only positive integer values. Value was " + K);
        const ce = z.dom;
        rm(ce) && (ce.style[i] = K + "px");
      }, y = (z) => {
        const K = m(z);
        if (K <= 0 || K === null) {
          const ce = gd(z, i);
          return parseFloat(ce) || 0;
        }
        return K;
      }, E = y, D = (z, K) => ye(K, (ce, Ce) => {
        const Ge = gd(z, Ce), kt = Ge === void 0 ? 0 : parseInt(Ge, 10);
        return isNaN(kt) ? ce : ce + kt;
      }, 0);
      return {
        set: p,
        get: y,
        getOuter: E,
        aggregate: D,
        max: (z, K, ce) => {
          const Ce = D(z, ce);
          return K > Ce ? K - Ce : 0;
        }
      };
    }, cg = (i, m) => Mi(i).getOr(m), Hi = (i, m, p) => cg(gd(i, m), p), $l = (i, m, p, y) => {
      const E = Hi(i, `padding-${p}`, 0), D = Hi(i, `padding-${y}`, 0), $ = Hi(i, `border-${p}-width`, 0), z = Hi(i, `border-${y}-width`, 0);
      return m - E - D - $ - z;
    }, Jp = (i, m) => {
      const p = i.dom, y = p.getBoundingClientRect().width || p.offsetWidth;
      return $l(i, y, "left", "right");
    }, ca = (i) => Hi(i, "height", i.dom.offsetHeight), cl = (i) => Hi(i, "width", i.dom.offsetWidth), zi = (i) => Jp(i), bo = ph("height", (i) => {
      const m = i.dom;
      return ln(i) ? m.getBoundingClientRect().height : m.offsetHeight;
    }), Lc = (i) => bo.get(i), o0 = (i) => bo.getOuter(i), lg = ca, ll = ph("width", (i) => {
      const m = i.dom;
      return ln(i) ? m.getBoundingClientRect().width : m.offsetWidth;
    }), gn = (i) => ll.get(i), Ss = (i) => ll.getOuter(i), ea = zi, gs = cl, il = (i, m) => ({
      left: i,
      top: m,
      translate: (y, E) => il(i + y, m + E)
    }), Cs = il, sr = (i) => {
      const m = i.getBoundingClientRect();
      return Cs(m.left, m.top);
    }, Qm = (i, m) => i !== void 0 ? i : m !== void 0 ? m : 0, Kn = (i) => {
      const m = i.dom.ownerDocument, p = m.body, y = m.defaultView, E = m.documentElement;
      if (p === i.dom)
        return Cs(p.offsetLeft, p.offsetTop);
      const D = Qm(y?.pageYOffset, E.scrollTop), $ = Qm(y?.pageXOffset, E.scrollLeft), z = Qm(E.clientTop, p.clientTop), K = Qm(E.clientLeft, p.clientLeft);
      return Il(i).translate($ - K, D - z);
    }, Il = (i) => {
      const m = i.dom, y = m.ownerDocument.body;
      return y === m ? Cs(y.offsetLeft, y.offsetTop) : ln(i) ? sr(m) : Cs(0, 0);
    }, qo = (i) => {
      const m = i !== void 0 ? i.dom : document, p = m.body.scrollLeft || m.documentElement.scrollLeft, y = m.body.scrollTop || m.documentElement.scrollTop;
      return Cs(p, y);
    }, hc = (i, m, p) => {
      const E = (p !== void 0 ? p.dom : document).defaultView;
      E && E.scrollBy(i, m);
    }, pr = ((i, m) => {
      const p = (D) => {
        if (!i(D))
          throw new Error("Can only get " + m + " value of a " + m + " node");
        return y(D).getOr("");
      }, y = (D) => i(D) ? se.from(D.dom.nodeValue) : se.none();
      return {
        get: p,
        getOption: y,
        set: (D, $) => {
          if (!i(D))
            throw new Error("Can only set raw " + m + " value of a " + m + " node");
          D.dom.nodeValue = $;
        }
      };
    })(sm, "text"), Vi = (i) => pr.get(i), Jm = (i) => pr.getOption(i), ku = (i, m) => pr.set(i, m), hd = (i, m) => (p) => pd(p) === "rtl" ? m : i, pd = (i) => gd(i, "direction") === "rtl" ? "rtl" : "ltr", la = (i, m) => {
      const p = Fc(i, m);
      return p === void 0 || p === "" ? [] : p.split(" ");
    }, Au = (i, m, p) => {
      const E = la(i, m).concat([p]);
      return gr(i, m, E.join(" ")), !0;
    }, Jy = (i, m, p) => {
      const y = fn(la(i, m), (E) => E !== p);
      return y.length > 0 ? gr(i, m, y.join(" ")) : Oo(i, m), !1;
    };
    var bd = (i, m, p, y, E) => i(p, y) ? se.some(p) : pn(E) && E(p) ? se.none() : m(p, y, E);
    const Mo = (i, m, p) => {
      let y = i.dom;
      const E = pn(p) ? p : jt;
      for (; y.parentNode; ) {
        y = y.parentNode;
        const D = vt.fromDom(y);
        if (m(D))
          return se.some(D);
        if (E(D))
          break;
      }
      return se.none();
    }, e1 = (i, m, p) => bd((E, D) => D(E), Mo, i, m, p), ef = (i, m) => {
      const p = (E) => m(vt.fromDom(E));
      return P(i.dom.childNodes, p).map(vt.fromDom);
    }, Ca = (i, m) => {
      const p = (y) => {
        for (let E = 0; E < y.childNodes.length; E++) {
          const D = vt.fromDom(y.childNodes[E]);
          if (m(D))
            return se.some(D);
          const $ = p(y.childNodes[E]);
          if ($.isSome())
            return $;
        }
        return se.none();
      };
      return p(i.dom);
    }, pc = (i, m, p) => Mo(i, (y) => pa(y, m), p), Ls = (i, m) => ef(i, (p) => pa(p, m)), _u = (i, m) => ri(m, i), rr = (i, m, p) => bd((E, D) => pa(E, D), pc, i, m, p), tf = (i) => i.dom.classList !== void 0, bh = (i) => la(i, "class"), t1 = (i, m) => Au(i, "class", m), BS = (i, m) => Jy(i, "class", m), di = (i, m) => {
      tf(i) ? i.dom.classList.add(m) : t1(i, m);
    }, e2 = (i) => {
      (tf(i) ? i.dom.classList : bh(i)).length === 0 && Oo(i, "class");
    }, n1 = (i, m) => {
      tf(i) ? i.dom.classList.remove(m) : BS(i, m), e2(i);
    }, mi = (i, m) => tf(i) && i.dom.classList.contains(m), s0 = (i, m) => {
      ue(m, (p) => {
        n1(i, p);
      });
    }, nf = (i) => rr(i, "[contenteditable]"), ig = (i, m = !1) => ln(i) ? i.dom.isContentEditable : nf(i).fold(U(m), (p) => ug(p) === "true"), ug = (i) => i.dom.contentEditable, o1 = (i) => (m) => {
      di(m, i);
    }, r0 = (i) => (m) => {
      s0(m, i);
    }, Fl = (i, m, p) => fn(dd(i, p), m), t2 = (i, m) => fn(va(i), m), vd = (i, m) => {
      let p = [];
      return ue(va(i), (y) => {
        m(y) && (p = p.concat([y])), p = p.concat(vd(y, m));
      }), p;
    }, Po = (i, m, p) => (
      // It may surprise you to learn this is exactly what JQuery does
      // TODO: Avoid all this wrapping and unwrapping
      Fl(i, (y) => pa(y, m), p)
    ), xa = (i, m) => (
      // It may surprise you to learn this is exactly what JQuery does
      // TODO: Avoid all the wrapping and unwrapping
      t2(i, (p) => pa(p, m))
    ), Ui = (i, m) => $i(m, i), s1 = (i, m, p, y) => ({
      parent: i,
      children: m,
      element: p,
      index: y
    }), yd = (i) => te(i).bind((m) => {
      const p = va(m);
      return r1(p, i).map((y) => s1(m, p, i, y));
    }), r1 = (i, m) => ro(i, Ot(zo, m)), a0 = (i, m, p) => Mo(i, m, p).isSome(), ji = (i) => Qs(i) === "img" ? 1 : Jm(i).fold(() => va(i).length, (m) => m.length), Wi = (i) => Jm(i).filter((m) => (
      // For the purposes of finding cursor positions only allow text nodes with content,
      // but trim removes &nbsp; and that's allowed
      m.trim().length !== 0 || m.indexOf(Ya) > -1
    )).isSome(), Uo = (i) => e0(i) && Fc(i, "contenteditable") === "false", c0 = ["img", "br"], Ds = (i) => Wi(i) || No(c0, Qs(i)) || Uo(i), of = (i) => Ca(i, Ds), ar = (i) => Zi(i, Ds), Zi = (i, m) => {
      const p = (y) => {
        const E = va(y);
        for (let D = E.length - 1; D >= 0; D--) {
          const $ = E[D];
          if (m($))
            return se.some($);
          const z = p($);
          if (z.isSome())
            return z;
        }
        return se.none();
      };
      return p(i);
    }, Ou = {
      create: (i, m, p, y) => ({
        start: i,
        soffset: m,
        finish: p,
        foffset: y
      })
    }, vh = Gr.generate([
      { before: ["element"] },
      { on: ["element", "offset"] },
      { after: ["element"] }
    ]), a1 = (i, m, p, y) => i.fold(m, p, y), c1 = (i) => i.fold(Ye, Ye, Ye), n2 = vh.before, bc = vh.on, fi = vh.after, cr = {
      before: n2,
      on: bc,
      after: fi,
      cata: a1,
      getStart: c1
    }, Lr = Gr.generate([
      { domRange: ["rng"] },
      { relative: ["startSitu", "finishSitu"] },
      { exact: ["start", "soffset", "finish", "foffset"] }
    ]), yh = (i) => Lr.exact(i.start, i.soffset, i.finish, i.foffset), dg = (i) => i.match({
      domRange: (m) => vt.fromDom(m.startContainer),
      relative: (m, p) => cr.getStart(m),
      exact: (m, p, y, E) => m
    }), Ch = Lr.domRange, l0 = Lr.relative, Ll = Lr.exact, $S = (i) => {
      const m = dg(i);
      return Up(m);
    }, w = Ou.create, k = {
      domRange: Ch,
      relative: l0,
      exact: Ll,
      exactFromRange: yh,
      getWin: $S,
      range: w
    }, F = (i, m, p) => se.from(i.caretPositionFromPoint?.(m, p)).bind((y) => {
      if (y.offsetNode === null)
        return se.none();
      const E = i.createRange();
      return E.setStart(y.offsetNode, y.offset), E.collapse(), se.some(E);
    }), q = (i, m, p) => se.from(i.caretRangeFromPoint?.(m, p)), de = (i, m, p) => i.caretPositionFromPoint ? F(i, m, p) : i.caretRangeFromPoint ? q(i, m, p) : se.none(), Ne = (i, m, p) => {
      const y = i.document;
      return de(y, m, p).map((E) => Ou.create(vt.fromDom(E.startContainer), E.startOffset, vt.fromDom(E.endContainer), E.endOffset));
    }, ft = (i, m) => {
      const p = Qs(i);
      return p === "input" ? cr.after(i) : No(["br", "img"], p) ? m === 0 ? cr.before(i) : cr.after(i) : cr.on(i, m);
    }, Zt = (i, m) => {
      const p = i.fold(cr.before, ft, cr.after), y = m.fold(cr.before, ft, cr.after);
      return k.relative(p, y);
    }, Dn = (i, m, p, y) => {
      const E = ft(i, m), D = ft(p, y);
      return k.relative(E, D);
    }, Vn = (i) => se.from(i.getSelection()), ss = (i, m) => {
      Vn(i).each((p) => {
        p.removeAllRanges(), p.addRange(m);
      });
    }, ws = (i, m, p, y, E) => {
      const D = Bc(i, m, p, y, E);
      ss(i, D);
    }, lr = (i, m, p, y, E, D) => {
      m.collapse(p.dom, y), m.extend(E.dom, D);
    }, Hc = (i, m) => wu(i, m).match({
      ltr: (p, y, E, D) => {
        ws(i, p, y, E, D);
      },
      rtl: (p, y, E, D) => {
        Vn(i).each(($) => {
          if ($.setBaseAndExtent)
            $.setBaseAndExtent(p.dom, y, E.dom, D);
          else if ($.extend)
            try {
              lr(i, $, p, y, E, D);
            } catch {
              ws(i, E, D, p, y);
            }
          else
            ws(i, E, D, p, y);
        });
      }
    }), gi = (i, m, p, y, E) => {
      const D = Dn(m, p, y, E);
      Hc(i, D);
    }, Du = (i, m, p) => {
      const y = Zt(m, p);
      Hc(i, y);
    }, Hl = (i) => {
      if (i.rangeCount > 0) {
        const m = i.getRangeAt(0), p = i.getRangeAt(i.rangeCount - 1);
        return se.some(Ou.create(vt.fromDom(m.startContainer), m.startOffset, vt.fromDom(p.endContainer), p.endOffset));
      } else
        return se.none();
    }, l1 = (i) => {
      if (i.anchorNode === null || i.focusNode === null)
        return Hl(i);
      {
        const m = vt.fromDom(i.anchorNode), p = vt.fromDom(i.focusNode);
        return sg(m, i.anchorOffset, p, i.focusOffset) ? se.some(Ou.create(m, i.anchorOffset, p, i.focusOffset)) : Hl(i);
      }
    }, sf = (i, m, p = !0) => {
      const E = (p ? ha : ni)(i, m);
      ss(i, E);
    }, mg = (i) => (
      // We want to retrieve the selection as it is.
      Vn(i).filter((m) => m.rangeCount > 0).bind(l1)
    ), fg = (i) => mg(i).map((m) => k.exact(m.start, m.soffset, m.finish, m.foffset)), gg = (i, m) => {
      const p = at(i, m);
      return tg(p);
    }, rf = (i, m, p) => Ne(i, m, p), xh = (i) => {
      Vn(i).each((m) => m.removeAllRanges());
    }, o2 = {
      // we don't really support all of these different ways to express a length
      unsupportedLength: [
        "em",
        "ex",
        "cap",
        "ch",
        "ic",
        "rem",
        "lh",
        "rlh",
        "vw",
        "vh",
        "vi",
        "vb",
        "vmin",
        "vmax",
        "cm",
        "mm",
        "Q",
        "in",
        "pc",
        "pt",
        "px"
      ],
      // these are the length values we do support
      fixed: ["px", "pt"],
      relative: ["%"],
      empty: [""]
    }, s2 = (() => {
      const i = "[0-9]+", p = "[eE]" + ("[+-]?" + i), y = "\\.", E = (z) => `(?:${z})?`, $ = `[+-]?(?:${[
        "Infinity",
        i + y + E(i) + E(p),
        y + i + E(p),
        i + E(p)
      ].join("|")})`;
      return new RegExp(`^(${$})(.*)$`);
    })(), vo = (i, m) => ot(m, (p) => ot(o2[p], (y) => i === y)), Hs = (i, m) => se.from(s2.exec(i)).bind((y) => {
      const E = Number(y[1]), D = y[2];
      return vo(D, m) ? se.some({
        value: E,
        unit: D
      }) : se.none();
    }), Gs = (i) => he(i, U(0)), Sa = (i, m, p, y, E) => E(i.slice(0, m)).concat(y).concat(E(i.slice(p))), Sh = (i) => (m, p, y, E) => {
      if (i(y)) {
        const D = Math.max(E, m[p] - Math.abs(y)), $ = Math.abs(D - m[p]);
        return y >= 0 ? $ : -$;
      } else
        return y;
    }, hg = Sh((i) => i < 0), wh = Sh(X), Eh = () => {
      const i = (z, K, ce, Ce, Ge) => {
        const kt = hg(z, K, Ce, Ge);
        return Sa(z, K, ce + 1, [kt, 0], Gs);
      }, m = (z, K, ce, Ce) => {
        const Ge = (100 + ce) / 100, kt = Math.max(Ce, (z[K] + ce) / Ge);
        return he(z, (wt, Gt) => (Gt === K ? kt : wt / Ge) - wt);
      }, p = (z, K, ce, Ce, Ge, kt) => kt ? m(z, K, Ce, Ge) : i(z, K, ce, Ce, Ge);
      return {
        resizeTable: (z, K) => z(K),
        clampTableDelta: hg,
        calcLeftEdgeDeltas: p,
        calcMiddleDeltas: (z, K, ce, Ce, Ge, kt, wt) => p(z, ce, Ce, Ge, kt, wt),
        calcRightEdgeDeltas: (z, K, ce, Ce, Ge, kt) => {
          if (kt)
            return m(z, ce, Ce, Ge);
          {
            const wt = hg(z, ce, Ce, Ge);
            return Gs(z.slice(0, ce)).concat([wt]);
          }
        },
        calcRedestributedWidths: (z, K, ce, Ce) => {
          if (Ce) {
            const kt = (K + ce) / K, wt = he(z, (Gt) => Gt / kt);
            return {
              delta: kt * 100 - 100,
              newSizes: wt
            };
          } else
            return {
              delta: ce,
              newSizes: z
            };
        }
      };
    }, IS = () => {
      const i = ($, z, K, ce, Ce) => {
        const Ge = ce >= 0 ? K : z, kt = wh($, Ge, ce, Ce);
        return Sa($, z, K + 1, [kt, -kt], Gs);
      };
      return {
        resizeTable: ($, z, K) => {
          K && $(z);
        },
        clampTableDelta: ($, z, K, ce, Ce) => {
          if (Ce) {
            if (K >= 0)
              return K;
            {
              const Ge = ye($, (kt, wt) => kt + wt - ce, 0);
              return Math.max(-Ge, K);
            }
          } else
            return hg($, z, K, ce);
        },
        calcLeftEdgeDeltas: i,
        calcMiddleDeltas: ($, z, K, ce, Ce, Ge) => i($, K, ce, Ce, Ge),
        calcRightEdgeDeltas: ($, z, K, ce, Ce, Ge) => {
          if (Ge)
            return Gs($);
          {
            const kt = ce / $.length;
            return he($, U(kt));
          }
        },
        calcRedestributedWidths: ($, z, K, ce) => ({
          delta: 0,
          newSizes: $
        })
      };
    }, am = (i, m, p = 0) => ya(i, m).map((y) => parseInt(y, 10)).getOr(p), i1 = (i, m) => am(i, m, 1), af = (i) => $c("col")(i) ? am(i, "span", 1) > 1 : i1(i, "colspan") > 1, M3 = (i) => i1(i, "rowspan") > 1, Rr = (i, m) => parseInt(gd(i, m), 10), wr = U(10), cf = U(10), cm = (i, m) => r2(i, m, X), r2 = (i, m, p) => oo(va(i), (y) => pa(y, m) ? p(y) ? [y] : [] : r2(y, m, p)), Ia = (i, m, p = jt) => {
      if (p(m))
        return se.none();
      if (No(i, Qs(m)))
        return se.some(m);
      const y = (E) => pa(E, "table") || p(E);
      return pc(m, i.join(","), y);
    }, a2 = (i, m) => Ia(["td", "th"], i, m), lf = (i) => cm(i, "th,td"), i0 = (i) => pa(i, "colgroup") ? xa(i, "col") : oo(ul(i), (m) => xa(m, "col")), zl = (i, m) => rr(i, "table", m), c2 = (i) => cm(i, "tr"), ul = (i) => zl(i).fold(U([]), (m) => xa(m, "colgroup")), Js = $c("th"), u0 = (i) => ao(i, (m) => Js(m.element)), Th = (i, m) => i && m ? "sectionCells" : i ? "section" : "cells", FS = (i) => {
      const m = i.section === "thead", p = kn(l2(i.cells), "th");
      return i.section === "tfoot" ? { type: "footer" } : m || p ? { type: "header", subType: Th(m, p) } : { type: "body" };
    }, l2 = (i) => {
      const m = fn(i, (p) => Js(p.element));
      return m.length === 0 ? se.some("td") : m.length === i.length ? se.some("th") : se.none();
    }, LS = (i) => {
      const m = he(i, (E) => FS(E).type), p = No(m, "header"), y = No(m, "footer");
      if (!p && !y)
        return se.some("body");
      {
        const E = No(m, "body");
        return p && !E && !y ? se.some("header") : !p && !E && y ? se.some("footer") : se.none();
      }
    }, HS = (i) => st(i.all, (m) => {
      const p = FS(m);
      return p.type === "header" ? se.from(p.subType) : se.none();
    }), d0 = (i, m) => he(i, (p) => {
      if (Qs(p) === "colgroup") {
        const y = he(i0(p), (E) => {
          const D = am(E, "span", 1);
          return uc(E, 1, D);
        });
        return ld(p, y, "colgroup");
      } else {
        const y = he(lf(p), (E) => {
          const D = am(E, "rowspan", 1), $ = am(E, "colspan", 1);
          return uc(E, D, $);
        });
        return ld(p, y, m(p));
      }
    }), kh = (i) => te(i).map((m) => {
      const p = Qs(m);
      return kl(p) ? p : "tbody";
    }).getOr("tbody"), m0 = (i) => {
      const m = c2(i), y = [...ul(i), ...m];
      return d0(y, kh);
    }, ht = (i, m) => d0(i, () => m), zc = "data-snooker-locked-cols", P3 = (i) => ya(i, zc).bind((m) => se.from(m.match(/\d+/g))).map((m) => Lt(m, X)), vc = (i) => {
      const m = ye(_s(i).rows, (y, E) => (ue(E.cells, (D, $) => {
        D.isLocked && (y[$] = !0);
      }), y), {}), p = ga(m, (y, E) => parseInt(E, 10));
      return po(p);
    }, hi = (i, m) => i + "," + m, f0 = (i, m, p) => se.from(i.access[hi(m, p)]), B3 = (i, m, p) => {
      const y = uf(i, (E) => p(m, E.element));
      return y.length > 0 ? se.some(y[0]) : se.none();
    }, uf = (i, m) => {
      const p = oo(i.all, (y) => y.cells);
      return fn(p, m);
    }, $3 = (i) => {
      const m = {};
      let p = 0;
      return ue(i.cells, (y) => {
        const E = y.colspan;
        jo(E, (D) => {
          const $ = p + D;
          m[$] = mh(y.element, E, $);
        }), p += E;
      }), m;
    }, Vc = (i) => {
      const m = {}, p = [], E = xe(i).map((wt) => wt.element).bind(zl).bind(P3).getOr({});
      let D = 0, $ = 0, z = 0;
      const { pass: K, fail: ce } = cn(i, (wt) => wt.section === "colgroup");
      ue(ce, (wt) => {
        const Gt = [];
        ue(wt.cells, (Fe) => {
          let qe = 0;
          for (; m[hi(z, qe)] !== void 0; )
            qe++;
          const dn = Bs(E, qe.toString()), Bn = Al(Fe.element, Fe.rowspan, Fe.colspan, z, qe, dn);
          for (let Bt = 0; Bt < Fe.colspan; Bt++)
            for (let Bo = 0; Bo < Fe.rowspan; Bo++) {
              const $o = z + Bo, Rn = qe + Bt, br = hi($o, Rn);
              m[br] = Bn, $ = Math.max($, Rn + 1);
            }
          Gt.push(Bn);
        }), D++, p.push(ld(wt.element, Gt, wt.section)), z++;
      });
      const { columns: Ce, colgroups: Ge } = We(K).map((wt) => {
        const Gt = $3(wt);
        return {
          colgroups: [Jd(wt.element, xo(Gt))],
          columns: Gt
        };
      }).getOrThunk(() => ({
        colgroups: [],
        columns: {}
      }));
      return {
        grid: Ho(D, $),
        access: m,
        all: p,
        columns: Ce,
        colgroups: Ge
      };
    }, zn = {
      fromTable: (i) => {
        const m = m0(i);
        return Vc(m);
      },
      generate: Vc,
      getAt: f0,
      findItem: B3,
      filterItems: uf,
      justCells: (i) => oo(i.all, (m) => m.cells),
      justColumns: (i) => xo(i.columns),
      hasColumns: (i) => ze(i.columns).length > 0,
      getColumnAt: (i, m) => se.from(i.columns[m])
    }, lm = (i, m, p) => Pr(p(i.element, m), !0, i.isLocked), Ah = (i, m) => i.section !== m ? tl(i.element, i.cells, m, i.isNew) : i, zs = () => ({
      transformRow: Ah,
      transformCell: (i, m, p) => {
        const y = p(i.element, m), E = Qs(y) !== "td" ? Yp(y, "td") : y;
        return Pr(E, i.isNew, i.isLocked);
      }
    }), bi = () => ({
      transformRow: Ah,
      transformCell: lm
    }), u1 = () => ({
      transformRow: (i, m) => Ah(i, m === "thead" ? "tbody" : m),
      transformCell: lm
    }), im = {
      getTableSectionType: (i, m) => {
        const p = zn.fromTable(i);
        switch (HS(p).getOr(m)) {
          case "section":
            return zs();
          case "sectionCells":
            return bi();
          case "cells":
            return u1();
        }
      },
      section: zs,
      sectionCells: bi,
      cells: u1,
      fallback: () => ({
        transformRow: Ye,
        transformCell: lm
      })
    }, _h = (i, m = X) => {
      const p = i.grid, y = jo(p.columns, Ye), E = jo(p.rows, Ye);
      return he(y, (D) => u2(() => oo(E, (ce) => zn.getAt(i, ce, D).filter((Ce) => Ce.column === D).toArray()), (ce) => ce.colspan === 1 && m(ce.element), () => zn.getAt(i, 0, D)));
    }, u2 = (i, m, p) => {
      const y = i();
      return P(y, m).orThunk(() => se.from(y[0]).orThunk(p)).map(($) => $.element);
    }, d2 = (i) => {
      const m = i.grid, p = jo(m.rows, Ye), y = jo(m.columns, Ye);
      return he(p, (E) => u2(() => oo(y, (K) => zn.getAt(i, E, K).filter((ce) => ce.row === E).fold(U([]), (ce) => [ce])), (K) => K.rowspan === 1, () => zn.getAt(i, E, 0)));
    }, vi = (i, m) => {
      if (m < 0 || m >= i.length - 1)
        return se.none();
      const p = i[m].fold(() => {
        const E = ur(i.slice(0, m));
        return st(E, (D, $) => D.map((z) => ({ value: z, delta: $ + 1 })));
      }, (E) => se.some({ value: E, delta: 0 })), y = i[m + 1].fold(() => {
        const E = i.slice(m + 1);
        return st(E, (D, $) => D.map((z) => ({ value: z, delta: $ + 1 })));
      }, (E) => se.some({ value: E, delta: 1 }));
      return p.bind((E) => y.map((D) => {
        const $ = D.delta + E.delta;
        return Math.abs(D.value - E.value) / $;
      }));
    }, d1 = (i, m) => ({
      row: i,
      y: m
    }), m1 = (i, m) => ({
      col: i,
      x: m
    }), I3 = (i) => Kn(i).left + Ss(i), m2 = (i) => Kn(i).left, f1 = (i, m) => m1(i, m2(m)), f2 = (i, m) => m1(i, I3(m)), g0 = (i) => Kn(i).top, F3 = (i, m) => d1(i, g0(m)), L3 = (i, m) => d1(i, g0(m) + o0(m)), g2 = (i, m, p) => {
      if (p.length === 0)
        return [];
      const y = he(p.slice(1), (D, $) => D.map((z) => i($, z))), E = p[p.length - 1].map((D) => m(p.length - 1, D));
      return y.concat([E]);
    }, H3 = (i) => -i, g1 = {
      delta: Ye,
      positions: (i) => g2(F3, L3, i),
      edge: g0
    }, on = hd({
      delta: Ye,
      edge: m2,
      positions: (i) => g2(f1, f2, i)
    }, {
      delta: H3,
      edge: I3,
      positions: (i) => g2(f2, f1, i)
    }), er = {
      delta: (i, m) => on(m).delta(i, m),
      positions: (i, m) => on(m).positions(i, m),
      edge: (i) => on(i).edge(i)
    }, Oh = /(\d+(\.\d+)?)%/, VS = /(\d+(\.\d+)?)px|em/, pg = $c("col"), Dh = $c("tr"), h2 = (i, m, p) => {
      const y = mc(i).getOrThunk(() => Qp(og(i)));
      return m(i) / p(y) * 100;
    }, bg = (i, m) => {
      Jr(i, "width", m + "px");
    }, US = (i, m) => {
      Jr(i, "width", m + "%");
    }, Cd = (i, m) => {
      Jr(i, "height", m + "px");
    }, jS = (i) => {
      ui(i, "height");
    }, p2 = (i) => lg(i) + "px", Fs = (i, m, p, y) => {
      const E = zl(i).map((D) => {
        const $ = p(D);
        return Math.floor(m / 100 * $);
      }).getOr(m);
      return y(i, E), E;
    }, yi = (i, m, p, y) => {
      const E = parseFloat(i);
      return ad(i, "%") && Qs(m) !== "table" ? Fs(m, E, p, y) : E;
    }, yc = (i) => {
      const m = p2(i);
      return m ? yi(m, i, Lc, Cd) : Lc(i);
    }, Rh = (i, m, p) => {
      const y = p(i), E = i1(i, m);
      return y / E;
    }, Cc = (i, m) => al(i, m).orThunk(() => ya(i, m).map((p) => p + "px")), vg = (i) => Cc(i, "width"), ta = (i) => Cc(i, "height"), xc = (i) => h2(i, gn, ea), h0 = (i) => (
      // For col elements use the computed width as col elements aren't affected by borders, padding, etc...
      pg(i) ? Math.round(gn(i)) : gs(i)
    ), Ze = (i) => Dh(i) ? Lc(i) : Rh(i, "rowspan", yc), Uc = (i) => vg(i).bind((p) => Hs(p, ["fixed", "relative", "empty"])), h1 = (i, m, p) => {
      Jr(i, "width", m + p);
    }, qs = (i) => gn(i) + "px", Gi = (i) => Lc(i) + "px", fl = (i) => h2(i, gn, ea) + "%", z3 = (i) => vg(i).exists((m) => Oh.test(m)), xd = (i) => vg(i).exists((m) => VS.test(m)), WS = (i) => vg(i).isNone(), jc = U(Oh), Fo = $c("col"), Ru = (i) => vg(i).getOrThunk(() => h0(i) + "px"), Nh = (i) => ta(i).getOrThunk(() => Ze(i) + "px"), Ks = (i) => he(zn.justColumns(i), (m) => se.from(m.element)), b2 = (i) => {
      const m = sl().browser, p = m.isChromium() || m.isFirefox();
      return Fo(i) ? p : !0;
    }, v2 = (i, m, p, y, E, D) => i.filter(y).fold(
      // Can't just read the width of a cell, so calculate.
      () => D(vi(p, m)),
      ($) => E($)
    ), qi = (i, m, p, y) => {
      const E = _h(i), D = zn.hasColumns(i) ? Ks(i) : E, $ = [se.some(er.edge(m))].concat(he(er.positions(E, m), (K) => K.map((ce) => ce.x))), z = oe(af);
      return he(D, (K, ce) => v2(K, ce, $, z, (Ce) => {
        if (b2(Ce))
          return p(Ce);
        {
          const Ge = rd(E[ce], Ye);
          return v2(Ge, ce, $, z, (kt) => y(se.some(Math.round(gn(kt)))), y);
        }
      }, y));
    }, p0 = (i) => i.map((m) => m + "px").getOr(""), Wc = (i, m) => qi(i, m, Ru, p0), V3 = (i, m, p) => qi(i, m, xc, (y) => y.fold(() => p.minCellWidth(), (E) => E / p.pixelWidth() * 100)), we = (i, m, p) => qi(i, m, h0, (y) => y.getOrThunk(p.minCellWidth)), Vl = (i, m, p, y) => {
      const E = d2(i), D = he(i.all, (z) => se.some(z.element)), $ = [se.some(g1.edge(m))].concat(he(g1.positions(E, m), (z) => z.map((K) => K.y)));
      return he(D, (z, K) => v2(z, K, $, X, p, y));
    }, p1 = (i, m) => Vl(i, m, Ze, (p) => p.getOrThunk(cf)), Vs = (i, m) => Vl(i, m, Nh, p0), Sc = (i, m) => () => ln(i) ? m(i) : parseFloat(al(i, "width").getOr("0")), zr = (i) => {
      const m = Sc(i, gn), p = U(0);
      return {
        width: m,
        pixelWidth: m,
        getWidths: (E, D) => we(E, i, D),
        getCellDelta: p,
        singleColumnWidth: U([0]),
        minCellWidth: p,
        setElementWidth: Xe,
        adjustTableWidth: Xe,
        isRelative: !0,
        label: "none"
      };
    }, cs = (i) => {
      const m = Sc(i, (K) => parseFloat(fl(K))), p = Sc(i, gn);
      return {
        width: m,
        pixelWidth: p,
        getWidths: (K, ce) => V3(K, i, ce),
        getCellDelta: (K) => K / p() * 100,
        singleColumnWidth: (K, ce) => [100 - K],
        minCellWidth: () => wr() / p() * 100,
        setElementWidth: US,
        adjustTableWidth: (K) => {
          const ce = m(), Ce = K / 100 * ce, Ge = ce + Ce;
          US(i, Ge);
        },
        isRelative: !0,
        label: "percent"
      };
    }, ZS = (i) => {
      const m = Sc(i, gn);
      return {
        width: m,
        pixelWidth: m,
        getWidths: ($, z) => we($, i, z),
        getCellDelta: Ye,
        singleColumnWidth: ($, z) => [Math.max(wr(), $ + z) - $],
        minCellWidth: wr,
        setElementWidth: bg,
        adjustTableWidth: ($) => {
          const z = m() + $;
          bg(i, z);
        },
        isRelative: !1,
        label: "pixel"
      };
    }, df = (i, m) => jc().exec(m) !== null ? cs(i) : ZS(i), Mh = {
      getTableSize: (i) => vg(i).fold(() => zr(i), (p) => df(i, p)),
      pixelSize: ZS,
      percentageSize: cs,
      noneSize: zr
    }, b1 = (i, m, p, y) => {
      p === y ? Oo(i, m) : gr(i, m, p);
    }, y2 = (i, m, p) => {
      We(xa(i, m)).fold(() => Is(i, p), (y) => li(y, p));
    }, C2 = (i, m) => {
      const p = Ls(i, m).getOrThunk(() => {
        const y = vt.fromTag(m, og(i).dom);
        return m === "thead" ? y2(i, "caption,colgroup", y) : m === "colgroup" ? y2(i, "caption", y) : Eo(i, y), y;
      });
      return tc(p), p;
    }, ff = (i, m) => {
      const p = [], y = [], E = (wt) => he(wt, (Gt) => {
        Gt.isNew && p.push(Gt.element);
        const Fe = Gt.element;
        return tc(Fe), ue(Gt.cells, (qe) => {
          qe.isNew && y.push(qe.element), b1(qe.element, "colspan", qe.colspan, 1), b1(qe.element, "rowspan", qe.rowspan, 1), Eo(Fe, qe.element);
        }), Fe;
      }), D = (wt) => oo(wt, (Gt) => he(Gt.cells, (Fe) => (b1(Fe.element, "span", Fe.colspan, 1), Fe.element))), $ = (wt, Gt) => {
        const Fe = C2(i, Gt), dn = (Gt === "colgroup" ? D : E)(wt);
        Ml(Fe, dn);
      }, z = (wt) => {
        Ls(i, wt).each(Xr);
      }, K = (wt, Gt) => {
        wt.length > 0 ? $(wt, Gt) : z(Gt);
      }, ce = [], Ce = [], Ge = [], kt = [];
      return ue(m, (wt) => {
        switch (wt.section) {
          case "thead":
            ce.push(wt);
            break;
          case "tbody":
            Ce.push(wt);
            break;
          case "tfoot":
            Ge.push(wt);
            break;
          case "colgroup":
            kt.push(wt);
            break;
        }
      }), K(kt, "colgroup"), K(ce, "thead"), K(Ce, "tbody"), K(Ge, "tfoot"), {
        newRows: p,
        newCells: y
      };
    }, Ph = (i) => he(i, (m) => {
      const p = Bl(m.element);
      return ue(m.cells, (y) => {
        const E = Ir(y.element);
        b1(E, "colspan", y.colspan, 1), b1(E, "rowspan", y.rowspan, 1), Eo(p, E);
      }), p;
    }), GS = (i, m) => he(i, (p) => hn(p, m)), x2 = (i, m) => i[m], U3 = (i, m) => {
      if (i.length === 0)
        return 0;
      const p = i[0];
      return ro(i, (E) => !m(p.element, E.element)).getOr(i.length);
    }, Fa = (i, m, p, y) => {
      const E = x2(i, m), D = E.section === "colgroup", $ = U3(E.cells.slice(p), y), z = D ? 1 : U3(GS(i.slice(m), p), y);
      return {
        colspan: $,
        rowspan: z
      };
    }, gl = (i, m) => {
      const p = he(i, (E) => he(E.cells, jt)), y = (E, D, $, z) => {
        for (let K = E; K < E + $; K++)
          for (let ce = D; ce < D + z; ce++)
            p[K][ce] = !0;
      };
      return he(i, (E, D) => {
        const $ = oo(E.cells, (z, K) => {
          if (p[D][K] === !1) {
            const ce = Fa(i, D, K, m);
            return y(D, K, ce.rowspan, ce.colspan), [Xs(z.element, ce.rowspan, ce.colspan, z.isNew)];
          } else
            return [];
        });
        return $a(E.element, $, E.section, E.isNew);
      });
    }, ir = (i, m, p) => {
      const y = [];
      ue(i.colgroups, (E) => {
        const D = [];
        for (let $ = 0; $ < i.grid.columns; $++) {
          const z = zn.getColumnAt(i, $).map((K) => Pr(K.element, p, !1)).getOrThunk(() => Pr(m.colGap(), !0, !1));
          D.push(z);
        }
        y.push(tl(E.element, D, "colgroup", p));
      });
      for (let E = 0; E < i.grid.rows; E++) {
        const D = [];
        for (let K = 0; K < i.grid.columns; K++) {
          const ce = zn.getAt(i, E, K).map((Ce) => Pr(Ce.element, p, Ce.isLocked)).getOrThunk(() => Pr(m.gap(), !0, !1));
          D.push(ce);
        }
        const $ = i.all[E], z = tl($.element, D, $.section, p);
        y.push(z);
      }
      return y;
    }, gf = (i, m) => ir(i, m, !1), v1 = (i) => gl(i, zo), Zc = (i, m) => st(i.all, (p) => P(p.cells, (y) => zo(m, y.element))), Bh = (i, m, p) => {
      const y = he(m.selection, (D) => a2(D).bind(($) => Zc(i, $)).filter(p)), E = Zo(y);
      return yu(E.length > 0, E);
    }, Nr = (i, m, p, y, E, D, $, z, K) => {
      const ce = zn.fromTable(D), Ce = se.from(K?.section).getOrThunk(im.fallback);
      return m(ce, $).map((kt) => {
        const wt = gf(ce, z), Gt = i(wt, kt, zo, E(z), Ce), Fe = vc(Gt.grid), qe = v1(Gt.grid);
        return {
          info: kt,
          grid: qe,
          cursor: Gt.cursor,
          lockedColumns: Fe
        };
      }).bind((kt) => {
        const wt = ff(D, kt.grid), Gt = se.from(K?.sizing).getOrThunk(() => Mh.getTableSize(D)), Fe = se.from(K?.resize).getOrThunk(IS);
        return p(D, kt.grid, kt.info, { sizing: Gt, resize: Fe, section: Ce }), y(D), Oo(D, zc), kt.lockedColumns.length > 0 && gr(D, zc, kt.lockedColumns.join(",")), se.some({
          cursor: kt.cursor,
          newRows: wt.newRows,
          newCells: wt.newCells
        });
      });
    }, b0 = (i, m) => a2(m.element).bind((p) => Zc(i, p).map((y) => ({
      ...y,
      generators: m.generators,
      clipboard: m.clipboard
    }))), Ul = (i, m) => Bh(i, m, X).map((p) => ({
      cells: p,
      generators: m.generators,
      clipboard: m.clipboard
    })), Ki = (i, m) => m.mergable, S2 = (i, m) => m.unmergable, na = (i, m) => Bh(i, m, X), $h = (i, m) => Bh(i, m, (p) => !p.isLocked), Nu = (i, m) => Zc(i, m).exists((p) => !p.isLocked), yg = (i, m) => ao(m, (p) => Nu(i, p)), Cg = (i, m) => Ki(i, m).filter((p) => yg(i, p.cells)), j3 = (i, m) => S2(i, m).filter((p) => yg(i, p)), um = {
      ...Gr.generate([
        { none: [] },
        { only: ["index"] },
        { left: ["index", "next"] },
        { middle: ["prev", "index", "next"] },
        { right: ["prev", "index"] }
      ])
    }, y1 = (i, m) => i.length === 0 ? um.none() : i.length === 1 ? um.only(0) : m === 0 ? um.left(0, 1) : m === i.length - 1 ? um.right(m - 1, m) : m > 0 && m < i.length - 1 ? um.middle(m - 1, m, m + 1) : um.none(), ls = (i, m, p, y, E) => {
      const D = i.slice(0), $ = y1(i, m), z = U(he(D, U(0))), K = (kt) => y.singleColumnWidth(D[kt], p), ce = (kt, wt) => E.calcLeftEdgeDeltas(D, kt, wt, p, y.minCellWidth(), y.isRelative), Ce = (kt, wt, Gt) => E.calcMiddleDeltas(D, kt, wt, Gt, p, y.minCellWidth(), y.isRelative), Ge = (kt, wt) => E.calcRightEdgeDeltas(D, kt, wt, p, y.minCellWidth(), y.isRelative);
      return $.fold(z, K, ce, Ce, Ge);
    }, qS = (i, m, p) => {
      let y = 0;
      for (let E = i; E < m; E++)
        y += p[E] !== void 0 ? p[E] : 0;
      return y;
    }, dm = (i, m) => {
      const p = zn.justCells(i);
      return he(p, (y) => {
        const E = qS(y.column, y.column + y.colspan, m);
        return {
          element: y.element,
          width: E,
          colspan: y.colspan
        };
      });
    }, Ih = (i, m) => {
      const p = zn.justColumns(i);
      return he(p, (y, E) => ({
        element: y.element,
        width: m[E],
        colspan: y.colspan
      }));
    }, y0 = (i, m) => he(i.all, (p, y) => ({
      element: p.element,
      height: m[y]
    })), mm = (i) => Fn(i, (m, p) => m + p, 0), wa = (i, m) => zn.hasColumns(i) ? Ih(i, m) : dm(i, m), xg = (i, m, p) => {
      const y = wa(i, m);
      ue(y, (E) => {
        p.setElementWidth(E.element, E.width);
      });
    }, Fh = (i, m, p, y, E) => {
      const D = zn.fromTable(i), $ = E.getCellDelta(m), z = E.getWidths(D, E), K = p === D.grid.columns - 1, ce = y.clampTableDelta(z, p, $, E.minCellWidth(), K), Ce = ls(z, p, ce, E, y), Ge = he(Ce, (kt, wt) => kt + z[wt]);
      xg(D, Ge, E), y.resizeTable(E.adjustTableWidth, ce, K);
    }, C0 = (i, m, p) => {
      const y = zn.fromTable(i), E = p1(y, i), D = he(E, (K, ce) => p === ce ? Math.max(m + K, cf()) : K), $ = y0(y, D);
      ue($, (K) => {
        Cd(K.element, K.height);
      }), ue(zn.justCells(y), (K) => {
        jS(K.element);
      });
      const z = mm(D);
      Cd(i, z);
    }, x0 = (i, m, p, y, E) => {
      const D = zn.generate(m), $ = y.getWidths(D, y), z = y.pixelWidth(), { newSizes: K, delta: ce } = E.calcRedestributedWidths($, z, p.pixelDelta, y.isRelative);
      xg(D, K, y), y.adjustTableWidth(ce);
    }, S0 = (i, m, p, y) => {
      const E = zn.generate(m), D = y.getWidths(E, y);
      xg(E, D, y);
    }, C1 = (i, m) => {
      af(i) || Uc(i).each((y) => {
        const E = y.value / 2;
        h1(i, E, y.unit), h1(m, E, y.unit);
      });
    }, KS = (i, m, p) => {
      const y = am(i, m, 1);
      p === 1 || y <= 1 ? Oo(i, m) : gr(i, m, Math.min(p, y));
    }, w2 = (i, m) => (p) => {
      const y = p.column + p.colspan - 1, E = p.column;
      return y >= i && E < m;
    }, E2 = (i, m, p) => {
      if (zn.hasColumns(i)) {
        const y = fn(zn.justColumns(i), w2(m, p)), E = he(y, ($) => {
          const z = Ir($.element);
          return KS(z, "span", p - m), z;
        }), D = vt.fromTag("colgroup");
        return Ml(D, E), [D];
      } else
        return [];
    }, Lh = (i, m, p) => he(i.all, (y) => {
      const E = fn(y.cells, w2(m, p)), D = he(E, (z) => {
        const K = Ir(z.element);
        return KS(K, "colspan", p - m), K;
      }), $ = vt.fromTag("tr");
      return Ml($, D), $;
    }), Mu = (i, m) => {
      const p = zn.fromTable(i);
      return $h(p, m).map((E) => {
        const D = E[E.length - 1], $ = E[0].column, z = D.column + D.colspan, K = E2(p, $, z), ce = Lh(p, $, z);
        return [...K, ...ce];
      });
    }, Ci = (i, m, p) => {
      const y = zn.fromTable(i);
      return na(y, m).bind((D) => {
        const $ = ir(y, p, !1), K = _s($).rows.slice(D[0].row, D[D.length - 1].row + D[D.length - 1].rowspan), ce = oo(K, (Ge) => {
          const kt = fn(Ge.cells, (wt) => !wt.isLocked);
          return kt.length > 0 ? [{ ...Ge, cells: kt }] : [];
        }), Ce = v1(ce);
        return yu(Ce.length > 0, Ce);
      }).map((D) => Ph(D));
    }, fm = (i, m, p, y, E, D) => ({
      minRow: i,
      minCol: m,
      maxRow: p,
      maxCol: y,
      allCells: E,
      selectedCells: D
    }), YS = (i, m) => {
      const p = i.grid.columns;
      let E = i.grid.rows, D = p, $ = 0, z = 0;
      const K = [], ce = [];
      return qn(i.access, (Ce) => {
        if (K.push(Ce), m(Ce)) {
          ce.push(Ce);
          const Ge = Ce.row, kt = Ge + Ce.rowspan - 1, wt = Ce.column, Gt = wt + Ce.colspan - 1;
          Ge < E ? E = Ge : kt > $ && ($ = kt), wt < D ? D = wt : Gt > z && (z = Gt);
        }
      }), fm(E, D, $, z, K, ce);
    }, w0 = (i, m, p) => {
      const y = i[p].element, E = vt.fromTag("td");
      Eo(E, vt.fromTag("br")), (m ? Eo : Is)(y, E);
    }, T2 = (i, m, p, y) => {
      const E = fn(i, (z) => z.section !== "colgroup"), D = m.grid.columns, $ = m.grid.rows;
      for (let z = 0; z < $; z++) {
        let K = !1;
        for (let ce = 0; ce < D; ce++)
          z < p.minRow || z > p.maxRow || ce < p.minCol || ce > p.maxCol || (zn.getAt(m, z, ce).filter(y).isNone() ? w0(E, K, z) : K = !0);
      }
    }, XS = (i, m, p, y) => {
      qn(p.columns, ($) => {
        ($.column < m.minCol || $.column > m.maxCol) && Xr($.element);
      });
      const E = fn(cm(i, "tr"), ($) => (
        // there is no sugar method for this, and Traverse.children() does too much processing
        $.dom.childElementCount === 0
      ));
      ue(E, Xr), (m.minCol === m.maxCol || m.minRow === m.maxRow) && ue(cm(i, "th,td"), ($) => {
        Oo($, "rowspan"), Oo($, "colspan");
      }), Oo(i, zc), Oo(i, "data-snooker-col-series"), Mh.getTableSize(i).adjustTableWidth(y);
    }, k2 = (i, m, p, y) => {
      if (y.minCol === 0 && m.grid.columns === y.maxCol + 1)
        return 0;
      const E = we(m, i, p), D = ye(E, (ce, Ce) => ce + Ce, 0), K = ye(E.slice(y.minCol, y.maxCol + 1), (ce, Ce) => ce + Ce, 0) / D * p.pixelWidth() - p.pixelWidth();
      return p.getCellDelta(K);
    }, E0 = (i, m) => {
      const p = (kt) => pa(kt.element, m), y = Ir(i), E = m0(y), D = Mh.getTableSize(i), $ = zn.generate(E), z = YS($, p), K = "th:not(" + m + "),td:not(" + m + ")", ce = r2(y, "th,td", (kt) => pa(kt, K));
      ue(ce, Xr), T2(E, $, z, p);
      const Ce = zn.fromTable(i), Ge = k2(i, Ce, D, z);
      return XS(y, z, $, Ge), y;
    }, T0 = $c("col"), k0 = $c("colgroup"), Pu = (i) => Qs(i) === "tr" || k0(i), x1 = (i) => {
      const m = am(i, "colspan", 1), p = am(i, "rowspan", 1);
      return {
        element: i,
        colspan: m,
        rowspan: p
      };
    }, Hh = (i, m = x1) => {
      const p = (z) => T0(z.element) ? i.col(z) : i.cell(z), y = (z) => k0(z.element) ? i.colgroup(z) : i.row(z), E = (z) => {
        if (Pu(z))
          return y({ element: z });
        {
          const K = z, ce = p(m(K));
          return D = se.some({ item: K, replacement: ce }), ce;
        }
      };
      let D = se.none();
      return {
        getOrInit: (z, K) => D.fold(() => E(z), (ce) => K(z, ce.item) ? ce.replacement : E(z))
      };
    }, Sg = (i) => (m) => {
      const p = [], y = ($, z) => P(p, (K) => z(K.item, $)), E = ($) => {
        const z = i === "td" ? { scope: null } : {}, K = m.replace($, i, z);
        return p.push({
          item: $,
          sub: K
        }), K;
      };
      return {
        replaceOrInit: ($, z) => {
          if (Pu($) || T0($))
            return $;
          {
            const K = $;
            return y(K, z).fold(() => E(K), (ce) => z($, ce.item) ? ce.sub : E(K));
          }
        }
      };
    }, QS = (i) => ya(i, "scope").map(
      // Attribute can be col, colgroup, row, and rowgroup.
      // As col and colgroup are to be treated as if they are the same, lob off everything after the first three characters and there is no difference.
      (m) => m.substr(0, 3)
    ), wc = {
      modification: Hh,
      transform: Sg,
      merging: (i) => ({
        unmerge: (y) => {
          const E = QS(y);
          return E.each((D) => gr(y, "scope", D)), () => {
            const D = i.cell({
              element: y,
              colspan: 1,
              rowspan: 1
            });
            return ui(D, "width"), ui(y, "width"), E.each(($) => gr(D, "scope", $)), D;
          };
        },
        merge: (y) => {
          const E = () => {
            const D = Zo(he(y, QS));
            if (D.length === 0)
              return se.none();
            {
              const $ = D[0], z = ["row", "col"];
              return ot(D, (ce) => ce !== $ && No(z, ce)) ? se.none() : se.from($);
            }
          };
          return ui(y[0], "width"), E().fold(() => Oo(y[0], "scope"), (D) => gr(y[0], "scope", D + "group")), U(y[0]);
        }
      })
    }, W3 = (i, m) => {
      const p = i.slice(0, m[m.length - 1].row + 1), y = v1(p);
      return oo(y, (E) => {
        const D = E.cells.slice(0, m[m.length - 1].column + 1);
        return he(D, ($) => $.element);
      });
    }, A2 = (i, m) => {
      const p = i.slice(m[0].row + m[0].rowspan - 1, i.length), y = v1(p);
      return oo(y, (E) => {
        const D = E.cells.slice(m[0].column + m[0].colspan - 1, E.cells.length);
        return he(D, ($) => $.element);
      });
    }, _2 = (i, m, p) => {
      const y = zn.fromTable(i);
      return na(y, m).map((D) => {
        const $ = ir(y, p, !1), { rows: z } = _s($), K = W3(z, D), ce = A2(z, D);
        return {
          upOrLeftCells: K,
          downOrRightCells: ce
        };
      });
    }, ew = {
      only: (i, m) => {
        const p = Yy(i) ? Km(i) : i;
        return {
          parent: U(p),
          view: U(i),
          dragContainer: U(p),
          origin: U(Cs(0, 0)),
          isResizable: m
        };
      },
      detached: (i, m, p) => {
        const y = () => Kn(m);
        return {
          parent: U(m),
          view: U(i),
          dragContainer: U(m),
          origin: y,
          isResizable: p
        };
      },
      body: (i, m) => ({
        parent: U(i),
        view: U(i),
        dragContainer: U(i),
        origin: () => Kn(i),
        isResizable: m
      })
    }, S1 = Gr.generate([
      { invalid: ["raw"] },
      { pixels: ["value"] },
      { percent: ["value"] }
    ]), O2 = (i, m, p) => {
      const y = p.substring(0, p.length - i.length), E = parseFloat(y);
      return y === E.toString() ? m(E) : S1.invalid(p);
    }, lo = {
      ...S1,
      from: (i) => ad(i, "%") ? O2("%", S1.percent, i) : ad(i, "px") ? O2("px", S1.pixels, i) : S1.invalid(i)
    }, _0 = (i, m) => he(i, (p) => lo.from(p).fold(() => p, (E) => E / m * 100 + "%", (E) => E + "%")), yo = (i, m, p) => {
      const y = p / m;
      return he(i, (E) => lo.from(E).fold(() => E, ($) => $ * y + "px", ($) => $ / 100 * p + "px"));
    }, hl = (i, m) => {
      const p = i.fold(() => U(""), (y) => {
        const E = y / m;
        return U(E + "px");
      }, () => {
        const y = 100 / m;
        return U(y + "%");
      });
      return jo(m, p);
    }, hf = (i, m, p) => i.fold(() => m, (y) => yo(m, p, y), (y) => _0(m, p)), w1 = (i, m, p) => {
      const y = lo.from(p), E = ao(i, (D) => D === "0px") ? hl(y, i.length) : hf(y, i, m);
      return Z3(E);
    }, Do = (i, m) => i.length === 0 ? m : Fn(i, (p, y) => lo.from(y).fold(U(0), Ye, Ye) + p, 0), nw = (i, m) => {
      const p = Math.floor(i);
      return { value: p + m, remainder: i - p };
    }, ow = (i, m) => lo.from(i).fold(U(i), (p) => p + m + "px", (p) => p + m + "%"), Z3 = (i) => {
      if (i.length === 0)
        return i;
      const m = Fn(i, (y, E) => {
        const D = lo.from(E).fold(() => ({ value: E, remainder: 0 }), ($) => nw($, "px"), ($) => ({ value: $ + "%", remainder: 0 }));
        return {
          output: [D.value].concat(y.output),
          remainder: y.remainder + D.remainder
        };
      }, { output: [], remainder: 0 }), p = m.output;
      return p.slice(0, p.length - 1).concat([ow(p[p.length - 1], Math.round(m.remainder))]);
    }, Eg = lo.from, E1 = (i, m, p) => {
      ue(m, (y) => {
        const E = i.slice(y.column, y.colspan + y.column), D = Do(E, wr());
        Jr(y.element, "width", D + p);
      });
    }, sw = (i, m, p) => {
      ue(m, (y, E) => {
        const D = Do([i[E]], wr());
        Jr(y.element, "width", D + p);
      });
    }, G3 = (i, m, p) => {
      ue(p, (y) => {
        ui(y.element, "height");
      }), ue(m, (y, E) => {
        Jr(y.element, "height", i[E]);
      });
    }, q3 = (i) => Eg(i).fold(U("px"), U("px"), U("%")), rw = (i, m, p) => {
      const y = zn.fromTable(i), E = y.all, D = zn.justCells(y), $ = zn.justColumns(y);
      m.each((z) => {
        const K = q3(z), ce = gn(i), Ce = Wc(y, i), Ge = w1(Ce, ce, z);
        zn.hasColumns(y) ? sw(Ge, $, K) : E1(Ge, D, K), Jr(i, "width", z);
      }), p.each((z) => {
        const K = Lc(i), ce = Vs(y, i), Ce = w1(ce, K, z);
        G3(Ce, E, D), Jr(i, "height", z);
      });
    }, aw = z3, K3 = xd, Y3 = WS;
    var Tg = [
      "body",
      "p",
      "div",
      "article",
      "aside",
      "figcaption",
      "figure",
      "footer",
      "header",
      "nav",
      "section",
      "ol",
      "ul",
      "li",
      "table",
      "thead",
      "tbody",
      "tfoot",
      "caption",
      "tr",
      "td",
      "th",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "blockquote",
      "pre",
      "address"
    ], pl = () => {
      const i = (ce) => vt.fromDom(ce.dom.cloneNode(!1)), m = (ce) => Nl(ce).dom, p = (ce) => Zs(ce) ? Qs(ce) === "body" ? !0 : No(Tg, Qs(ce)) : !1, y = (ce) => Zs(ce) ? No(["br", "img", "hr", "input"], Qs(ce)) : !1, E = (ce) => Zs(ce) && Fc(ce, "contenteditable") === "false", D = (ce, Ce) => ce.dom.compareDocumentPosition(Ce.dom), $ = (ce, Ce) => {
        const Ge = rl(ce);
        ii(Ce, Ge);
      }, z = (ce) => {
        const Ce = Qs(ce);
        return No([
          "script",
          "noscript",
          "iframe",
          "noframes",
          "noembed",
          "title",
          "style",
          "textarea",
          "xmp"
        ], Ce);
      }, K = (ce) => Zs(ce) ? ya(ce, "lang") : se.none();
      return {
        up: U({
          selector: pc,
          closest: rr,
          predicate: Mo,
          all: dd
        }),
        down: U({
          selector: Ui,
          predicate: vd
        }),
        styles: U({
          get: gd,
          getRaw: al,
          set: Jr,
          remove: ui
        }),
        attrs: U({
          get: Fc,
          set: gr,
          remove: Oo,
          copyTo: $
        }),
        insert: U({
          before: ci,
          after: li,
          afterAll: fr,
          append: Eo,
          appendAll: Ml,
          prepend: Is,
          wrap: Qy
        }),
        remove: U({
          unwrap: $r,
          remove: Xr
        }),
        create: U({
          nu: vt.fromTag,
          clone: i,
          text: vt.fromText
        }),
        query: U({
          comparePosition: D,
          prevSibling: jp,
          nextSibling: Ym
        }),
        property: U({
          children: va,
          name: Qs,
          parent: te,
          document: m,
          isText: sm,
          isComment: PS,
          isElement: Zs,
          isSpecial: z,
          getLanguage: K,
          getText: Vi,
          setText: ku,
          isBoundary: p,
          isEmptyTag: y,
          isNonEditable: E
        }),
        eq: zo,
        is: B
      };
    };
    const Vr = (i, m) => ({
      item: i,
      mode: m
    }), pf = (i, m, p, y = Yi) => i.property().parent(m).map((E) => Vr(E, y)), Yi = (i, m, p, y = Sd) => p.sibling(i, m).map((E) => Vr(E, y)), Sd = (i, m, p, y = Sd) => {
      const E = i.property().children(m);
      return p.first(E).map(($) => Vr($, y));
    }, Vh = [
      { current: pf, next: Yi, fallback: se.none() },
      { current: Yi, next: Sd, fallback: se.some(pf) },
      { current: Sd, next: Sd, fallback: se.some(Yi) }
    ], Uh = (i, m, p, y, E = Vh) => P(E, ($) => $.current === p).bind(($) => $.current(i, m, y, $.next).orThunk(() => $.fallback.bind((z) => Uh(i, m, z, y)))), D0 = {
      left: () => ({
        sibling: (p, y) => p.query().prevSibling(y),
        first: (p) => p.length > 0 ? se.some(p[p.length - 1]) : se.none()
      }),
      right: () => ({
        sibling: (p, y) => p.query().nextSibling(y),
        first: (p) => p.length > 0 ? se.some(p[0]) : se.none()
      })
    }, D2 = (i, m, p, y, E, D) => Uh(i, m, y, E).bind((z) => D(z.item) ? se.none() : p(z.item) ? se.some(z.item) : D2(i, z.item, p, z.mode, E, D)), R2 = (i, m, p, y) => D2(i, m, p, Yi, D0.left(), y), T1 = (i, m, p, y) => D2(i, m, p, Yi, D0.right(), y), gm = (i, m) => ({
      element: i,
      offset: m
    }), R0 = (i, m, p) => i.property().isText(m) && i.property().getText(m).trim().length === 0 || i.property().isComment(m) ? p(m).bind((y) => R0(i, y, p).orThunk(() => se.some(y))) : se.none(), k1 = (i, m) => i.property().isText(m) ? i.property().getText(m).length : i.property().children(m).length, N0 = (i, m) => {
      const p = R0(i, m, i.query().prevSibling).getOr(m);
      if (i.property().isText(p))
        return gm(p, k1(i, p));
      const y = i.property().children(p);
      return y.length > 0 ? N0(i, y[y.length - 1]) : gm(p, k1(i, p));
    }, cw = N0, wd = pl(), M0 = (i) => cw(wd, i), lw = (i) => (m) => i.property().children(m).length === 0, Q3 = (i, m, p) => iw(i, m, lw(i), p), J3 = (i, m, p) => N2(i, m, lw(i), p), iw = R2, N2 = T1, Ed = pl(), uw = (i, m) => Q3(Ed, i, m), Xi = (i, m) => J3(Ed, i, m), nc = (i, m, p) => iw(Ed, i, m, p), xi = (i, m, p) => N2(Ed, i, m, p), Ec = [
      "body",
      "p",
      "div",
      "article",
      "aside",
      "figcaption",
      "figure",
      "footer",
      "header",
      "nav",
      "section",
      "ol",
      "ul",
      // --- NOTE, TagBoundaries has li here. That means universe.isBoundary => true for li tags.
      "table",
      "thead",
      "tfoot",
      "tbody",
      "caption",
      "tr",
      "td",
      "th",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "blockquote",
      "pre",
      "address"
    ], P0 = (i, m) => {
      const p = i.property().name(m);
      return No(["ol", "ul"], p);
    }, kg = (i, m) => {
      const p = i.property().name(m);
      return No(Ec, p);
    }, B0 = (i, m) => No(["br", "img", "hr", "input"], i.property().name(m)), M2 = (i, m, p, y) => {
      const E = p[0], D = p.slice(1);
      return y(i, m, E, D);
    }, ek = (i, m, p) => p.length > 0 ? M2(i, m, p, bf) : se.none(), bf = (i, m, p, y) => {
      const E = m(i, p);
      return Fn(y, (D, $) => {
        const z = m(i, $);
        return vf(i, D, z);
      }, E);
    }, vf = (i, m, p) => m.bind((y) => p.filter(Ot(i.eq, y))), P2 = (i, m) => Ot(i.eq, m), Ur = (i, m, p, y = jt) => {
      const E = [m].concat(i.up().all(m)), D = [p].concat(i.up().all(p)), $ = (Ce) => ro(Ce, y).fold(() => Ce, (kt) => Ce.slice(0, kt + 1)), z = $(E), K = $(D), ce = P(z, (Ce) => ot(K, P2(i, Ce)));
      return {
        firstpath: z,
        secondpath: K,
        shared: ce
      };
    }, A1 = ek, Gc = Ur, $0 = pl(), Jo = (i, m) => A1($0, (p, y) => i(y), m), Bu = (i, m, p) => Gc($0, i, m, p), hm = pl(), $u = (i) => kg(hm, i), jl = (i) => P0(hm, i), I0 = (i) => B0(hm, i), dw = (i) => {
      const m = $c("br"), p = (K) => ao(K, (ce) => m(ce) || sm(ce) && Vi(ce).trim().length === 0), y = (K) => Qs(K) === "li" || Mo(K, jl).isSome(), E = (K) => Ym(K).map((ce) => $u(ce) ? !0 : I0(ce) ? Qs(ce) !== "img" : !1).getOr(!1), D = (K) => ar(K).bind((ce) => {
        const Ce = E(ce);
        return te(ce).map((Ge) => Ce === !0 || y(Ge) || m(ce) || $u(Ge) && !zo(K, Ge) ? [] : [vt.fromTag("br")]);
      }).getOr([]), z = (() => {
        const K = oo(i, (ce) => {
          const Ce = va(ce);
          return p(Ce) ? [] : Ce.concat(D(ce));
        });
        return K.length === 0 ? [vt.fromTag("br")] : K;
      })();
      tc(i[0]), Ml(i[0], z);
    }, pm = (i) => {
      Oo(i, "width"), Oo(i, "height");
    }, Ag = (i) => {
      const m = fl(i);
      rw(i, se.some(m), se.none()), pm(i);
    }, B2 = (i) => {
      const m = qs(i);
      rw(i, se.some(m), se.none()), pm(i);
    }, bl = (i) => {
      const m = Gi(i);
      rw(i, se.none(), se.some(m)), pm(i);
    }, yf = (i) => {
      ui(i, "width");
      const m = i0(i), p = m.length > 0 ? m : lf(i);
      ue(p, (y) => {
        ui(y, "width"), pm(y);
      }), pm(i);
    }, Ea = {
      scope: [
        "row",
        "col"
      ]
    }, Qi = (i) => () => {
      const m = vt.fromTag("td", i.dom);
      return Eo(m, vt.fromTag("br", i.dom)), m;
    }, F0 = (i) => () => vt.fromTag("col", i.dom), _g = (i) => () => vt.fromTag("colgroup", i.dom), Cf = (i) => () => vt.fromTag("tr", i.dom), _1 = (i, m, p) => {
      const y = fd(i, m);
      return qn(p, (E, D) => {
        E === null ? Oo(y, D) : gr(y, D, E);
      }), y;
    }, $2 = (i) => i, L0 = (i, m, p) => of(i).map((E) => {
      const D = p.join(","), $ = Po(E, D, (z) => zo(z, i));
      return Fn($, (z, K) => {
        const ce = Bl(K);
        return Eo(z, ce), ce;
      }, m);
    }).getOr(m), Og = (i, m) => {
      qn(Ea, (p, y) => ya(i, y).filter((E) => No(p, E)).each((E) => gr(m, y, E)));
    }, xf = (i, m, p) => {
      const y = ($, z) => {
        ag($.element, z), ui(z, "height"), $.colspan !== 1 && ui(z, "width");
      }, E = ($) => {
        const z = vt.fromTag(Qs($.element), m.dom), K = p.getOr(["strong", "em", "b", "i", "span", "font", "h1", "h2", "h3", "h4", "h5", "h6", "p", "div"]), ce = K.length > 0 ? L0($.element, z, K) : z;
        return Eo(ce, vt.fromTag("br")), y($, z), Og($.element, z), i($.element, z), z;
      };
      return {
        col: ($) => {
          const z = vt.fromTag(Qs($.element), m.dom);
          return y($, z), i($.element, z), z;
        },
        colgroup: _g(m),
        row: Cf(m),
        cell: E,
        replace: _1,
        colGap: F0(m),
        gap: Qi(m)
      };
    }, I2 = (i) => ({
      col: F0(i),
      colgroup: _g(i),
      row: Cf(i),
      cell: Qi(i),
      replace: $2,
      colGap: F0(i),
      gap: Qi(i)
    }), O1 = (i) => zn.fromTable(i).grid, F2 = (i, m, p, y) => {
      const E = _s(i).rows;
      if (E.length === 0)
        return i;
      for (let D = m.startRow; D <= m.finishRow; D++)
        for (let $ = m.startCol; $ <= m.finishCol; $++) {
          const z = E[D], K = hn(z, $).isLocked;
          ei(z, $, Pr(y(), !1, K));
        }
      return i;
    }, mw = (i, m, p, y) => {
      const E = _s(i).rows;
      let D = !0;
      for (let $ = 0; $ < E.length; $++)
        for (let z = 0; z < Kr(E[0]); z++) {
          const K = E[$], ce = hn(K, z), Ce = ce.element, Ge = p(Ce, m);
          Ge && !D ? ei(K, z, Pr(y(), !0, ce.isLocked)) : Ge && (D = !1);
        }
      return i;
    }, jr = (i, m) => ye(i, (p, y) => ot(p, (E) => m(E.element, y.element)) ? p : p.concat([y]), []), Sf = (i, m, p, y) => (m > 0 && m < i[0].cells.length && ue(i, (E) => {
      const D = E.cells[m - 1];
      let $ = 0;
      const z = y();
      for (; E.cells.length > m + $ && p(D.element, E.cells[m + $].element); )
        ei(E, m + $, Pr(z, !0, E.cells[m + $].isLocked)), $++;
    }), i), wf = (i, m, p, y) => {
      const E = _s(i).rows;
      if (m > 0 && m < E.length) {
        const D = E[m - 1].cells, $ = jr(D, p);
        ue($, (z) => {
          let K = se.none();
          for (let ce = m; ce < E.length; ce++)
            for (let Ce = 0; Ce < Kr(E[0]); Ce++) {
              const Ge = E[ce], kt = hn(Ge, Ce);
              p(kt.element, z.element) && (K.isNone() && (K = se.some(y())), K.each((Gt) => {
                ei(Ge, Ce, Pr(Gt, !0, kt.isLocked));
              }));
            }
        });
      }
      return i;
    }, fw = (i, m, p) => {
      if (i.row >= m.length || i.column > Kr(m[0]))
        return ic.error("invalid start address out of table bounds, row: " + i.row + ", column: " + i.column);
      const y = m.slice(i.row), E = y[0].cells.slice(i.column), D = Kr(p[0]), $ = p.length;
      return ic.value({
        rowDelta: y.length - $,
        colDelta: E.length - D
      });
    }, H0 = (i, m) => {
      const p = Kr(i[0]), y = Kr(m[0]);
      return {
        rowDelta: 0,
        colDelta: p - y
      };
    }, L2 = (i, m) => {
      const p = i.length, y = m.length;
      return {
        rowDelta: p - y,
        colDelta: 0
      };
    }, D1 = (i, m, p, y) => {
      const E = m.section === "colgroup" ? p.col : p.cell;
      return jo(i, (D) => Pr(E(), !0, y(D)));
    }, z0 = (i, m, p, y) => {
      const E = i[i.length - 1];
      return i.concat(jo(m, () => {
        const D = E.section === "colgroup" ? p.colgroup : p.row, $ = em(E, D, Ye), z = D1($.cells.length, $, p, (K) => ds(y, K.toString()));
        return Zm($, z);
      }));
    }, gw = (i, m, p, y) => he(i, (E) => {
      const D = D1(m, E, p, jt);
      return Mc(E, y, D);
    }), tk = (i, m, p) => he(i, (y) => ye(p, (E, D) => {
      const $ = D1(1, y, m, X)[0];
      return _l(E, D, $);
    }, y)), R1 = (i, m, p) => {
      const y = m.colDelta < 0 ? gw : Ye, E = m.rowDelta < 0 ? z0 : Ye, D = vc(i), $ = Kr(i[0]), z = ot(D, (Ce) => Ce === $ - 1), K = y(i, Math.abs(m.colDelta), p, z ? $ - 1 : $), ce = vc(K);
      return E(K, Math.abs(m.rowDelta), p, Lt(ce, X));
    }, Mr = (i, m, p, y) => {
      const E = hn(i[m], p), D = Ot(y, E.element), $ = i[m];
      return i.length > 1 && Kr($) > 1 && // search left, if we're not on the left edge
      // search down, if we're not on the bottom edge
      (p > 0 && D(qr($, p - 1)) || // search right, if we're not on the right edge
      p < $.cells.length - 1 && D(qr($, p + 1)) || // search up, if we're not on the top edge
      m > 0 && D(qr(i[m - 1], p)) || m < i.length - 1 && D(qr(i[m + 1], p)));
    }, Er = (i, m, p, y, E, D) => {
      const $ = i.row, z = i.column, K = p.length, ce = Kr(p[0]), Ce = $ + K, Ge = z + ce + D.length, kt = Lt(D, X);
      for (let wt = $; wt < Ce; wt++) {
        let Gt = 0;
        for (let Fe = z; Fe < Ge; Fe++) {
          if (kt[Fe]) {
            Gt++;
            continue;
          }
          Mr(m, wt, Fe, E) && mw(m, qr(m[wt], Fe), E, y.cell);
          const qe = Fe - z - Gt, dn = hn(p[wt - $], qe), Bn = dn.element, Bt = y.replace(Bn);
          ei(m[wt], Fe, Pr(Bt, !0, dn.isLocked));
        }
      }
      return m;
    }, Ta = (i, m, p) => {
      const y = Kr(m[0]), E = _s(m).cols.length + i.row, D = jo(y - i.column, (z) => z + i.column), $ = P(D, (z) => ao(p, (K) => K !== z)).getOr(y - 1);
      return {
        row: E,
        column: $
      };
    }, ua = (i, m, p) => fn(p, (y) => y >= i.column && y <= Kr(m[0]) + i.column), Rs = (i, m, p, y, E) => {
      const D = vc(m), $ = Ta(i, m, D), z = _s(p).rows, K = ua($, z, D);
      return fw($, m, z).map((Ce) => {
        const Ge = {
          ...Ce,
          colDelta: Ce.colDelta - K.length
        }, kt = R1(m, Ge, y), wt = vc(kt), Gt = ua($, z, wt);
        return Er($, kt, z, y, E, Gt);
      });
    }, Tr = (i, m, p, y, E) => {
      Sf(m, i, E, y.cell);
      const D = L2(p, m), $ = R1(p, D, y), z = L2(m, $), K = R1(m, z, y);
      return he(K, (ce, Ce) => Mc(ce, i, $[Ce].cells));
    }, jh = (i, m, p, y, E) => {
      wf(m, i, E, y.cell);
      const D = vc(m), $ = H0(m, p), z = {
        ...$,
        colDelta: $.colDelta - D.length
      }, K = R1(m, z, y), { cols: ce, rows: Ce } = _s(K), Ge = vc(K), kt = H0(p, m), wt = {
        ...kt,
        colDelta: kt.colDelta + Ge.length
      }, Gt = tk(p, y, Ge), Fe = R1(Gt, wt, y);
      return [
        ...ce,
        ...Ce.slice(0, i),
        ...Fe,
        ...Ce.slice(i, Ce.length)
      ];
    }, H2 = (i, m, p, y) => em(i, (E) => y(E, p), m), z2 = (i, m, p, y, E) => {
      const { rows: D, cols: $ } = _s(i), z = D.slice(0, m), K = D.slice(m), ce = H2(D[p], (Ce, Ge) => m > 0 && m < D.length && y(qr(D[m - 1], Ge), qr(D[m], Ge)) ? hn(D[m], Ge) : Pr(E(Ce.element, y), !0, Ce.isLocked), y, E);
      return [
        ...$,
        ...z,
        ce,
        ...K
      ];
    }, hw = (i, m, p, y, E, D, $) => {
      if (p === "colgroup" || !y) {
        const z = hn(i, E);
        return Pr($(z.element, D), !0, !1);
      } else
        return hn(i, m);
    }, V0 = (i, m, p, y, E) => he(i, (D) => {
      const $ = m > 0 && m < Kr(D) && y(qr(D, m - 1), qr(D, m)), z = hw(D, m, D.section, $, p, y, E);
      return _l(D, m, z);
    }), V2 = (i, m) => oo(i, (p) => {
      const y = p.cells, E = Fn(m, (D, $) => $ >= 0 && $ < D.length ? D.slice(0, $).concat(D.slice($ + 1)) : D, y);
      return E.length > 0 ? [tl(p.element, E, p.section, p.isNew)] : [];
    }), U2 = (i, m, p) => {
      const { rows: y, cols: E } = _s(i);
      return [
        ...E,
        ...y.slice(0, m),
        ...y.slice(p + 1)
      ];
    }, U0 = (i, m, p, y) => qr(i[m], p) !== void 0 && m > 0 && y(qr(i[m - 1], p), qr(i[m], p)), j2 = (i, m, p) => m > 0 && p(qr(i, m - 1), qr(i, m)), Wh = (i, m, p, y) => U0(i, m, p, y) || j2(i[m], p, y), pw = (i, m) => ao(m, Ye) && u0(i.cells) ? X : (y, E, D) => !(Qs(y.element) === "th" && m[D]), N1 = (i, m) => ao(m, Ye) && u0(i) ? X : (y, E, D) => !(Qs(y.element) === "th" && m[E]), Iu = (i, m, p, y) => {
      const E = ($) => $ === "row" ? M3(m) : af(m), D = ($) => E($) ? `${$}group` : $;
      return i ? Js(m) ? D(p) : null : y && Js(m) ? D(p === "row" ? "col" : "row") : null;
    }, j0 = (i, m) => (p, y, E) => se.some(Iu(i, p.element, "col", m[E])), M1 = (i, m) => (p, y) => se.some(Iu(i, p.element, "row", m[y])), Zh = (i, m, p) => Pr(p(i.element, m), !0, i.isLocked), Dg = (i, m, p, y, E, D, $) => {
      const z = (K) => ot(m, (ce) => p(K.element, ce.element));
      return he(i, (K, ce) => As(K, (Ce, Ge) => {
        if (z(Ce)) {
          const kt = $(Ce, ce, Ge) ? E(Ce, p, y) : Ce;
          return D(kt, ce, Ge).each((wt) => {
            ec(kt.element, { scope: se.from(wt) });
          }), kt;
        } else
          return Ce;
      }));
    }, P1 = (i, m, p) => oo(i, (y, E) => Wh(i, E, m, p) ? [] : [hn(y, m)]), W0 = (i, m, p) => {
      const y = i[m];
      return oo(y.cells, (E, D) => Wh(i, m, D, p) ? [] : [E]);
    }, B1 = (i, m, p, y, E) => {
      const D = _s(i).rows, $ = oo(m, (Ce) => P1(D, Ce, y)), z = he(D, (Ce) => u0(Ce.cells)), K = N1($, z), ce = M1(p, z);
      return Dg(i, $, y, E, Zh, ce, K);
    }, Z0 = (i, m, p, y, E, D, $) => {
      const { cols: z, rows: K } = _s(i), ce = K[m[0]], Ce = oo(m, (qe) => W0(K, qe, E)), Ge = he(ce.cells, (qe, dn) => u0(P1(K, dn, E))), kt = [...K];
      ue(m, (qe) => {
        kt[qe] = $.transformRow(K[qe], p);
      });
      const wt = [...z, ...kt], Gt = pw(ce, Ge), Fe = j0(y, Ge);
      return Dg(wt, Ce, E, D, $.transformCell, Fe, Gt);
    }, Rg = (i, m, p, y) => {
      const E = _s(i).rows, D = he(m, ($) => hn(E[$.row], $.column));
      return Dg(i, D, p, y, Zh, se.none, X);
    }, Tc = (i) => ye(i, (p, y) => ot(p, (D) => D.column === y.column) ? p : p.concat([y]), []).sort((p, y) => p.column - y.column), La = (i) => ig(i, !0), Gh = (i) => {
      lf(i).length === 0 && Xr(i);
    }, Re = (i, m) => ({
      grid: i,
      cursor: m
    }), $1 = (i) => st(i, (m) => st(m.cells, (p) => {
      const y = p.element;
      return yu(La(y), y);
    })), nk = (i, m, p) => {
      const y = _s(i).rows;
      return se.from(y[m]?.cells[p]?.element).filter(La).orThunk(() => $1(y));
    }, kc = (i, m, p) => {
      const y = nk(i, m, p);
      return Re(i, y);
    }, qh = (i) => ye(i, (p, y) => ot(p, (D) => D.row === y.row) ? p : p.concat([y]), []).sort((p, y) => p.row - y.row), Fu = (i, m, p, y) => {
      const E = m[0].row, D = qh(m), $ = Fn(D, (z, K) => ({ grid: z2(z.grid, E, K.row + z.delta, p, y.getOrInit), delta: z.delta + 1 }), { grid: i, delta: 0 }).grid;
      return kc($, E, m[0].column);
    }, W2 = (i, m, p, y) => {
      const E = qh(m), D = E[E.length - 1], $ = D.row + D.rowspan, z = Fn(E, (K, ce) => z2(K, $, ce.row, p, y.getOrInit), i);
      return kc(z, $, m[0].column);
    }, Z2 = (i, m, p, y) => {
      const E = m.details, D = Tc(E), $ = D[0].column, z = Fn(D, (K, ce) => ({ grid: V0(K.grid, $, ce.column + K.delta, p, y.getOrInit), delta: K.delta + 1 }), { grid: i, delta: 0 }).grid;
      return kc(z, E[0].row, $);
    }, Ng = (i, m, p, y) => {
      const E = m.details, D = E[E.length - 1], $ = D.column + D.colspan, z = Tc(E), K = Fn(z, (ce, Ce) => V0(ce, $, Ce.column, p, y.getOrInit), i);
      return kc(K, E[0].row, $);
    }, I1 = (i, m, p, y) => {
      const E = Tc(m), D = he(E, (z) => z.column), $ = B1(i, D, !0, p, y.replaceOrInit);
      return kc($, m[0].row, m[0].column);
    }, bm = (i, m, p, y) => {
      const E = Rg(i, m, p, y.replaceOrInit);
      return kc(E, m[0].row, m[0].column);
    }, G0 = (i, m, p, y) => {
      const E = Tc(m), D = he(E, (z) => z.column), $ = B1(i, D, !1, p, y.replaceOrInit);
      return kc($, m[0].row, m[0].column);
    }, ok = (i, m, p, y) => {
      const E = Rg(i, m, p, y.replaceOrInit);
      return kc(E, m[0].row, m[0].column);
    }, Ha = (i, m) => (p, y, E, D, $) => {
      const z = qh(y), K = he(z, (Ce) => Ce.row), ce = Z0(p, K, i, m, E, D.replaceOrInit, $);
      return kc(ce, y[0].row, y[0].column);
    }, Lu = Ha("thead", !0), vl = Ha("tbody", !1), sk = Ha("tfoot", !1), Kh = (i, m, p, y) => {
      const E = Tc(m.details), D = V2(i, he(E, (z) => z.column)), $ = D.length > 0 ? D[0].cells.length - 1 : 0;
      return kc(D, E[0].row, Math.min(E[0].column, $));
    }, bw = (i, m, p, y) => {
      const E = qh(m), D = U2(i, E[0].row, E[E.length - 1].row), $ = Math.max(_s(D).rows.length - 1, 0);
      return kc(D, Math.min(m[0].row, $), m[0].column);
    }, q0 = (i, m, p, y) => {
      const E = m.cells;
      dw(E);
      const D = F2(i, m.bounds, p, y.merge(E));
      return Re(D, se.from(E[0]));
    }, rk = (i, m, p, y) => {
      const D = Fn(m, ($, z) => mw($, z, p, y.unmerge(z)), i);
      return Re(D, se.from(m[0]));
    }, vw = (i, m, p, y) => {
      const D = ((K, ce) => {
        const Ce = zn.fromTable(K);
        return ir(Ce, ce, !0);
      })(m.clipboard, m.generators), $ = cd(m.row, m.column);
      return Rs($, i, D, m.generators, p).fold(() => Re(i, se.some(m.element)), (K) => kc(K, m.row, m.column));
    }, Wn = (i, m, p) => {
      const y = ht(i, p.section), E = zn.generate(y);
      return ir(E, m, !0);
    }, tn = (i, m, p, y) => {
      const E = _s(i).rows, D = m.cells[0].column, $ = E[m.cells[0].row], z = Wn(m.clipboard, m.generators, $), K = Tr(D, i, z, m.generators, p);
      return kc(K, m.cells[0].row, m.cells[0].column);
    }, Yh = (i, m, p, y) => {
      const E = _s(i).rows, D = m.cells[m.cells.length - 1].column + m.cells[m.cells.length - 1].colspan, $ = E[m.cells[0].row], z = Wn(m.clipboard, m.generators, $), K = Tr(D, i, z, m.generators, p);
      return kc(K, m.cells[0].row, D);
    }, K0 = (i, m, p, y) => {
      const E = _s(i).rows, D = m.cells[0].row, $ = E[D], z = Wn(m.clipboard, m.generators, $), K = jh(D, i, z, m.generators, p);
      return kc(K, m.cells[0].row, m.cells[0].column);
    }, Y0 = (i, m, p, y) => {
      const E = _s(i).rows, D = m.cells[m.cells.length - 1].row + m.cells[m.cells.length - 1].rowspan, $ = E[m.cells[0].row], z = Wn(m.clipboard, m.generators, $), K = jh(D, i, z, m.generators, p);
      return kc(K, D, m.cells[0].column);
    }, ak = (i, m) => {
      const p = zn.fromTable(i);
      return na(p, m).bind((E) => {
        const D = E[E.length - 1], $ = E[0].column, z = D.column + D.colspan, K = Ln(he(p.all, (ce) => fn(ce.cells, (Ce) => Ce.column >= $ && Ce.column < z)));
        return l2(K);
      }).getOr("");
    }, G2 = (i, m) => {
      const p = zn.fromTable(i);
      return na(p, m).bind(l2).getOr("");
    }, Ts = (i, m) => {
      const p = zn.fromTable(i);
      return na(p, m).bind((E) => {
        const D = E[E.length - 1], $ = E[0].row, z = D.row + D.rowspan, K = p.all.slice($, z);
        return LS(K);
      }).getOr("");
    }, X0 = (i, m, p, y) => S0(i, m, p, y.sizing), Q0 = (i, m, p, y) => x0(i, m, p, y.sizing, y.resize), q2 = (i, m) => ot(m, (p) => p.column === 0 && p.isLocked), Ie = (i, m) => ot(m, (p) => p.column + p.colspan >= i.grid.columns && p.isLocked), Xh = (i, m) => {
      const p = _h(i), y = Tc(m);
      return ye(y, (E, D) => {
        const z = p[D.column].map(Ss).getOr(0);
        return E + z;
      }, 0);
    }, Mg = (i) => (m, p) => na(m, p).filter((y) => !(i ? q2 : Ie)(m, y)).map((y) => ({
      details: y,
      pixelDelta: Xh(m, y)
    })), Td = (i, m) => $h(i, m).map((p) => ({
      details: p,
      pixelDelta: -Xh(i, p)
      // needs to be negative as we are removing columns
    })), Ji = (i) => (m, p) => Ul(m, p).filter((y) => !(i ? q2 : Ie)(m, y.cells)), kd = wc.transform("th"), Qh = wc.transform("td"), Pg = (i, m, p, y) => Nr(Fu, na, Xe, Xe, wc.modification, i, m, p, y), ck = (i, m, p, y) => Nr(W2, na, Xe, Xe, wc.modification, i, m, p, y), Jh = (i, m, p, y) => Nr(Z2, Mg(!0), Q0, Xe, wc.modification, i, m, p, y), hs = (i, m, p, y) => Nr(Ng, Mg(!1), Q0, Xe, wc.modification, i, m, p, y), eu = (i, m, p, y) => Nr(Kh, Td, Q0, Gh, wc.modification, i, m, p, y), K2 = (i, m, p, y) => Nr(bw, na, Xe, Gh, wc.modification, i, m, p, y), Ef = (i, m, p, y) => Nr(I1, $h, Xe, Xe, kd, i, m, p, y), Hu = (i, m, p, y) => Nr(G0, $h, Xe, Xe, Qh, i, m, p, y), za = (i, m, p, y) => Nr(Lu, na, Xe, Xe, kd, i, m, p, y), yw = (i, m, p, y) => Nr(vl, na, Xe, Xe, Qh, i, m, p, y), Y2 = (i, m, p, y) => Nr(sk, na, Xe, Xe, Qh, i, m, p, y), Cw = (i, m, p, y) => Nr(bm, $h, Xe, Xe, kd, i, m, p, y), lk = (i, m, p, y) => Nr(ok, $h, Xe, Xe, Qh, i, m, p, y), ik = (i, m, p, y) => Nr(q0, Cg, X0, Xe, wc.merging, i, m, p, y), X2 = (i, m, p, y) => Nr(rk, j3, X0, Xe, wc.merging, i, m, p, y), xw = (i, m, p, y) => Nr(vw, b0, X0, Xe, wc.modification, i, m, p, y), nt = (i, m, p, y) => Nr(tn, Ji(!0), Xe, Xe, wc.modification, i, m, p, y), Q2 = (i, m, p, y) => Nr(Yh, Ji(!1), Xe, Xe, wc.modification, i, m, p, y), da = (i, m, p, y) => Nr(K0, Ul, Xe, Xe, wc.modification, i, m, p, y), J2 = (i, m, p, y) => Nr(Y0, Ul, Xe, Xe, wc.modification, i, m, p, y), eC = ak, tC = G2, uk = Ts, xn = (i, m) => {
      const p = m.column, y = m.column + m.colspan - 1, E = m.row, D = m.row + m.rowspan - 1;
      return p <= i.finishCol && y >= i.startCol && E <= i.finishRow && D >= i.startRow;
    }, Sw = (i, m) => m.column >= i.startCol && m.column + m.colspan - 1 <= i.finishCol && m.row >= i.startRow && m.row + m.rowspan - 1 <= i.finishRow, ww = (i, m) => {
      let p = !0;
      const y = Ot(Sw, m);
      for (let E = m.startRow; E <= m.finishRow; E++)
        for (let D = m.startCol; D <= m.finishCol; D++)
          p = p && zn.getAt(i, E, D).exists(y);
      return p ? se.some(m) : se.none();
    }, dk = (i, m) => Br(Math.min(i.row, m.row), Math.min(i.column, m.column), Math.max(i.row + i.rowspan - 1, m.row + m.rowspan - 1), Math.max(i.column + i.colspan - 1, m.column + m.colspan - 1)), mk = (i, m, p) => {
      const y = zn.findItem(i, m, zo), E = zn.findItem(i, p, zo);
      return y.bind((D) => E.map(($) => dk(D, $)));
    }, Ew = (i, m, p) => mk(i, m, p).bind((y) => ww(i, y)), p7 = (i, m, p, y) => zn.findItem(i, m, zo).bind((E) => {
      const D = p > 0 ? E.row + E.rowspan - 1 : E.row, $ = y > 0 ? E.column + E.colspan - 1 : E.column;
      return zn.getAt(i, D + p, $ + y).map((K) => K.element);
    }), t5 = (i, m, p) => mk(i, m, p).map((y) => {
      const E = zn.filterItems(i, Ot(xn, y));
      return he(E, (D) => D.element);
    }), Tw = (i, m) => {
      const p = (y, E) => ud(E, y);
      return zn.findItem(i, m, p).map((y) => y.element);
    }, fk = (i, m, p) => zl(i).bind((y) => {
      const E = Si(y);
      return p7(E, i, m, p);
    }), En = (i, m, p) => {
      const y = Si(i);
      return t5(y, m, p);
    }, nC = (i, m, p, y, E) => {
      const D = Si(i), $ = zo(i, p) ? se.some(m) : Tw(D, m), z = zo(i, E) ? se.some(y) : Tw(D, y);
      return $.bind((K) => z.bind((ce) => t5(D, K, ce)));
    }, vm = (i, m, p) => {
      const y = Si(i);
      return Ew(y, m, p);
    }, Si = zn.fromTable, J0 = {
      styles: {
        "border-collapse": "collapse",
        width: "100%"
      },
      attributes: {
        border: "1"
      },
      colGroups: !1
    }, Ac = () => vt.fromTag("th"), ep = () => vt.fromTag("td"), F1 = () => vt.fromTag("col"), ev = (i, m, p, y) => {
      const E = vt.fromTag("tr");
      for (let D = 0; D < i; D++) {
        const $ = y < m || D < p ? Ac() : ep();
        D < p && gr($, "scope", "row"), y < m && gr($, "scope", "col"), Eo($, vt.fromTag("br")), Eo(E, $);
      }
      return E;
    }, tp = (i) => {
      const m = vt.fromTag("colgroup");
      return jo(i, () => Eo(m, F1())), m;
    }, np = (i, m, p, y) => jo(i, (E) => ev(m, p, y, E)), Ad = (i, m, p, y, E, D = J0) => {
      const $ = vt.fromTag("table"), z = E !== "cells";
      fs($, D.styles), ii($, D.attributes), D.colGroups && Eo($, tp(m));
      const K = Math.min(i, p);
      if (z && p > 0) {
        const wt = vt.fromTag("thead");
        Eo($, wt);
        const Fe = np(p, m, E === "sectionCells" ? K : 0, y);
        Ml(wt, Fe);
      }
      const ce = vt.fromTag("tbody");
      Eo($, ce);
      const Ce = z ? i - K : i, kt = np(Ce, m, z ? 0 : p, y);
      return Ml(ce, kt), $;
    }, kr = (i) => {
      let m = [];
      return {
        bind: (D) => {
          if (D === void 0)
            throw new Error("Event bind error: undefined handler");
          m.push(D);
        },
        unbind: (D) => {
          m = fn(m, ($) => $ !== D);
        },
        trigger: (...D) => {
          const $ = {};
          ue(i, (z, K) => {
            $[z] = D[K];
          }), ue(m, (z) => {
            z($);
          });
        }
      };
    }, ym = (i) => {
      const m = Io(i, (y) => ({
        bind: y.bind,
        unbind: y.unbind
      })), p = Io(i, (y) => y.trigger);
      return {
        registry: m,
        trigger: p
      };
    }, kw = Pt([
      "compare",
      "extract",
      "mutate",
      "sink"
    ]), oC = Pt([
      "element",
      "start",
      "stop",
      "destroy"
    ]), Aw = Pt([
      "forceDrop",
      "drop",
      "move",
      "delayDrop"
    ]), gk = () => {
      let i = se.none();
      const m = () => {
        i = se.none();
      }, p = (D, $) => {
        const z = i.map((K) => D.compare(K, $));
        return i = se.some($), z;
      }, y = (D, $) => {
        $.extract(D).each((K) => {
          p($, K).each((Ce) => {
            E.trigger.move(Ce);
          });
        });
      }, E = ym({
        move: kr(["info"])
      });
      return {
        onEvent: y,
        reset: m,
        events: E.registry
      };
    }, io = () => {
      const i = ym({
        move: kr(["info"])
      });
      return {
        onEvent: Xe,
        reset: Xe,
        events: i.registry
      };
    }, tu = () => {
      const i = io(), m = gk();
      let p = i;
      return {
        on: () => {
          p.reset(), p = m;
        },
        off: () => {
          p.reset(), p = i;
        },
        isOn: () => p === m,
        onEvent: (z, K) => {
          p.onEvent(z, K);
        },
        events: m.events
      };
    }, Tf = (i, m, p) => {
      let y = !1;
      const E = ym({
        start: kr([]),
        stop: kr([])
      }), D = tu(), $ = () => {
        Gt.stop(), D.isOn() && (D.off(), E.trigger.stop());
      }, z = Cu($, 200), K = (qe) => {
        Gt.start(qe), D.on(), E.trigger.start();
      }, ce = (qe) => {
        z.cancel(), D.onEvent(qe, m);
      };
      D.events.move.bind((qe) => {
        m.mutate(i, qe.info);
      });
      const Ce = () => {
        y = !0;
      }, Ge = () => {
        y = !1;
      }, kt = () => y, wt = (qe) => (...dn) => {
        y && qe.apply(null, dn);
      }, Gt = m.sink(Aw({
        // ASSUMPTION: runIfActive is not needed for mousedown. This is pretty much a safety measure for
        // inconsistent situations so that we don't block input.
        forceDrop: $,
        drop: wt($),
        move: wt(ce),
        delayDrop: wt(z.throttle)
      }), p), Fe = () => {
        Gt.destroy();
      };
      return {
        element: Gt.element,
        go: K,
        on: Ce,
        off: Ge,
        isActive: kt,
        destroy: Fe,
        events: E.registry
      };
    }, op = Wo("ephox-dragster").resolve, go = (i) => {
      const m = {
        layerClass: op("blocker"),
        ...i
      }, p = vt.fromTag("div");
      return gr(p, "role", "presentation"), gr(p, "data-mce-bogus", "all"), fs(p, {
        position: "fixed",
        left: "0px",
        top: "0px",
        width: "100%",
        height: "100%"
      }), di(p, op("blocker")), di(p, m.layerClass), {
        element: U(p),
        destroy: () => {
          Xr(p);
        }
      };
    };
    var L1 = kw({
      compare: (i, m) => Cs(m.left - i.left, m.top - i.top),
      extract: (i) => se.some(Cs(i.x, i.y)),
      sink: (i, m) => {
        const p = go(m), y = Tu(p.element(), "mousedown", i.forceDrop), E = Tu(p.element(), "mouseup", i.drop), D = Tu(p.element(), "mousemove", i.move), $ = Tu(p.element(), "mouseout", i.delayDrop), z = () => {
          p.destroy(), E.unbind(), D.unbind(), $.unbind(), y.unbind();
        }, K = (Ce) => {
          Eo(Ce, p.element());
        }, ce = () => {
          Xr(p.element());
        };
        return oC({
          element: p.element,
          start: K,
          stop: ce,
          destroy: z
        });
      },
      mutate: (i, m) => {
        i.mutate(m.left, m.top);
      }
    });
    const bk = (i, m = {}) => {
      const p = m.mode ?? L1;
      return Tf(i, p, m);
    }, H1 = Wo("ephox-snooker").resolve, yk = () => {
      const i = ym({
        drag: kr(["xDelta", "yDelta"])
      });
      return {
        mutate: (p, y) => {
          i.trigger.drag(p, y);
        },
        events: i.registry
      };
    }, z1 = () => {
      const i = ym({
        drag: kr(["xDelta", "yDelta", "target"])
      });
      let m = se.none();
      const p = yk();
      return p.events.drag.bind((D) => {
        m.each(($) => {
          i.trigger.drag(D.xDelta, D.yDelta, $);
        });
      }), {
        assign: (D) => {
          m = se.some(D);
        },
        get: () => m,
        mutate: p.mutate,
        events: i.registry
      };
    }, _w = (i, m, p, y, E) => {
      const D = vt.fromTag("div");
      return fs(D, {
        position: "absolute",
        left: m - y / 2 + "px",
        top: p + "px",
        height: E + "px",
        width: y + "px"
      }), ii(D, { "data-mce-bogus": "all", "data-column": i, role: "presentation" }), D;
    }, Ck = (i, m, p, y, E) => {
      const D = vt.fromTag("div");
      return fs(D, {
        position: "absolute",
        left: m + "px",
        top: p - E / 2 + "px",
        height: E + "px",
        width: y + "px"
      }), ii(D, { "data-mce-bogus": "all", "data-row": i, role: "presentation" }), D;
    }, tv = H1("resizer-bar"), sC = H1("resizer-rows"), rC = H1("resizer-cols"), Ow = 7, xk = (i, m) => oo(i.all, (p, y) => m(p.element) ? [y] : []), Dw = (i, m) => {
      const p = [];
      return jo(i.grid.columns, (y) => {
        zn.getColumnAt(i, y).map((D) => D.element).forall(m) && p.push(y);
      }), fn(p, (y) => {
        const E = zn.filterItems(i, (D) => D.column === y);
        return ao(E, (D) => m(D.element));
      });
    }, aC = (i) => {
      const m = Ui(i.parent(), "." + tv);
      ue(m, Xr);
    }, Rw = (i, m, p) => {
      const y = i.origin();
      ue(m, (E) => {
        E.each((D) => {
          const $ = p(y, D);
          di($, tv), Eo(i.parent(), $);
        });
      });
    }, So = (i, m, p, y) => {
      Rw(i, m, (E, D) => {
        const $ = _w(D.col, D.x - E.left, p.top - E.top, Ow, y);
        return di($, rC), $;
      });
    }, Nw = (i, m, p, y) => {
      Rw(i, m, (E, D) => {
        const $ = Ck(D.row, p.left - E.left, D.y - E.top, y, Ow);
        return di($, sC), $;
      });
    }, cC = (i, m, p, y, E) => {
      const D = Kn(p), $ = m.isResizable, z = y.length > 0 ? g1.positions(y, p) : [], K = z.length > 0 ? xk(i, $) : [], ce = fn(z, (wt, Gt) => ot(K, (Fe) => Gt === Fe));
      Nw(m, ce, D, Ss(p));
      const Ce = E.length > 0 ? er.positions(E, p) : [], Ge = Ce.length > 0 ? Dw(i, $) : [], kt = fn(Ce, (wt, Gt) => ot(Ge, (Fe) => Gt === Fe));
      So(m, kt, D, o0(p));
    }, nv = (i, m) => {
      if (aC(i), i.isResizable(m)) {
        const p = zn.fromTable(m), y = d2(p), E = _h(p);
        cC(p, i, m, y, E);
      }
    }, Cm = (i, m) => {
      const p = Ui(i.parent(), "." + tv);
      ue(p, m);
    }, lC = (i) => {
      Cm(i, (m) => {
        Jr(m, "display", "none");
      });
    }, Sk = (i) => {
      Cm(i, (m) => {
        Jr(m, "display", "block");
      });
    }, Mw = (i) => mi(i, sC), sp = (i) => mi(i, rC), Pw = H1("resizer-bar-dragging"), V1 = (i) => {
      const m = z1(), p = bk(m, {});
      let y = se.none();
      const E = (Fe, qe) => se.from(Fc(Fe, qe));
      m.events.drag.bind((Fe) => {
        E(Fe.target, "data-row").each((qe) => {
          const dn = Rr(Fe.target, "top");
          Jr(Fe.target, "top", dn + Fe.yDelta + "px");
        }), E(Fe.target, "data-column").each((qe) => {
          const dn = Rr(Fe.target, "left");
          Jr(Fe.target, "left", dn + Fe.xDelta + "px");
        });
      });
      const D = (Fe, qe) => {
        const dn = Rr(Fe, qe), Bn = am(Fe, "data-initial-" + qe, 0);
        return dn - Bn;
      };
      p.events.stop.bind(() => {
        m.get().each((Fe) => {
          y.each((qe) => {
            E(Fe, "data-row").each((dn) => {
              const Bn = D(Fe, "top");
              Oo(Fe, "data-initial-top"), Gt.trigger.adjustHeight(qe, Bn, parseInt(dn, 10));
            }), E(Fe, "data-column").each((dn) => {
              const Bn = D(Fe, "left");
              Oo(Fe, "data-initial-left"), Gt.trigger.adjustWidth(qe, Bn, parseInt(dn, 10));
            }), nv(i, qe);
          });
        });
      });
      const $ = (Fe, qe) => {
        Gt.trigger.startAdjust(), m.assign(Fe), gr(Fe, "data-initial-" + qe, Rr(Fe, qe)), di(Fe, Pw), Jr(Fe, "opacity", "0.2"), p.go(i.dragContainer());
      }, z = Tu(i.parent(), "mousedown", (Fe) => {
        Mw(Fe.target) && $(Fe.target, "top"), sp(Fe.target) && $(Fe.target, "left");
      }), K = (Fe) => zo(Fe, i.view()), ce = (Fe) => rr(Fe, "table", K).filter(ig), Ce = (Fe) => mi(Fe, "ephox-snooker-resizer-bar") || mi(Fe, "ephox-dragster-blocker"), Ge = Tu(i.view(), "mouseover", (Fe) => {
        ce(Fe.target).fold(() => {
          ln(Fe.target) && !Ce(Fe.target) && aC(i);
        }, (qe) => {
          p.isActive() && (y = se.some(qe), nv(i, qe));
        });
      }), kt = () => {
        z.unbind(), Ge.unbind(), p.destroy(), aC(i);
      }, wt = (Fe) => {
        nv(i, Fe);
      }, Gt = ym({
        adjustHeight: kr(["table", "delta", "row"]),
        adjustWidth: kr(["table", "delta", "column"]),
        startAdjust: kr([])
      });
      return {
        destroy: kt,
        refresh: wt,
        on: p.on,
        off: p.off,
        hideBars: Ot(lC, i),
        showBars: Ot(Sk, i),
        events: Gt.registry
      };
    }, iC = {
      create: (i, m, p) => {
        const y = g1, E = er, D = V1(i), $ = ym({
          beforeResize: kr(["table", "type"]),
          afterResize: kr(["table", "type"]),
          startDrag: kr([])
        });
        return D.events.adjustHeight.bind((z) => {
          const K = z.table;
          $.trigger.beforeResize(K, "row");
          const ce = y.delta(z.delta, K);
          C0(K, ce, z.row), $.trigger.afterResize(K, "row");
        }), D.events.startAdjust.bind((z) => {
          $.trigger.startDrag();
        }), D.events.adjustWidth.bind((z) => {
          const K = z.table;
          $.trigger.beforeResize(K, "col");
          const ce = E.delta(z.delta, K), Ce = p(K);
          Fh(K, ce, z.column, m, Ce), $.trigger.afterResize(K, "col");
        }), {
          on: D.on,
          off: D.off,
          refreshBars: D.refresh,
          hideBars: D.hideBars,
          showBars: D.showBars,
          destroy: D.destroy,
          events: $.registry
        };
      }
    }, kf = (i) => (m) => m.options.get(i), Bw = "100%", $w = (i) => {
      const m = i.dom, p = m.getParent(i.selection.getStart(), m.isBlock) ?? i.getBody();
      return ea(vt.fromDom(p)) + "px";
    }, Iw = (i, m) => W1(i) || !uC(i) ? m : _d(i) ? { ...m, width: $w(i) } : { ...m, width: Bw }, Fw = (i, m) => W1(i) || uC(i) ? m : _d(i) ? { ...m, width: $w(i) } : { ...m, width: Bw }, r5 = (i) => {
      const m = i.options.register;
      m("table_clone_elements", {
        processor: "string[]"
      }), m("table_use_colgroups", {
        processor: "boolean",
        default: !0
      }), m("table_header_type", {
        processor: (p) => {
          const y = No(["section", "cells", "sectionCells", "auto"], p);
          return y ? { value: p, valid: y } : { valid: !1, message: "Must be one of: section, cells, sectionCells or auto." };
        },
        default: "section"
      }), m("table_sizing_mode", {
        processor: "string",
        default: "auto"
      }), m("table_default_attributes", {
        processor: "object",
        default: {
          border: "1"
        }
      }), m("table_default_styles", {
        processor: "object",
        default: {
          "border-collapse": "collapse"
        }
      }), m("table_column_resizing", {
        processor: (p) => {
          const y = No(["preservetable", "resizetable"], p);
          return y ? { value: p, valid: y } : { valid: !1, message: "Must be preservetable, or resizetable." };
        },
        default: "preservetable"
      }), m("table_resize_bars", {
        processor: "boolean",
        default: !0
      }), m("table_style_by_css", {
        processor: "boolean",
        default: !0
      }), m("table_merge_content_on_paste", {
        processor: "boolean",
        default: !0
      });
    }, Lw = (i) => se.from(i.options.get("table_clone_elements")), ov = (i) => {
      const m = i.options.get("object_resizing");
      return No(m.split(","), "table");
    }, sv = kf("table_header_type"), j1 = kf("table_column_resizing"), rv = (i) => j1(i) === "preservetable", av = (i) => j1(i) === "resizetable", Rt = kf("table_sizing_mode"), Af = (i) => Rt(i) === "relative", _d = (i) => Rt(i) === "fixed", W1 = (i) => Rt(i) === "responsive", Hw = kf("table_resize_bars"), uC = kf("table_style_by_css"), dC = kf("table_merge_content_on_paste"), zw = (i) => {
      const m = i.options, p = m.get("table_default_attributes");
      return m.isSet("table_default_attributes") ? p : Fw(i, p);
    }, Vw = (i) => {
      const m = i.options, p = m.get("table_default_styles");
      return m.isSet("table_default_styles") ? p : Iw(i, p);
    }, Uw = kf("table_use_colgroups"), cv = (i) => vt.fromDom(i.getBody()), Ar = (i) => (m) => zo(m, cv(i)), nu = (i) => {
      Oo(i, "data-mce-style");
      const m = (p) => Oo(p, "data-mce-style");
      ue(lf(i), m), ue(i0(i), m), ue(c2(i), m);
    }, lv = (i) => vt.fromDom(i.selection.getStart()), jw = (i) => i.getBoundingClientRect().width, Ww = (i) => i.getBoundingClientRect().height, Zw = (i) => (m, p) => {
      const y = m.dom.getStyle(p, i) || m.dom.getAttrib(p, i);
      return se.from(y).filter(nr);
    }, iv = Zw("width"), mC = Zw("height"), Gw = (i) => /^(\d+(\.\d+)?)%$/.test(i), qw = (i) => /^(\d+(\.\d+)?)px$/.test(i), Z1 = (i) => e1(i, $c("table")).exists(ig), fC = (i) => pc(i, "table"), uv = (i, m, p) => {
      const y = (E) => (D) => p !== void 0 && p(D) || zo(D, E);
      return zo(i, m) ? se.some({
        boxes: se.some([i]),
        start: i,
        finish: m
      }) : fC(i).bind((E) => fC(m).bind((D) => {
        if (zo(E, D))
          return se.some({
            boxes: En(E, i, m),
            start: i,
            finish: m
          });
        if (ud(E, D)) {
          const $ = Po(m, "td,th", y(E)), z = $.length > 0 ? $[$.length - 1] : m;
          return se.some({
            boxes: nC(E, i, E, m, D),
            start: i,
            finish: z
          });
        } else if (ud(D, E)) {
          const $ = Po(i, "td,th", y(D)), z = $.length > 0 ? $[$.length - 1] : i;
          return se.some({
            boxes: nC(D, i, E, m, D),
            start: i,
            finish: z
          });
        } else
          return Bu(i, m).shared.bind(($) => rr($, "table", p).bind((z) => {
            const K = Po(m, "td,th", y(z)), ce = K.length > 0 ? K[K.length - 1] : m, Ce = Po(i, "td,th", y(z)), Ge = Ce.length > 0 ? Ce[Ce.length - 1] : i;
            return se.some({
              boxes: nC(z, i, E, m, D),
              start: Ge,
              finish: ce
            });
          }));
      }));
    }, gC = (i, m) => {
      const p = Ui(i, m);
      return p.length > 0 ? se.some(p) : se.none();
    }, wk = (i, m) => P(i, (p) => pa(p, m)), Kw = (i, m, p) => _u(i, m).bind((y) => _u(i, p).bind((E) => Jo(fC, [y, E]).map((D) => ({
      first: y,
      last: E,
      table: D
    })))), Yw = (i, m) => pc(i, "table").bind((p) => _u(p, m).bind((y) => uv(y, i).bind((E) => E.boxes.map((D) => ({
      boxes: D,
      start: E.start,
      finish: E.finish
    }))))), dv = (i, m, p, y, E) => wk(i, E).bind((D) => fk(D, m, p).bind(($) => Yw($, y))), Bg = (i, m) => gC(i, m), Xw = (i, m, p) => Kw(i, m, p).bind((y) => {
      const E = (K) => zo(i, K), D = "thead,tfoot,tbody,table", $ = pc(y.first, D, E), z = pc(y.last, D, E);
      return $.bind((K) => z.bind((ce) => zo(K, ce) ? vm(y.table, y.first, y.last) : se.none()));
    }), Qw = Ye, mv = (i) => {
      const m = (y, E) => ya(y, E).exists((D) => parseInt(D, 10) > 1), p = (y) => m(y, "rowspan") || m(y, "colspan");
      return i.length > 0 && ao(i, p) ? se.some(i) : se.none();
    }, Ek = (i, m, p) => m.length <= 1 ? se.none() : Xw(i, p.firstSelectedSelector, p.lastSelectedSelector).map((y) => ({ bounds: y, cells: m })), $g = {
      create: (i, m) => ({
        selection: i,
        kill: m
      })
    }, hC = (i, m, p, y) => {
      switch (i.tag) {
        case "none":
          return m();
        case "single":
          return y(i.element);
        case "multiple":
          return p(i.elements);
      }
    }, kk = () => ({
      tag: "none"
      /* SelectionTypeTag.None */
    }), Ak = (i) => ({ tag: "multiple", elements: i }), Jw = (i) => ({ tag: "single", element: i }), _k = (i, m, p) => ({
      get: () => Bg(i(), p).fold(() => m().fold(kk, Jw), Ak)
    }), fv = {
      create: (i, m, p, y) => ({
        start: cr.on(i, m),
        finish: cr.on(p, y)
      })
    }, bC = (i, m) => {
      const p = at(i, m);
      return Ou.create(vt.fromDom(p.startContainer), p.startOffset, vt.fromDom(p.endContainer), p.endOffset);
    }, Od = fv.create, eE = (i, m, p, y, E, D, $) => zo(p, E) && y === D ? se.none() : rr(p, "td,th", m).bind((z) => rr(E, "td,th", m).bind((K) => gv(i, m, z, K, $))), gv = (i, m, p, y, E) => zo(p, y) ? se.none() : uv(p, y, m).bind((D) => {
      const $ = D.boxes.getOr([]);
      return $.length > 1 ? (E(i, $, D.start, D.finish), se.some($g.create(se.some(Od(p, 0, p, ji(p))), !0))) : se.none();
    }), Ok = (i, m, p, y, E) => {
      const D = ($) => (E.clearBeforeUpdate(p), E.selectRange(p, $.boxes, $.start, $.finish), $.boxes);
      return dv(y, i, m, E.firstSelectedSelector, E.lastSelectedSelector).map(D);
    }, _f = Gr.generate([
      { none: ["message"] },
      { success: [] },
      { failedUp: ["cell"] },
      { failedDown: ["cell"] }
    ]), Dk = (i, m, p) => {
      const y = i.getRect(m), E = i.getRect(p);
      return E.right > y.left && E.left < y.right;
    }, Rk = (i) => rr(i, "tr"), rp = {
      ..._f,
      verify: (i, m, p, y, E, D, $) => rr(y, "td,th", $).bind((z) => rr(m, "td,th", $).map((K) => zo(z, K) ? zo(y, z) && ji(z) === E ? D(K) : _f.none("in same cell") : Jo(Rk, [z, K]).fold(() => Dk(i, K, z) ? _f.success() : D(K), (ce) => D(K)))).getOr(_f.none("default")),
      cata: (i, m, p, y, E) => i.fold(m, p, y, E)
    }, G1 = $c("br"), vC = (i, m, p) => m(i, p).bind((y) => sm(y) && Vi(y).trim().length === 0 ? vC(y, m, p) : se.some(y)), Nk = (i, m, p) => p.traverse(m).orThunk(() => vC(m, p.gather, i)).map(p.relative), Mk = (i, m) => fc(i, m).filter(G1).orThunk(() => fc(i, m - 1).filter(G1)), hv = (i, m, p, y) => Mk(m, p).bind((E) => y.traverse(E).fold(() => vC(E, y.gather, i).map(y.relative), (D) => yd(D).map(($) => cr.on($.parent, $.index)))), tE = (i, m, p, y) => (G1(m) ? Nk(i, m, y) : hv(i, m, p, y)).map((D) => ({
      start: D,
      finish: D
    })), nE = (i) => rp.cata(i, (m) => se.none(), () => se.none(), (m) => se.some(gm(m, 0)), (m) => se.some(gm(m, ji(m)))), q1 = (i, m) => ({
      left: i.left,
      top: i.top + m,
      right: i.right,
      bottom: i.bottom + m
    }), pv = (i, m) => ({
      left: i.left,
      top: i.top - m,
      right: i.right,
      bottom: i.bottom - m
    }), yC = (i, m, p) => ({
      left: i.left + m,
      top: i.top + p,
      right: i.right + m,
      bottom: i.bottom + p
    }), K1 = (i) => i.top, CC = (i) => i.bottom, Pk = (i, m, p) => p >= 0 && p < ji(m) ? i.getRangedRect(m, p, m, p + 1) : p > 0 ? i.getRangedRect(m, p - 1, m, p) : se.none(), Y1 = (i) => ({
      left: i.left,
      top: i.top,
      right: i.right,
      bottom: i.bottom
    }), oE = (i, m) => se.some(i.getRect(m)), bv = (i, m, p) => Zs(m) ? oE(i, m).map(Y1) : sm(m) ? Pk(i, m, p).map(Y1) : se.none(), vv = (i, m) => Zs(m) ? oE(i, m).map(Y1) : sm(m) ? i.getRangedRect(m, 0, m, ji(m)).map(Y1) : se.none(), Ig = 5, Bk = 100, Dd = Gr.generate([
      { none: [] },
      { retry: ["caret"] }
    ]), $k = (i, m) => i.left < m.left || Math.abs(m.right - i.left) < 1 || i.left > m.right, sE = (i, m, p) => e1(m, $u).fold(jt, (y) => vv(i, y).exists((E) => $k(p, E))), Ik = (i, m, p, y, E) => {
      const D = q1(E, Ig);
      return Math.abs(p.bottom - y.bottom) < 1 || p.top > E.bottom ? Dd.retry(D) : p.top === E.bottom ? Dd.retry(q1(E, 1)) : sE(i, m, E) ? Dd.retry(yC(D, Ig, 0)) : Dd.none();
    }, yv = {
      point: K1,
      adjuster: (i, m, p, y, E) => {
        const D = pv(E, Ig);
        return Math.abs(p.top - y.top) < 1 || p.bottom < E.top ? Dd.retry(D) : p.bottom === E.top ? Dd.retry(pv(E, 1)) : sE(i, m, E) ? Dd.retry(yC(D, Ig, 0)) : Dd.none();
      },
      move: pv,
      gather: uw
    }, Fk = {
      point: CC,
      adjuster: Ik,
      move: q1,
      gather: Xi
    }, Lk = (i, m, p) => i.elementFromPoint(m, p).filter((y) => Qs(y) === "table").isSome(), Hk = (i, m, p, y, E) => xC(i, m, p, m.move(y, Ig), E), xC = (i, m, p, y, E) => E === 0 ? se.some(y) : Lk(i, y.left, m.point(y)) ? Hk(i, m, p, y, E - 1) : i.situsFromPoint(y.left, m.point(y)).bind((D) => D.start.fold(se.none, ($) => vv(i, $).bind((z) => m.adjuster(i, $, z, p, y).fold(se.none, (K) => xC(i, m, p, K, E - 1))).orThunk(() => se.some(y)), se.none)), zk = (i, m, p) => i.point(m) > p.getInnerHeight() ? se.some(i.point(m) - p.getInnerHeight()) : i.point(m) < 0 ? se.some(-i.point(m)) : se.none(), rE = (i, m, p) => {
      const y = i.move(p, Ig), E = xC(m, i, p, y, Bk).getOr(y);
      return zk(i, E, m).fold(() => m.situsFromPoint(E.left, i.point(E)), (D) => (m.scrollBy(0, D), m.situsFromPoint(E.left, i.point(E) - D)));
    }, SC = {
      tryUp: Ot(rE, yv),
      tryDown: Ot(rE, Fk),
      getJumpSize: U(Ig)
    }, Vk = 20, Uk = (i, m, p) => i.getSelection().bind((y) => tE(m, y.finish, y.foffset, p).fold(() => se.some(gm(y.finish, y.foffset)), (E) => {
      const D = i.fromSitus(E), $ = rp.verify(i, y.finish, y.foffset, D.finish, D.foffset, p.failure, m);
      return nE($);
    })), wC = (i, m, p, y, E, D) => D === 0 ? se.none() : X1(i, m, p, y, E).bind(($) => {
      const z = i.fromSitus($), K = rp.verify(i, p, y, z.finish, z.foffset, E.failure, m);
      return rp.cata(K, () => se.none(), () => se.some($), (ce) => zo(p, ce) && y === 0 ? aE(i, p, y, pv, E) : wC(i, m, ce, 0, E, D - 1), (ce) => zo(p, ce) && y === ji(ce) ? aE(i, p, y, q1, E) : wC(i, m, ce, ji(ce), E, D - 1));
    }), aE = (i, m, p, y, E) => bv(i, m, p).bind((D) => Xt(i, E, y(D, SC.getJumpSize()))), Xt = (i, m, p) => {
      const y = sl().browser;
      return y.isChromium() || y.isSafari() || y.isFirefox() ? m.retry(i, p) : se.none();
    }, X1 = (i, m, p, y, E) => bv(i, p, y).bind((D) => Xt(i, E, D)), cE = (i, m, p) => Uk(i, m, p).bind((y) => wC(i, m, y.element, y.offset, p, Vk).map(i.fromSitus)), jk = (i, m) => a0(i, (p) => te(p).exists((y) => zo(y, m))), EC = (i, m, p, y, E) => rr(y, "td,th", m).bind((D) => rr(D, "table", m).bind(($) => jk(E, $) ? cE(i, m, p).bind((z) => rr(z.finish, "td,th", m).map((K) => ({
      start: D,
      finish: K,
      range: z
    }))) : se.none())), Q1 = (i, m, p, y, E, D) => D(y, m).orThunk(() => EC(i, m, p, y, E).map(($) => {
      const z = $.range;
      return $g.create(se.some(Od(z.start, z.soffset, z.finish, z.foffset)), !0);
    })), Cv = (i, m) => rr(i, "tr", m).bind((p) => rr(p, "table", m).bind((y) => {
      const E = Ui(y, "tr");
      return zo(p, E[0]) ? nc(y, (D) => ar(D).isSome(), m).map((D) => {
        const $ = ji(D);
        return $g.create(se.some(Od(D, $, D, $)), !0);
      }) : se.none();
    })), J1 = (i, m) => rr(i, "tr", m).bind((p) => rr(p, "table", m).bind((y) => {
      const E = Ui(y, "tr");
      return zo(p, E[E.length - 1]) ? xi(y, (D) => of(D).isSome(), m).map((D) => $g.create(se.some(Od(D, 0, D, 0)), !0)) : se.none();
    })), ap = (i, m, p, y, E, D, $) => EC(i, p, y, E, D).bind((z) => gv(m, p, z.start, z.finish, $)), TC = (i, m) => rr(i, "td,th", m), kC = (i) => mc(i).exists(ig), lE = (i, m, p, y) => {
      const E = Or(), D = E.clear, $ = (Ce) => {
        E.on((Ge) => {
          y.clearBeforeUpdate(m), TC(Ce.target, p).each((kt) => {
            uv(Ge, kt, p).each((wt) => {
              const Gt = wt.boxes.getOr([]);
              if (Gt.length === 1) {
                const Fe = Gt[0], qe = ug(Fe) === "false", dn = kn(nf(Ce.target), Fe, zo);
                qe && dn && y.selectRange(m, Gt, Fe, Fe);
              } else Gt.length > 1 && (y.selectRange(m, Gt, wt.start, wt.finish), i.selectContents(kt));
            });
          });
        });
      };
      return {
        clearstate: D,
        mousedown: (Ce) => {
          y.clear(m), TC(Ce.target, p).filter(kC).each(E.set);
        },
        mouseover: (Ce) => {
          $(Ce);
        },
        mouseup: (Ce) => {
          $(Ce), D();
        }
      };
    }, AC = {
      traverse: Ym,
      gather: Xi,
      relative: cr.before,
      retry: SC.tryDown,
      failure: rp.failedDown
    }, iE = {
      traverse: jp,
      gather: uw,
      relative: cr.before,
      retry: SC.tryUp,
      failure: rp.failedUp
    }, cp = (i) => (m) => m === i, xm = cp(38), lp = cp(40), Sm = (i) => i >= 37 && i <= 40, wm = {
      // We need to move KEYS out of keytar and into something much more low-level.
      isBackward: cp(37),
      isForward: cp(39)
    }, uE = {
      isBackward: cp(39),
      isForward: cp(37)
    }, eb = (i) => ({
      elementFromPoint: (qe, dn) => vt.fromPoint(vt.fromDom(i.document), qe, dn),
      getRect: (qe) => qe.dom.getBoundingClientRect(),
      getRangedRect: (qe, dn, Bn, Bt) => {
        const Bo = k.exact(qe, dn, Bn, Bt);
        return gg(i, Bo);
      },
      getSelection: () => fg(i).map((qe) => bC(i, qe)),
      fromSitus: (qe) => {
        const dn = k.relative(qe.start, qe.finish);
        return bC(i, dn);
      },
      situsFromPoint: (qe, dn) => rf(i, qe, dn).map((Bn) => fv.create(Bn.start, Bn.soffset, Bn.finish, Bn.foffset)),
      clearSelection: () => {
        xh(i);
      },
      collapseSelection: (qe = !1) => {
        fg(i).each((dn) => dn.fold((Bn) => Bn.collapse(qe), (Bn, Bt) => {
          const Bo = qe ? Bn : Bt;
          Du(i, Bo, Bo);
        }, (Bn, Bt, Bo, $o) => {
          const Rn = qe ? Bn : Bo, br = qe ? Bt : $o;
          gi(i, Rn, br, Rn, br);
        }));
      },
      setSelection: (qe) => {
        gi(i, qe.start, qe.soffset, qe.finish, qe.foffset);
      },
      setRelativeSelection: (qe, dn) => {
        Du(i, qe, dn);
      },
      selectNode: (qe) => {
        sf(i, qe, !1);
      },
      selectContents: (qe) => {
        sf(i, qe);
      },
      getInnerHeight: () => i.innerHeight,
      getScrollY: () => qo(vt.fromDom(i.document)).top,
      scrollBy: (qe, dn) => {
        hc(qe, dn, vt.fromDom(i.document));
      }
    }), ou = (i, m) => ({ rows: i, cols: m }), dE = (i, m, p, y) => {
      const E = eb(i), D = lE(E, m, p, y);
      return {
        clearstate: D.clearstate,
        mousedown: D.mousedown,
        mouseover: D.mouseover,
        mouseup: D.mouseup
      };
    }, mE = (i) => e1(i, e0).exists(ig), _C = (i, m) => mE(i) || mE(m), OC = (i, m, p, y) => {
      const E = eb(i), D = () => (y.clear(m), se.none());
      return {
        keydown: (K, ce, Ce, Ge, kt, wt) => {
          const Gt = K.raw, Fe = Gt.which, qe = Gt.shiftKey === !0;
          return gC(m, y.selectedSelector).fold(() => (Sm(Fe) && !qe && y.clearBeforeUpdate(m), Sm(Fe) && qe && !_C(ce, Ge) ? se.none : lp(Fe) && qe ? Ot(ap, E, m, p, AC, Ge, ce, y.selectRange) : xm(Fe) && qe ? Ot(ap, E, m, p, iE, Ge, ce, y.selectRange) : lp(Fe) ? Ot(Q1, E, p, AC, Ge, ce, J1) : xm(Fe) ? Ot(Q1, E, p, iE, Ge, ce, Cv) : se.none), (Bn) => {
            const Bt = (Bo) => () => st(Bo, (Rn) => Ok(Rn.rows, Rn.cols, m, Bn, y)).fold(() => Kw(m, y.firstSelectedSelector, y.lastSelectedSelector).map((Rn) => {
              const br = lp(Fe) || wt.isForward(Fe) ? cr.after : cr.before;
              return E.setRelativeSelection(cr.on(Rn.first, 0), br(Rn.table)), y.clear(m), $g.create(se.none(), !0);
            }), (Rn) => se.some($g.create(se.none(), !0)));
            return Sm(Fe) && qe && !_C(ce, Ge) ? se.none : lp(Fe) && qe ? Bt([ou(1, 0)]) : xm(Fe) && qe ? Bt([ou(-1, 0)]) : wt.isBackward(Fe) && qe ? Bt([ou(0, -1), ou(-1, 0)]) : wt.isForward(Fe) && qe ? Bt([ou(0, 1), ou(1, 0)]) : Sm(Fe) && !qe ? D : se.none;
          })();
        },
        keyup: (K, ce, Ce, Ge, kt) => gC(m, y.selectedSelector).fold(() => {
          const wt = K.raw, Gt = wt.which;
          return wt.shiftKey === !0 && Sm(Gt) && _C(ce, Ge) ? eE(m, p, ce, Ce, Ge, kt, y.selectRange) : se.none();
        }, se.none)
      };
    }, fE = (i, m, p, y) => {
      const E = eb(i);
      return (D, $) => {
        y.clearBeforeUpdate(m), uv(D, $, p).each((z) => {
          const K = z.boxes.getOr([]);
          y.selectRange(m, K, z.start, z.finish), E.selectContents($), E.collapseSelection();
        });
      };
    }, hE = {
      byClass: (i) => {
        const m = o1(i.selected), p = r0([i.selected, i.lastSelected, i.firstSelected]), y = (D) => {
          const $ = Ui(D, i.selectedSelector);
          ue($, p);
        };
        return {
          clearBeforeUpdate: y,
          clear: y,
          selectRange: (D, $, z, K) => {
            y(D), ue($, m), di(z, i.firstSelected), di(K, i.lastSelected);
          },
          selectedSelector: i.selectedSelector,
          firstSelectedSelector: i.firstSelectedSelector,
          lastSelectedSelector: i.lastSelectedSelector
        };
      },
      byAttr: (i, m, p) => {
        const y = (K) => {
          Oo(K, i.selected), Oo(K, i.firstSelected), Oo(K, i.lastSelected);
        }, E = (K) => {
          gr(K, i.selected, "1");
        }, D = (K) => {
          $(K), p();
        }, $ = (K) => {
          const ce = Ui(K, `${i.selectedSelector},${i.firstSelectedSelector},${i.lastSelectedSelector}`);
          ue(ce, y);
        };
        return {
          clearBeforeUpdate: $,
          clear: D,
          selectRange: (K, ce, Ce, Ge) => {
            D(K), ue(ce, E), gr(Ce, i.firstSelected, "1"), gr(Ge, i.lastSelected, "1"), m(ce, Ce, Ge);
          },
          selectedSelector: i.selectedSelector,
          firstSelectedSelector: i.firstSelectedSelector,
          lastSelectedSelector: i.lastSelectedSelector
        };
      }
    }, Fg = "data-mce-selected", DC = "td[" + Fg + "],th[" + Fg + "]", pE = "[" + Fg + "]", RC = "data-mce-first-selected", NC = "td[" + RC + "],th[" + RC + "]", MC = "data-mce-last-selected", Zk = "td[" + MC + "],th[" + MC + "]", Lg = pE, Hg = {
      selected: Fg,
      selectedSelector: DC,
      firstSelected: RC,
      firstSelectedSelector: NC,
      lastSelected: MC,
      lastSelectedSelector: Zk
    }, xv = (i, m, p) => ({
      element: p,
      mergable: Ek(m, i, Hg),
      unmergable: mv(i),
      selection: Qw(i)
    }), Sv = (i, m, p) => ({
      element: i,
      clipboard: m,
      generators: p
    }), bE = (i, m, p, y) => ({
      selection: Qw(i),
      clipboard: p,
      generators: y
    }), Gk = (i) => zl(i).bind((m) => Bg(m, Hg.firstSelectedSelector)).fold(U(i), (m) => m[0]), vE = (i) => (m, p) => {
      const y = Qs(m), E = y === "col" || y === "colgroup" ? Gk(m) : m;
      return rr(E, i, p);
    }, An = vE("th,td,caption"), wv = vE("th,td"), Wl = (i) => Fr(i.model.table.getSelectedCells()), tb = (i) => fn(Wl(i), (m) => pa(m, Hg.selectedSelector)), qk = (i) => zl(i[0]).map((m) => {
      const p = E0(m, Lg);
      return nu(p), [p];
    }), Ev = (i, m) => he(m, (p) => i.selection.serializer.serialize(p.dom, {})).join(""), Kk = (i, m) => {
      const p = i.getDoc(), y = Gp(vt.fromDom(i.getBody())), E = vt.fromTag("div", p);
      gr(E, "data-mce-bogus", "all"), fs(E, {
        position: "fixed",
        left: "-9999999px",
        top: "0",
        overflow: "hidden",
        opacity: "0"
      });
      const D = Li(y);
      Ml(E, m), Eo(D, E);
      const $ = E.dom.innerText;
      return Xr(E), $;
    }, PC = (i, m) => {
      i.on("BeforeGetContent", (p) => {
        const y = (E) => {
          p.preventDefault(), qk(E).each((D) => {
            const $ = p.format === "text" ? Kk(i, D) : Ev(i, D);
            p.content = $;
          });
        };
        if (p.selection === !0) {
          const E = tb(i);
          E.length >= 1 && y(E);
        }
      }), i.on("BeforeSetContent", (p) => {
        if (p.selection === !0 && p.paste === !0) {
          const y = Wl(i);
          xe(y).each((E) => {
            zl(E).each((D) => {
              const $ = fn(gh(p.content), (K) => Qs(K) !== "meta"), z = $c("table");
              if (dC(i) && $.length === 1 && z($[0])) {
                p.preventDefault();
                const K = vt.fromDom(i.getDoc()), ce = I2(K), Ce = Sv(E, $[0], ce);
                m.pasteCells(D, Ce).each(() => {
                  i.focus();
                });
              }
            });
          });
        }
      });
    }, BC = (i, m) => i.dispatch("NewRow", { node: m }), nb = (i, m) => i.dispatch("NewCell", { node: m }), zu = (i, m, p) => {
      i.dispatch("TableModified", { ...p, table: m });
    }, ip = (i, m, p, y, E) => {
      i.dispatch("TableSelectionChange", {
        cells: m,
        start: p,
        finish: y,
        otherCells: E
      });
    }, Yk = (i) => {
      i.dispatch("TableSelectionClear");
    }, zg = (i, m, p, y, E) => {
      i.dispatch("ObjectResizeStart", { target: m, width: p, height: y, origin: E });
    }, ob = (i, m, p, y, E) => {
      i.dispatch("ObjectResized", { target: m, width: p, height: y, origin: E });
    }, Tv = { structure: !1, style: !0 }, Wr = { structure: !0, style: !1 }, Xk = { structure: !0, style: !0 }, $C = (i, m) => Af(i) ? Mh.percentageSize(m) : _d(i) ? Mh.pixelSize(m) : Mh.getTableSize(m), Of = (i, m, p) => {
      const y = (ka) => Qs(cv(ka)) === "table", E = (ka) => !y(i) || O1(ka).rows > 1, D = (ka) => !y(i) || O1(ka).columns > 1, $ = Lw(i), z = av(i) ? Xe : C1, K = (ka) => {
        switch (sv(i)) {
          case "section":
            return im.section();
          case "sectionCells":
            return im.sectionCells();
          case "cells":
            return im.cells();
          default:
            return im.getTableSectionType(ka, "section");
        }
      }, ce = (ka, Mv) => Mv.cursor.fold(() => {
        const cb = lf(ka);
        return xe(cb).filter(ln).map((Tm) => {
          p.clearSelectedCells(ka.dom);
          const sc = i.dom.createRng();
          return sc.selectNode(Tm.dom), i.selection.setRng(sc), gr(Tm, "data-mce-selected", "1"), sc;
        });
      }, (cb) => {
        const Tm = M0(cb), sc = i.dom.createRng();
        return sc.setStart(Tm.element.dom, Tm.offset), sc.setEnd(Tm.element.dom, Tm.offset), i.selection.setRng(sc), p.clearSelectedCells(ka.dom), se.some(sc);
      }), Ce = (ka, Mv, cb, Tm) => (sc, oA, TE = !1) => {
        nu(sc);
        const Ft = vt.fromDom(i.getDoc()), qc = xf(cb, Ft, $), sA = {
          sizing: $C(i, sc),
          resize: av(i) ? Eh() : IS(),
          section: K(sc)
        };
        return Mv(sc) ? ka(sc, oA, qc, sA).bind((Pv) => {
          m.refresh(sc.dom), ue(Pv.newRows, (Ug) => {
            BC(i, Ug.dom);
          }), ue(Pv.newCells, (Ug) => {
            nb(i, Ug.dom);
          });
          const kE = ce(sc, Pv);
          return ln(sc) && (nu(sc), TE || zu(i, sc.dom, Tm)), kE.map((Ug) => ({
            rng: Ug,
            effect: Tm
          }));
        }) : se.none();
      }, Ge = Ce(K2, E, Xe, Wr), kt = Ce(eu, D, Xe, Wr), wt = Ce(Pg, X, Xe, Wr), Gt = Ce(ck, X, Xe, Wr), Fe = Ce(Jh, X, z, Wr), qe = Ce(hs, X, z, Wr), dn = Ce(ik, X, Xe, Wr), Bn = Ce(X2, X, Xe, Wr), Bt = Ce(nt, X, Xe, Wr), Bo = Ce(Q2, X, Xe, Wr), $o = Ce(da, X, Xe, Wr), Rn = Ce(J2, X, Xe, Wr), br = Ce(xw, X, Xe, Xk), wi = Ce(Cw, X, Xe, Wr), Em = Ce(lk, X, Xe, Wr), Nf = Ce(Ef, X, Xe, Wr), Vg = Ce(Hu, X, Xe, Wr), Ko = Ce(za, X, Xe, Wr), _c = Ce(yw, X, Xe, Wr), Ys = Ce(Y2, X, Xe, Wr);
      return {
        deleteRow: Ge,
        deleteColumn: kt,
        insertRowsBefore: wt,
        insertRowsAfter: Gt,
        insertColumnsBefore: Fe,
        insertColumnsAfter: qe,
        mergeCells: dn,
        unmergeCells: Bn,
        pasteColsBefore: Bt,
        pasteColsAfter: Bo,
        pasteRowsBefore: $o,
        pasteRowsAfter: Rn,
        pasteCells: br,
        makeCellsHeader: wi,
        unmakeCellsHeader: Em,
        makeColumnsHeader: Nf,
        unmakeColumnsHeader: Vg,
        makeRowsHeader: Ko,
        makeRowsBody: _c,
        makeRowsFooter: Ys,
        getTableRowType: uk,
        getTableCellType: tC,
        getTableColType: eC
      };
    }, Rd = (i, m) => {
      i.selection.select(m.dom, !0), i.selection.collapse(!0);
    }, IC = (i, m) => {
      _u(m, "td,th").each(Ot(Rd, i));
    }, yE = (i, m) => {
      ue(Ui(m, "tr"), (p) => {
        BC(i, p.dom), ue(Ui(p, "th,td"), (y) => {
          nb(i, y.dom);
        });
      });
    }, Qk = (i) => nn(i) && i.indexOf("%") !== -1, kv = (i, m, p, y, E) => {
      const D = Vw(i), $ = {
        styles: D,
        attributes: zw(i),
        colGroups: Uw(i)
      };
      return i.undoManager.ignore(() => {
        const z = Ad(p, m, E, y, sv(i), $);
        gr(z, "data-mce-id", "__mce");
        const K = n0(z);
        i.insertContent(K), i.addVisual();
      }), _u(cv(i), 'table[data-mce-id="__mce"]').map((z) => (_d(i) ? B2(z) : W1(i) ? yf(z) : (Af(i) || Qk(D.width)) && Ag(z), nu(z), Oo(z, "data-mce-id"), yE(i, z), IC(i, z), z.dom)).getOrNull();
    }, sb = (i, m, p, y = {}) => {
      const E = (D) => un(D) && D > 0;
      if (E(m) && E(p)) {
        const D = y.headerRows || 0, $ = y.headerColumns || 0;
        return kv(i, p, m, $, D);
      } else
        return console.error("Invalid values for mceInsertTable - rows and columns values are required to insert a table."), null;
    };
    var Df = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
    const Av = "x-tinymce/dom-table-", _v = Av + "rows", Rf = Av + "columns", rb = (i) => {
      const m = Df.FakeClipboardItem(i);
      Df.write([m]);
    }, FC = (i) => {
      const m = Df.read() ?? [];
      return st(m, (p) => se.from(p.getType(i)));
    }, Ov = (i) => {
      FC(i).isSome() && Df.clear();
    }, Vu = (i) => {
      i.fold(Nd, (m) => rb({ [_v]: m }));
    }, CE = () => FC(_v), Nd = () => Ov(_v), LC = (i) => {
      i.fold(up, (m) => rb({ [Rf]: m }));
    }, Dv = () => FC(Rf), up = () => Ov(Rf), ab = (i) => An(lv(i), Ar(i)).filter(Z1), Rv = (i) => wv(lv(i), Ar(i)).filter(Z1), Jk = (i, m) => {
      const p = Ar(i), y = () => ab(i).each((qe) => {
        zl(qe, p).filter(oe(p)).each((dn) => {
          const Bn = vt.fromText("");
          if (li(dn, Bn), Xr(dn), i.dom.isEmpty(i.getBody()))
            i.setContent(""), i.selection.setCursorLocation();
          else {
            const Bt = i.dom.createRng();
            Bt.setStart(Bn.dom, 0), Bt.setEnd(Bn.dom, 0), i.selection.setRng(Bt), i.nodeChanged();
          }
        });
      }), E = (qe) => ab(i).each((dn) => {
        W1(i) || _d(i) || Af(i) || zl(dn, p).each((Bt) => {
          qe === "relative" && !aw(Bt) ? Ag(Bt) : qe === "fixed" && !K3(Bt) ? B2(Bt) : qe === "responsive" && !Y3(Bt) && yf(Bt), nu(Bt), zu(i, Bt.dom, Wr);
        });
      }), D = (qe) => zl(qe, p), $ = (qe) => Rv(i).bind((dn) => D(dn).map((Bn) => qe(Bn, dn))), z = (qe, dn) => {
        $((Bn) => {
          i.formatter.toggle("tableclass", { value: dn }, Bn.dom), zu(i, Bn.dom, Tv);
        });
      }, K = (qe, dn) => {
        $((Bn) => {
          const Bt = Wl(i), $o = ao(Bt, (Rn) => i.formatter.match("tablecellclass", { value: dn }, Rn.dom)) ? i.formatter.remove : i.formatter.apply;
          ue(Bt, (Rn) => $o("tablecellclass", { value: dn }, Rn.dom)), zu(i, Bn.dom, Tv);
        });
      }, ce = () => {
        ab(i).each((qe) => {
          zl(qe, p).each((dn) => {
            Ls(dn, "caption").fold(() => {
              const Bn = vt.fromTag("caption");
              Eo(Bn, vt.fromText("Caption")), Xy(dn, Bn, 0), i.selection.setCursorLocation(Bn.dom, 0);
            }, (Bn) => {
              $c("caption")(qe) && ri("td", dn).each((Bt) => i.selection.setCursorLocation(Bt.dom, 0)), Xr(Bn);
            }), zu(i, dn.dom, Wr);
          });
        });
      }, Ce = (qe) => {
        i.focus();
      }, Ge = (qe, dn = !1) => $((Bn, Bt) => {
        const Bo = xv(Wl(i), Bn, Bt);
        qe(Bn, Bo, dn).each(Ce);
      }), kt = () => $((qe, dn) => {
        const Bn = xv(Wl(i), qe, dn), Bt = xf(Xe, vt.fromDom(i.getDoc()), se.none());
        return Ci(qe, Bn, Bt);
      }), wt = () => $((qe, dn) => {
        const Bn = xv(Wl(i), qe, dn);
        return Mu(qe, Bn);
      }), Gt = (qe, dn) => (
        // If we have FakeClipboard rows to paste
        dn().each((Bn) => {
          const Bt = he(Bn, (Bo) => Ir(Bo));
          $((Bo, $o) => {
            const Rn = I2(vt.fromDom(i.getDoc())), br = bE(Wl(i), $o, Bt, Rn);
            qe(Bo, br).each(Ce);
          });
        })
      ), Fe = (qe) => (dn, Bn) => qa(Bn, "type").each((Bt) => {
        Ge(qe(Bt), Bn.no_events);
      });
      qn({
        mceTableSplitCells: () => Ge(m.unmergeCells),
        mceTableMergeCells: () => Ge(m.mergeCells),
        mceTableInsertRowBefore: () => Ge(m.insertRowsBefore),
        mceTableInsertRowAfter: () => Ge(m.insertRowsAfter),
        mceTableInsertColBefore: () => Ge(m.insertColumnsBefore),
        mceTableInsertColAfter: () => Ge(m.insertColumnsAfter),
        mceTableDeleteCol: () => Ge(m.deleteColumn),
        mceTableDeleteRow: () => Ge(m.deleteRow),
        mceTableCutCol: () => wt().each((qe) => {
          LC(qe), Ge(m.deleteColumn);
        }),
        mceTableCutRow: () => kt().each((qe) => {
          Vu(qe), Ge(m.deleteRow);
        }),
        mceTableCopyCol: () => wt().each((qe) => LC(qe)),
        mceTableCopyRow: () => kt().each((qe) => Vu(qe)),
        mceTablePasteColBefore: () => Gt(m.pasteColsBefore, Dv),
        mceTablePasteColAfter: () => Gt(m.pasteColsAfter, Dv),
        mceTablePasteRowBefore: () => Gt(m.pasteRowsBefore, CE),
        mceTablePasteRowAfter: () => Gt(m.pasteRowsAfter, CE),
        mceTableDelete: y,
        mceTableCellToggleClass: K,
        mceTableToggleClass: z,
        mceTableToggleCaption: ce,
        mceTableSizingMode: (qe, dn) => E(dn),
        mceTableCellType: Fe((qe) => qe === "th" ? m.makeCellsHeader : m.unmakeCellsHeader),
        mceTableColType: Fe((qe) => qe === "th" ? m.makeColumnsHeader : m.unmakeColumnsHeader),
        mceTableRowType: Fe((qe) => {
          switch (qe) {
            case "header":
              return m.makeRowsHeader;
            case "footer":
              return m.makeRowsFooter;
            default:
              return m.makeRowsBody;
          }
        })
      }, (qe, dn) => i.addCommand(dn, qe)), i.addCommand("mceInsertTable", (qe, dn) => {
        sb(i, dn.rows, dn.columns, dn.options);
      }), i.addCommand("mceTableApplyCellStyle", (qe, dn) => {
        const Bn = ($o) => "tablecell" + $o.toLowerCase().replace("-", "");
        if (!De(dn))
          return;
        const Bt = fn(Wl(i), Z1);
        if (Bt.length === 0)
          return;
        const Bo = jm(dn, ($o, Rn) => i.formatter.has(Bn(Rn)) && nn($o));
        vu(Bo) || (qn(Bo, ($o, Rn) => {
          const br = Bn(Rn);
          ue(Bt, (wi) => {
            $o === "" ? i.formatter.remove(br, { value: null }, wi.dom, !0) : i.formatter.apply(br, { value: $o }, wi.dom);
          });
        }), D(Bt[0]).each(($o) => zu(i, $o.dom, Tv)));
      });
    }, xE = (i, m) => {
      const p = Ar(i), y = (E) => wv(lv(i)).bind((D) => zl(D, p).map(($) => {
        const z = xv(Wl(i), $, D);
        return E($, z);
      })).getOr("");
      qn({
        mceTableRowType: () => y(m.getTableRowType),
        mceTableCellType: () => y(m.getTableCellType),
        mceTableColType: () => y(m.getTableColType)
      }, (E, D) => i.addQueryValueHandler(D, E));
    }, Nv = (i) => !mi(vt.fromDom(i.target), "ephox-snooker-resizer-bar"), eA = (i, m) => {
      const p = _k(() => vt.fromDom(i.getBody()), () => wv(lv(i), Ar(i)), Hg.selectedSelector), y = (K, ce, Ce) => {
        zl(ce).each((kt) => {
          const wt = he(K, (Bn) => Bn.dom), Gt = Lw(i), Fe = xf(Xe, vt.fromDom(i.getDoc()), Gt), qe = Wl(i), dn = _2(kt, { selection: qe }, Fe).map((Bn) => Io(Bn, (Bt) => he(Bt, (Bo) => Bo.dom))).getOrUndefined();
          ip(i, wt, ce.dom, Ce.dom, dn);
        });
      }, E = () => Yk(i), D = hE.byAttr(Hg, y, E);
      return i.on("init", (K) => {
        const ce = i.getWin(), Ce = cv(i), Ge = Ar(i), kt = () => {
          const Ko = i.selection, _c = vt.fromDom(Ko.getStart()), Ys = vt.fromDom(Ko.getEnd());
          Jo(zl, [_c, Ys]).fold(() => D.clear(Ce), Xe);
        }, wt = dE(ce, Ce, Ge, D), Gt = OC(ce, Ce, Ge, D), Fe = fE(ce, Ce, Ge, D), qe = (Ko) => Ko.raw.shiftKey === !0;
        i.on("TableSelectorChange", (Ko) => Fe(Ko.start, Ko.finish));
        const dn = (Ko, _c) => {
          qe(Ko) && (_c.kill && Ko.kill(), _c.selection.each((Ys) => {
            const ju = k.relative(Ys.start, Ys.finish), oc = at(ce, ju);
            i.selection.setRng(oc);
          }));
        }, Bn = (Ko) => {
          const _c = mr(Ko);
          if (_c.raw.shiftKey && Sm(_c.raw.which)) {
            const Ys = i.selection.getRng(), ju = vt.fromDom(Ys.startContainer), oc = vt.fromDom(Ys.endContainer);
            Gt.keyup(_c, ju, Ys.startOffset, oc, Ys.endOffset).each((Gl) => {
              dn(_c, Gl);
            });
          }
        }, Bt = (Ko) => {
          const _c = mr(Ko);
          m.hide();
          const Ys = i.selection.getRng(), ju = vt.fromDom(Ys.startContainer), oc = vt.fromDom(Ys.endContainer), Gl = hd(wm, uE)(vt.fromDom(i.selection.getStart()));
          Gt.keydown(_c, ju, Ys.startOffset, oc, Ys.endOffset, Gl).each((ka) => {
            dn(_c, ka);
          }), m.show();
        }, Bo = (Ko) => Ko.button === 0, $o = (Ko) => Ko.buttons === void 0 ? !0 : (Ko.buttons & 1) !== 0, Rn = (Ko) => {
          wt.clearstate();
        }, br = (Ko) => {
          Bo(Ko) && Nv(Ko) && wt.mousedown(mr(Ko));
        }, wi = (Ko) => {
          $o(Ko) && Nv(Ko) && wt.mouseover(mr(Ko));
        }, Em = (Ko) => {
          Bo(Ko) && Nv(Ko) && wt.mouseup(mr(Ko));
        }, Vg = (() => {
          const Ko = js(vt.fromDom(Ce)), _c = js(0);
          return {
            touchEnd: (ju) => {
              const oc = vt.fromDom(ju.target);
              if ($c("td")(oc) || $c("th")(oc)) {
                const Gl = Ko.get(), ka = _c.get();
                zo(Gl, oc) && ju.timeStamp - ka < 300 && (ju.preventDefault(), Fe(oc, oc));
              }
              Ko.set(oc), _c.set(ju.timeStamp);
            }
          };
        })();
        i.on("dragstart", Rn), i.on("mousedown", br), i.on("mouseover", wi), i.on("mouseup", Em), i.on("touchend", Vg.touchEnd), i.on("keyup", Bn), i.on("keydown", Bt), i.on("NodeChange", kt);
      }), i.on("PreInit", () => {
        i.serializer.addTempAttr(Hg.firstSelected), i.serializer.addTempAttr(Hg.lastSelected);
      }), {
        getSelectedCells: () => hC(
          p.get(),
          // No fake selected cells
          U([]),
          // This path is taken whenever there is fake cell selection even for just a single selected cell
          (K) => he(K, (ce) => ce.dom),
          // For this path, the start of the selection whether collapsed or ranged is within a table cell
          (K) => [K.dom]
        ),
        clearSelectedCells: (K) => D.clear(vt.fromDom(K))
      };
    }, HC = (i, m) => {
      const p = vt.fromDom(i.getBody());
      return ew.body(p, m);
    }, Uu = (i) => Cn(i) && i.nodeName === "TABLE", zC = "bar-", tA = (i) => Fc(i, "data-mce-resize") !== "false", SE = (i) => {
      const m = zn.fromTable(i);
      zn.hasColumns(m) || ue(lf(i), (p) => {
        const y = gd(p, "width");
        Jr(p, "width", y), Oo(p, "width");
      });
    }, wE = (i) => Ni(i, "corner-"), EE = (i) => Qd(i, "corner-"), nA = (i) => {
      const m = Or(), p = Or(), y = Or();
      let E, D, $, z;
      const K = (Bt) => $C(i, Bt), ce = () => rv(i) ? IS() : Eh(), Ce = (Bt) => O1(Bt).columns, Ge = (Bt) => O1(Bt).rows, kt = (Bt, Bo, $o, Rn) => {
        const br = EE(Bo), wi = ad(br, "e"), Em = Ni(br, "n");
        if (D === "" && Ag(Bt), z === "" && bl(Bt), $o !== E && D !== "") {
          Jr(Bt, "width", D);
          const Nf = ce(), Vg = K(Bt), Ko = rv(i) || wi ? Ce(Bt) - 1 : 0;
          Fh(Bt, $o - E, Ko, Nf, Vg);
        } else if (Gw(D)) {
          const Nf = parseFloat(D.replace("%", "")), Vg = $o * Nf / E;
          Jr(Bt, "width", Vg + "%");
        }
        if (qw(D) && SE(Bt), Rn !== $ && z !== "") {
          Jr(Bt, "height", z);
          const Nf = Em ? 0 : Ge(Bt) - 1;
          C0(Bt, Rn - $, Nf);
        }
      }, wt = () => {
        p.on((Bt) => {
          Bt.destroy();
        });
      };
      i.on("init", () => {
        const Bt = HC(i, tA);
        if (y.set(Bt), ov(i) && Hw(i)) {
          const Bo = ce(), $o = iC.create(Bt, Bo, K);
          i.mode.isReadOnly() || $o.on(), $o.events.startDrag.bind((Rn) => {
            m.set(i.selection.getRng());
          }), $o.events.beforeResize.bind((Rn) => {
            const br = Rn.table.dom;
            zg(i, br, jw(br), Ww(br), zC + Rn.type);
          }), $o.events.afterResize.bind((Rn) => {
            const br = Rn.table, wi = br.dom;
            nu(br), m.on((Em) => {
              i.selection.setRng(Em), i.focus();
            }), ob(i, wi, jw(wi), Ww(wi), zC + Rn.type), i.undoManager.add();
          }), p.set($o);
        }
      }), i.on("ObjectResizeStart", (Bt) => {
        const Bo = Bt.target;
        if (Uu(Bo) && !i.mode.isReadOnly()) {
          const $o = vt.fromDom(Bo);
          ue(i.dom.select(".mce-clonedresizable"), (Rn) => {
            i.dom.addClass(Rn, "mce-" + j1(i) + "-columns");
          }), !K3($o) && _d(i) ? B2($o) : !aw($o) && Af(i) && Ag($o), Y3($o) && Ni(Bt.origin, zC) && Ag($o), E = Bt.width, D = W1(i) ? "" : iv(i, Bo).getOr(""), $ = Bt.height, z = mC(i, Bo).getOr("");
        }
      }), i.on("ObjectResized", (Bt) => {
        const Bo = Bt.target;
        if (Uu(Bo)) {
          const $o = vt.fromDom(Bo), Rn = Bt.origin;
          wE(Rn) && kt($o, Rn, Bt.width, Bt.height), nu($o), zu(i, $o.dom, Tv);
        }
      });
      const Gt = () => {
        p.on((Bt) => {
          Bt.on(), Bt.showBars();
        });
      }, Fe = () => {
        p.on((Bt) => {
          Bt.off(), Bt.hideBars();
        });
      };
      return i.on("DisabledStateChange", (Bt) => {
        Bt.state ? Fe() : Gt();
      }), i.on("SwitchMode", () => {
        i.mode.isReadOnly() ? Fe() : Gt();
      }), i.on("dragstart dragend", (Bt) => {
        Bt.type === "dragstart" ? Fe() : Gt();
      }), i.on("remove", () => {
        wt();
      }), {
        refresh: (Bt) => {
          p.on((Bo) => Bo.refreshBars(vt.fromDom(Bt)));
        },
        hide: () => {
          p.on((Bt) => Bt.hideBars());
        },
        show: () => {
          p.on((Bt) => Bt.showBars());
        }
      };
    }, xs = (i) => {
      r5(i);
      const m = nA(i), p = eA(i, m), y = Of(i, m, p);
      return Jk(i, y), xE(i, y), PC(i, y), {
        getSelectedCells: p.getSelectedCells,
        clearSelectedCells: p.clearSelectedCells
      };
    }, Zl = (i) => ({
      table: xs(i)
    });
    var dp = () => {
      V.add("dom", Zl);
    };
    dp();
  }()), sQ;
}
var aQ;
function bJ() {
  return aQ || (aQ = 1, pJ()), oQ;
}
bJ();
var cQ = {}, lQ = {}, iQ;
function vJ() {
  return iQ || (iQ = 1, function() {
    var V = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const me = (We) => ({
      backspaceDelete: (st) => {
        We.execCommand("mceListBackspaceDelete", !1, st);
      }
    }), pt = (We) => We == null, rt = (We) => !pt(We), Nt = (We) => () => We, mt = (We, st) => We === st, nn = Nt(!1);
    class De {
      tag;
      value;
      // Sneaky optimisation: every instance of Optional.none is identical, so just
      // reuse the same object
      static singletonNone = new De(!1);
      // The internal representation has a `tag` and a `value`, but both are
      // private: able to be console.logged, but not able to be accessed by code
      constructor(st, ze) {
        this.tag = st, this.value = ze;
      }
      // --- Identities ---
      /**
       * Creates a new `Optional<T>` that **does** contain a value.
       */
      static some(st) {
        return new De(!0, st);
      }
      /**
       * Create a new `Optional<T>` that **does not** contain a value. `T` can be
       * any type because we don't actually have a `T`.
       */
      static none() {
        return De.singletonNone;
      }
      /**
       * Perform a transform on an `Optional` type. Regardless of whether this
       * `Optional` contains a value or not, `fold` will return a value of type `U`.
       * If this `Optional` does not contain a value, the `U` will be created by
       * calling `onNone`. If this `Optional` does contain a value, the `U` will be
       * created by calling `onSome`.
       *
       * For the FP enthusiasts in the room, this function:
       * 1. Could be used to implement all of the functions below
       * 2. Forms a catamorphism
       */
      fold(st, ze) {
        return this.tag ? ze(this.value) : st();
      }
      /**
       * Determine if this `Optional` object contains a value.
       */
      isSome() {
        return this.tag;
      }
      /**
       * Determine if this `Optional` object **does not** contain a value.
       */
      isNone() {
        return !this.tag;
      }
      // --- Functor (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value. If
       * you provide a function to turn a T into a U, this is the function you use
       * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
       * a value then the output will also contain a value (that value being the
       * output of `mapper(this.value)`), and if this **does not** contain a value
       * then neither will the output.
       */
      map(st) {
        return this.tag ? De.some(st(this.value)) : De.none();
      }
      // --- Monad (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value.
       * Unlike `map`, here the transform itself also returns an `Optional`.
       */
      bind(st) {
        return this.tag ? st(this.value) : De.none();
      }
      // --- Traversable (name stolen from Haskell / maths) ---
      /**
       * For a given predicate, this function finds out if there **exists** a value
       * inside this `Optional` object that meets the predicate. In practice, this
       * means that for `Optional`s that do not contain a value it returns false (as
       * no predicate-meeting value exists).
       */
      exists(st) {
        return this.tag && st(this.value);
      }
      /**
       * For a given predicate, this function finds out if **all** the values inside
       * this `Optional` object meet the predicate. In practice, this means that
       * for `Optional`s that do not contain a value it returns true (as all 0
       * objects do meet the predicate).
       */
      forall(st) {
        return !this.tag || st(this.value);
      }
      filter(st) {
        return !this.tag || st(this.value) ? this : De.none();
      }
      // --- Getters ---
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.
       */
      getOr(st) {
        return this.tag ? this.value : st;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.  Unlike `getOr`, in this method the `replacement` object is also
       * `Optional` - meaning that this method will always return an `Optional`.
       */
      or(st) {
        return this.tag ? this : st;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value. Unlike `getOr`, in this method the `replacement` value is
       * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
       * pass a function which (if called) will **return** the `value` you want to
       * use.
       */
      getOrThunk(st) {
        return this.tag ? this.value : st();
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided Optional object does not contain a
       * value.
       *
       * Unlike `or`, in this method the `replacement` value is "thunked" - that is
       * to say that you don't pass a value to `orThunk`, you pass a function which
       * (if called) will **return** the `value` you want to use.
       *
       * Unlike `getOrThunk`, in this method the `replacement` value is also
       * `Optional`, meaning that this method will always return an `Optional`.
       */
      orThunk(st) {
        return this.tag ? this : st();
      }
      /**
       * Get the value out of the inside of the `Optional` object, throwing an
       * exception if the provided `Optional` object does not contain a value.
       *
       * WARNING:
       * You should only be using this function if you know that the `Optional`
       * object **is not** empty (otherwise you're throwing exceptions in production
       * code, which is bad).
       *
       * In tests this is more acceptable.
       *
       * Prefer other methods to this, such as `.each`.
       */
      getOrDie(st) {
        if (this.tag)
          return this.value;
        throw new Error(st ?? "Called getOrDie on None");
      }
      // --- Interop with null and undefined ---
      /**
       * Creates an `Optional` value from a nullable (or undefined-able) input.
       * Null, or undefined, is converted to `None`, and anything else is converted
       * to `Some`.
       */
      static from(st) {
        return rt(st) ? De.some(st) : De.none();
      }
      /**
       * Converts an `Optional` to a nullable type, by getting the value if it
       * exists, or returning `null` if it does not.
       */
      getOrNull() {
        return this.tag ? this.value : null;
      }
      /**
       * Converts an `Optional` to an undefined-able type, by getting the value if
       * it exists, or returning `undefined` if it does not.
       */
      getOrUndefined() {
        return this.value;
      }
      // --- Utilities ---
      /**
       * If the `Optional` contains a value, perform an action on that value.
       * Unlike the rest of the methods on this type, `.each` has side-effects. If
       * you want to transform an `Optional<T>` **into** something, then this is not
       * the method for you. If you want to use an `Optional<T>` to **do**
       * something, then this is the method for you - provided you're okay with not
       * doing anything in the case where the `Optional` doesn't have a value inside
       * it. If you're not sure whether your use-case fits into transforming
       * **into** something or **doing** something, check whether it has a return
       * value. If it does, you should be performing a transform.
       */
      each(st) {
        this.tag && st(this.value);
      }
      /**
       * Turn the `Optional` object into an array that contains all of the values
       * stored inside the `Optional`. In practice, this means the output will have
       * either 0 or 1 elements.
       */
      toArray() {
        return this.tag ? [this.value] : [];
      }
      /**
       * Turn the `Optional` object into a string for debugging or printing. Not
       * recommended for production code, but good for debugging. Also note that
       * these days an `Optional` object can be logged to the console directly, and
       * its inner value (if it exists) will be visible.
       */
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    const et = Array.prototype.slice, Tt = (We, st) => {
      for (let ze = 0, no = We.length; ze < no; ze++) {
        const qn = We[ze];
        if (st(qn, ze))
          return !0;
      }
      return !1;
    }, $n = (We, st) => {
      const ze = We.length, no = new Array(ze);
      for (let qn = 0; qn < ze; qn++) {
        const Io = We[qn];
        no[qn] = st(Io, qn);
      }
      return no;
    }, Mt = (We, st) => {
      for (let ze = 0, no = We.length; ze < no; ze++) {
        const qn = We[ze];
        st(qn, ze);
      }
    }, vn = (We, st, ze) => (Mt(We, (no, qn) => {
      ze = st(ze, no, qn);
    }), ze), Cn = (We, st, ze) => {
      for (let no = 0, qn = We.length; no < qn; no++) {
        const Io = We[no];
        if (st(Io, no))
          return De.some(Io);
        if (ze(Io, no))
          break;
      }
      return De.none();
    }, pn = (We, st) => Cn(We, st, nn), un = (We) => {
      const st = et.call(We, 0);
      return st.reverse(), st;
    }, Xe = (We, st, ze = mt) => We.exists((no) => ze(no, st)), lt = ((We) => (st) => st.replace(We, ""))(/^\s+|\s+$/g), U = (We) => We.length > 0, Ye = (We) => !U(We), On = (We) => {
      const st = un(lt(We).split("")), ze = $n(st, (no, qn) => {
        const Io = no.toUpperCase().charCodeAt(0) - 65 + 1;
        return Math.pow(26, qn) * Io;
      });
      return vn(ze, (no, qn) => no + qn, 0);
    }, Ot = (We) => {
      if (We--, We < 0)
        return "";
      {
        const st = We % 26, ze = Math.floor(We / 26), no = Ot(ze), qn = String.fromCharCode(65 + st);
        return no + qn;
      }
    }, oe = (We) => /^[A-Z]+$/.test(We), Yt = (We) => /^[a-z]+$/.test(We), Gn = (We) => /^[0-9]+$/.test(We), jt = (We) => Gn(We) ? 2 : oe(We) ? 0 : Yt(We) ? 1 : Ye(We) ? 3 : 4, X = (We) => {
      switch (jt(We)) {
        case 2:
          return De.some({
            listStyleType: De.none(),
            start: We
          });
        case 0:
          return De.some({
            listStyleType: De.some("upper-alpha"),
            start: On(We).toString()
          });
        case 1:
          return De.some({
            listStyleType: De.some("lower-alpha"),
            start: On(We).toString()
          });
        case 3:
          return De.some({
            listStyleType: De.none(),
            start: ""
          });
        case 4:
          return De.none();
      }
    }, se = (We) => {
      const st = parseInt(We.start, 10);
      return Xe(We.listStyleType, "upper-alpha") ? Ot(st) : Xe(We.listStyleType, "lower-alpha") ? Ot(st).toLowerCase() : We.start;
    }, an = ((We) => (st) => st.options.get(We))("forced_root_block"), St = (We) => /\btox\-/.test(We.className), A = (We) => (st) => rt(st) && We.test(st.nodeName), No = (We) => (st) => rt(st) && st.nodeName.toLowerCase() === We, ot = A(/^(OL|UL|DL)$/), jo = A(/^(TH|TD)$/), he = A(/^(LI|DT|DD)$/), ue = (We, st) => Cn(We, ot, jo).exists((ze) => ze.nodeName === st && !St(ze)), bt = (We, st) => {
      const ze = We.selection.getNode();
      return st({
        parents: We.dom.getParents(ze),
        element: ze
      }), We.on("NodeChange", st), () => We.off("NodeChange", st);
    }, cn = (We, st) => st !== null && !We.dom.isEditable(st), fn = (We, st) => {
      const ze = We.dom.getParent(st, "ol,ul,dl");
      return cn(We, ze) || !We.selection.isEditable();
    }, Fn = No("ol"), ye = ["OL", "UL", "DL"], He = ye.join(","), P = (We, st) => {
      const ze = st || We.selection.getStart(!0);
      return We.dom.getParent(ze, He, ro(We, ze));
    }, ro = (We, st) => {
      const ze = We.dom.getParents(st, We.dom.isBlock), no = (Io) => Io.nodeName.toLowerCase() !== an(We);
      return pn(ze, (Io) => no(Io) && Ln(We.schema, Io)).getOr(We.getBody());
    }, Ln = (We, st) => !ot(st) && !he(st) && Tt(ye, (ze) => We.isValidChild(st.nodeName, ze)), oo = (We) => {
      const st = P(We);
      !Fn(st) || fn(We, st) || We.windowManager.open({
        title: "List Properties",
        body: {
          type: "panel",
          items: [
            {
              type: "input",
              name: "start",
              label: "Start list at number",
              inputMode: "numeric"
            }
          ]
        },
        initialData: {
          start: se({
            start: We.dom.getAttrib(st, "start", "1"),
            listStyleType: De.from(We.dom.getStyle(st, "list-style-type"))
          })
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        onSubmit: (ze) => {
          const no = ze.getData();
          X(no.start).each((qn) => {
            We.execCommand("mceListUpdate", !1, {
              attrs: {
                start: qn.start === "1" ? "" : qn.start
              },
              styles: {
                "list-style-type": qn.listStyleType.getOr("")
              }
            });
          }), ze.close();
        }
      });
    }, ao = (We) => {
      We.addCommand("mceListProps", () => {
        oo(We);
      });
    }, ur = (We, st) => (ze) => {
      const no = (qn) => {
        ze.setActive(ue(qn.parents, st)), ze.setEnabled(!fn(We, qn.element) && We.selection.isEditable());
      };
      return ze.setEnabled(We.selection.isEditable()), bt(We, no);
    }, Lt = (We) => {
      const st = (ze) => () => We.execCommand(ze);
      We.hasPlugin("advlist") || (We.ui.registry.addToggleButton("numlist", {
        icon: "ordered-list",
        active: !1,
        tooltip: "Numbered list",
        onAction: st("InsertOrderedList"),
        onSetup: ur(We, "OL")
      }), We.ui.registry.addToggleButton("bullist", {
        icon: "unordered-list",
        active: !1,
        tooltip: "Bullet list",
        onAction: st("InsertUnorderedList"),
        onSetup: ur(We, "UL")
      }));
    }, po = (We, st) => (ze) => bt(We, (qn) => ze.setEnabled(ue(qn.parents, st) && !fn(We, qn.element))), en = (We) => {
      const st = {
        text: "List properties...",
        icon: "ordered-list",
        onAction: () => We.execCommand("mceListProps"),
        onSetup: po(We, "OL")
      };
      We.ui.registry.addMenuItem("listprops", st), We.ui.registry.addContextMenu("lists", {
        update: (ze) => {
          const no = P(We, ze);
          return Fn(no) ? ["listprops"] : [];
        }
      });
    };
    var xe = () => {
      V.add("lists", (We) => (ao(We), Lt(We), en(We), me(We)));
    };
    xe();
  }()), lQ;
}
var uQ;
function yJ() {
  return uQ || (uQ = 1, vJ()), cQ;
}
yJ();
var dQ = {}, mQ = {}, fQ;
function CJ() {
  return fQ || (fQ = 1, function() {
    var V = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const me = (I, ee, fe) => fe(I, ee.prototype) ? !0 : I.constructor?.name === ee.name, pt = (I) => {
      const ee = typeof I;
      return I === null ? "null" : ee === "object" && Array.isArray(I) ? "array" : ee === "object" && me(I, String, (fe, _e) => _e.isPrototypeOf(fe)) ? "string" : ee;
    }, rt = (I) => (ee) => pt(ee) === I, Nt = (I) => (ee) => typeof ee === I, mt = (I) => (ee) => I === ee, nn = rt("string"), De = rt("object"), et = rt("array"), Tt = mt(null), $n = Nt("boolean"), Mt = (I) => I == null, vn = (I) => !Mt(I), Cn = Nt("function"), pn = (I, ee) => {
      if (et(I)) {
        for (let fe = 0, _e = I.length; fe < _e; ++fe)
          if (!ee(I[fe]))
            return !1;
        return !0;
      }
      return !1;
    }, un = () => {
    }, Xe = (I) => () => I, In = (I) => I, lt = (I, ee) => I === ee;
    class U {
      tag;
      value;
      // Sneaky optimisation: every instance of Optional.none is identical, so just
      // reuse the same object
      static singletonNone = new U(!1);
      // The internal representation has a `tag` and a `value`, but both are
      // private: able to be console.logged, but not able to be accessed by code
      constructor(ee, fe) {
        this.tag = ee, this.value = fe;
      }
      // --- Identities ---
      /**
       * Creates a new `Optional<T>` that **does** contain a value.
       */
      static some(ee) {
        return new U(!0, ee);
      }
      /**
       * Create a new `Optional<T>` that **does not** contain a value. `T` can be
       * any type because we don't actually have a `T`.
       */
      static none() {
        return U.singletonNone;
      }
      /**
       * Perform a transform on an `Optional` type. Regardless of whether this
       * `Optional` contains a value or not, `fold` will return a value of type `U`.
       * If this `Optional` does not contain a value, the `U` will be created by
       * calling `onNone`. If this `Optional` does contain a value, the `U` will be
       * created by calling `onSome`.
       *
       * For the FP enthusiasts in the room, this function:
       * 1. Could be used to implement all of the functions below
       * 2. Forms a catamorphism
       */
      fold(ee, fe) {
        return this.tag ? fe(this.value) : ee();
      }
      /**
       * Determine if this `Optional` object contains a value.
       */
      isSome() {
        return this.tag;
      }
      /**
       * Determine if this `Optional` object **does not** contain a value.
       */
      isNone() {
        return !this.tag;
      }
      // --- Functor (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value. If
       * you provide a function to turn a T into a U, this is the function you use
       * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
       * a value then the output will also contain a value (that value being the
       * output of `mapper(this.value)`), and if this **does not** contain a value
       * then neither will the output.
       */
      map(ee) {
        return this.tag ? U.some(ee(this.value)) : U.none();
      }
      // --- Monad (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value.
       * Unlike `map`, here the transform itself also returns an `Optional`.
       */
      bind(ee) {
        return this.tag ? ee(this.value) : U.none();
      }
      // --- Traversable (name stolen from Haskell / maths) ---
      /**
       * For a given predicate, this function finds out if there **exists** a value
       * inside this `Optional` object that meets the predicate. In practice, this
       * means that for `Optional`s that do not contain a value it returns false (as
       * no predicate-meeting value exists).
       */
      exists(ee) {
        return this.tag && ee(this.value);
      }
      /**
       * For a given predicate, this function finds out if **all** the values inside
       * this `Optional` object meet the predicate. In practice, this means that
       * for `Optional`s that do not contain a value it returns true (as all 0
       * objects do meet the predicate).
       */
      forall(ee) {
        return !this.tag || ee(this.value);
      }
      filter(ee) {
        return !this.tag || ee(this.value) ? this : U.none();
      }
      // --- Getters ---
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.
       */
      getOr(ee) {
        return this.tag ? this.value : ee;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.  Unlike `getOr`, in this method the `replacement` object is also
       * `Optional` - meaning that this method will always return an `Optional`.
       */
      or(ee) {
        return this.tag ? this : ee;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value. Unlike `getOr`, in this method the `replacement` value is
       * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
       * pass a function which (if called) will **return** the `value` you want to
       * use.
       */
      getOrThunk(ee) {
        return this.tag ? this.value : ee();
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided Optional object does not contain a
       * value.
       *
       * Unlike `or`, in this method the `replacement` value is "thunked" - that is
       * to say that you don't pass a value to `orThunk`, you pass a function which
       * (if called) will **return** the `value` you want to use.
       *
       * Unlike `getOrThunk`, in this method the `replacement` value is also
       * `Optional`, meaning that this method will always return an `Optional`.
       */
      orThunk(ee) {
        return this.tag ? this : ee();
      }
      /**
       * Get the value out of the inside of the `Optional` object, throwing an
       * exception if the provided `Optional` object does not contain a value.
       *
       * WARNING:
       * You should only be using this function if you know that the `Optional`
       * object **is not** empty (otherwise you're throwing exceptions in production
       * code, which is bad).
       *
       * In tests this is more acceptable.
       *
       * Prefer other methods to this, such as `.each`.
       */
      getOrDie(ee) {
        if (this.tag)
          return this.value;
        throw new Error(ee ?? "Called getOrDie on None");
      }
      // --- Interop with null and undefined ---
      /**
       * Creates an `Optional` value from a nullable (or undefined-able) input.
       * Null, or undefined, is converted to `None`, and anything else is converted
       * to `Some`.
       */
      static from(ee) {
        return vn(ee) ? U.some(ee) : U.none();
      }
      /**
       * Converts an `Optional` to a nullable type, by getting the value if it
       * exists, or returning `null` if it does not.
       */
      getOrNull() {
        return this.tag ? this.value : null;
      }
      /**
       * Converts an `Optional` to an undefined-able type, by getting the value if
       * it exists, or returning `undefined` if it does not.
       */
      getOrUndefined() {
        return this.value;
      }
      // --- Utilities ---
      /**
       * If the `Optional` contains a value, perform an action on that value.
       * Unlike the rest of the methods on this type, `.each` has side-effects. If
       * you want to transform an `Optional<T>` **into** something, then this is not
       * the method for you. If you want to use an `Optional<T>` to **do**
       * something, then this is the method for you - provided you're okay with not
       * doing anything in the case where the `Optional` doesn't have a value inside
       * it. If you're not sure whether your use-case fits into transforming
       * **into** something or **doing** something, check whether it has a return
       * value. If it does, you should be performing a transform.
       */
      each(ee) {
        this.tag && ee(this.value);
      }
      /**
       * Turn the `Optional` object into an array that contains all of the values
       * stored inside the `Optional`. In practice, this means the output will have
       * either 0 or 1 elements.
       */
      toArray() {
        return this.tag ? [this.value] : [];
      }
      /**
       * Turn the `Optional` object into a string for debugging or printing. Not
       * recommended for production code, but good for debugging. Also note that
       * these days an `Optional` object can be logged to the console directly, and
       * its inner value (if it exists) will be visible.
       */
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    const Ye = Array.prototype.indexOf, On = Array.prototype.push, Ot = (I, ee) => Ye.call(I, ee), oe = (I, ee) => Ot(I, ee) > -1, Yt = (I, ee) => {
      const fe = I.length, _e = new Array(fe);
      for (let it = 0; it < fe; it++) {
        const It = I[it];
        _e[it] = ee(It, it);
      }
      return _e;
    }, Gn = (I, ee) => {
      for (let fe = 0, _e = I.length; fe < _e; fe++) {
        const it = I[fe];
        ee(it, fe);
      }
    }, jt = (I, ee, fe) => (Gn(I, (_e, it) => {
      fe = ee(fe, _e, it);
    }), fe), X = (I) => {
      const ee = [];
      for (let fe = 0, _e = I.length; fe < _e; ++fe) {
        if (!et(I[fe]))
          throw new Error("Arr.flatten item " + fe + " was not an array, input: " + I);
        On.apply(ee, I[fe]);
      }
      return ee;
    }, se = (I, ee) => X(Yt(I, ee)), ns = (I, ee) => ee >= 0 && ee < I.length ? U.some(I[ee]) : U.none(), an = (I) => ns(I, 0), St = (I, ee) => {
      for (let fe = 0; fe < I.length; fe++) {
        const _e = ee(I[fe], fe);
        if (_e.isSome())
          return _e;
      }
      return U.none();
    }, A = Object.keys, No = Object.hasOwnProperty, ot = (I, ee) => {
      const fe = A(I);
      for (let _e = 0, it = fe.length; _e < it; _e++) {
        const It = fe[_e], Mn = I[It];
        ee(Mn, It);
      }
    }, jo = (I) => (ee, fe) => {
      I[fe] = ee;
    }, he = (I, ee, fe, _e) => {
      ot(I, (it, It) => {
        (ee(it, It) ? fe : _e)(it, It);
      });
    }, ue = (I, ee) => {
      const fe = {};
      return he(I, ee, jo(fe), un), fe;
    }, bt = (I, ee) => No.call(I, ee), cn = (I, ee) => bt(I, ee) && I[ee] !== void 0 && I[ee] !== null, fn = (I) => {
      let ee = I;
      return {
        get: () => ee,
        set: (it) => {
          ee = it;
        }
      };
    }, Fn = (I, ee, fe = lt) => I.exists((_e) => fe(_e, ee)), ye = (I) => {
      const ee = [], fe = (_e) => {
        ee.push(_e);
      };
      for (let _e = 0; _e < I.length; _e++)
        I[_e].each(fe);
      return ee;
    }, He = (I, ee) => I ? U.some(ee) : U.none(), P = (I) => {
      const ee = fn(U.none()), fe = () => ee.get().each(I);
      return {
        clear: () => {
          fe(), ee.set(U.none());
        },
        isSet: () => ee.get().isSome(),
        get: () => ee.get(),
        set: (wo) => {
          fe(), ee.set(U.some(wo));
        }
      };
    }, ro = () => {
      const I = P(un);
      return {
        ...I,
        on: (fe) => I.get().each(fe)
      };
    }, Ln = (I, ee) => I.substring(ee), oo = (I, ee, fe) => ee === "" || I.length >= ee.length && I.substr(fe, fe + ee.length) === ee, ao = (I, ee) => ur(I, ee) ? Ln(I, ee.length) : I, ur = (I, ee) => oo(I, ee, 0), Lt = (I) => (ee) => ee.options.get(I), po = (I) => {
      const ee = I.options.register;
      ee("link_assume_external_targets", {
        processor: (fe) => {
          const _e = nn(fe) || $n(fe);
          return _e ? fe === !0 ? { value: 1, valid: _e } : fe === "http" || fe === "https" ? { value: fe, valid: _e } : { value: 0, valid: _e } : { valid: !1, message: "Must be a string or a boolean." };
        },
        default: !1
      }), ee("link_context_toolbar", {
        processor: "boolean",
        default: !1
      }), ee("link_list", {
        processor: (fe) => nn(fe) || Cn(fe) || pn(fe, De)
      }), ee("link_default_target", {
        processor: "string"
      }), ee("link_default_protocol", {
        processor: "string",
        default: "https"
      }), ee("link_target_list", {
        processor: (fe) => $n(fe) || pn(fe, De),
        default: !0
      }), ee("link_rel_list", {
        processor: "object[]",
        default: []
      }), ee("link_class_list", {
        processor: "object[]",
        default: []
      }), ee("link_title", {
        processor: "boolean",
        default: !0
      }), ee("allow_unsafe_link_target", {
        processor: "boolean",
        default: !1
      }), ee("link_quicklink", {
        processor: "boolean",
        default: !1
      }), ee("link_attributes_postprocess", {
        processor: "function"
      }), ee("files_upload_handler", {
        processor: "function"
      }), ee("link_uploadtab", {
        processor: "boolean",
        default: !0
      });
    }, en = Lt("link_assume_external_targets"), xe = Lt("link_context_toolbar"), We = Lt("link_list"), st = Lt("link_default_target"), ze = Lt("link_default_protocol"), no = Lt("link_target_list"), qn = Lt("link_rel_list"), Io = Lt("link_class_list"), Jc = Lt("link_title"), _o = Lt("allow_unsafe_link_target"), Ql = Lt("link_quicklink"), jm = Lt("link_attributes_postprocess"), ga = Lt("files_upload_handler"), xo = Lt("link_uploadtab"), qa = Lt("documents_file_types"), ds = (I) => vn(I.options.get("files_upload_handler")), Bs = (I) => vn(I.options.get("documents_file_types"));
    var vu = tinymce.util.Tools.resolve("tinymce.util.URI"), Tl = tinymce.util.Tools.resolve("tinymce.dom.TreeWalker"), Gr = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const js = (I) => vn(I) && I.nodeName.toLowerCase() === "a", dr = (I) => js(I) && !!Ka(I), rs = (I, ee) => {
      if (I.collapsed)
        return [];
      {
        const fe = I.cloneContents(), _e = fe.firstChild, it = new Tl(_e, fe), It = [];
        let Mn = _e;
        do
          ee(Mn) && It.push(Mn);
        while (Mn = it.next());
        return It;
      }
    }, cc = (I) => /^\w+:/i.test(I), Ka = (I) => I.getAttribute("data-mce-href") ?? I.getAttribute("href") ?? "", Vt = (I, ee) => {
      const fe = ["noopener"], _e = I ? I.split(/\s+/) : [], it = (co) => Gr.trim(co.sort().join(" ")), It = (co) => (co = Mn(co), co.length > 0 ? co.concat(fe) : fe), Mn = (co) => co.filter((ba) => Gr.inArray(fe, ba) === -1), wo = ee ? It(_e) : Mn(_e);
      return wo.length > 0 ? it(wo) : "";
    }, mo = (I) => I.replace(/\uFEFF/g, ""), Un = (I, ee) => (ee = ee || Pt(I.selection.getRng())[0] || I.selection.getNode(), Pa(ee) ? U.from(I.dom.select("a[href]", ee)[0]) : U.from(I.dom.getParent(ee, "a[href]"))), lc = (I, ee) => Un(I, ee).isSome(), Ma = (I, ee) => {
      const fe = ee.fold(() => I.getContent({ format: "text" }), (_e) => _e.innerText || _e.textContent || "");
      return mo(fe);
    }, Pt = (I) => rs(I, dr), Di = (I) => Gr.grep(I, dr), as = (I) => Di(I).length > 0, Ri = (I) => Pt(I).length > 0, ic = (I) => {
      const ee = I.schema.getTextInlineElements(), fe = (It) => It.nodeType === 1 && !js(It) && !bt(ee, It.nodeName.toLowerCase());
      if (Un(I).exists((It) => It.hasAttribute("data-mce-block")))
        return !1;
      const it = I.selection.getRng();
      return it.collapsed ? !0 : rs(it, fe).length === 0;
    }, Pa = (I) => vn(I) && I.nodeName === "FIGURE" && /\bimage\b/i.test(I.className), Wo = (I) => new Promise((ee, fe) => {
      const _e = new FileReader();
      _e.onload = () => {
        ee(_e.result);
      }, _e.onerror = () => {
        fe(new Error(_e.error?.message ?? "Failed to convert blob to a data url"));
      }, _e.readAsDataURL(I);
    }), kn = (I) => jt(["title", "rel", "class", "target"], (fe, _e) => (I[_e].each((it) => {
      fe[_e] = it.length > 0 ? it : null;
    }), fe), {
      href: I.href
    }), Zo = (I, ee) => (ee === "http" || ee === "https") && !cc(I) ? ee + "://" + I : I, rd = (I, ee) => {
      const fe = { ...ee };
      if (qn(I).length === 0 && !_o(I)) {
        const _e = Vt(fe.rel, fe.target === "_blank");
        fe.rel = _e || null;
      }
      return U.from(fe.target).isNone() && no(I) === !1 && (fe.target = st(I)), fe.href = Zo(fe.href, en(I)), fe;
    }, yu = (I, ee, fe, _e) => {
      fe.each((It) => {
        bt(ee, "innerText") ? ee.innerText = It : ee.textContent = It;
      }), I.dom.setAttribs(ee, _e);
      const it = I.dom.createRng();
      it.setStartAfter(ee), it.setEndAfter(ee), I.selection.setRng(it);
    }, el = (I, ee, fe, _e) => {
      const it = I.dom;
      Pa(ee) ? ad(it, ee, _e) : fe.fold(() => {
        I.execCommand("mceInsertLink", !1, _e);
        const It = I.selection.getEnd(), Mn = it.createRng();
        Mn.setStartAfter(It), Mn.setEndAfter(It), I.selection.setRng(Mn);
      }, (It) => {
        I.insertContent(it.createHTML("a", _e, it.encode(It)));
      });
    }, Wt = (I, ee, fe) => {
      const _e = I.selection.getNode(), it = Un(I, _e), It = rd(I, kn(fe)), Mn = jm(I);
      vn(Mn) && Mn(It), I.undoManager.transact(() => {
        fe.href === ee.href && ee.attach(), it.fold(() => {
          el(I, _e, fe.text, It);
        }, (wo) => {
          I.focus(), yu(I, wo, fe.text, It);
        });
      });
    }, Ba = (I) => {
      const ee = I.dom, fe = I.selection, _e = fe.getBookmark(), it = fe.getRng().cloneRange(), It = ee.getParent(it.startContainer, "a[href]", I.getBody()), Mn = ee.getParent(it.endContainer, "a[href]", I.getBody());
      It && it.setStartBefore(It), Mn && it.setEndAfter(Mn), fe.setRng(it), I.execCommand("unlink"), fe.moveToBookmark(_e);
    }, Or = (I) => {
      I.undoManager.transact(() => {
        const ee = I.selection.getNode();
        Pa(ee) ? Ni(I, ee) : Ba(I), I.focus();
      });
    }, Wm = (I) => {
      const { class: ee, href: fe, rel: _e, target: it, text: It, title: Mn } = I;
      return ue({
        class: ee.getOrNull(),
        href: fe,
        rel: _e.getOrNull(),
        target: it.getOrNull(),
        text: It.getOrNull(),
        title: Mn.getOrNull()
      }, (wo, co) => Tt(wo) === !1);
    }, xr = (I, ee) => {
      const fe = I.options.get, _e = {
        allow_html_data_urls: fe("allow_html_data_urls"),
        allow_script_urls: fe("allow_script_urls"),
        allow_svg_data_urls: fe("allow_svg_data_urls")
      }, it = ee.href;
      return {
        ...ee,
        href: vu.isDomSafe(it, "a", _e) ? it : ""
      };
    }, Qd = (I, ee, fe) => {
      const _e = xr(I, fe);
      I.hasPlugin("rtc", !0) ? I.execCommand("createlink", !1, Wm(_e)) : Wt(I, ee, _e);
    }, os = (I) => {
      I.hasPlugin("rtc", !0) ? I.execCommand("unlink") : Or(I);
    }, Ni = (I, ee) => {
      const fe = I.dom.select("img", ee)[0];
      if (fe) {
        const _e = I.dom.getParents(fe, "a[href]", ee)[0];
        _e && (_e.parentNode?.insertBefore(fe, _e), I.dom.remove(_e));
      }
    }, ad = (I, ee, fe) => {
      const _e = I.select("img", ee)[0];
      if (_e) {
        const it = I.create("a", fe);
        _e.parentNode?.insertBefore(it, _e), it.appendChild(_e);
      }
    }, Jl = (I) => nn(I.value) ? I.value : "", Nc = (I) => nn(I.text) ? I.text : nn(I.title) ? I.title : "", nr = (I, ee) => {
      const fe = [];
      return Gr.each(I, (_e) => {
        const it = Nc(_e);
        if (_e.menu !== void 0) {
          const It = nr(_e.menu, ee);
          fe.push({ text: it, items: It });
        } else {
          const It = ee(_e);
          fe.push({ text: it, value: It });
        }
      }), fe;
    }, Mi = (I = Jl) => (ee) => U.from(ee).map((fe) => nr(fe, I)), Ya = {
      sanitize: (I) => Mi(Jl)(I),
      sanitizeWith: Mi,
      createUi: (I, ee) => (fe) => ({
        name: I,
        type: "listbox",
        label: ee,
        items: fe
      }),
      getValue: Jl
    }, xu = (I) => cn(I, "items"), kl = (I, ee) => St(ee, (fe) => xu(fe) ? kl(I, fe.items) : He(fe.value === I, fe)), Ho = (I, ee, fe, _e) => {
      const it = _e[ee], It = I.length > 0;
      return it !== void 0 ? kl(it, fe).map((Mn) => ({
        url: {
          value: Mn.value,
          meta: {
            text: It ? I : Mn.text,
            attach: un
          }
        },
        text: It ? I : Mn.text
      })) : U.none();
    }, cd = (I, ee) => ee === "link" ? I.link : ee === "anchor" ? I.anchor : U.none(), Xs = {
      init: (I, ee) => {
        const fe = {
          text: I.text,
          title: I.title
        }, _e = (co) => He(fe.title.length <= 0, U.from(co.meta?.title).getOr("")), it = (co) => He(fe.text.length <= 0, U.from(co.meta?.text).getOr(co.value)), It = (co) => {
          const ba = it(co.url), Ws = _e(co.url);
          return ba.isSome() || Ws.isSome() ? U.some({
            ...ba.map((Eu) => ({ text: Eu })).getOr({}),
            ...Ws.map((Eu) => ({ title: Eu })).getOr({})
          }) : U.none();
        }, Mn = (co, ba) => {
          const Ws = cd(ee, ba).getOr([]);
          return Ho(fe.text, ba, Ws, co);
        };
        return {
          onChange: (co, ba) => {
            const Ws = ba.name;
            return Ws === "url" ? It(co()) : oe(["anchor", "link"], Ws) ? Mn(co(), Ws) : ((Ws === "text" || Ws === "title") && (fe[Ws] = co()[Ws]), U.none());
          }
        };
      },
      getDelta: Ho
    };
    var Al = tinymce.util.Tools.resolve("tinymce.util.Delay");
    const ld = (I, ee, fe) => {
      const _e = I.selection.getRng();
      Al.setEditorTimeout(I, () => {
        I.windowManager.confirm(ee, (it) => {
          I.selection.setRng(_e), fe(it);
        });
      });
    }, $a = (I) => {
      const ee = I.href;
      return ee.indexOf("@") > 0 && ee.indexOf("/") === -1 && ee.indexOf("mailto:") === -1 ? U.some({
        message: "The URL you entered seems to be an email address. Do you want to add the required mailto: prefix?",
        preprocess: (_e) => ({ ..._e, href: "mailto:" + ee })
      }) : U.none();
    }, Pr = (I, ee) => (fe) => {
      const _e = fe.href;
      return I === 1 && !cc(_e) || I === 0 && /^\s*www(\.|\d\.)/i.test(_e) ? U.some({
        message: `The URL you entered seems to be an external link. Do you want to add the required ${ee}:// prefix?`,
        preprocess: (It) => ({ ...It, href: ee + "://" + _e })
      }) : U.none();
    }, Br = {
      preprocess: (I, ee) => St([$a, Pr(en(I), ze(I))], (fe) => fe(ee)).fold(() => Promise.resolve(ee), (fe) => new Promise((_e) => {
        ld(I, fe.message, (it) => {
          _e(it ? fe.preprocess(ee) : ee);
        });
      }))
    }, Jd = {
      getAnchors: (I) => {
        const ee = I.dom.select("a:not([href])"), fe = se(ee, (_e) => {
          const it = _e.name || _e.id;
          return it ? [{ text: it, value: "#" + it }] : [];
        });
        return fe.length > 0 ? U.some([{ text: "None", value: "" }].concat(fe)) : U.none();
      }
    }, _l = {
      getClasses: (I) => {
        const ee = Io(I);
        return ee.length > 0 ? Ya.sanitize(ee) : U.none();
      }
    }, ei = (I) => {
      try {
        return U.some(JSON.parse(I));
      } catch {
        return U.none();
      }
    }, As = {
      getLinks: (I) => {
        const ee = (_e) => I.convertURL(_e.value || _e.url || "", "href"), fe = We(I);
        return new Promise((_e) => {
          nn(fe) ? fetch(fe).then((it) => it.ok ? it.text().then(ei) : Promise.reject()).then(_e, () => _e(U.none())) : Cn(fe) ? fe((it) => _e(U.some(it))) : _e(U.from(fe));
        }).then((_e) => _e.bind(Ya.sanitizeWith(ee)).map((it) => it.length > 0 ? [{ text: "None", value: "" }].concat(it) : it));
      }
    }, qr = {
      getRels: (I, ee) => {
        const fe = qn(I);
        if (fe.length > 0) {
          const _e = Fn(ee, "_blank"), it = _o(I) === !1, It = (wo) => Vt(Ya.getValue(wo), _e);
          return (it ? Ya.sanitizeWith(It) : Ya.sanitize)(fe);
        }
        return U.none();
      }
    }, Kr = [
      { text: "Current window", value: "" },
      { text: "New window", value: "_blank" }
    ], em = {
      getTargets: (I) => {
        const ee = no(I);
        return et(ee) ? Ya.sanitize(ee).orThunk(() => U.some(Kr)) : ee === !1 ? U.none() : U.some(Kr);
      }
    }, Pi = (I, ee, fe) => {
      const _e = I.getAttrib(ee, fe);
      return _e !== null && _e.length > 0 ? U.some(_e) : U.none();
    }, ms = (I, ee) => {
      const fe = I.dom, it = ic(I) ? U.some(Ma(I.selection, ee)) : U.none(), It = ee.bind((Ws) => U.from(fe.getAttrib(Ws, "href"))), Mn = ee.bind((Ws) => U.from(fe.getAttrib(Ws, "target"))), wo = ee.bind((Ws) => Pi(fe, Ws, "rel")), co = ee.bind((Ws) => Pi(fe, Ws, "class")), ba = ee.bind((Ws) => Pi(fe, Ws, "title"));
      return {
        url: It,
        text: it,
        title: ba,
        target: Mn,
        rel: wo,
        linkClass: co
      };
    }, nl = {
      collect: (I, ee) => As.getLinks(I).then((fe) => {
        const _e = ds(I) && Bs(I) && xo(I), it = ms(I, ee);
        return {
          anchor: it,
          catalogs: {
            targets: em.getTargets(I),
            // This should be initial target. Is anchor.target that?
            rels: qr.getRels(I, it.target),
            classes: _l.getClasses(I),
            anchor: Jd.getAnchors(I),
            link: fe
          },
          hasUploadPanel: _e,
          optNode: ee,
          flags: {
            titleEnabled: Jc(I)
          }
        };
      })
    }, vt = {
      makeTab: (I) => ({
        title: "Upload",
        name: "upload",
        items: [
          {
            type: "dropzone",
            name: "fileinput",
            buttonLabel: "Browse for a file",
            dropAreaLabel: "Drop a file here",
            allowedFileTypes: I.map((fe) => fe.mimeType).join(","),
            allowedFileExtensions: X(I.map((fe) => fe.extensions))
          }
        ]
      })
    }, ni = (I, ee) => (fe) => {
      const _e = fe.getData();
      if (!_e.url.value) {
        os(I), fe.close();
        return;
      }
      const it = (wo) => U.from(_e[wo]).filter((co) => !Fn(ee.anchor[wo], co)), It = {
        href: _e.url.value,
        text: it("text"),
        target: it("target"),
        rel: it("rel"),
        class: it("linkClass"),
        title: it("title")
      }, Mn = {
        href: _e.url.value,
        attach: _e.url.meta !== void 0 && _e.url.meta.attach ? _e.url.meta.attach : un
      };
      Br.preprocess(I, It).then((wo) => {
        Qd(I, Mn, wo);
      }), fe.close();
    }, ha = (I) => (ee, fe) => ga(I)(ee, fe), Pc = (I) => U.from(I.split(",")[1]).getOr(""), $s = (I, ee) => {
      const fe = ee.getData();
      ee.block("Uploading file"), an(fe.fileinput).fold(() => {
        ee.unblock();
      }, (_e) => {
        const it = URL.createObjectURL(_e), It = ({ url: wo, fileName: co }) => {
          ee.setData({ text: co, title: co, url: { value: wo, meta: {} } }), ee.showTab("general"), ee.focus("url");
        }, Mn = () => {
          ee.unblock(), URL.revokeObjectURL(it);
        };
        Wo(_e).then((wo) => {
          const co = I.getExistingBlobInfo(Pc(wo), _e.type), ba = co && co.filename() === _e.name ? co : I.createBlobCache(_e, it, wo);
          return I.addToBlobCache(ba), I.uploadFile(ba, In);
        }).then((wo) => {
          It(wo), Mn();
        }).catch((wo) => {
          Mn(), I.alertErr(wo, () => {
            ee.focus("fileinput");
          });
        });
      });
    }, eg = (I) => (ee, fe, _e) => I.editorUpload.blobCache.create({
      blob: ee,
      blobUri: fe,
      name: ee.name?.replace(/\.[^\.]+$/, ""),
      filename: ee.name,
      base64: _e.split(",")[1]
    }), Xa = (I) => (ee) => {
      I.editorUpload.blobCache.add(ee);
    }, Bc = (I) => (ee, fe) => I.editorUpload.blobCache.getByData(ee, fe), Gm = (I) => (ee, fe) => {
      I.windowManager.alert(ee, fe);
    }, tg = (I) => {
      const ee = Un(I);
      return nl.collect(I, ee);
    }, oi = (I, ee) => {
      const fe = I.anchor, _e = fe.url.getOr("");
      return {
        url: {
          value: _e,
          meta: {
            original: {
              value: _e
            }
          }
        },
        text: fe.text.getOr(""),
        title: fe.title.getOr(""),
        anchor: _e,
        link: _e,
        rel: fe.rel.getOr(""),
        target: fe.target.or(ee).getOr(""),
        linkClass: fe.linkClass.getOr(""),
        fileinput: []
      };
    }, ng = (I, ee, fe, _e, it, It) => {
      const Mn = X([
        I,
        ee,
        fe,
        ye([
          _e.anchor.map(Ya.createUi("anchor", "Anchors")),
          _e.rels.map(Ya.createUi("rel", "Rel")),
          _e.targets.map(Ya.createUi("target", "Open link in...")),
          _e.link.map(Ya.createUi("link", "Link list")),
          _e.classes.map(Ya.createUi("linkClass", "Class"))
        ])
      ]);
      return it ? {
        type: "tabpanel",
        tabs: X([
          [{
            title: "General",
            name: "general",
            items: Mn
          }],
          [vt.makeTab(It)]
        ])
      } : {
        type: "panel",
        items: Mn
      };
    }, Su = (I, ee, fe) => {
      const _e = [
        {
          name: "url",
          type: "urlinput",
          filetype: "file",
          label: "URL",
          picker_text: "Browse links"
        }
      ], it = I.anchor.text.map(() => ({
        name: "text",
        type: "input",
        label: "Text to display"
      })).toArray(), It = I.flags.titleEnabled ? [
        {
          name: "title",
          type: "input",
          label: "Title"
        }
      ] : [], Mn = U.from(st(fe)), wo = oi(I, Mn), co = I.catalogs, ba = Xs.init(wo, co), Ws = ng(_e, it, It, co, I.hasUploadPanel, qa(fe)), Eu = {
        addToBlobCache: Xa(fe),
        createBlobCache: eg(fe),
        alertErr: Gm(fe),
        uploadFile: ha(fe),
        getExistingBlobInfo: Bc(fe)
      };
      return {
        title: "Insert/Edit Link",
        size: "normal",
        body: Ws,
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: wo,
        onChange: (qm, { name: nm }) => {
          nm === "fileinput" ? $s(Eu, qm) : ba.onChange(qm.getData, { name: nm }).each((Dl) => {
            qm.setData(Dl);
          });
        },
        onSubmit: ee
      };
    }, si = (I) => {
      tg(I).then((fe) => {
        const _e = ni(I, fe);
        return Su(fe, _e, I);
      }).then((fe) => {
        I.windowManager.open(fe);
      });
    }, wu = (I) => {
      I.addCommand("mceLink", (ee, fe) => {
        fe?.dialog === !0 || !Ql(I) ? si(I) : I.dispatch("contexttoolbar-show", {
          toolbarKey: "quicklink"
        });
      });
    }, at = (I) => {
      I.addShortcut("Meta+K", "", () => {
        I.execCommand("mceLink");
      });
    };
    var Bi = tinymce.util.Tools.resolve("tinymce.util.VK");
    const tm = (I, ee) => {
      document.body.appendChild(I), I.dispatchEvent(ee), document.body.removeChild(I);
    }, ol = (I) => {
      const ee = document.createElement("a");
      ee.target = "_blank", ee.href = I, ee.rel = "noreferrer noopener";
      const fe = new MouseEvent("click", {
        bubbles: !0,
        cancelable: !0,
        view: window
      });
      document.dispatchEvent(fe), tm(ee, fe);
    }, dc = (I) => I.altKey === !0 && I.shiftKey === !1 && I.ctrlKey === !1 && I.metaKey === !1, id = (I, ee) => {
      if (ee) {
        const fe = Ka(ee);
        if (/^#/.test(fe)) {
          const _e = I.dom.select(`${fe},[name="${ao(fe, "#")}"]`);
          _e.length && I.selection.scrollIntoView(_e[0], !0);
        } else
          ol(ee.href);
      }
    }, pa = (I) => {
      const ee = I.selection.getRng(), fe = ee.startContainer;
      return dr(fe) && ee.startContainer === ee.endContainer && I.dom.select("img", fe).length === 1;
    }, Ol = (I, ee) => {
      const fe = Di(I.dom.getParents(ee));
      return He(fe.length === 1, fe[0]);
    }, $i = (I) => {
      const ee = Pt(I.selection.getRng());
      return He(ee.length > 0, ee[0]).or(Ol(I, I.selection.getNode()));
    }, ri = (I) => I.selection.isCollapsed() || pa(I) ? Ol(I, I.selection.getStart()) : $i(I), zo = (I) => {
      const ee = ro(), fe = () => ee.get().or(ri(I)), _e = () => fe().each((it) => id(I, it));
      return I.on("contextmenu", (it) => {
        Ol(I, it.target).each(ee.set);
      }), I.on("SelectionChange", () => {
        ee.isSet() || ri(I).each(ee.set);
      }), I.on("click", (it) => {
        ee.clear();
        const It = Di(I.dom.getParents(it.target));
        It.length === 1 && Bi.metaKeyPressed(it) && (it.preventDefault(), id(I, It[0]));
      }), I.on("keydown", (it) => {
        ee.clear(), !it.isDefaultPrevented() && it.keyCode === 13 && dc(it) && fe().each((It) => {
          it.preventDefault(), id(I, It);
        });
      }), {
        gotoSelectedLink: _e
      };
    }, ud = (I) => () => {
      I.execCommand("mceLink", !1, { dialog: !0 });
    }, B = (I, ee) => (I.on("NodeChange", ee), () => I.off("NodeChange", ee)), G = (I) => (ee) => {
      const fe = () => {
        ee.setActive(!I.mode.isReadOnly() && lc(I, I.selection.getNode())), ee.setEnabled(I.selection.isEditable());
      };
      return fe(), B(I, fe);
    }, re = (I) => (ee) => {
      const fe = () => {
        ee.setEnabled(I.selection.isEditable());
      };
      return fe(), B(I, fe);
    }, Pe = (I) => (ee) => {
      const fe = (It) => as(It) || Ri(I.selection.getRng()), _e = I.dom.getParents(I.selection.getStart()), it = (It) => {
        ee.setEnabled(fe(It) && I.selection.isEditable());
      };
      return it(_e), B(I, (It) => it(It.parents));
    }, Ht = (I, ee) => {
      I.ui.registry.addToggleButton("link", {
        icon: "link",
        tooltip: "Insert/edit link",
        shortcut: "Meta+K",
        onAction: ud(I),
        onSetup: G(I)
      }), I.ui.registry.addButton("openlink", {
        icon: "new-tab",
        tooltip: "Open link",
        onAction: ee.gotoSelectedLink,
        onSetup: Pe(I)
      }), I.ui.registry.addButton("unlink", {
        icon: "unlink",
        tooltip: "Remove link",
        onAction: () => os(I),
        onSetup: Pe(I)
      });
    }, Jn = (I, ee) => {
      I.ui.registry.addMenuItem("openlink", {
        text: "Open link",
        icon: "new-tab",
        onAction: ee.gotoSelectedLink,
        onSetup: Pe(I)
      }), I.ui.registry.addMenuItem("link", {
        icon: "link",
        text: "Link...",
        shortcut: "Meta+K",
        onAction: ud(I),
        onSetup: re(I)
      }), I.ui.registry.addMenuItem("unlink", {
        icon: "unlink",
        text: "Remove link",
        onAction: () => os(I),
        onSetup: Pe(I)
      });
    }, Vo = (I) => {
      const ee = "link unlink openlink", fe = "link";
      I.ui.registry.addContextMenu("link", {
        update: (_e) => I.dom.isEditable(_e) ? as(I.dom.getParents(_e, "a")) ? ee : fe : ""
      });
    }, Sr = (I, ee) => {
      const fe = (It) => {
        It.selection.collapse(!1);
      }, _e = (It) => {
        const Mn = I.selection.getNode();
        return It.setEnabled(lc(I, Mn) && I.selection.isEditable()), un;
      }, it = (It) => {
        const Mn = Un(I), wo = ic(I);
        if (Mn.isNone() && wo) {
          const co = Ma(I.selection, Mn);
          return He(co.length === 0, It);
        } else
          return U.none();
      };
      I.ui.registry.addContextForm("quicklink", {
        launch: {
          type: "contextformtogglebutton",
          icon: "link",
          tooltip: "Link",
          onSetup: G(I)
        },
        label: "Link",
        predicate: (It) => xe(I) && lc(I, It),
        initValue: () => Un(I).fold(Xe(""), Ka),
        commands: [
          {
            type: "contextformtogglebutton",
            icon: "link",
            tooltip: "Link",
            primary: !0,
            onSetup: (It) => {
              const Mn = I.selection.getNode();
              return It.setActive(lc(I, Mn)), G(I)(It);
            },
            onAction: (It) => {
              const Mn = It.getValue(), wo = it(Mn);
              Qd(I, { href: Mn, attach: un }, {
                href: Mn,
                text: wo,
                title: U.none(),
                rel: U.none(),
                target: U.from(st(I)),
                class: U.none()
              }), fe(I), It.hide();
            }
          },
          {
            type: "contextformbutton",
            icon: "unlink",
            tooltip: "Remove link",
            onSetup: _e,
            // TODO: The original inlite action was quite complex. Are we missing something with this?
            onAction: (It) => {
              os(I), It.hide();
            }
          },
          {
            type: "contextformbutton",
            icon: "new-tab",
            tooltip: "Open link",
            onSetup: _e,
            onAction: (It) => {
              ee.gotoSelectedLink(), It.hide();
            }
          }
        ]
      });
    }, Yr = (I) => {
      const ee = zo(I);
      Ht(I, ee), Jn(I, ee), Vo(I), Sr(I, ee);
    };
    var Qa = () => {
      V.add("link", (I) => {
        po(I), wu(I), Yr(I), at(I);
      });
    };
    Qa();
  }()), mQ;
}
var gQ;
function xJ() {
  return gQ || (gQ = 1, CJ()), dQ;
}
xJ();
var hQ = {}, pQ = {}, bQ;
function SJ() {
  return bQ || (bQ = 1, function() {
    var V = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const me = Object.getPrototypeOf, pt = (B, G, re) => re(B, G.prototype) ? !0 : B.constructor?.name === G.name, rt = (B) => {
      const G = typeof B;
      return B === null ? "null" : G === "object" && Array.isArray(B) ? "array" : G === "object" && pt(B, String, (re, Pe) => Pe.isPrototypeOf(re)) ? "string" : G;
    }, Nt = (B) => (G) => rt(G) === B, mt = (B) => (G) => typeof G === B, nn = (B) => (G) => B === G, De = (B, G) => Tt(B) && pt(B, G, (re, Pe) => me(re) === Pe), et = Nt("string"), Tt = Nt("object"), $n = (B) => De(B, Object), Mt = Nt("array"), vn = nn(null), Cn = mt("boolean"), pn = (B) => B == null, un = (B) => !pn(B), Xe = mt("function"), In = mt("number"), lt = (B, G) => {
      if (Mt(B)) {
        for (let re = 0, Pe = B.length; re < Pe; ++re)
          if (!G(B[re]))
            return !1;
        return !0;
      }
      return !1;
    }, U = () => {
    };
    class Ye {
      tag;
      value;
      // Sneaky optimisation: every instance of Optional.none is identical, so just
      // reuse the same object
      static singletonNone = new Ye(!1);
      // The internal representation has a `tag` and a `value`, but both are
      // private: able to be console.logged, but not able to be accessed by code
      constructor(G, re) {
        this.tag = G, this.value = re;
      }
      // --- Identities ---
      /**
       * Creates a new `Optional<T>` that **does** contain a value.
       */
      static some(G) {
        return new Ye(!0, G);
      }
      /**
       * Create a new `Optional<T>` that **does not** contain a value. `T` can be
       * any type because we don't actually have a `T`.
       */
      static none() {
        return Ye.singletonNone;
      }
      /**
       * Perform a transform on an `Optional` type. Regardless of whether this
       * `Optional` contains a value or not, `fold` will return a value of type `U`.
       * If this `Optional` does not contain a value, the `U` will be created by
       * calling `onNone`. If this `Optional` does contain a value, the `U` will be
       * created by calling `onSome`.
       *
       * For the FP enthusiasts in the room, this function:
       * 1. Could be used to implement all of the functions below
       * 2. Forms a catamorphism
       */
      fold(G, re) {
        return this.tag ? re(this.value) : G();
      }
      /**
       * Determine if this `Optional` object contains a value.
       */
      isSome() {
        return this.tag;
      }
      /**
       * Determine if this `Optional` object **does not** contain a value.
       */
      isNone() {
        return !this.tag;
      }
      // --- Functor (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value. If
       * you provide a function to turn a T into a U, this is the function you use
       * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
       * a value then the output will also contain a value (that value being the
       * output of `mapper(this.value)`), and if this **does not** contain a value
       * then neither will the output.
       */
      map(G) {
        return this.tag ? Ye.some(G(this.value)) : Ye.none();
      }
      // --- Monad (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value.
       * Unlike `map`, here the transform itself also returns an `Optional`.
       */
      bind(G) {
        return this.tag ? G(this.value) : Ye.none();
      }
      // --- Traversable (name stolen from Haskell / maths) ---
      /**
       * For a given predicate, this function finds out if there **exists** a value
       * inside this `Optional` object that meets the predicate. In practice, this
       * means that for `Optional`s that do not contain a value it returns false (as
       * no predicate-meeting value exists).
       */
      exists(G) {
        return this.tag && G(this.value);
      }
      /**
       * For a given predicate, this function finds out if **all** the values inside
       * this `Optional` object meet the predicate. In practice, this means that
       * for `Optional`s that do not contain a value it returns true (as all 0
       * objects do meet the predicate).
       */
      forall(G) {
        return !this.tag || G(this.value);
      }
      filter(G) {
        return !this.tag || G(this.value) ? this : Ye.none();
      }
      // --- Getters ---
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.
       */
      getOr(G) {
        return this.tag ? this.value : G;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.  Unlike `getOr`, in this method the `replacement` object is also
       * `Optional` - meaning that this method will always return an `Optional`.
       */
      or(G) {
        return this.tag ? this : G;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value. Unlike `getOr`, in this method the `replacement` value is
       * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
       * pass a function which (if called) will **return** the `value` you want to
       * use.
       */
      getOrThunk(G) {
        return this.tag ? this.value : G();
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided Optional object does not contain a
       * value.
       *
       * Unlike `or`, in this method the `replacement` value is "thunked" - that is
       * to say that you don't pass a value to `orThunk`, you pass a function which
       * (if called) will **return** the `value` you want to use.
       *
       * Unlike `getOrThunk`, in this method the `replacement` value is also
       * `Optional`, meaning that this method will always return an `Optional`.
       */
      orThunk(G) {
        return this.tag ? this : G();
      }
      /**
       * Get the value out of the inside of the `Optional` object, throwing an
       * exception if the provided `Optional` object does not contain a value.
       *
       * WARNING:
       * You should only be using this function if you know that the `Optional`
       * object **is not** empty (otherwise you're throwing exceptions in production
       * code, which is bad).
       *
       * In tests this is more acceptable.
       *
       * Prefer other methods to this, such as `.each`.
       */
      getOrDie(G) {
        if (this.tag)
          return this.value;
        throw new Error(G ?? "Called getOrDie on None");
      }
      // --- Interop with null and undefined ---
      /**
       * Creates an `Optional` value from a nullable (or undefined-able) input.
       * Null, or undefined, is converted to `None`, and anything else is converted
       * to `Some`.
       */
      static from(G) {
        return un(G) ? Ye.some(G) : Ye.none();
      }
      /**
       * Converts an `Optional` to a nullable type, by getting the value if it
       * exists, or returning `null` if it does not.
       */
      getOrNull() {
        return this.tag ? this.value : null;
      }
      /**
       * Converts an `Optional` to an undefined-able type, by getting the value if
       * it exists, or returning `undefined` if it does not.
       */
      getOrUndefined() {
        return this.value;
      }
      // --- Utilities ---
      /**
       * If the `Optional` contains a value, perform an action on that value.
       * Unlike the rest of the methods on this type, `.each` has side-effects. If
       * you want to transform an `Optional<T>` **into** something, then this is not
       * the method for you. If you want to use an `Optional<T>` to **do**
       * something, then this is the method for you - provided you're okay with not
       * doing anything in the case where the `Optional` doesn't have a value inside
       * it. If you're not sure whether your use-case fits into transforming
       * **into** something or **doing** something, check whether it has a return
       * value. If it does, you should be performing a transform.
       */
      each(G) {
        this.tag && G(this.value);
      }
      /**
       * Turn the `Optional` object into an array that contains all of the values
       * stored inside the `Optional`. In practice, this means the output will have
       * either 0 or 1 elements.
       */
      toArray() {
        return this.tag ? [this.value] : [];
      }
      /**
       * Turn the `Optional` object into a string for debugging or printing. Not
       * recommended for production code, but good for debugging. Also note that
       * these days an `Optional` object can be logged to the console directly, and
       * its inner value (if it exists) will be visible.
       */
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    const On = Array.prototype.push, Ot = (B) => {
      const G = [];
      for (let re = 0, Pe = B.length; re < Pe; ++re) {
        if (!Mt(B[re]))
          throw new Error("Arr.flatten item " + re + " was not an array, input: " + B);
        On.apply(G, B[re]);
      }
      return G;
    }, oe = (B, G) => G >= 0 && G < B.length ? Ye.some(B[G]) : Ye.none(), Yt = (B) => oe(B, 0), Gn = (B, G) => {
      for (let re = 0; re < B.length; re++) {
        const Pe = G(B[re], re);
        if (Pe.isSome())
          return Pe;
      }
      return Ye.none();
    }, jt = Object.keys, X = Object.hasOwnProperty, se = (B, G) => {
      const re = jt(B);
      for (let Pe = 0, Ht = re.length; Pe < Ht; Pe++) {
        const Jn = re[Pe], Vo = B[Jn];
        G(Vo, Jn);
      }
    }, ns = (B) => (G, re) => {
      B[re] = G;
    }, an = (B, G, re, Pe) => {
      se(B, (Ht, Jn) => {
        (G(Ht, Jn) ? re : Pe)(Ht, Jn);
      });
    }, St = (B, G) => {
      const re = {};
      return an(B, G, ns(re), U), re;
    }, A = (B, G) => X.call(B, G), No = (B, G) => A(B, G) && B[G] !== void 0 && B[G] !== null, he = ((B) => (...G) => {
      if (G.length === 0)
        throw new Error("Can't merge zero objects");
      const re = {};
      for (let Pe = 0; Pe < G.length; Pe++) {
        const Ht = G[Pe];
        for (const Jn in Ht)
          A(Ht, Jn) && (re[Jn] = B(re[Jn], Ht[Jn]));
      }
      return re;
    })((B, G) => $n(B) && $n(G) ? he(B, G) : G), ue = (B) => B.length > 0, bt = (B, G) => {
      const Pe = (G || document).createElement("div");
      if (Pe.innerHTML = B, !Pe.hasChildNodes() || Pe.childNodes.length > 1) {
        const Ht = "HTML does not have a single root node";
        throw console.error(Ht, B), new Error(Ht);
      }
      return Fn(Pe.childNodes[0]);
    }, cn = (B, G) => {
      const Pe = (G || document).createElement(B);
      return Fn(Pe);
    }, fn = (B, G) => {
      const Pe = (G || document).createTextNode(B);
      return Fn(Pe);
    }, Fn = (B) => {
      if (B == null)
        throw new Error("Node cannot be null or undefined");
      return {
        dom: B
      };
    }, He = {
      fromHtml: bt,
      fromTag: cn,
      fromText: fn,
      fromDom: Fn,
      fromPoint: (B, G, re) => Ye.from(B.dom.elementFromPoint(G, re)).map(Fn)
    }, P = (B, G, re) => {
      if (et(re) || Cn(re) || In(re))
        B.setAttribute(G, re + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", G, ":: Value ", re, ":: Element ", B), new Error("Attribute value was not simple");
    }, ro = (B, G, re) => {
      P(B.dom, G, re);
    }, Ln = (B, G) => {
      B.dom.removeAttribute(G);
    };
    var oo = tinymce.util.Tools.resolve("tinymce.dom.DOMUtils"), ao = tinymce.util.Tools.resolve("tinymce.util.URI");
    const ur = (B) => (G) => G.options.get(B), Lt = (B) => {
      const G = B.options.register;
      G("image_dimensions", {
        processor: "boolean",
        default: !0
      }), G("image_advtab", {
        processor: "boolean",
        default: !1
      }), G("image_uploadtab", {
        processor: "boolean",
        default: !0
      }), G("image_prepend_url", {
        processor: "string",
        default: ""
      }), G("image_class_list", {
        processor: "object[]"
      }), G("image_description", {
        processor: "boolean",
        default: !0
      }), G("image_title", {
        processor: "boolean",
        default: !1
      }), G("image_caption", {
        processor: "boolean",
        default: !1
      }), G("image_list", {
        processor: (re) => {
          const Pe = re === !1 || et(re) || lt(re, Tt) || Xe(re);
          return Pe ? { value: re, valid: Pe } : { valid: !1, message: "Must be false, a string, an array or a function." };
        },
        default: !1
      });
    }, po = ur("image_dimensions"), en = ur("image_advtab"), xe = ur("image_uploadtab"), We = ur("image_prepend_url"), st = ur("image_class_list"), ze = ur("image_description"), no = ur("image_title"), qn = ur("image_caption"), Io = ur("image_list"), Jc = ur("a11y_advanced_options"), _o = ur("automatic_uploads"), Ql = (B) => ue(B.options.get("images_upload_url")), jm = (B) => un(B.options.get("images_upload_handler")), ga = (B, G) => Math.max(parseInt(B, 10), parseInt(G, 10)), xo = (B) => new Promise((G) => {
      const re = document.createElement("img"), Pe = (Jn) => {
        re.parentNode && re.parentNode.removeChild(re), G(Jn);
      };
      re.addEventListener("load", () => {
        const Jn = ga(re.width, re.clientWidth), Vo = ga(re.height, re.clientHeight), Sr = { width: Jn, height: Vo };
        Pe(Promise.resolve(Sr));
      }), re.addEventListener("error", () => {
        Pe(Promise.reject(`Failed to get image dimensions for: ${B}`));
      });
      const Ht = re.style;
      Ht.visibility = "hidden", Ht.position = "fixed", Ht.bottom = Ht.left = "0px", Ht.width = Ht.height = "auto", document.body.appendChild(re), re.src = B;
    }), qa = (B) => (B && (B = B.replace(/px$/, "")), B), ds = (B) => (B.length > 0 && /^[0-9]+$/.test(B) && (B += "px"), B), Bs = (B) => {
      if (B.margin) {
        const G = String(B.margin).split(" ");
        switch (G.length) {
          case 1:
            B["margin-top"] = B["margin-top"] || G[0], B["margin-right"] = B["margin-right"] || G[0], B["margin-bottom"] = B["margin-bottom"] || G[0], B["margin-left"] = B["margin-left"] || G[0];
            break;
          case 2:
            B["margin-top"] = B["margin-top"] || G[0], B["margin-right"] = B["margin-right"] || G[1], B["margin-bottom"] = B["margin-bottom"] || G[0], B["margin-left"] = B["margin-left"] || G[1];
            break;
          case 3:
            B["margin-top"] = B["margin-top"] || G[0], B["margin-right"] = B["margin-right"] || G[1], B["margin-bottom"] = B["margin-bottom"] || G[2], B["margin-left"] = B["margin-left"] || G[1];
            break;
          case 4:
            B["margin-top"] = B["margin-top"] || G[0], B["margin-right"] = B["margin-right"] || G[1], B["margin-bottom"] = B["margin-bottom"] || G[2], B["margin-left"] = B["margin-left"] || G[3];
        }
        delete B.margin;
      }
      return B;
    }, vu = (B, G) => {
      const re = Io(B);
      et(re) ? fetch(re).then((Pe) => {
        Pe.ok && Pe.json().then(G);
      }) : Xe(re) ? re(G) : G(re);
    }, Tl = (B, G, re) => {
      const Pe = () => {
        re.onload = re.onerror = null, B.selection && (B.selection.select(re), B.nodeChanged());
      };
      re.onload = () => {
        !G.width && !G.height && po(B) && B.dom.setAttribs(re, {
          width: String(re.clientWidth),
          height: String(re.clientHeight)
        }), Pe();
      }, re.onerror = Pe;
    }, Gr = (B) => new Promise((G, re) => {
      const Pe = new FileReader();
      Pe.onload = () => {
        G(Pe.result);
      }, Pe.onerror = () => {
        re(Pe.error?.message);
      }, Pe.readAsDataURL(B);
    }), js = (B) => B.nodeName === "IMG" && (B.hasAttribute("data-mce-object") || B.hasAttribute("data-mce-placeholder")), dr = (B, G) => {
      const re = B.options.get;
      return ao.isDomSafe(G, "img", {
        allow_html_data_urls: re("allow_html_data_urls"),
        allow_script_urls: re("allow_script_urls"),
        allow_svg_data_urls: re("allow_svg_data_urls")
      });
    }, rs = oo.DOM, cc = (B) => B.style.marginLeft && B.style.marginRight && B.style.marginLeft === B.style.marginRight ? qa(B.style.marginLeft) : "", Ka = (B) => B.style.marginTop && B.style.marginBottom && B.style.marginTop === B.style.marginBottom ? qa(B.style.marginTop) : "", Vt = (B) => B.style.borderWidth ? qa(B.style.borderWidth) : "", mo = (B, G) => B.hasAttribute(G) ? B.getAttribute(G) ?? "" : "", Un = (B) => B.parentNode !== null && B.parentNode.nodeName === "FIGURE", lc = (B, G, re) => {
      re === "" || re === null ? B.removeAttribute(G) : B.setAttribute(G, re);
    }, Ma = (B) => {
      const G = rs.create("figure", { class: "image" });
      rs.insertAfter(G, B), G.appendChild(B), G.appendChild(rs.create("figcaption", { contentEditable: "true" }, "Caption")), G.contentEditable = "false";
    }, Pt = (B) => {
      const G = B.parentNode;
      un(G) && (rs.insertAfter(B, G), rs.remove(G));
    }, Di = (B) => {
      Un(B) ? Pt(B) : Ma(B);
    }, as = (B, G) => {
      const re = B.getAttribute("style"), Pe = G(re !== null ? re : "");
      Pe.length > 0 ? (B.setAttribute("style", Pe), B.setAttribute("data-mce-style", Pe)) : B.removeAttribute("style");
    }, Ri = (B, G) => (re, Pe, Ht) => {
      const Jn = re.style;
      Jn[Pe] ? (Jn[Pe] = ds(Ht), as(re, G)) : lc(re, Pe, Ht);
    }, ic = (B, G) => B.style[G] ? qa(B.style[G]) : mo(B, G), Pa = (B, G) => {
      const re = ds(G);
      B.style.marginLeft = re, B.style.marginRight = re;
    }, Wo = (B, G) => {
      const re = ds(G);
      B.style.marginTop = re, B.style.marginBottom = re;
    }, kn = (B, G) => {
      const re = ds(G);
      B.style.borderWidth = re;
    }, Zo = (B, G) => {
      B.style.borderStyle = G;
    }, rd = (B) => B.style.borderStyle ?? "", yu = (B) => un(B) && B.nodeName === "FIGURE", el = (B) => B.nodeName === "IMG", Wt = (B) => {
      const G = rs.getAttrib(B, "alt"), re = rs.getAttrib(B, "role");
      return B.hasAttribute("alt") && G.length === 0 || re === "presentation" || re === "none";
    }, Ba = (B) => Wt(B) ? "" : mo(B, "alt"), Or = () => ({
      src: "",
      alt: "",
      title: "",
      width: "",
      height: "",
      class: "",
      style: "",
      caption: !1,
      hspace: "",
      vspace: "",
      border: "",
      borderStyle: "",
      isDecorative: !1
    }), Wm = (B, G) => {
      const re = document.createElement("img");
      return lc(re, "style", G.style), (cc(re) || G.hspace !== "") && Pa(re, G.hspace), (Ka(re) || G.vspace !== "") && Wo(re, G.vspace), (Vt(re) || G.border !== "") && kn(re, G.border), (rd(re) || G.borderStyle !== "") && Zo(re, G.borderStyle), B(re.getAttribute("style") ?? "");
    }, xr = (B, G) => {
      const re = document.createElement("img");
      if (Nc(B, { ...G, caption: !1 }, re), Ni(re, G.alt, G.isDecorative), G.caption) {
        const Pe = rs.create("figure", { class: "image" });
        return Pe.appendChild(re), Pe.appendChild(rs.create("figcaption", { contentEditable: "true" }, "Caption")), Pe.contentEditable = "false", Pe;
      } else
        return re;
    }, Qd = (B, G) => ({
      src: mo(G, "src"),
      alt: Ba(G),
      title: mo(G, "title"),
      width: ic(G, "width"),
      height: ic(G, "height"),
      class: mo(G, "class"),
      style: B(mo(G, "style")),
      caption: Un(G),
      hspace: cc(G),
      vspace: Ka(G),
      border: Vt(G),
      borderStyle: rd(G),
      isDecorative: Wt(G)
    }), os = (B, G, re, Pe, Ht) => {
      re[Pe] !== G[Pe] && Ht(B, Pe, String(re[Pe]));
    }, Ni = (B, G, re) => {
      if (re) {
        rs.setAttrib(B, "role", "presentation");
        const Pe = He.fromDom(B);
        ro(Pe, "alt", "");
      } else {
        if (vn(G)) {
          const Pe = He.fromDom(B);
          Ln(Pe, "alt");
        } else {
          const Pe = He.fromDom(B);
          ro(Pe, "alt", G);
        }
        rs.getAttrib(B, "role") === "presentation" && rs.setAttrib(B, "role", "");
      }
    }, ad = (B, G, re) => {
      (re.alt !== G.alt || re.isDecorative !== G.isDecorative) && Ni(B, re.alt, re.isDecorative);
    }, Jl = (B, G) => (re, Pe, Ht) => {
      B(re, Ht), as(re, G);
    }, Nc = (B, G, re) => {
      const Pe = Qd(B, re);
      os(re, Pe, G, "caption", (Ht, Jn, Vo) => Di(Ht)), os(re, Pe, G, "src", lc), os(re, Pe, G, "title", lc), os(re, Pe, G, "width", Ri("width", B)), os(re, Pe, G, "height", Ri("height", B)), os(re, Pe, G, "class", lc), os(re, Pe, G, "style", Jl((Ht, Jn) => lc(Ht, "style", Jn), B)), os(re, Pe, G, "hspace", Jl(Pa, B)), os(re, Pe, G, "vspace", Jl(Wo, B)), os(re, Pe, G, "border", Jl(kn, B)), os(re, Pe, G, "borderStyle", Jl(Zo, B)), ad(re, Pe, G);
    }, nr = (B, G) => {
      const re = B.dom.styles.parse(G), Pe = Bs(re), Ht = B.dom.styles.parse(B.dom.styles.serialize(Pe));
      return B.dom.styles.serialize(Ht);
    }, Mi = (B) => {
      const G = B.selection.getNode(), re = B.dom.getParent(G, "figure.image");
      return re ? B.dom.select("img", re)[0] : G && (G.nodeName !== "IMG" || js(G)) ? null : G;
    }, Cu = (B, G) => {
      const re = B.dom, Pe = St(B.schema.getTextBlockElements(), (Jn, Vo) => !B.schema.isValidChild(Vo, "figure")), Ht = re.getParent(G.parentNode, (Jn) => No(Pe, Jn.nodeName), B.getBody());
      return Ht ? re.split(Ht, G) ?? G : G;
    }, Ct = (B) => {
      const G = Mi(B);
      return G ? Qd((re) => nr(B, re), G) : Or();
    }, Ya = (B, G) => {
      const re = xr((Ht) => nr(B, Ht), G);
      B.dom.setAttrib(re, "data-mce-id", "__mcenew"), B.focus(), B.insertContent(re.outerHTML);
      const Pe = B.dom.select('*[data-mce-id="__mcenew"]')[0];
      if (B.dom.setAttrib(Pe, "data-mce-id", null), yu(Pe)) {
        const Ht = Cu(B, Pe);
        B.selection.select(Ht);
      } else
        B.selection.select(Pe);
    }, xu = (B, G) => {
      B.dom.setAttrib(G, "src", G.getAttribute("src"));
    }, kl = (B, G) => {
      if (G) {
        const re = B.dom.is(G.parentNode, "figure.image") ? G.parentNode : G;
        B.dom.remove(re), B.focus(), B.nodeChanged(), B.dom.isEmpty(B.getBody()) && (B.setContent(""), B.selection.setCursorLocation());
      }
    }, Ho = (B, G) => {
      const re = Mi(B);
      if (re)
        if (Nc((Pe) => nr(B, Pe), G, re), xu(B, re), yu(re.parentNode)) {
          B.dom.setStyle(re, "float", "");
          const Pe = re.parentNode;
          Cu(B, Pe), B.selection.select(re.parentNode);
        } else
          B.selection.select(re), Tl(B, G, re);
    }, cd = (B, G) => {
      const re = G.src;
      return {
        ...G,
        src: dr(B, re) ? re : ""
      };
    }, uc = (B, G) => {
      const re = Mi(B);
      if (re) {
        const Ht = { ...Qd((Vo) => nr(B, Vo), re), ...G }, Jn = cd(B, Ht);
        Ht.src ? Ho(B, Jn) : kl(B, re);
      } else G.src && Ya(B, { ...Or(), ...G });
    };
    var Xs = tinymce.util.Tools.resolve("tinymce.util.ImageUploader"), Al = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const ld = (B) => et(B.value) ? B.value : "", $a = (B) => et(B.text) ? B.text : et(B.title) ? B.title : "", Pr = (B, G) => {
      const re = [];
      return Al.each(B, (Pe) => {
        const Ht = $a(Pe);
        if (Pe.menu !== void 0) {
          const Jn = Pr(Pe.menu, G);
          re.push({ text: Ht, items: Jn });
        } else {
          const Jn = G(Pe);
          re.push({ text: Ht, value: Jn });
        }
      }), re;
    }, tl = (B = ld) => (G) => G ? Ye.from(G).map((re) => Pr(re, B)) : Ye.none(), Br = (B) => tl(ld)(B), mh = (B) => A(B, "items"), Jd = (B, G) => Gn(B, (re) => mh(re) ? Jd(re.items, G) : re.value === G ? Ye.some(re) : Ye.none()), _l = {
      sanitizer: tl,
      sanitize: Br,
      findEntry: (B, G) => B.bind((re) => Jd(re, G))
    }, Zm = {
      makeTab: (B) => ({
        title: "Advanced",
        name: "advanced",
        items: [
          {
            type: "grid",
            columns: 2,
            items: [
              {
                type: "input",
                label: "Vertical space",
                name: "vspace",
                inputMode: "numeric"
              },
              {
                type: "input",
                label: "Horizontal space",
                name: "hspace",
                inputMode: "numeric"
              },
              {
                type: "input",
                label: "Border width",
                name: "border",
                inputMode: "numeric"
              },
              {
                type: "listbox",
                name: "borderstyle",
                label: "Border style",
                items: [
                  { text: "Select...", value: "" },
                  { text: "Solid", value: "solid" },
                  { text: "Dotted", value: "dotted" },
                  { text: "Dashed", value: "dashed" },
                  { text: "Double", value: "double" },
                  { text: "Groove", value: "groove" },
                  { text: "Ridge", value: "ridge" },
                  { text: "Inset", value: "inset" },
                  { text: "Outset", value: "outset" },
                  { text: "None", value: "none" },
                  { text: "Hidden", value: "hidden" }
                ]
              }
            ]
          }
        ]
      })
    }, As = (B) => {
      const G = _l.sanitizer((Mn) => B.convertURL(Mn.value || Mn.url || "", "src")), re = new Promise((Mn) => {
        vu(B, (wo) => {
          Mn(G(wo).map((co) => Ot([
            [{ text: "None", value: "" }],
            co
          ])));
        });
      }), Pe = _l.sanitize(st(B)), Ht = en(B), Jn = xe(B), Vo = Ql(B), Sr = jm(B), Yr = Ct(B), Qa = ze(B), I = no(B), ee = po(B), fe = qn(B), _e = Jc(B), it = _o(B), It = Ye.some(We(B)).filter((Mn) => et(Mn) && Mn.length > 0);
      return re.then((Mn) => ({
        image: Yr,
        imageList: Mn,
        classList: Pe,
        hasAdvTab: Ht,
        hasUploadTab: Jn,
        hasUploadUrl: Vo,
        hasUploadHandler: Sr,
        hasDescription: Qa,
        hasImageTitle: I,
        hasDimensions: ee,
        hasImageCaption: fe,
        prependURL: It,
        hasAccessibilityOptions: _e,
        automaticUploads: it
      }));
    }, hn = (B) => {
      const G = {
        name: "src",
        type: "urlinput",
        filetype: "image",
        label: "Source",
        picker_text: "Browse files"
      }, re = B.imageList.map((I) => ({
        name: "images",
        type: "listbox",
        label: "Image list",
        items: I
      })), Pe = {
        name: "alt",
        type: "input",
        label: "Alternative description",
        enabled: !(B.hasAccessibilityOptions && B.image.isDecorative)
      }, Ht = {
        name: "title",
        type: "input",
        label: "Image title"
      }, Jn = {
        name: "dimensions",
        type: "sizeinput"
      }, Vo = {
        type: "label",
        label: "Accessibility",
        items: [{
          name: "isDecorative",
          type: "checkbox",
          label: "Image is decorative"
        }]
      }, Sr = B.classList.map((I) => ({
        name: "classes",
        type: "listbox",
        label: "Class",
        items: I
      })), Yr = {
        type: "label",
        label: "Caption",
        items: [
          {
            type: "checkbox",
            name: "caption",
            label: "Show caption"
          }
        ]
      }, Qa = (I) => I ? { type: "grid", columns: 2 } : { type: "panel" };
      return Ot([
        [G],
        re.toArray(),
        B.hasAccessibilityOptions && B.hasDescription ? [Vo] : [],
        B.hasDescription ? [Pe] : [],
        B.hasImageTitle ? [Ht] : [],
        B.hasDimensions ? [Jn] : [],
        [{
          ...Qa(B.classList.isSome() && B.hasImageCaption),
          items: Ot([
            Sr.toArray(),
            B.hasImageCaption ? [Yr] : []
          ])
        }]
      ]);
    }, Kr = {
      makeTab: (B) => ({
        title: "General",
        name: "general",
        items: hn(B)
      }),
      makeItems: hn
    }, em = {
      makeTab: (B) => ({
        title: "Upload",
        name: "upload",
        items: [
          {
            type: "dropzone",
            name: "fileinput"
          }
        ]
      })
    }, Pi = (B) => ({
      prevImage: _l.findEntry(B.imageList, B.image.src),
      prevAlt: B.image.alt,
      open: !0
    }), ms = (B) => ({
      src: {
        value: B.src,
        meta: {}
      },
      images: B.src,
      alt: B.alt,
      title: B.title,
      dimensions: {
        width: B.width,
        height: B.height
      },
      classes: B.class,
      caption: B.caption,
      style: B.style,
      vspace: B.vspace,
      border: B.border,
      hspace: B.hspace,
      borderstyle: B.borderStyle,
      fileinput: [],
      isDecorative: B.isDecorative
    }), ti = (B, G) => ({
      src: B.src.value,
      alt: (B.alt === null || B.alt.length === 0) && G ? null : B.alt,
      title: B.title,
      width: B.dimensions.width,
      height: B.dimensions.height,
      class: B.classes,
      style: B.style,
      caption: B.caption,
      hspace: B.hspace,
      vspace: B.vspace,
      border: B.border,
      borderStyle: B.borderstyle,
      isDecorative: B.isDecorative
    }), nl = (B, G) => /^(?:[a-zA-Z]+:)?\/\//.test(G) ? Ye.none() : B.prependURL.bind((re) => G.substring(0, re.length) !== re ? Ye.some(re + G) : Ye.none()), Jf = (B, G) => {
      const re = G.getData();
      nl(B, re.src.value).each((Pe) => {
        G.setData({ src: { value: Pe, meta: re.src.meta } });
      });
    }, vt = (B, G, re) => {
      B.hasDescription && et(re.alt) && (G.alt = re.alt), B.hasAccessibilityOptions && (G.isDecorative = re.isDecorative || G.isDecorative || !1), B.hasImageTitle && et(re.title) && (G.title = re.title), B.hasDimensions && (et(re.width) && (G.dimensions.width = re.width), et(re.height) && (G.dimensions.height = re.height)), et(re.class) && _l.findEntry(B.classList, re.class).each((Pe) => {
        G.classes = Pe.value;
      }), B.hasImageCaption && Cn(re.caption) && (G.caption = re.caption), B.hasAdvTab && (et(re.style) && (G.style = re.style), et(re.vspace) && (G.vspace = re.vspace), et(re.border) && (G.border = re.border), et(re.hspace) && (G.hspace = re.hspace), et(re.borderstyle) && (G.borderstyle = re.borderstyle));
    }, ni = (B, G) => {
      const re = G.getData(), Pe = re.src.meta;
      if (Pe !== void 0) {
        const Ht = he({}, re);
        vt(B, Ht, Pe), G.setData(Ht);
      }
    }, ha = (B, G, re, Pe) => {
      const Ht = Pe.getData(), Jn = Ht.src.value, Vo = Ht.src.meta || {};
      !Vo.width && !Vo.height && G.hasDimensions && (ue(Jn) ? B.imageSize(Jn).then((Sr) => {
        re.open && Pe.setData({ dimensions: Sr });
      }).catch((Sr) => console.error(Sr)) : Pe.setData({ dimensions: { width: "", height: "" } }));
    }, Pc = (B, G, re) => {
      const Pe = re.getData(), Ht = _l.findEntry(B.imageList, Pe.src.value);
      G.prevImage = Ht, re.setData({ images: Ht.map((Jn) => Jn.value).getOr("") });
    }, $s = (B, G, re, Pe) => {
      Jf(G, Pe), ni(G, Pe), ha(B, G, re, Pe), Pc(G, re, Pe);
    }, eg = (B, G, re, Pe) => {
      const Ht = Pe.getData(), Jn = _l.findEntry(G.imageList, Ht.images);
      Jn.each((Vo) => {
        Ht.alt === "" || re.prevImage.map((Yr) => Yr.text === Ht.alt).getOr(!1) ? Vo.value === "" ? Pe.setData({ src: Vo, alt: re.prevAlt }) : Pe.setData({ src: Vo, alt: Vo.text }) : Pe.setData({ src: Vo });
      }), re.prevImage = Jn, $s(B, G, re, Pe);
    }, Xa = (B, G, re, Pe) => {
      const Ht = Pe.getData();
      Pe.block("Uploading image"), Yt(Ht.fileinput).fold(() => {
        Pe.unblock();
      }, (Jn) => {
        const Vo = URL.createObjectURL(Jn), Sr = () => {
          Pe.unblock(), URL.revokeObjectURL(Vo);
        }, Yr = (Qa) => {
          Pe.setData({ src: { value: Qa, meta: {} } }), Pe.showTab("general"), $s(B, G, re, Pe), Pe.focus("src");
        };
        Gr(Jn).then((Qa) => {
          const I = B.createBlobCache(Jn, Vo, Qa);
          G.automaticUploads ? B.uploadImage(I).then((ee) => {
            Yr(ee.url), Sr();
          }).catch((ee) => {
            Sr(), B.alertErr(ee, () => {
              Pe.focus("fileinput");
            });
          }) : (B.addToBlobCache(I), Yr(I.blobUri()), Pe.unblock());
        });
      });
    }, Bc = (B, G, re) => (Pe, Ht) => {
      Ht.name === "src" ? $s(B, G, re, Pe) : Ht.name === "images" ? eg(B, G, re, Pe) : Ht.name === "alt" ? re.prevAlt = Pe.getData().alt : Ht.name === "fileinput" ? Xa(B, G, re, Pe) : Ht.name === "isDecorative" && Pe.setEnabled("alt", !Pe.getData().isDecorative);
    }, Gm = (B) => () => {
      B.open = !1;
    }, tg = (B) => B.hasAdvTab || B.hasUploadUrl || B.hasUploadHandler ? {
      type: "tabpanel",
      tabs: Ot([
        [Kr.makeTab(B)],
        B.hasAdvTab ? [Zm.makeTab(B)] : [],
        B.hasUploadTab && (B.hasUploadUrl || B.hasUploadHandler) ? [em.makeTab(B)] : []
      ])
    } : {
      type: "panel",
      items: Kr.makeItems(B)
    }, oi = (B, G, re) => (Pe) => {
      const Ht = he(ms(G.image), Pe.getData()), Jn = {
        ...Ht,
        style: Wm(re.normalizeCss, ti(Ht, !1))
      };
      B.execCommand("mceUpdateImage", !1, ti(Jn, G.hasAccessibilityOptions)), B.editorUpload.uploadImagesAuto(), Pe.close();
    }, ng = (B) => (G) => dr(B, G) ? xo(B.documentBaseURI.toAbsolute(G)).then((re) => ({
      width: String(re.width),
      height: String(re.height)
    })) : Promise.resolve({ width: "", height: "" }), Su = (B) => (G, re, Pe) => B.editorUpload.blobCache.create({
      blob: G,
      blobUri: re,
      name: G.name?.replace(/\.[^\.]+$/, ""),
      filename: G.name,
      base64: Pe.split(",")[1]
    }), si = (B) => (G) => {
      B.editorUpload.blobCache.add(G);
    }, wu = (B) => (G, re) => {
      B.windowManager.alert(G, re);
    }, at = (B) => (G) => nr(B, G), Bi = (B) => (G) => B.dom.parseStyle(G), tm = (B) => (G, re) => B.dom.serializeStyle(G, re), ol = (B) => (G) => Xs(B).upload([G], !1).then((re) => re.length === 0 ? Promise.reject("Failed to upload image") : re[0].status === !1 ? Promise.reject(re[0].error?.message) : re[0]), dc = (B) => {
      const G = {
        imageSize: ng(B),
        addToBlobCache: si(B),
        createBlobCache: Su(B),
        alertErr: wu(B),
        normalizeCss: at(B),
        parseStyle: Bi(B),
        serializeStyle: tm(B),
        uploadImage: ol(B)
      };
      return {
        open: () => {
          As(B).then((Pe) => {
            const Ht = Pi(Pe);
            return {
              title: "Insert/Edit Image",
              size: "normal",
              body: tg(Pe),
              buttons: [
                {
                  type: "cancel",
                  name: "cancel",
                  text: "Cancel"
                },
                {
                  type: "submit",
                  name: "save",
                  text: "Save",
                  primary: !0
                }
              ],
              initialData: ms(Pe.image),
              onSubmit: oi(B, Pe, G),
              onChange: Bc(G, Pe, Ht),
              onClose: Gm(Ht)
            };
          }).then(B.windowManager.open);
        }
      };
    }, id = (B) => {
      B.addCommand("mceImage", dc(B).open), B.addCommand("mceUpdateImage", (G, re) => {
        B.undoManager.transact(() => uc(B, re));
      });
    }, pa = (B) => {
      const G = B.attr("class");
      return un(G) && /\bimage\b/.test(G);
    }, Ol = (B) => (G) => {
      let re = G.length;
      const Pe = (Ht) => {
        Ht.attr("contenteditable", B ? "true" : null);
      };
      for (; re--; ) {
        const Ht = G[re];
        pa(Ht) && (Ht.attr("contenteditable", B ? "false" : null), Al.each(Ht.getAll("figcaption"), Pe));
      }
    }, $i = (B) => {
      B.on("PreInit", () => {
        B.parser.addNodeFilter("figure", Ol(!0)), B.serializer.addNodeFilter("figure", Ol(!1));
      });
    }, ri = (B) => (G) => {
      const re = () => {
        G.setEnabled(B.selection.isEditable());
      };
      return B.on("NodeChange", re), re(), () => {
        B.off("NodeChange", re);
      };
    }, zo = (B) => {
      B.ui.registry.addToggleButton("image", {
        icon: "image",
        tooltip: "Insert/edit image",
        onAction: dc(B).open,
        onSetup: (G) => {
          G.setActive(un(Mi(B)));
          const re = B.selection.selectorChangedWithUnbind("img:not([data-mce-object]):not([data-mce-placeholder]),figure.image", G.setActive).unbind, Pe = ri(B)(G);
          return () => {
            re(), Pe();
          };
        }
      }), B.ui.registry.addMenuItem("image", {
        icon: "image",
        text: "Image...",
        onAction: dc(B).open,
        onSetup: ri(B)
      }), B.ui.registry.addContextMenu("image", {
        update: (G) => B.selection.isEditable() && (yu(G) || el(G) && !js(G)) ? ["image"] : []
      });
    };
    var ud = () => {
      V.add("image", (B) => {
        Lt(B), $i(B), zo(B), id(B);
      });
    };
    ud();
  }()), pQ;
}
var vQ;
function wJ() {
  return vQ || (vQ = 1, SJ()), hQ;
}
wJ();
var yQ = {}, CQ = {}, xQ;
function EJ() {
  return xQ || (xQ = 1, function() {
    var V = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const me = (w, k, F) => F(w, k.prototype) ? !0 : w.constructor?.name === k.name, pt = (w) => {
      const k = typeof w;
      return w === null ? "null" : k === "object" && Array.isArray(w) ? "array" : k === "object" && me(w, String, (F, q) => q.isPrototypeOf(F)) ? "string" : k;
    }, rt = (w) => (k) => pt(k) === w, Nt = (w) => (k) => typeof k === w, mt = (w) => (k) => w === k, nn = rt("string"), De = rt("array"), et = Nt("boolean"), Tt = mt(void 0), $n = (w) => w == null, Mt = (w) => !$n(w), vn = Nt("function"), Cn = Nt("number"), pn = () => {
    }, un = (w, k) => (F) => w(k(F)), Xe = (w) => () => w, In = (w) => w, lt = (w, k) => w === k;
    function U(w, ...k) {
      return (...F) => {
        const q = k.concat(F);
        return w.apply(null, q);
      };
    }
    const Ye = (w) => {
      w();
    }, On = Xe(!1), Ot = Xe(!0);
    class oe {
      tag;
      value;
      // Sneaky optimisation: every instance of Optional.none is identical, so just
      // reuse the same object
      static singletonNone = new oe(!1);
      // The internal representation has a `tag` and a `value`, but both are
      // private: able to be console.logged, but not able to be accessed by code
      constructor(k, F) {
        this.tag = k, this.value = F;
      }
      // --- Identities ---
      /**
       * Creates a new `Optional<T>` that **does** contain a value.
       */
      static some(k) {
        return new oe(!0, k);
      }
      /**
       * Create a new `Optional<T>` that **does not** contain a value. `T` can be
       * any type because we don't actually have a `T`.
       */
      static none() {
        return oe.singletonNone;
      }
      /**
       * Perform a transform on an `Optional` type. Regardless of whether this
       * `Optional` contains a value or not, `fold` will return a value of type `U`.
       * If this `Optional` does not contain a value, the `U` will be created by
       * calling `onNone`. If this `Optional` does contain a value, the `U` will be
       * created by calling `onSome`.
       *
       * For the FP enthusiasts in the room, this function:
       * 1. Could be used to implement all of the functions below
       * 2. Forms a catamorphism
       */
      fold(k, F) {
        return this.tag ? F(this.value) : k();
      }
      /**
       * Determine if this `Optional` object contains a value.
       */
      isSome() {
        return this.tag;
      }
      /**
       * Determine if this `Optional` object **does not** contain a value.
       */
      isNone() {
        return !this.tag;
      }
      // --- Functor (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value. If
       * you provide a function to turn a T into a U, this is the function you use
       * to turn an `Optional<T>` into an `Optional<U>`. If this **does** contain
       * a value then the output will also contain a value (that value being the
       * output of `mapper(this.value)`), and if this **does not** contain a value
       * then neither will the output.
       */
      map(k) {
        return this.tag ? oe.some(k(this.value)) : oe.none();
      }
      // --- Monad (name stolen from Haskell / maths) ---
      /**
       * Perform a transform on an `Optional` object, **if** there is a value.
       * Unlike `map`, here the transform itself also returns an `Optional`.
       */
      bind(k) {
        return this.tag ? k(this.value) : oe.none();
      }
      // --- Traversable (name stolen from Haskell / maths) ---
      /**
       * For a given predicate, this function finds out if there **exists** a value
       * inside this `Optional` object that meets the predicate. In practice, this
       * means that for `Optional`s that do not contain a value it returns false (as
       * no predicate-meeting value exists).
       */
      exists(k) {
        return this.tag && k(this.value);
      }
      /**
       * For a given predicate, this function finds out if **all** the values inside
       * this `Optional` object meet the predicate. In practice, this means that
       * for `Optional`s that do not contain a value it returns true (as all 0
       * objects do meet the predicate).
       */
      forall(k) {
        return !this.tag || k(this.value);
      }
      filter(k) {
        return !this.tag || k(this.value) ? this : oe.none();
      }
      // --- Getters ---
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.
       */
      getOr(k) {
        return this.tag ? this.value : k;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value.  Unlike `getOr`, in this method the `replacement` object is also
       * `Optional` - meaning that this method will always return an `Optional`.
       */
      or(k) {
        return this.tag ? this : k;
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided `Optional` object does not contain a
       * value. Unlike `getOr`, in this method the `replacement` value is
       * "thunked" - that is to say that you don't pass a value to `getOrThunk`, you
       * pass a function which (if called) will **return** the `value` you want to
       * use.
       */
      getOrThunk(k) {
        return this.tag ? this.value : k();
      }
      /**
       * Get the value out of the inside of the `Optional` object, using a default
       * `replacement` value if the provided Optional object does not contain a
       * value.
       *
       * Unlike `or`, in this method the `replacement` value is "thunked" - that is
       * to say that you don't pass a value to `orThunk`, you pass a function which
       * (if called) will **return** the `value` you want to use.
       *
       * Unlike `getOrThunk`, in this method the `replacement` value is also
       * `Optional`, meaning that this method will always return an `Optional`.
       */
      orThunk(k) {
        return this.tag ? this : k();
      }
      /**
       * Get the value out of the inside of the `Optional` object, throwing an
       * exception if the provided `Optional` object does not contain a value.
       *
       * WARNING:
       * You should only be using this function if you know that the `Optional`
       * object **is not** empty (otherwise you're throwing exceptions in production
       * code, which is bad).
       *
       * In tests this is more acceptable.
       *
       * Prefer other methods to this, such as `.each`.
       */
      getOrDie(k) {
        if (this.tag)
          return this.value;
        throw new Error(k ?? "Called getOrDie on None");
      }
      // --- Interop with null and undefined ---
      /**
       * Creates an `Optional` value from a nullable (or undefined-able) input.
       * Null, or undefined, is converted to `None`, and anything else is converted
       * to `Some`.
       */
      static from(k) {
        return Mt(k) ? oe.some(k) : oe.none();
      }
      /**
       * Converts an `Optional` to a nullable type, by getting the value if it
       * exists, or returning `null` if it does not.
       */
      getOrNull() {
        return this.tag ? this.value : null;
      }
      /**
       * Converts an `Optional` to an undefined-able type, by getting the value if
       * it exists, or returning `undefined` if it does not.
       */
      getOrUndefined() {
        return this.value;
      }
      // --- Utilities ---
      /**
       * If the `Optional` contains a value, perform an action on that value.
       * Unlike the rest of the methods on this type, `.each` has side-effects. If
       * you want to transform an `Optional<T>` **into** something, then this is not
       * the method for you. If you want to use an `Optional<T>` to **do**
       * something, then this is the method for you - provided you're okay with not
       * doing anything in the case where the `Optional` doesn't have a value inside
       * it. If you're not sure whether your use-case fits into transforming
       * **into** something or **doing** something, check whether it has a return
       * value. If it does, you should be performing a transform.
       */
      each(k) {
        this.tag && k(this.value);
      }
      /**
       * Turn the `Optional` object into an array that contains all of the values
       * stored inside the `Optional`. In practice, this means the output will have
       * either 0 or 1 elements.
       */
      toArray() {
        return this.tag ? [this.value] : [];
      }
      /**
       * Turn the `Optional` object into a string for debugging or printing. Not
       * recommended for production code, but good for debugging. Also note that
       * these days an `Optional` object can be logged to the console directly, and
       * its inner value (if it exists) will be visible.
       */
      toString() {
        return this.tag ? `some(${this.value})` : "none()";
      }
    }
    const Yt = Array.prototype.indexOf, Gn = Array.prototype.push, jt = (w, k) => Yt.call(w, k), X = (w, k) => jt(w, k) > -1, se = (w, k) => {
      for (let F = 0, q = w.length; F < q; F++) {
        const de = w[F];
        if (k(de, F))
          return !0;
      }
      return !1;
    }, ns = (w, k) => {
      const F = [];
      for (let q = 0; q < w; q++)
        F.push(k(q));
      return F;
    }, an = (w, k) => {
      const F = w.length, q = new Array(F);
      for (let de = 0; de < F; de++) {
        const Ne = w[de];
        q[de] = k(Ne, de);
      }
      return q;
    }, St = (w, k) => {
      for (let F = 0, q = w.length; F < q; F++) {
        const de = w[F];
        k(de, F);
      }
    }, A = (w, k) => {
      for (let F = w.length - 1; F >= 0; F--) {
        const q = w[F];
        k(q, F);
      }
    }, No = (w, k) => {
      const F = [], q = [];
      for (let de = 0, Ne = w.length; de < Ne; de++) {
        const ft = w[de];
        (k(ft, de) ? F : q).push(ft);
      }
      return { pass: F, fail: q };
    }, ot = (w, k) => {
      const F = [];
      for (let q = 0, de = w.length; q < de; q++) {
        const Ne = w[q];
        k(Ne, q) && F.push(Ne);
      }
      return F;
    }, jo = (w, k, F) => (A(w, (q, de) => {
      F = k(F, q, de);
    }), F), he = (w, k, F) => (St(w, (q, de) => {
      F = k(F, q, de);
    }), F), ue = (w, k, F) => {
      for (let q = 0, de = w.length; q < de; q++) {
        const Ne = w[q];
        if (k(Ne, q))
          return oe.some(Ne);
        if (F(Ne, q))
          break;
      }
      return oe.none();
    }, bt = (w, k) => ue(w, k, On), cn = (w) => {
      const k = [];
      for (let F = 0, q = w.length; F < q; ++F) {
        if (!De(w[F]))
          throw new Error("Arr.flatten item " + F + " was not an array, input: " + w);
        Gn.apply(k, w[F]);
      }
      return k;
    }, fn = (w, k) => cn(an(w, k)), Fn = (w, k) => {
      for (let F = 0, q = w.length; F < q; ++F) {
        const de = w[F];
        if (k(de, F) !== !0)
          return !1;
      }
      return !0;
    }, ye = (w, k) => {
      const F = {};
      for (let q = 0, de = w.length; q < de; q++) {
        const Ne = w[q];
        F[String(Ne)] = k(Ne, q);
      }
      return F;
    }, He = (w, k) => k >= 0 && k < w.length ? oe.some(w[k]) : oe.none(), P = (w) => He(w, 0), ro = (w) => He(w, w.length - 1), Ln = (w, k) => {
      for (let F = 0; F < w.length; F++) {
        const q = k(w[F], F);
        if (q.isSome())
          return q;
      }
      return oe.none();
    }, oo = Object.keys, ao = Object.hasOwnProperty, ur = (w, k) => {
      const F = oo(w);
      for (let q = 0, de = F.length; q < de; q++) {
        const Ne = F[q], ft = w[Ne];
        k(ft, Ne);
      }
    }, Lt = (w) => (k, F) => {
      w[F] = k;
    }, po = (w, k, F, q) => {
      ur(w, (de, Ne) => {
        (k(de, Ne) ? F : q)(de, Ne);
      });
    }, en = (w, k) => {
      const F = {};
      return po(w, k, Lt(F), pn), F;
    }, xe = (w, k) => {
      const F = [];
      return ur(w, (q, de) => {
        F.push(k(q, de));
      }), F;
    }, We = (w) => xe(w, In), st = (w) => oo(w).length, ze = (w, k) => no(w, k) ? oe.from(w[k]) : oe.none(), no = (w, k) => ao.call(w, k), qn = (w, k) => no(w, k) && w[k] !== void 0 && w[k] !== null, Io = (w) => {
      for (const k in w)
        if (ao.call(w, k))
          return !1;
      return !0;
    }, Jc = (w) => {
      let k = w;
      return {
        get: () => k,
        set: (de) => {
          k = de;
        }
      };
    }, _o = (w, k, F = lt) => w.exists((q) => F(q, k)), Ql = (w) => {
      const k = [], F = (q) => {
        k.push(q);
      };
      for (let q = 0; q < w.length; q++)
        w[q].each(F);
      return k;
    }, jm = (w, k, F) => w.isSome() && k.isSome() ? oe.some(F(w.getOrDie(), k.getOrDie())) : oe.none(), ga = (w) => w.bind(In), xo = (w, k) => w ? oe.some(k) : oe.none(), qa = (w) => {
      const k = Jc(oe.none()), F = () => k.get().each(w);
      return {
        clear: () => {
          F(), k.set(oe.none());
        },
        isSet: () => k.get().isSome(),
        get: () => k.get(),
        set: (Zt) => {
          F(), k.set(oe.some(Zt));
        }
      };
    }, ds = () => qa((w) => w.unbind()), Bs = (w, k) => w.substring(k), vu = (w, k, F) => k === "" || w.length >= k.length && w.substr(F, F + k.length) === k, Tl = (w, k) => Gr(w, k) ? Bs(w, k.length) : w, Gr = (w, k) => vu(w, k, 0), dr = ((w) => (k) => k.replace(w, ""))(/^\s+|\s+$/g), rs = (w) => w.length > 0, cc = (w) => !rs(w), Ka = (w, k = 10) => {
      const F = parseInt(w, k);
      return isNaN(F) ? oe.none() : oe.some(F);
    }, Vt = (w) => {
      const k = parseFloat(w);
      return isNaN(k) ? oe.none() : oe.some(k);
    }, mo = (w) => {
      let k = !1, F;
      return (...q) => (k || (k = !0, F = w.apply(null, q)), F);
    }, Un = (w, k) => {
      const q = (k || document).createElement("div");
      if (q.innerHTML = w, !q.hasChildNodes() || q.childNodes.length > 1) {
        const de = "HTML does not have a single root node";
        throw console.error(de, w), new Error(de);
      }
      return Pt(q.childNodes[0]);
    }, lc = (w, k) => {
      const q = (k || document).createElement(w);
      return Pt(q);
    }, Ma = (w, k) => {
      const q = (k || document).createTextNode(w);
      return Pt(q);
    }, Pt = (w) => {
      if (w == null)
        throw new Error("Node cannot be null or undefined");
      return {
        dom: w
      };
    }, as = {
      fromHtml: Un,
      fromTag: lc,
      fromText: Ma,
      fromDom: Pt,
      fromPoint: (w, k, F) => oe.from(w.dom.elementFromPoint(k, F)).map(Pt)
    }, Ri = 8, ic = 9, Pa = 11, Wo = 1, kn = 3, Zo = (w, k) => {
      const F = w.dom;
      if (F.nodeType !== Wo)
        return !1;
      {
        const q = F;
        if (q.matches !== void 0)
          return q.matches(k);
        if (q.msMatchesSelector !== void 0)
          return q.msMatchesSelector(k);
        if (q.webkitMatchesSelector !== void 0)
          return q.webkitMatchesSelector(k);
        if (q.mozMatchesSelector !== void 0)
          return q.mozMatchesSelector(k);
        throw new Error("Browser lacks native selectors");
      }
    }, rd = (w) => (
      // Only elements, documents and shadow roots support querySelector
      // shadow root element type is DOCUMENT_FRAGMENT
      w.nodeType !== Wo && w.nodeType !== ic && w.nodeType !== Pa || // IE fix for complex queries on empty nodes: http://jsfiddle.net/spyder/fv9ptr5L/
      w.childElementCount === 0
    ), yu = (w, k) => {
      const F = k === void 0 ? document : k.dom;
      return rd(F) ? [] : an(F.querySelectorAll(w), as.fromDom);
    }, el = (w, k) => {
      const F = k === void 0 ? document : k.dom;
      return rd(F) ? oe.none() : oe.from(F.querySelector(w)).map(as.fromDom);
    }, Wt = (w, k) => w.dom === k.dom, Ba = Zo, Or = (w) => w.dom.nodeName.toLowerCase(), Wm = (w) => w.dom.nodeType, xr = (w) => (k) => Wm(k) === w, Qd = (w) => Wm(w) === Ri || Or(w) === "#comment", os = xr(Wo), Ni = xr(kn), ad = xr(ic), Jl = xr(Pa), Nc = (w) => (k) => os(k) && Or(k) === w, nr = (w) => as.fromDom(w.dom.ownerDocument), Mi = (w) => ad(w) ? w : nr(w), Cu = (w) => oe.from(w.dom.parentNode).map(as.fromDom), Ct = (w, k) => {
      const F = vn(k) ? k : On;
      let q = w.dom;
      const de = [];
      for (; q.parentNode !== null && q.parentNode !== void 0; ) {
        const Ne = q.parentNode, ft = as.fromDom(Ne);
        if (de.push(ft), F(ft) === !0)
          break;
        q = Ne;
      }
      return de;
    }, Ya = (w) => oe.from(w.dom.previousSibling).map(as.fromDom), xu = (w) => oe.from(w.dom.nextSibling).map(as.fromDom), kl = (w) => an(w.dom.childNodes, as.fromDom), Ho = (w, k) => {
      const F = w.dom.childNodes;
      return oe.from(F[k]).map(as.fromDom);
    }, cd = (w) => Ho(w, 0), uc = (w) => Jl(w) && Mt(w.dom.host), Xs = (w) => as.fromDom(w.dom.getRootNode()), Al = (w) => {
      const k = Xs(w);
      return uc(k) ? oe.some(k) : oe.none();
    }, ld = (w) => as.fromDom(w.dom.host), $a = (w, k) => {
      Cu(w).each((q) => {
        q.dom.insertBefore(k.dom, w.dom);
      });
    }, Pr = (w, k) => {
      xu(w).fold(() => {
        Cu(w).each((de) => {
          Br(de, k);
        });
      }, (q) => {
        $a(q, k);
      });
    }, tl = (w, k) => {
      cd(w).fold(() => {
        Br(w, k);
      }, (q) => {
        w.dom.insertBefore(k.dom, q.dom);
      });
    }, Br = (w, k) => {
      w.dom.appendChild(k.dom);
    }, mh = (w, k) => {
      $a(w, k), Br(k, w);
    }, Jd = (w, k) => {
      St(k, (F, q) => {
        const de = q === 0 ? w : k[q - 1];
        Pr(de, F);
      });
    }, Mc = (w, k) => {
      St(k, (F) => {
        Br(w, F);
      });
    }, _l = (w, k, F) => {
      if (nn(F) || et(F) || Cn(F))
        w.setAttribute(k, F + "");
      else
        throw console.error("Invalid call to Attribute.set. Key ", k, ":: Value ", F, ":: Element ", w), new Error("Attribute value was not simple");
    }, ei = (w, k, F) => {
      _l(w.dom, k, F);
    }, Zm = (w, k) => {
      const F = w.dom;
      ur(k, (q, de) => {
        _l(F, de, q);
      });
    }, As = (w, k) => {
      const F = w.dom.getAttribute(k);
      return F === null ? void 0 : F;
    }, hn = (w, k) => oe.from(As(w, k)), qr = (w, k) => {
      w.dom.removeAttribute(k);
    }, Kr = (w) => he(w.dom.attributes, (k, F) => (k[F.name] = F.value, k), {}), _s = (w) => {
      const k = w.dom;
      k.parentNode !== null && k.parentNode.removeChild(k);
    }, em = (w) => {
      const k = kl(w);
      k.length > 0 && Jd(w, k), _s(w);
    }, Pi = (w) => an(w, as.fromDom), ms = (w) => w.style !== void 0 && vn(w.style.getPropertyValue), ti = (w) => {
      const k = Ni(w) ? w.dom.parentNode : w.dom;
      if (k == null || k.ownerDocument === null)
        return !1;
      const F = k.ownerDocument;
      return Al(as.fromDom(k)).fold(() => F.body.contains(k), un(ti, ld));
    }, nl = (w, k, F) => {
      if (!nn(F))
        throw console.error("Invalid call to CSS.set. Property ", k, ":: Value ", F, ":: Element ", w), new Error("CSS value must be a string: " + F);
      ms(w) && w.style.setProperty(k, F);
    }, Jf = (w, k) => {
      ms(w) && w.style.removeProperty(k);
    }, vt = (w, k, F) => {
      const q = w.dom;
      nl(q, k, F);
    }, ni = (w, k) => {
      const F = w.dom, de = window.getComputedStyle(F).getPropertyValue(k);
      return de === "" && !ti(w) ? ha(F, k) : de;
    }, ha = (w, k) => ms(w) ? w.style.getPropertyValue(k) : "", Pc = (w, k) => {
      const F = w.dom, q = ha(F, k);
      return oe.from(q).filter((de) => de.length > 0);
    }, $s = (w, k) => {
      const F = w.dom;
      Jf(F, k), _o(hn(w, "style").map(dr), "") && qr(w, "style");
    }, eg = (w, k) => Vt(w).getOr(k), Xa = (w, k, F) => eg(ni(w, k), F), Bc = (w, k, F, q) => {
      const de = Xa(w, `padding-${F}`, 0), Ne = Xa(w, `padding-${q}`, 0), ft = Xa(w, `border-${F}-width`, 0), Zt = Xa(w, `border-${q}-width`, 0);
      return k - de - Ne - ft - Zt;
    }, Gm = (w, k) => {
      const F = w.dom, q = F.getBoundingClientRect().width || F.offsetWidth;
      return Bc(w, q, "left", "right");
    }, oi = (w) => Gm(w), Su = ((w, k) => {
      const F = (Ne) => {
        if (!w(Ne))
          throw new Error("Can only get " + k + " value of a " + k + " node");
        return q(Ne).getOr("");
      }, q = (Ne) => w(Ne) ? oe.from(Ne.dom.nodeValue) : oe.none();
      return {
        get: F,
        getOption: q,
        set: (Ne, ft) => {
          if (!w(Ne))
            throw new Error("Can only set raw " + k + " value of a " + k + " node");
          Ne.dom.nodeValue = ft;
        }
      };
    })(Ni, "text"), si = (w) => Su.get(w), wu = (w, k) => Su.set(w, k);
    var at = (w, k, F, q, de) => w(F, q) ? oe.some(F) : vn(de) && de(F) ? oe.none() : k(F, q, de);
    const Bi = (w, k, F) => {
      let q = w.dom;
      const de = vn(F) ? F : On;
      for (; q.parentNode; ) {
        q = q.parentNode;
        const Ne = as.fromDom(q);
        if (k(Ne))
          return oe.some(Ne);
        if (de(Ne))
          break;
      }
      return oe.none();
    }, tm = (w, k, F) => at((de, Ne) => Ne(de), Bi, w, k, F), ol = (w, k) => {
      const F = (de) => k(as.fromDom(de));
      return bt(w.dom.childNodes, F).map(as.fromDom);
    }, dc = (w, k, F) => Bi(w, (q) => Zo(q, k), F), id = (w, k) => ol(w, (F) => Zo(F, k)), pa = (w, k) => el(k, w), Ol = (w, k, F) => at((de, Ne) => Zo(de, Ne), dc, w, k, F), $i = (w) => Ol(w, "[contenteditable]"), ri = (w, k = !1) => ti(w) ? w.dom.isContentEditable : $i(w).fold(Xe(k), (F) => zo(F) === "true"), zo = (w) => w.dom.contentEditable, ud = (w, k) => ot(kl(w), k), B = (w, k) => {
      let F = [];
      return St(kl(w), (q) => {
        k(q) && (F = F.concat([q])), F = F.concat(B(q, k));
      }), F;
    }, G = (w, k) => (
      // It may surprise you to learn this is exactly what JQuery does
      // TODO: Avoid all the wrapping and unwrapping
      ud(w, (F) => Zo(F, k))
    ), re = (w, k) => yu(k, w), Pe = (w, k) => id(w, k).isSome(), Ht = (w) => w.nodeName.toLowerCase(), Jn = (w) => as.fromDom(w.getBody()), Vo = (w) => (k) => Wt(k, Jn(w)), Sr = (w) => w ? w.replace(/px$/, "") : "", Yr = (w) => /^\d+(\.\d+)?$/.test(w) ? w + "px" : w, Qa = (w) => as.fromDom(w.selection.getStart()), I = (w) => as.fromDom(w.selection.getEnd()), ee = (w) => tm(w, Nc("table")).forall(ri), fe = ["tfoot", "thead", "tbody", "colgroup"], _e = (w) => X(fe, w), it = (w, k) => ({
      rows: w,
      columns: k
    }), It = (w, k, F) => ({
      element: w,
      rowspan: k,
      colspan: F
    }), Mn = (w, k, F, q, de, Ne) => ({
      element: w,
      rowspan: k,
      colspan: F,
      row: q,
      column: de,
      isLocked: Ne
    }), wo = (w, k, F) => ({
      element: w,
      cells: k,
      section: F
    }), co = (w, k, F, q) => ({
      startRow: w,
      startCol: k,
      finishRow: F,
      finishCol: q
    }), ba = (w, k, F) => ({
      element: w,
      colspan: k,
      column: F
    }), Ws = (w, k) => ({
      element: w,
      columns: k
    }), Eu = (w, k, F = 0) => hn(w, k).map((q) => parseInt(q, 10)).getOr(F), qm = (w, k) => nm(w, k, Ot), nm = (w, k, F) => fn(kl(w), (q) => Zo(q, k) ? F(q) ? [q] : [] : nm(q, k, F)), Dl = (w, k, F = On) => {
      if (F(k))
        return oe.none();
      if (X(w, Or(k)))
        return oe.some(k);
      const q = (de) => Zo(de, "table") || F(de);
      return dc(k, w.join(","), q);
    }, Yb = (w, k) => Dl(["td", "th"], w, k), Xb = (w) => qm(w, "th,td"), Fp = (w) => Zo(w, "colgroup") ? G(w, "col") : fn(Jb(w), (k) => G(k, "col")), Rl = (w, k) => Ol(w, "table", k), Qb = (w) => qm(w, "tr"), Jb = (w) => Rl(w).fold(Xe([]), (k) => G(k, "colgroup")), jy = Nc("th"), Ii = (w, k) => w && k ? "sectionCells" : w ? "section" : "cells", Wy = (w) => {
      const k = w.section === "thead", F = _o(Zy(w.cells), "th");
      return w.section === "tfoot" ? { type: "footer" } : k || F ? { type: "header", subType: Ii(k, F) } : { type: "body" };
    }, Zy = (w) => {
      const k = ot(w, (F) => jy(F.element));
      return k.length === 0 ? oe.some("td") : k.length === w.length ? oe.some("th") : oe.none();
    }, Lp = (w) => {
      const k = an(w, (de) => Wy(de).type), F = X(k, "header"), q = X(k, "footer");
      if (!F && !q)
        return oe.some("body");
      {
        const de = X(k, "body");
        return F && !de && !q ? oe.some("header") : !F && !de && q ? oe.some("footer") : oe.none();
      }
    }, Hp = (w, k) => an(w, (F) => {
      if (Or(F) === "colgroup") {
        const q = an(Fp(F), (de) => {
          const Ne = Eu(de, "span", 1);
          return It(de, 1, Ne);
        });
        return wo(F, q, "colgroup");
      } else {
        const q = an(Xb(F), (de) => {
          const Ne = Eu(de, "rowspan", 1), ft = Eu(de, "colspan", 1);
          return It(de, Ne, ft);
        });
        return wo(F, q, k(F));
      }
    }), NS = (w) => Cu(w).map((k) => {
      const F = Or(k);
      return _e(F) ? F : "tbody";
    }).getOr("tbody"), Gy = (w) => {
      const k = Qb(w), q = [...Jb(w), ...k];
      return Hp(q, NS);
    }, zp = "data-snooker-locked-cols", Fi = (w) => hn(w, zp).bind((k) => oe.from(k.match(/\d+/g))).map((k) => ye(k, Ot)), sl = (w, k) => w + "," + k, om = (w, k, F) => oe.from(w.access[sl(k, F)]), qy = (w, k, F) => {
      const q = fo(w, (de) => F(k, de.element));
      return q.length > 0 ? oe.some(q[0]) : oe.none();
    }, fo = (w, k) => {
      const F = fn(w.all, (q) => q.cells);
      return ot(F, k);
    }, Ky = (w) => {
      const k = {};
      let F = 0;
      return St(w.cells, (q) => {
        const de = q.colspan;
        ns(de, (Ne) => {
          const ft = F + Ne;
          k[ft] = ba(q.element, de, ft);
        }), F += de;
      }), k;
    }, fh = (w) => {
      const k = {}, F = [], de = P(w).map((Hc) => Hc.element).bind(Rl).bind(Fi).getOr({});
      let Ne = 0, ft = 0, Zt = 0;
      const { pass: Dn, fail: Vn } = No(w, (Hc) => Hc.section === "colgroup");
      St(Vn, (Hc) => {
        const gi = [];
        St(Hc.cells, (Du) => {
          let Hl = 0;
          for (; k[sl(Zt, Hl)] !== void 0; )
            Hl++;
          const l1 = qn(de, Hl.toString()), sf = Mn(Du.element, Du.rowspan, Du.colspan, Zt, Hl, l1);
          for (let mg = 0; mg < Du.colspan; mg++)
            for (let fg = 0; fg < Du.rowspan; fg++) {
              const gg = Zt + fg, rf = Hl + mg, xh = sl(gg, rf);
              k[xh] = sf, ft = Math.max(ft, rf + 1);
            }
          gi.push(sf);
        }), Ne++, F.push(wo(Hc.element, gi, Hc.section)), Zt++;
      });
      const { columns: ss, colgroups: ws } = ro(Dn).map((Hc) => {
        const gi = Ky(Hc);
        return {
          colgroups: [Ws(Hc.element, We(gi))],
          columns: gi
        };
      }).getOrThunk(() => ({
        colgroups: [],
        columns: {}
      }));
      return {
        grid: it(Ne, ft),
        access: k,
        all: F,
        columns: ss,
        colgroups: ws
      };
    }, Zs = {
      fromTable: (w) => {
        const k = Gy(w);
        return fh(k);
      },
      generate: fh,
      getAt: om,
      findItem: qy,
      filterItems: fo,
      justCells: (w) => fn(w.all, (k) => k.cells),
      justColumns: (w) => We(w.columns),
      hasColumns: (w) => oo(w.columns).length > 0,
      getColumnAt: (w, k) => oe.from(w.columns[k])
    }, sm = (w, k) => Ln(w.all, (F) => bt(F.cells, (q) => Wt(k, q.element))), Yy = (w, k, F) => {
      const q = an(k.selection, (Ne) => Yb(Ne).bind((ft) => sm(w, ft)).filter(F)), de = Ql(q);
      return xo(de.length > 0, de);
    }, Je = (w, k) => k.mergable, $c = (w, k) => k.unmergable, og = (w, k) => Yy(w, k, Ot), Nl = (w, k) => sm(w, k).exists((F) => !F.isLocked), Km = (w, k) => Fn(k, (F) => Nl(w, F)), Up = (w, k) => Je(w, k).filter((F) => Km(w, F.cells)), te = (w, k) => $c(w, k).filter((F) => Km(w, F));
    var mc = [
      "body",
      "p",
      "div",
      "article",
      "aside",
      "figcaption",
      "figure",
      "footer",
      "header",
      "nav",
      "section",
      "ol",
      "ul",
      "li",
      "table",
      "thead",
      "tbody",
      "tfoot",
      "caption",
      "tr",
      "td",
      "th",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "blockquote",
      "pre",
      "address"
    ], dd = () => {
      const w = (Vn) => as.fromDom(Vn.dom.cloneNode(!1)), k = (Vn) => Mi(Vn).dom, F = (Vn) => os(Vn) ? Or(Vn) === "body" ? !0 : X(mc, Or(Vn)) : !1, q = (Vn) => os(Vn) ? X(["br", "img", "hr", "input"], Or(Vn)) : !1, de = (Vn) => os(Vn) && As(Vn, "contenteditable") === "false", Ne = (Vn, ss) => Vn.dom.compareDocumentPosition(ss.dom), ft = (Vn, ss) => {
        const ws = Kr(Vn);
        Zm(ss, ws);
      }, Zt = (Vn) => {
        const ss = Or(Vn);
        return X([
          "script",
          "noscript",
          "iframe",
          "noframes",
          "noembed",
          "title",
          "style",
          "textarea",
          "xmp"
        ], ss);
      }, Dn = (Vn) => os(Vn) ? hn(Vn, "lang") : oe.none();
      return {
        up: Xe({
          selector: dc,
          closest: Ol,
          predicate: Bi,
          all: Ct
        }),
        down: Xe({
          selector: re,
          predicate: B
        }),
        styles: Xe({
          get: ni,
          getRaw: Pc,
          set: vt,
          remove: $s
        }),
        attrs: Xe({
          get: As,
          set: ei,
          remove: qr,
          copyTo: ft
        }),
        insert: Xe({
          before: $a,
          after: Pr,
          afterAll: Jd,
          append: Br,
          appendAll: Mc,
          prepend: tl,
          wrap: mh
        }),
        remove: Xe({
          unwrap: em,
          remove: _s
        }),
        create: Xe({
          nu: as.fromTag,
          clone: w,
          text: as.fromText
        }),
        query: Xe({
          comparePosition: Ne,
          prevSibling: Ya,
          nextSibling: xu
        }),
        property: Xe({
          children: kl,
          name: Or,
          parent: Cu,
          document: k,
          isText: Ni,
          isComment: Qd,
          isElement: os,
          isSpecial: Zt,
          getLanguage: Dn,
          getText: si,
          setText: wu,
          isBoundary: F,
          isEmptyTag: q,
          isNonEditable: de
        }),
        eq: Wt,
        is: Ba
      };
    };
    const jp = (w, k, F, q) => {
      const de = F[0], Ne = F.slice(1);
      return q(w, k, de, Ne);
    }, Ym = (w, k, F) => F.length > 0 ? jp(w, k, F, va) : oe.none(), va = (w, k, F, q) => {
      const de = k(w, F);
      return jo(q, (Ne, ft) => {
        const Zt = k(w, ft);
        return fc(w, Ne, Zt);
      }, de);
    }, fc = (w, k, F) => k.bind((q) => F.filter(U(w.eq, q))), Wp = Ym, Zp = dd(), sg = (w, k) => Wp(Zp, (F, q) => w(q), k), Gp = (w, k) => {
      const F = Zs.fromTable(w);
      return og(F, k).bind((de) => {
        const Ne = de[de.length - 1], ft = de[0].row, Zt = Ne.row + Ne.rowspan, Dn = F.all.slice(ft, Zt);
        return Lp(Dn);
      }).getOr("");
    }, Li = (w, k) => k.column >= w.startCol && k.column + k.colspan - 1 <= w.finishCol && k.row >= w.startRow && k.row + k.rowspan - 1 <= w.finishRow, rg = (w, k) => {
      let F = !0;
      const q = U(Li, k);
      for (let de = k.startRow; de <= k.finishRow; de++)
        for (let Ne = k.startCol; Ne <= k.finishCol; Ne++)
          F = F && Zs.getAt(w, de, Ne).exists(q);
      return F ? oe.some(k) : oe.none();
    }, qp = (w, k) => co(Math.min(w.row, k.row), Math.min(w.column, k.column), Math.max(w.row + w.rowspan - 1, k.row + k.rowspan - 1), Math.max(w.column + w.colspan - 1, k.column + k.colspan - 1)), Ic = (w, k, F) => {
      const q = Zs.findItem(w, k, Wt), de = Zs.findItem(w, F, Wt);
      return q.bind((Ne) => de.map((ft) => qp(Ne, ft)));
    }, Kp = (w, k, F) => Ic(w, k, F).bind((q) => rg(w, q)), ai = (w, k, F) => {
      const q = md(w);
      return Kp(q, k, F);
    }, md = Zs.fromTable;
    var Qn = tinymce.util.Tools.resolve("tinymce.util.Tools");
    const Ja = (w, k, F) => {
      const q = w.select("td,th", k);
      let de;
      for (let Ne = 0; Ne < q.length; Ne++) {
        const ft = w.getStyle(q[Ne], F);
        if (Tt(de) && (de = ft), de !== ft)
          return "";
      }
      return de;
    }, Xm = (w, k, F) => {
      Qn.each("left center right".split(" "), (q) => {
        q !== F && w.formatter.remove("align" + q, {}, k);
      }), F && w.formatter.apply("align" + F, {}, k);
    }, t0 = (w, k, F) => {
      Qn.each("top middle bottom".split(" "), (q) => {
        q !== F && w.formatter.remove("valign" + q, {}, k);
      }), F && w.formatter.apply("valign" + F, {}, k);
    }, Hn = (w, k, F) => {
      w.dispatch("TableModified", { ...F, table: k });
    };
    var Tu = tinymce.util.Tools.resolve("tinymce.Env");
    const mr = "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol", ci = ns(5, (w) => {
      const k = `${w + 1}px`;
      return { title: k, value: k };
    }), li = an(["Solid", "Dotted", "Dashed", "Double", "Groove", "Ridge", "Inset", "Outset", "None", "Hidden"], (w) => ({ title: w, value: w.toLowerCase() })), Is = "100%", Eo = (w) => {
      const k = w.dom, F = k.getParent(w.selection.getStart(), k.isBlock) ?? w.getBody();
      return oi(as.fromDom(F)) + "px";
    }, Xy = (w, k) => Yp(w) || !tc(w) ? k : fd(w) ? { ...k, width: Eo(w) } : { ...k, width: Is }, Qy = (w, k) => Yp(w) || tc(w) ? k : fd(w) ? { ...k, width: Eo(w) } : { ...k, width: Is }, fr = (w) => (k) => k.options.get(w), Ml = (w) => {
      const k = w.options.register;
      k("table_border_widths", {
        processor: "object[]",
        default: ci
      }), k("table_border_styles", {
        processor: "object[]",
        default: li
      }), k("table_cell_advtab", {
        processor: "boolean",
        default: !0
      }), k("table_row_advtab", {
        processor: "boolean",
        default: !0
      }), k("table_advtab", {
        processor: "boolean",
        default: !0
      }), k("table_appearance_options", {
        processor: "boolean",
        default: !0
      }), k("table_grid", {
        processor: "boolean",
        // Table grid relies on hover, which isn't available on touch devices so use the dialog instead
        default: !Tu.deviceType.isTouch()
      }), k("table_cell_class_list", {
        processor: "object[]",
        default: []
      }), k("table_row_class_list", {
        processor: "object[]",
        default: []
      }), k("table_class_list", {
        processor: "object[]",
        default: []
      }), k("table_toolbar", {
        processor: "string",
        default: mr
      }), k("table_background_color_map", {
        processor: "object[]",
        default: []
      }), k("table_border_color_map", {
        processor: "object[]",
        default: []
      });
    }, Pl = fr("table_sizing_mode"), gr = fr("table_border_widths"), ii = fr("table_border_styles"), ec = fr("table_cell_advtab"), Fc = fr("table_row_advtab"), ya = fr("table_advtab"), Oo = fr("table_appearance_options"), rl = fr("table_grid"), tc = fr("table_style_by_css"), Xr = fr("table_cell_class_list"), $r = fr("table_row_class_list"), Os = fr("table_class_list"), Bl = fr("table_toolbar"), Ir = fr("table_background_color_map"), or = fr("table_border_color_map"), fd = (w) => Pl(w) === "fixed", Yp = (w) => Pl(w) === "responsive", gh = (w) => {
      const k = w.options, F = k.get("table_default_styles");
      return k.isSet("table_default_styles") ? F : Xy(w, F);
    }, Fr = (w) => {
      const k = w.options, F = k.get("table_default_attributes");
      return k.isSet("table_default_attributes") ? F : Qy(w, F);
    }, Xp = (w) => dc(w, "table"), n0 = (w, k) => {
      const F = re(w, k);
      return F.length > 0 ? oe.some(F) : oe.none();
    }, rm = (w, k, F) => pa(w, k).bind((q) => pa(w, F).bind((de) => sg(Xp, [q, de]).map((Ne) => ({
      first: q,
      last: de,
      table: Ne
    })))), ln = (w, k) => n0(w, k), Qp = (w, k, F) => rm(w, k, F).bind((q) => {
      const de = (Dn) => Wt(w, Dn), Ne = "thead,tfoot,tbody,table", ft = dc(q.first, Ne, de), Zt = dc(q.last, Ne, de);
      return ft.bind((Dn) => Zt.bind((Vn) => Wt(Dn, Vn) ? ai(q.table, q.first, q.last) : oe.none()));
    }), Dr = In, Qr = (w) => {
      const k = (q, de) => hn(q, de).exists((Ne) => parseInt(Ne, 10) > 1), F = (q) => k(q, "rowspan") || k(q, "colspan");
      return w.length > 0 && Fn(w, F) ? oe.some(w) : oe.none();
    }, Jr = (w, k, F) => k.length <= 1 ? oe.none() : Qp(w, F.firstSelectedSelector, F.lastSelectedSelector).map((q) => ({ bounds: q, cells: k })), fs = "data-mce-selected", gd = "data-mce-first-selected", hh = "td[" + gd + "],th[" + gd + "]", al = "data-mce-last-selected", ui = "td[" + al + "],th[" + al + "]", ag = {
      selected: fs,
      firstSelectedSelector: hh,
      lastSelectedSelector: ui
    }, ph = (w) => Rl(w).bind((k) => ln(k, ag.firstSelectedSelector)).fold(Xe(w), (k) => k[0]), cg = (w) => (k, F) => {
      const q = Or(k), de = q === "col" || q === "colgroup" ? ph(k) : k;
      return Ol(de, w, F);
    }, Hi = cg("th,td,caption"), $l = cg("th,td"), Jp = (w) => Pi(w.model.table.getSelectedCells()), ca = (w, k) => {
      const F = $l(w), q = F.bind((de) => Rl(de)).map((de) => Qb(de));
      return jm(F, q, (de, Ne) => ot(Ne, (ft) => se(Pi(ft.dom.cells), (Zt) => As(Zt, k) === "1" || Wt(Zt, de)))).getOr([]);
    }, cl = [
      {
        text: "None",
        value: ""
      },
      {
        text: "Top",
        value: "top"
      },
      {
        text: "Middle",
        value: "middle"
      },
      {
        text: "Bottom",
        value: "bottom"
      }
    ], zi = (w) => ({
      value: lg(w)
    }), bo = /^#?([a-f\d])([a-f\d])([a-f\d])$/i, Lc = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i, o0 = (w) => bo.test(w) || Lc.test(w), lg = (w) => Tl(w, "#").toUpperCase(), ll = (w) => o0(w) ? oe.some({ value: lg(w) }) : oe.none(), gn = (w) => {
      const k = w.toString(16);
      return (k.length === 1 ? "0" + k : k).toUpperCase();
    }, Ss = (w) => {
      const k = gn(w.red) + gn(w.green) + gn(w.blue);
      return zi(k);
    }, ea = /^\s*rgb\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*\)\s*$/i, gs = /^\s*rgba\s*\(\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*(\d+)\s*[,\s]\s*((?:\d?\.\d+|\d+)%?)\s*\)\s*$/i, il = (w, k, F, q) => ({
      red: w,
      green: k,
      blue: F,
      alpha: q
    }), Cs = (w, k, F, q) => {
      const de = parseInt(w, 10), Ne = parseInt(k, 10), ft = parseInt(F, 10), Zt = parseFloat(q);
      return il(de, Ne, ft, Zt);
    }, sr = (w) => {
      const k = ea.exec(w);
      if (k !== null)
        return oe.some(Cs(k[1], k[2], k[3], "1"));
      const F = gs.exec(w);
      return F !== null ? oe.some(Cs(F[1], F[2], F[3], F[4])) : oe.none();
    }, Qm = (w) => ll(w).orThunk(() => sr(w).map(Ss)).getOrThunk(() => {
      const k = document.createElement("canvas");
      k.height = 1, k.width = 1;
      const F = k.getContext("2d");
      F.clearRect(0, 0, k.width, k.height), F.fillStyle = "#FFFFFF", F.fillStyle = w, F.fillRect(0, 0, 1, 1);
      const q = F.getImageData(0, 0, 1, 1).data, de = q[0], Ne = q[1], ft = q[2], Zt = q[3];
      return Ss(il(de, Ne, ft, Zt));
    }), Kn = (w) => sr(w).map(Ss).map((k) => "#" + k.value).getOr(w), Il = (w, k, F) => (q) => {
      const de = ds(), Ne = cc(F), ft = () => {
        const Zt = Jp(w), Dn = (Vn) => w.formatter.match(k, { value: F }, Vn.dom, Ne);
        Ne ? (q.setActive(!se(Zt, Dn)), de.set(w.formatter.formatChanged(k, (Vn) => q.setActive(!Vn), !0))) : (q.setActive(Fn(Zt, Dn)), de.set(w.formatter.formatChanged(k, q.setActive, !1, { value: F })));
      };
      return w.initialized ? ft() : w.on("init", ft), de.clear;
    }, qo = (w) => qn(w, "menu"), hc = (w) => an(w, (k) => {
      const F = k.text || k.title || "";
      return qo(k) ? {
        text: F,
        items: hc(k.menu)
      } : {
        text: F,
        value: k.value
      };
    }), hr = (w) => w.length ? oe.some(hc([{ text: "Select...", value: "mce-no-match" }, ...w])) : oe.none(), pr = (w, k, F, q) => an(k, (de) => {
      const Ne = de.text || de.title;
      return qo(de) ? {
        type: "nestedmenuitem",
        text: Ne,
        getSubmenuItems: () => pr(w, de.menu, F, q)
      } : {
        text: Ne,
        type: "togglemenuitem",
        onAction: () => q(de.value),
        onSetup: Il(w, F, de.value)
      };
    }), Vi = (w, k) => (F) => {
      w.execCommand("mceTableApplyCellStyle", !1, { [k]: F });
    }, Jm = (w) => fn(w, (k) => qo(k) ? [{ ...k, menu: Jm(k.menu) }] : rs(k.value) ? [k] : []), ku = (w, k, F, q) => (de) => de(pr(w, k, F, q)), hd = (w, k, F) => {
      const q = an(k, (de) => ({
        text: de.title,
        value: "#" + Qm(de.value).value,
        type: "choiceitem"
      }));
      return [{
        type: "fancymenuitem",
        fancytype: "colorswatch",
        initData: {
          colors: q.length > 0 ? q : void 0,
          allowCustomColors: !1
        },
        onAction: (de) => {
          const Ne = de.value === "remove" ? "" : de.value;
          w.execCommand("mceTableApplyCellStyle", !1, { [F]: Ne });
        }
      }];
    }, pd = (w) => () => {
      const F = w.queryCommandValue("mceTableRowType") === "header" ? "body" : "header";
      w.execCommand("mceTableRowType", !1, { type: F });
    }, la = (w) => () => {
      const F = w.queryCommandValue("mceTableColType") === "th" ? "td" : "th";
      w.execCommand("mceTableColType", !1, { type: F });
    }, Au = (w) => hr(Xr(w)).map((k) => ({
      name: "class",
      type: "listbox",
      label: "Class",
      items: k
    })), Jy = [
      {
        name: "width",
        type: "input",
        label: "Width"
      },
      {
        name: "celltype",
        type: "listbox",
        label: "Cell type",
        items: [
          { text: "Cell", value: "td" },
          { text: "Header cell", value: "th" }
        ]
      },
      {
        name: "scope",
        type: "listbox",
        label: "Scope",
        items: [
          { text: "None", value: "" },
          { text: "Row", value: "row" },
          { text: "Column", value: "col" },
          { text: "Row group", value: "rowgroup" },
          { text: "Column group", value: "colgroup" }
        ]
      },
      {
        name: "halign",
        type: "listbox",
        label: "Horizontal align",
        items: [
          { text: "None", value: "" },
          { text: "Left", value: "left" },
          { text: "Center", value: "center" },
          { text: "Right", value: "right" }
        ]
      },
      {
        name: "valign",
        type: "listbox",
        label: "Vertical align",
        items: cl
      }
    ], bd = (w) => Jy.concat(Au(w).toArray()), Mo = (w, k) => {
      const q = [
        {
          name: "borderstyle",
          type: "listbox",
          label: "Border style",
          items: [{ text: "Select...", value: "" }].concat(hc(ii(w)))
        },
        {
          name: "bordercolor",
          type: "colorinput",
          label: "Border color"
        },
        {
          name: "backgroundcolor",
          type: "colorinput",
          label: "Background color"
        }
      ];
      return {
        title: "Advanced",
        name: "advanced",
        items: k === "cell" ? [{
          name: "borderwidth",
          type: "input",
          label: "Border width"
        }].concat(q) : q
      };
    }, ef = {
      normal: (w, k) => {
        const F = w.dom;
        return {
          setAttrib: (ft, Zt) => {
            F.setAttrib(k, ft, Zt);
          },
          setStyle: (ft, Zt) => {
            F.setStyle(k, ft, Zt);
          },
          setFormat: (ft, Zt) => {
            Zt === "" ? w.formatter.remove(ft, { value: null }, k, !0) : w.formatter.apply(ft, { value: Zt }, k);
          }
        };
      }
    }, Ca = (w) => Gr(w, "rgb") ? Kn(w) : w, pc = (w) => {
      const k = as.fromDom(w);
      return {
        borderwidth: Pc(k, "border-width").getOr(""),
        borderstyle: Pc(k, "border-style").getOr(""),
        bordercolor: Pc(k, "border-color").map(Ca).getOr(""),
        backgroundcolor: Pc(k, "background-color").map(Ca).getOr("")
      };
    }, Ls = (w) => {
      const k = w[0], F = w.slice(1);
      return St(F, (q) => {
        St(oo(k), (de) => {
          ur(q, (Ne, ft) => {
            const Zt = k[de];
            Zt !== "" && de === ft && Zt !== Ne && (k[de] = de === "class" ? "mce-no-match" : "");
          });
        });
      }), k;
    }, _u = (w, k, F, q) => bt(w, (de) => !Tt(F.formatter.matchNode(q, k + de))).getOr(""), rr = U(_u, ["left", "center", "right"], "align"), tf = U(_u, ["top", "middle", "bottom"], "valign"), bh = (w, k) => {
      const F = gh(w), q = Fr(w), de = () => ({
        borderstyle: ze(F, "border-style").getOr(""),
        bordercolor: Ca(ze(F, "border-color").getOr("")),
        backgroundcolor: Ca(ze(F, "background-color").getOr(""))
      }), Ne = {
        height: "",
        width: "100%",
        cellspacing: "",
        cellpadding: "",
        caption: !1,
        class: "",
        align: "",
        border: ""
      }, ft = () => {
        const ss = F["border-width"];
        return tc(w) && ss ? { border: ss } : ze(q, "border").fold(() => ({}), (ws) => ({ border: ws }));
      }, Zt = k ? de() : {}, Dn = () => {
        const ss = ze(F, "border-spacing").or(ze(q, "cellspacing")).fold(() => ({}), (lr) => ({ cellspacing: lr })), ws = ze(F, "border-padding").or(ze(q, "cellpadding")).fold(() => ({}), (lr) => ({ cellpadding: lr }));
        return {
          ...ss,
          ...ws
        };
      };
      return {
        ...Ne,
        ...F,
        ...q,
        ...Zt,
        ...ft(),
        ...Dn()
      };
    }, t1 = (w) => Rl(as.fromDom(w)).map((k) => {
      const F = { selection: Pi(w.cells) };
      return Gp(k, F);
    }).getOr(""), BS = (w, k, F) => {
      const q = (Zt, Dn) => {
        const Vn = Pc(as.fromDom(Dn), "border-width");
        return tc(w) && Vn.isSome() ? Vn.getOr("") : Zt.getAttrib(Dn, "border") || Ja(w.dom, Dn, "border-width") || Ja(w.dom, Dn, "border") || "";
      }, de = w.dom, Ne = tc(w) ? de.getStyle(k, "border-spacing") || de.getAttrib(k, "cellspacing") : de.getAttrib(k, "cellspacing") || de.getStyle(k, "border-spacing"), ft = tc(w) ? Ja(de, k, "padding") || de.getAttrib(k, "cellpadding") : de.getAttrib(k, "cellpadding") || Ja(de, k, "padding");
      return {
        width: de.getStyle(k, "width") || de.getAttrib(k, "width"),
        height: de.getStyle(k, "height") || de.getAttrib(k, "height"),
        cellspacing: Ne ?? "",
        cellpadding: ft ?? "",
        border: q(de, k),
        caption: !!de.select("caption", k)[0],
        class: de.getAttrib(k, "class", ""),
        align: rr(w, k),
        ...F ? pc(k) : {}
      };
    }, di = (w, k, F) => {
      const q = w.dom;
      return {
        height: q.getStyle(k, "height") || q.getAttrib(k, "height"),
        class: q.getAttrib(k, "class", ""),
        type: t1(k),
        align: rr(w, k),
        ...F ? pc(k) : {}
      };
    }, e2 = (w, k, F, q) => {
      const de = w.dom, Ne = q.getOr(k);
      return {
        width: ((Zt, Dn) => de.getStyle(Zt, Dn) || de.getAttrib(Zt, Dn))(Ne, "width"),
        scope: de.getAttrib(k, "scope"),
        celltype: Ht(k),
        class: de.getAttrib(k, "class", ""),
        halign: rr(w, k),
        valign: tf(w, k),
        ...F ? pc(k) : {}
      };
    }, n1 = (w, k) => {
      const F = Zs.fromTable(w), q = Zs.justCells(F), de = ot(q, (Ne) => se(k, (ft) => Wt(Ne.element, ft)));
      return an(de, (Ne) => ({
        element: Ne.element.dom,
        column: Zs.getColumnAt(F, Ne.column).map((ft) => ft.element.dom)
      }));
    }, mi = (w, k, F, q) => {
      q("scope") && w.setAttrib("scope", F.scope), q("class") && F.class !== "mce-no-match" && w.setAttrib("class", F.class), q("width") && k.setStyle("width", Yr(F.width));
    }, s0 = (w, k, F) => {
      F("backgroundcolor") && w.setFormat("tablecellbackgroundcolor", k.backgroundcolor), F("bordercolor") && w.setFormat("tablecellbordercolor", k.bordercolor), F("borderstyle") && w.setFormat("tablecellborderstyle", k.borderstyle), F("borderwidth") && w.setFormat("tablecellborderwidth", Yr(k.borderwidth));
    }, nf = (w, k, F, q) => {
      const de = k.length === 1;
      St(k, (Ne) => {
        const ft = Ne.element, Zt = de ? Ot : q, Dn = ef.normal(w, ft), Vn = Ne.column.map((ss) => ef.normal(w, ss)).getOr(Dn);
        mi(Dn, Vn, F, Zt), ec(w) && s0(Dn, F, Zt), q("halign") && Xm(w, ft, F.halign), q("valign") && t0(w, ft, F.valign);
      });
    }, ig = (w, k) => {
      w.execCommand("mceTableCellType", !1, { type: k.celltype, no_events: !0 });
    }, ug = (w, k, F, q) => {
      const de = en(q, (Ne, ft) => F[ft] !== Ne);
      st(de) > 0 && k.length >= 1 && Rl(k[0]).each((Ne) => {
        const ft = n1(Ne, k), Zt = st(en(de, (Vn, ss) => ss !== "scope" && ss !== "celltype")) > 0, Dn = no(de, "celltype");
        (Zt || no(de, "scope")) && nf(w, ft, q, U(no, de)), Dn && ig(w, q), Hn(w, Ne.dom, {
          structure: Dn,
          style: Zt
        });
      });
    }, o1 = (w, k, F, q) => {
      const de = q.getData();
      q.close(), w.undoManager.transact(() => {
        ug(w, k, F, de), w.focus();
      });
    }, r0 = (w, k) => {
      const F = Rl(k[0]).map((q) => an(n1(q, k), (de) => e2(w, de.element, ec(w), de.column)));
      return Ls(F.getOrDie());
    }, Fl = (w) => {
      const k = Jp(w);
      if (k.length === 0)
        return;
      const F = r0(w, k), q = {
        type: "tabpanel",
        tabs: [
          {
            title: "General",
            name: "general",
            items: bd(w)
          },
          Mo(w, "cell")
        ]
      }, de = {
        type: "panel",
        items: [
          {
            type: "grid",
            columns: 2,
            items: bd(w)
          }
        ]
      };
      w.windowManager.open({
        title: "Cell Properties",
        size: "normal",
        body: ec(w) ? q : de,
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: F,
        onSubmit: U(o1, w, k, F)
      });
    }, t2 = (w) => hr($r(w)).map((k) => ({
      name: "class",
      type: "listbox",
      label: "Class",
      items: k
    })), vd = [
      {
        type: "listbox",
        name: "type",
        label: "Row type",
        items: [
          { text: "Header", value: "header" },
          { text: "Body", value: "body" },
          { text: "Footer", value: "footer" }
        ]
      },
      {
        type: "listbox",
        name: "align",
        label: "Alignment",
        items: [
          { text: "None", value: "" },
          { text: "Left", value: "left" },
          { text: "Center", value: "center" },
          { text: "Right", value: "right" }
        ]
      },
      {
        label: "Height",
        name: "height",
        type: "input"
      }
    ], Po = (w) => vd.concat(t2(w).toArray()), xa = (w, k, F) => {
      F("class") && k.class !== "mce-no-match" && w.setAttrib("class", k.class), F("height") && w.setStyle("height", Yr(k.height));
    }, Ui = (w, k, F) => {
      F("backgroundcolor") && w.setStyle("background-color", k.backgroundcolor), F("bordercolor") && w.setStyle("border-color", k.bordercolor), F("borderstyle") && w.setStyle("border-style", k.borderstyle);
    }, s1 = (w, k, F, q) => {
      const Ne = k.length === 1 ? Ot : q;
      St(k, (ft) => {
        const Zt = G(as.fromDom(ft), "td,th"), Dn = ef.normal(w, ft);
        xa(Dn, F, Ne), Fc(w) && Ui(Dn, F, Ne), q("height") && St(Zt, (Vn) => {
          w.dom.setStyle(Vn.dom, "height", null);
        }), q("align") && Xm(w, ft, F.align);
      });
    }, yd = (w, k) => {
      w.execCommand("mceTableRowType", !1, { type: k.type, no_events: !0 });
    }, r1 = (w, k, F, q) => {
      const de = en(q, (Ne, ft) => F[ft] !== Ne);
      if (st(de) > 0) {
        const Ne = no(de, "type"), ft = Ne ? st(de) > 1 : !0;
        ft && s1(w, k, q, U(no, de)), Ne && yd(w, q), Rl(as.fromDom(k[0])).each((Zt) => Hn(w, Zt.dom, {
          structure: Ne,
          style: ft
        }));
      }
    }, a0 = (w, k, F, q) => {
      const de = q.getData();
      q.close(), w.undoManager.transact(() => {
        r1(w, k, F, de), w.focus();
      });
    }, ji = (w) => {
      const k = ca(Qa(w), ag.selected);
      if (k.length === 0)
        return;
      const F = an(k, (ft) => di(w, ft.dom, Fc(w))), q = Ls(F), de = {
        type: "tabpanel",
        tabs: [
          {
            title: "General",
            name: "general",
            items: Po(w)
          },
          Mo(w, "row")
        ]
      }, Ne = {
        type: "panel",
        items: [
          {
            type: "grid",
            columns: 2,
            items: Po(w)
          }
        ]
      };
      w.windowManager.open({
        title: "Row Properties",
        size: "normal",
        body: Fc(w) ? de : Ne,
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: q,
        onSubmit: U(a0, w, an(k, (ft) => ft.dom), q)
      });
    }, Wi = (w, k, F) => {
      const q = F ? [
        {
          type: "input",
          name: "cols",
          label: "Cols",
          inputMode: "numeric"
        },
        {
          type: "input",
          name: "rows",
          label: "Rows",
          inputMode: "numeric"
        }
      ] : [], de = [
        {
          type: "input",
          name: "width",
          label: "Width"
        },
        {
          type: "input",
          name: "height",
          label: "Height"
        }
      ], Ne = Oo(w) ? [
        {
          type: "input",
          name: "cellspacing",
          label: "Cell spacing",
          inputMode: "numeric"
        },
        {
          type: "input",
          name: "cellpadding",
          label: "Cell padding",
          inputMode: "numeric"
        },
        {
          type: "input",
          name: "border",
          label: "Border width"
        },
        {
          type: "label",
          label: "Caption",
          items: [
            {
              type: "checkbox",
              name: "caption",
              label: "Show caption"
            }
          ]
        }
      ] : [], ft = [
        {
          type: "listbox",
          name: "align",
          label: "Alignment",
          items: [
            { text: "None", value: "" },
            { text: "Left", value: "left" },
            { text: "Center", value: "center" },
            { text: "Right", value: "right" }
          ]
        }
      ], Zt = k.length > 0 ? [
        {
          name: "class",
          type: "listbox",
          label: "Class",
          items: k
        }
      ] : [];
      return q.concat(de).concat(Ne).concat(ft).concat(Zt);
    }, Uo = (w, k, F, q) => {
      if (k.tagName === "TD" || k.tagName === "TH")
        nn(F) && Mt(q) ? w.setStyle(k, F, q) : w.setStyles(k, F);
      else if (k.children)
        for (let de = 0; de < k.children.length; de++)
          Uo(w, k.children[de], F, q);
    }, c0 = (w, k, F, q) => {
      const de = w.dom, Ne = {}, ft = {}, Zt = tc(w), Dn = ya(w), Vn = parseFloat(F.border) === 0;
      if (!Tt(F.class) && F.class !== "mce-no-match" && (Ne.class = F.class), ft.height = Yr(F.height), Zt ? ft.width = Yr(F.width) : de.getAttrib(k, "width") && (Ne.width = Sr(F.width)), Zt ? (Vn ? (Ne.border = 0, ft["border-width"] = "") : (ft["border-width"] = Yr(F.border), Ne.border = 1), ft["border-spacing"] = Yr(F.cellspacing)) : (Ne.border = Vn ? 0 : F.border, Ne.cellpadding = F.cellpadding, Ne.cellspacing = F.cellspacing), Zt && k.children) {
        const ss = {};
        if (Vn ? ss["border-width"] = "" : q.border && (ss["border-width"] = Yr(F.border)), q.cellpadding && (ss.padding = Yr(F.cellpadding)), Dn && q.bordercolor && (ss["border-color"] = F.bordercolor), !Io(ss))
          for (let ws = 0; ws < k.children.length; ws++)
            Uo(de, k.children[ws], ss);
      }
      if (Dn) {
        const ss = F;
        ft["background-color"] = ss.backgroundcolor, ft["border-color"] = ss.bordercolor, ft["border-style"] = ss.borderstyle;
      }
      de.setStyles(k, { ...gh(w), ...ft }), de.setAttribs(k, { ...Fr(w), ...Ne });
    }, Ds = (w, k, F, q) => {
      const de = w.dom, Ne = q.getData(), ft = en(Ne, (Zt, Dn) => F[Dn] !== Zt);
      q.close(), w.undoManager.transact(() => {
        if (!k) {
          const Zt = Ka(Ne.cols).getOr(1), Dn = Ka(Ne.rows).getOr(1);
          w.execCommand("mceInsertTable", !1, { rows: Dn, columns: Zt }), k = $l(Qa(w), Vo(w)).bind((Vn) => Rl(Vn, Vo(w))).map((Vn) => Vn.dom).getOrDie();
        }
        if (st(ft) > 0) {
          const Zt = {
            border: no(ft, "border"),
            bordercolor: no(ft, "bordercolor"),
            cellpadding: no(ft, "cellpadding")
          };
          c0(w, k, Ne, Zt);
          const Dn = de.select("caption", k)[0];
          (Dn && !Ne.caption || !Dn && Ne.caption) && w.execCommand("mceTableToggleCaption"), Xm(w, k, Ne.align);
        }
        if (w.focus(), w.addVisual(), st(ft) > 0) {
          const Zt = no(ft, "caption"), Dn = Zt ? st(ft) > 1 : !0;
          Hn(w, k, { structure: Zt, style: Dn });
        }
      });
    }, of = (w, k) => {
      const F = w.dom;
      let q, de = bh(w, ya(w));
      k ? (de.cols = "1", de.rows = "1", ya(w) && (de.borderstyle = "", de.bordercolor = "", de.backgroundcolor = "")) : (q = F.getParent(w.selection.getStart(), "table", w.getBody()), q ? de = BS(w, q, ya(w)) : ya(w) && (de.borderstyle = "", de.bordercolor = "", de.backgroundcolor = ""));
      const Ne = hr(Os(w));
      Ne.isSome() && de.class && (de.class = de.class.replace(/\s*mce\-item\-table\s*/g, ""));
      const ft = {
        type: "grid",
        columns: 2,
        items: Wi(w, Ne.getOr([]), k)
      }, Zt = () => ({
        type: "panel",
        items: [ft]
      }), Dn = () => ({
        type: "tabpanel",
        tabs: [
          {
            title: "General",
            name: "general",
            items: [ft]
          },
          Mo(w, "table")
        ]
      }), Vn = ya(w) ? Dn() : Zt();
      w.windowManager.open({
        title: "Table Properties",
        size: "normal",
        body: Vn,
        onSubmit: U(Ds, w, q, de),
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: de
      });
    }, ar = (w) => {
      const k = (F) => {
        ee(Qa(w)) && F();
      };
      ur({
        // AP-101 TableDialog.open renders a slightly different dialog if isNew is true
        mceTableProps: U(of, w, !1),
        mceTableRowProps: U(ji, w),
        mceTableCellProps: U(Fl, w),
        mceInsertTableDialog: U(of, w, !0)
      }, (F, q) => w.addCommand(q, () => k(F)));
    }, Zi = (w) => ({
      element: w,
      mergable: oe.none(),
      unmergable: oe.none(),
      selection: [w]
    }), ia = (w, k, F) => ({
      element: F,
      mergable: Jr(k, w, ag),
      unmergable: Qr(w),
      selection: Dr(w)
    }), Ou = (w) => {
      const k = Jc(oe.none()), F = Jc([]);
      let q = oe.none();
      const de = Nc("caption"), Ne = (vo) => q.forall((Hs) => !Hs[vo]), ft = () => Hi(Qa(w), Vo(w)), Zt = () => Hi(I(w), Vo(w)), Dn = () => ft().bind((vo) => ga(jm(Rl(vo), Zt().bind(Rl), (Hs, Gs) => Wt(Hs, Gs) ? de(vo) ? oe.some(Zi(vo)) : oe.some(ia(Jp(w), Hs, vo)) : oe.none()))), Vn = (vo) => Rl(vo.element).map((Gs) => {
        const Sa = Zs.fromTable(Gs), Sh = og(Sa, vo).getOr([]), hg = he(Sh, (wh, Eh) => (Eh.isLocked && (wh.onAny = !0, Eh.column === 0 ? wh.onFirst = !0 : Eh.column + Eh.colspan >= Sa.grid.columns && (wh.onLast = !0)), wh), { onAny: !1, onFirst: !1, onLast: !1 });
        return {
          mergeable: Up(Sa, vo).isSome(),
          unmergeable: te(Sa, vo).isSome(),
          locked: hg
        };
      }), ss = () => {
        k.set(mo(Dn)()), q = k.get().bind(Vn), St(F.get(), Ye);
      }, ws = (vo) => (vo(), F.set(F.get().concat([vo])), () => {
        F.set(ot(F.get(), (Hs) => Hs !== vo));
      }), lr = (vo, Hs) => ws(() => k.get().fold(() => {
        vo.setEnabled(!1);
      }, (Gs) => {
        vo.setEnabled(!Hs(Gs) && w.selection.isEditable());
      })), Hc = (vo, Hs, Gs) => ws(() => k.get().fold(() => {
        vo.setEnabled(!1), vo.setActive(!1);
      }, (Sa) => {
        vo.setEnabled(!Hs(Sa) && w.selection.isEditable()), vo.setActive(Gs(Sa));
      })), gi = (vo) => q.exists((Hs) => Hs.locked[vo]), Du = (vo) => lr(vo, (Hs) => !1), Hl = (vo) => lr(vo, (Hs) => de(Hs.element)), l1 = (vo) => (Hs) => lr(Hs, (Gs) => de(Gs.element) || gi(vo)), sf = (vo) => (Hs) => lr(Hs, (Gs) => de(Gs.element) || vo().isNone()), mg = (vo, Hs) => (Gs) => lr(Gs, (Sa) => de(Sa.element) || vo().isNone() || gi(Hs)), fg = (vo) => lr(vo, (Hs) => Ne("mergeable")), gg = (vo) => lr(vo, (Hs) => Ne("unmergeable")), rf = (vo) => Hc(vo, On, (Hs) => Rl(Hs.element, Vo(w)).exists((Sa) => Pe(Sa, "caption"))), xh = (vo, Hs) => (Gs) => Hc(Gs, (Sa) => de(Sa.element), () => w.queryCommandValue(vo) === Hs), o2 = xh("mceTableRowType", "header"), s2 = xh("mceTableColType", "th");
      return w.on("NodeChange ExecCommand TableSelectorChange", ss), {
        onSetupTable: Du,
        onSetupCellOrRow: Hl,
        onSetupColumn: l1,
        onSetupPasteable: sf,
        onSetupPasteableColumn: mg,
        onSetupMergeable: fg,
        onSetupUnmergeable: gg,
        resetTargets: ss,
        onSetupTableWithCaption: rf,
        onSetupTableRowHeaders: o2,
        onSetupTableColumnHeaders: s2,
        targets: k.get
      };
    };
    var vh = tinymce.util.Tools.resolve("tinymce.FakeClipboard");
    const a1 = "x-tinymce/dom-table-", c1 = a1 + "rows", n2 = a1 + "columns", bc = (w) => {
      const k = vh.read() ?? [];
      return Ln(k, (F) => oe.from(F.getType(w)));
    }, fi = () => bc(c1), cr = () => bc(n2), Lr = (w) => (k) => {
      const F = () => {
        k.setEnabled(w.selection.isEditable());
      };
      return w.on("NodeChange", F), F(), () => {
        w.off("NodeChange", F);
      };
    }, yh = (w, k) => {
      w.ui.registry.addMenuButton("table", {
        tooltip: "Table",
        icon: "table",
        onSetup: Lr(w),
        fetch: (Zt) => Zt("inserttable | cell row column | advtablesort | tableprops deletetable")
      });
      const F = (Zt) => () => w.execCommand(Zt), q = (Zt, Dn) => {
        w.queryCommandSupported(Dn.command) && w.ui.registry.addButton(Zt, {
          ...Dn,
          onAction: vn(Dn.onAction) ? Dn.onAction : F(Dn.command)
        });
      }, de = (Zt, Dn) => {
        w.queryCommandSupported(Dn.command) && w.ui.registry.addToggleButton(Zt, {
          ...Dn,
          onAction: vn(Dn.onAction) ? Dn.onAction : F(Dn.command)
        });
      };
      q("tableprops", {
        tooltip: "Table properties",
        command: "mceTableProps",
        icon: "table",
        onSetup: k.onSetupTable
      }), q("tabledelete", {
        tooltip: "Delete table",
        command: "mceTableDelete",
        icon: "table-delete-table",
        onSetup: k.onSetupTable
      }), q("tablecellprops", {
        tooltip: "Cell properties",
        command: "mceTableCellProps",
        icon: "table-cell-properties",
        onSetup: k.onSetupCellOrRow
      }), q("tablemergecells", {
        tooltip: "Merge cells",
        command: "mceTableMergeCells",
        icon: "table-merge-cells",
        onSetup: k.onSetupMergeable
      }), q("tablesplitcells", {
        tooltip: "Split cell",
        command: "mceTableSplitCells",
        icon: "table-split-cells",
        onSetup: k.onSetupUnmergeable
      }), q("tableinsertrowbefore", {
        tooltip: "Insert row before",
        command: "mceTableInsertRowBefore",
        icon: "table-insert-row-above",
        onSetup: k.onSetupCellOrRow
      }), q("tableinsertrowafter", {
        tooltip: "Insert row after",
        command: "mceTableInsertRowAfter",
        icon: "table-insert-row-after",
        onSetup: k.onSetupCellOrRow
      }), q("tabledeleterow", {
        tooltip: "Delete row",
        command: "mceTableDeleteRow",
        icon: "table-delete-row",
        onSetup: k.onSetupCellOrRow
      }), q("tablerowprops", {
        tooltip: "Row properties",
        command: "mceTableRowProps",
        icon: "table-row-properties",
        onSetup: k.onSetupCellOrRow
      }), q("tableinsertcolbefore", {
        tooltip: "Insert column before",
        command: "mceTableInsertColBefore",
        icon: "table-insert-column-before",
        onSetup: k.onSetupColumn(
          "onFirst"
          /* LockedDisable.onFirst */
        )
      }), q("tableinsertcolafter", {
        tooltip: "Insert column after",
        command: "mceTableInsertColAfter",
        icon: "table-insert-column-after",
        onSetup: k.onSetupColumn(
          "onLast"
          /* LockedDisable.onLast */
        )
      }), q("tabledeletecol", {
        tooltip: "Delete column",
        command: "mceTableDeleteCol",
        icon: "table-delete-column",
        onSetup: k.onSetupColumn(
          "onAny"
          /* LockedDisable.onAny */
        )
      }), q("tablecutrow", {
        tooltip: "Cut row",
        command: "mceTableCutRow",
        icon: "cut-row",
        onSetup: k.onSetupCellOrRow
      }), q("tablecopyrow", {
        tooltip: "Copy row",
        command: "mceTableCopyRow",
        icon: "duplicate-row",
        onSetup: k.onSetupCellOrRow
      }), q("tablepasterowbefore", {
        tooltip: "Paste row before",
        command: "mceTablePasteRowBefore",
        icon: "paste-row-before",
        onSetup: k.onSetupPasteable(fi)
      }), q("tablepasterowafter", {
        tooltip: "Paste row after",
        command: "mceTablePasteRowAfter",
        icon: "paste-row-after",
        onSetup: k.onSetupPasteable(fi)
      }), q("tablecutcol", {
        tooltip: "Cut column",
        command: "mceTableCutCol",
        icon: "cut-column",
        onSetup: k.onSetupColumn(
          "onAny"
          /* LockedDisable.onAny */
        )
      }), q("tablecopycol", {
        tooltip: "Copy column",
        command: "mceTableCopyCol",
        icon: "duplicate-column",
        onSetup: k.onSetupColumn(
          "onAny"
          /* LockedDisable.onAny */
        )
      }), q("tablepastecolbefore", {
        tooltip: "Paste column before",
        command: "mceTablePasteColBefore",
        icon: "paste-column-before",
        onSetup: k.onSetupPasteableColumn(
          cr,
          "onFirst"
          /* LockedDisable.onFirst */
        )
      }), q("tablepastecolafter", {
        tooltip: "Paste column after",
        command: "mceTablePasteColAfter",
        icon: "paste-column-after",
        onSetup: k.onSetupPasteableColumn(
          cr,
          "onLast"
          /* LockedDisable.onLast */
        )
      }), q("tableinsertdialog", {
        tooltip: "Insert table",
        command: "mceInsertTableDialog",
        icon: "table",
        onSetup: Lr(w)
      });
      const Ne = Jm(Os(w));
      Ne.length !== 0 && w.queryCommandSupported("mceTableToggleClass") && w.ui.registry.addMenuButton("tableclass", {
        icon: "table-classes",
        tooltip: "Table styles",
        fetch: ku(w, Ne, "tableclass", (Zt) => w.execCommand("mceTableToggleClass", !1, Zt)),
        onSetup: k.onSetupTable
      });
      const ft = Jm(Xr(w));
      ft.length !== 0 && w.queryCommandSupported("mceTableCellToggleClass") && w.ui.registry.addMenuButton("tablecellclass", {
        icon: "table-cell-classes",
        tooltip: "Cell styles",
        fetch: ku(w, ft, "tablecellclass", (Zt) => w.execCommand("mceTableCellToggleClass", !1, Zt)),
        onSetup: k.onSetupCellOrRow
      }), w.queryCommandSupported("mceTableApplyCellStyle") && (w.ui.registry.addMenuButton("tablecellvalign", {
        icon: "vertical-align",
        tooltip: "Vertical align",
        fetch: ku(w, cl, "tablecellverticalalign", Vi(w, "vertical-align")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellborderwidth", {
        icon: "border-width",
        tooltip: "Border width",
        fetch: ku(w, gr(w), "tablecellborderwidth", Vi(w, "border-width")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellborderstyle", {
        icon: "border-style",
        tooltip: "Border style",
        fetch: ku(w, ii(w), "tablecellborderstyle", Vi(w, "border-style")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellbackgroundcolor", {
        icon: "cell-background-color",
        tooltip: "Background color",
        fetch: (Zt) => Zt(hd(w, Ir(w), "background-color")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addMenuButton("tablecellbordercolor", {
        icon: "cell-border-color",
        tooltip: "Border color",
        fetch: (Zt) => Zt(hd(w, or(w), "border-color")),
        onSetup: k.onSetupCellOrRow
      })), de("tablecaption", {
        tooltip: "Table caption",
        icon: "table-caption",
        command: "mceTableToggleCaption",
        onSetup: k.onSetupTableWithCaption
      }), de("tablerowheader", {
        tooltip: "Row header",
        icon: "table-top-header",
        command: "mceTableRowType",
        onAction: pd(w),
        onSetup: k.onSetupTableRowHeaders
      }), de("tablecolheader", {
        tooltip: "Column header",
        icon: "table-left-header",
        command: "mceTableColType",
        onAction: la(w),
        onSetup: k.onSetupTableColumnHeaders
      });
    }, dg = (w) => {
      const k = (q) => w.dom.is(q, "table") && w.getBody().contains(q) && w.dom.isEditable(q.parentNode), F = Bl(w);
      F.length > 0 && w.ui.registry.addContextToolbar("table", {
        predicate: k,
        items: F,
        scope: "node",
        position: "node"
      });
    }, Ch = (w) => (k) => {
      const F = () => {
        k.setEnabled(w.selection.isEditable());
      };
      return w.on("NodeChange", F), F(), () => {
        w.off("NodeChange", F);
      };
    }, l0 = (w, k) => {
      const F = (ws) => () => w.execCommand(ws), q = (ws, lr) => w.queryCommandSupported(lr.command) ? (w.ui.registry.addMenuItem(ws, {
        ...lr,
        onAction: vn(lr.onAction) ? lr.onAction : F(lr.command)
      }), !0) : !1, de = (ws, lr) => {
        w.queryCommandSupported(lr.command) && w.ui.registry.addToggleMenuItem(ws, {
          ...lr,
          onAction: vn(lr.onAction) ? lr.onAction : F(lr.command)
        });
      }, Ne = (ws) => {
        w.execCommand("mceInsertTable", !1, {
          rows: ws.numRows,
          columns: ws.numColumns
        });
      }, ft = [
        q("tableinsertrowbefore", {
          text: "Insert row before",
          icon: "table-insert-row-above",
          command: "mceTableInsertRowBefore",
          onSetup: k.onSetupCellOrRow
        }),
        q("tableinsertrowafter", {
          text: "Insert row after",
          icon: "table-insert-row-after",
          command: "mceTableInsertRowAfter",
          onSetup: k.onSetupCellOrRow
        }),
        q("tabledeleterow", {
          text: "Delete row",
          icon: "table-delete-row",
          command: "mceTableDeleteRow",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablerowprops", {
          text: "Row properties",
          icon: "table-row-properties",
          command: "mceTableRowProps",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablecutrow", {
          text: "Cut row",
          icon: "cut-row",
          command: "mceTableCutRow",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablecopyrow", {
          text: "Copy row",
          icon: "duplicate-row",
          command: "mceTableCopyRow",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablepasterowbefore", {
          text: "Paste row before",
          icon: "paste-row-before",
          command: "mceTablePasteRowBefore",
          onSetup: k.onSetupPasteable(fi)
        }),
        q("tablepasterowafter", {
          text: "Paste row after",
          icon: "paste-row-after",
          command: "mceTablePasteRowAfter",
          onSetup: k.onSetupPasteable(fi)
        })
      ], Zt = [
        q("tableinsertcolumnbefore", {
          text: "Insert column before",
          icon: "table-insert-column-before",
          command: "mceTableInsertColBefore",
          onSetup: k.onSetupColumn(
            "onFirst"
            /* LockedDisable.onFirst */
          )
        }),
        q("tableinsertcolumnafter", {
          text: "Insert column after",
          icon: "table-insert-column-after",
          command: "mceTableInsertColAfter",
          onSetup: k.onSetupColumn(
            "onLast"
            /* LockedDisable.onLast */
          )
        }),
        q("tabledeletecolumn", {
          text: "Delete column",
          icon: "table-delete-column",
          command: "mceTableDeleteCol",
          onSetup: k.onSetupColumn(
            "onAny"
            /* LockedDisable.onAny */
          )
        }),
        q("tablecutcolumn", {
          text: "Cut column",
          icon: "cut-column",
          command: "mceTableCutCol",
          onSetup: k.onSetupColumn(
            "onAny"
            /* LockedDisable.onAny */
          )
        }),
        q("tablecopycolumn", {
          text: "Copy column",
          icon: "duplicate-column",
          command: "mceTableCopyCol",
          onSetup: k.onSetupColumn(
            "onAny"
            /* LockedDisable.onAny */
          )
        }),
        q("tablepastecolumnbefore", {
          text: "Paste column before",
          icon: "paste-column-before",
          command: "mceTablePasteColBefore",
          onSetup: k.onSetupPasteableColumn(
            cr,
            "onFirst"
            /* LockedDisable.onFirst */
          )
        }),
        q("tablepastecolumnafter", {
          text: "Paste column after",
          icon: "paste-column-after",
          command: "mceTablePasteColAfter",
          onSetup: k.onSetupPasteableColumn(
            cr,
            "onLast"
            /* LockedDisable.onLast */
          )
        })
      ], Dn = [
        q("tablecellprops", {
          text: "Cell properties",
          icon: "table-cell-properties",
          command: "mceTableCellProps",
          onSetup: k.onSetupCellOrRow
        }),
        q("tablemergecells", {
          text: "Merge cells",
          icon: "table-merge-cells",
          command: "mceTableMergeCells",
          onSetup: k.onSetupMergeable
        }),
        q("tablesplitcells", {
          text: "Split cell",
          icon: "table-split-cells",
          command: "mceTableSplitCells",
          onSetup: k.onSetupUnmergeable
        })
      ];
      rl(w) ? w.ui.registry.addNestedMenuItem("inserttable", {
        text: "Table",
        icon: "table",
        getSubmenuItems: () => [{ type: "fancymenuitem", fancytype: "inserttable", onAction: Ne }],
        onSetup: Ch(w)
      }) : w.ui.registry.addMenuItem("inserttable", {
        text: "Table",
        icon: "table",
        onAction: F("mceInsertTableDialog"),
        onSetup: Ch(w)
      }), w.ui.registry.addMenuItem("inserttabledialog", {
        text: "Insert table",
        icon: "table",
        onAction: F("mceInsertTableDialog"),
        onSetup: Ch(w)
      }), q("tableprops", {
        text: "Table properties",
        onSetup: k.onSetupTable,
        command: "mceTableProps"
      }), q("deletetable", {
        text: "Delete table",
        icon: "table-delete-table",
        onSetup: k.onSetupTable,
        command: "mceTableDelete"
      }), X(ft, !0) && w.ui.registry.addNestedMenuItem("row", {
        type: "nestedmenuitem",
        text: "Row",
        getSubmenuItems: Xe("tableinsertrowbefore tableinsertrowafter tabledeleterow tablerowprops | tablecutrow tablecopyrow tablepasterowbefore tablepasterowafter")
      }), X(Zt, !0) && w.ui.registry.addNestedMenuItem("column", {
        type: "nestedmenuitem",
        text: "Column",
        getSubmenuItems: Xe("tableinsertcolumnbefore tableinsertcolumnafter tabledeletecolumn | tablecutcolumn tablecopycolumn tablepastecolumnbefore tablepastecolumnafter")
      }), X(Dn, !0) && w.ui.registry.addNestedMenuItem("cell", {
        type: "nestedmenuitem",
        text: "Cell",
        getSubmenuItems: Xe("tablecellprops tablemergecells tablesplitcells")
      }), w.ui.registry.addContextMenu("table", {
        update: () => (k.resetTargets(), k.targets().fold(Xe(""), (ws) => Or(ws.element) === "caption" ? "tableprops deletetable" : "cell row column | advtablesort | tableprops deletetable"))
      });
      const Vn = Jm(Os(w));
      Vn.length !== 0 && w.queryCommandSupported("mceTableToggleClass") && w.ui.registry.addNestedMenuItem("tableclass", {
        icon: "table-classes",
        text: "Table styles",
        getSubmenuItems: () => pr(w, Vn, "tableclass", (ws) => w.execCommand("mceTableToggleClass", !1, ws)),
        onSetup: k.onSetupTable
      });
      const ss = Jm(Xr(w));
      ss.length !== 0 && w.queryCommandSupported("mceTableCellToggleClass") && w.ui.registry.addNestedMenuItem("tablecellclass", {
        icon: "table-cell-classes",
        text: "Cell styles",
        getSubmenuItems: () => pr(w, ss, "tablecellclass", (ws) => w.execCommand("mceTableCellToggleClass", !1, ws)),
        onSetup: k.onSetupCellOrRow
      }), w.queryCommandSupported("mceTableApplyCellStyle") && (w.ui.registry.addNestedMenuItem("tablecellvalign", {
        icon: "vertical-align",
        text: "Vertical align",
        getSubmenuItems: () => pr(w, cl, "tablecellverticalalign", Vi(w, "vertical-align")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellborderwidth", {
        icon: "border-width",
        text: "Border width",
        getSubmenuItems: () => pr(w, gr(w), "tablecellborderwidth", Vi(w, "border-width")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellborderstyle", {
        icon: "border-style",
        text: "Border style",
        getSubmenuItems: () => pr(w, ii(w), "tablecellborderstyle", Vi(w, "border-style")),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellbackgroundcolor", {
        icon: "cell-background-color",
        text: "Background color",
        getSubmenuItems: () => hd(w, Ir(w), "background-color"),
        onSetup: k.onSetupCellOrRow
      }), w.ui.registry.addNestedMenuItem("tablecellbordercolor", {
        icon: "cell-border-color",
        text: "Border color",
        getSubmenuItems: () => hd(w, or(w), "border-color"),
        onSetup: k.onSetupCellOrRow
      })), de("tablecaption", {
        icon: "table-caption",
        text: "Table caption",
        command: "mceTableToggleCaption",
        onSetup: k.onSetupTableWithCaption
      }), de("tablerowheader", {
        text: "Row header",
        icon: "table-top-header",
        command: "mceTableRowType",
        onAction: pd(w),
        onSetup: k.onSetupTableRowHeaders
      }), de("tablecolheader", {
        text: "Column header",
        icon: "table-left-header",
        command: "mceTableColType",
        onAction: la(w),
        onSetup: k.onSetupTableRowHeaders
      });
    }, Ll = (w) => {
      const k = Ou(w);
      Ml(w), ar(w), l0(w, k), yh(w, k), dg(w);
    };
    var $S = () => {
      V.add("table", Ll);
    };
    $S();
  }()), CQ;
}
var SQ;
function TJ() {
  return SQ || (SQ = 1, EJ()), yQ;
}
TJ();
var wQ = {}, EQ = {}, TQ;
function kJ() {
  return TQ || (TQ = 1, function() {
    var V = tinymce.util.Tools.resolve("tinymce.PluginManager");
    const me = (De, et) => {
      De.focus(), De.undoManager.transact(() => {
        De.setContent(et);
      }), De.selection.setCursorLocation(), De.nodeChanged();
    }, pt = (De) => De.getContent({ source_view: !0 }), rt = (De) => {
      const et = pt(De);
      De.windowManager.open({
        title: "Source Code",
        size: "large",
        body: {
          type: "panel",
          items: [
            {
              type: "textarea",
              name: "code",
              spellcheck: !1
            }
          ]
        },
        buttons: [
          {
            type: "cancel",
            name: "cancel",
            text: "Cancel"
          },
          {
            type: "submit",
            name: "save",
            text: "Save",
            primary: !0
          }
        ],
        initialData: {
          code: et
        },
        onSubmit: (Tt) => {
          me(De, Tt.getData().code), Tt.close();
        }
      });
    }, Nt = (De) => {
      De.addCommand("mceCodeEditor", () => {
        rt(De);
      });
    }, mt = (De) => {
      const et = () => De.execCommand("mceCodeEditor");
      De.ui.registry.addButton("code", {
        icon: "sourcecode",
        tooltip: "Source code",
        onAction: et
      }), De.ui.registry.addMenuItem("code", {
        icon: "sourcecode",
        text: "Source code",
        onAction: et
      });
    };
    var nn = () => {
      V.add("code", (De) => (Nt(De), mt(De), {}));
    };
    nn();
  }()), EQ;
}
var kQ;
function AJ() {
  return kQ || (kQ = 1, kJ()), wQ;
}
AJ();
const _J = FQ(
  () => import("./index-CJTfH1_L.js").then((V) => ({ default: V.Editor }))
);
function OJ({
  value: V,
  onChange: me,
  disabled: pt = !1
}) {
  const rt = MY(
    () => ({
      height: 500,
      menubar: !1,
      statusbar: !1,
      branding: !1,
      promotion: !1,
      plugins: [
        "lists",
        "link",
        "image",
        "table",
        "code"
      ],
      toolbar: "undo redo | bold italic underline | bullist numlist | table | link image | code",
      table_toolbar: "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol",
      content_style: `
        body {
          font-family: Inter, system-ui, sans-serif;
          font-size: 14px;
        }
      `
    }),
    []
  );
  return /* @__PURE__ */ ie.jsx(
    LQ,
    {
      fallback: /* @__PURE__ */ ie.jsx("div", { className: "p-3 text-sm text-gray-400 border rounded-lg", children: "Loading editor…" }),
      children: /* @__PURE__ */ ie.jsx(
        _J,
        {
          licenseKey: "gpl",
          value: V,
          disabled: pt,
          onEditorChange: me,
          init: rt
        }
      )
    }
  );
}
function JN({
  field: V,
  formik: me,
  methods: pt = {},
  sqlOpsUrls: rt,
  refid: Nt,
  module_refid: mt = "menuManager.main",
  optionsOverride: nn,
  setFieldOptions: De
}) {
  const {
    setHighlightedIndex: et,
    executeFieldMethod: Tt,
    handleFileUpload: $n,
    handleKeyDown: Mt,
    handleToggle: vn,
    setSearch: Cn,
    setOpen: pn,
    setIsFocused: un,
    handleInputChange: Xe,
    handleSelect: In,
    handlePersist: lt,
    optionCount: U,
    baseInputClasses: Ye,
    focusClasses: On,
    labelClasses: Ot,
    search: oe,
    highlightedIndex: Yt,
    options: Gn,
    isDisabled: jt,
    key: X,
    filteredOptions: se,
    open: ns,
    listRef: an,
    detailsRef: St,
    isFocused: A
  } = aJ({
    field: V,
    formik: me,
    methods: pt,
    sqlOpsUrls: rt,
    refid: Nt,
    module_refid: mt,
    ...nn && { optionsOverride: nn },
    ...De && { setFieldOptions: De }
  }), No = (ot) => ot.icon ? /* @__PURE__ */ ie.jsx("i", { className: ot.icon }) : null;
  switch (V.type) {
    case "suggest":
    case "autosuggest":
    case "autocomplete": {
      const he = me.values[X] ?? "", ue = oe !== "" ? oe : PY(Gn, he) ?? String(he ?? "");
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsx(
          "input",
          {
            className: `${Ye} ${On}`,
            value: ue,
            placeholder: V.placeholder || "Type to search...",
            onChange: Xe,
            onBlur: () => {
              setTimeout(() => pn(!1), 150);
            },
            onKeyDown: (bt) => {
              if (bt.key === "Enter") {
                if (bt.preventDefault(), se[Yt]) {
                  const [cn] = se[Yt];
                  me.setFieldValue(X, cn), lt(cn, V, mt);
                } else oe.trim() && (me.setFieldValue(X, oe.trim()), lt(oe.trim(), V, mt));
                pn(!1);
                return;
              }
              Mt(bt, !0);
            },
            disabled: jt
          }
        ),
        ns && !jt && /* @__PURE__ */ ie.jsx(
          "div",
          {
            ref: an,
            className: "absolute z-20 w-full bg-white border rounded shadow max-h-52 overflow-y-auto mt-1",
            children: se.length > 0 ? se.map(([bt, cn], fn) => /* @__PURE__ */ ie.jsx(
              "div",
              {
                id: `${X}-${bt}`,
                "data-index": fn,
                className: `px-3 py-2 cursor-pointer text-sm
                  ${Yt === fn ? "bg-gray-100" : "hover:bg-gray-100"}`,
                onMouseDown: () => In(bt),
                children: cn
              },
              bt
            )) : /* @__PURE__ */ ie.jsx("div", { className: "px-3 py-2 text-sm text-gray-400", children: `Press "ENTER" to ADD "${ue}" ` })
          }
        ),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    }
    case "dataSelector":
    case "dataSelectorFromTable":
    case "dataSelectorFromUniques":
    case "dataMethod": {
      if (V.multiple === !0) {
        const he = me.values[X];
        return /* @__PURE__ */ ie.jsx(
          GX,
          {
            field: V,
            isDisabled: jt,
            handleToggle: vn,
            detailsRef: St,
            handleKeyDown: Mt,
            valueArray: he,
            labelClasses: Ot,
            listRef: an,
            search: oe,
            filteredOptions: se,
            highlightedIndex: Yt,
            setSearch: Cn,
            formik: me,
            executeFieldMethod: Tt,
            setHighlightedIndex: et,
            handlePersist: lt,
            module_refid: mt,
            options: Gn
          }
        );
      }
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs(
          "details",
          {
            className: `relative w-full ${jt ? "opacity-70" : ""}`,
            onToggle: vn,
            ref: St,
            onKeyDown: (he) => {
              jt || Mt(he, !0);
            },
            children: [
              /* @__PURE__ */ ie.jsxs(
                "summary",
                {
                  className: `
    select-none border rounded-lg px-4 py-2.5 flex justify-between items-center
    ${jt ? "bg-gray-100 border-gray-200 text-gray-500 cursor-not-allowed" : "bg-white border-gray-300 cursor-pointer"}
  `,
                  children: [
                    /* @__PURE__ */ ie.jsx("span", { className: "text-sm text-gray-700", children: me.values[X] ? PY(Gn, me.values[X]) ?? "Select option" : `Select ${V.label}` }),
                    /* @__PURE__ */ ie.jsx(
                      "svg",
                      {
                        className: "w-4 h-4 text-gray-500",
                        fill: "none",
                        stroke: "currentColor",
                        viewBox: "0 0 24 24",
                        children: /* @__PURE__ */ ie.jsx(
                          "path",
                          {
                            strokeLinecap: "round",
                            strokeLinejoin: "round",
                            strokeWidth: 2,
                            d: "M19 9l-7 7-7-7"
                          }
                        )
                      }
                    )
                  ]
                }
              ),
              !jt && /* @__PURE__ */ ie.jsxs("div", { ref: an, className: "absolute mt-1 w-full border border-gray-200 rounded-lg bg-white shadow-md z-10 max-h-60 overflow-y-auto p-2", children: [
                V.search && /* @__PURE__ */ ie.jsx("div", { className: "sticky top-0 bg-white p-1", children: /* @__PURE__ */ ie.jsx(
                  "input",
                  {
                    type: "text",
                    value: oe,
                    onChange: (he) => {
                      Cn(he.target.value), et(0);
                    },
                    onKeyDown: (he) => Mt(he, !0),
                    placeholder: "Search...",
                    className: `px-2 py-[5px] rounded w-full border border-gray-200 transition-all duration-300 
                  bg-white/80 backdrop-blur-sm text-gray-800 placeholder-gray-400
                  focus:outline-none focus:ring-0`
                  }
                ) }),
                se.length > 0 && /* @__PURE__ */ ie.jsx(
                  "div",
                  {
                    onClick: (he) => {
                      he.preventDefault(), he.stopPropagation(), me.setFieldValue(X, ""), lt("", V, mt), St.current?.removeAttribute("open"), Cn("");
                    },
                    className: "px-2 py-1 hover:bg-gray-50 rounded cursor-pointer text-sm hover:bg-gray-50",
                    children: "Clear selection"
                  }
                ),
                se.length > 0 ? se.map(([he, ue], bt) => /* @__PURE__ */ ie.jsx(
                  "div",
                  {
                    id: `${X}-${he}`,
                    "data-index": bt,
                    onClick: (cn) => {
                      cn.preventDefault(), cn.stopPropagation(), me.setFieldValue(X, he), lt(he, V, mt), St.current?.removeAttribute("open"), Cn(""), et(0), Tt("onChange", V, `${X}-${he}`);
                    },
                    className: `px-2 py-1 hover:bg-gray-50 rounded cursor-pointer text-sm 
                        ${me.values[X] === he ? "bg-indigo-50 text-indigo-600 font-medium" : Yt === bt ? "bg-gray-100" : "hover:bg-gray-50"}`,
                    children: ue
                  },
                  he
                )) : /* @__PURE__ */ ie.jsx("div", { className: "px-2 py-1 text-gray-400 text-sm", children: "No results" })
              ] })
            ]
          }
        ),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500 ml-2", children: String(me.errors[X]) })
      ] });
    }
    case "richtextarea":
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsx(
          OJ,
          {
            value: me.values[X] ?? "",
            disabled: jt,
            onChange: (he) => {
              me.setFieldValue(X, he), lt(he, V, mt), Tt("onChange", V, X);
            }
          }
        ),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    case "textarea":
      return /* @__PURE__ */ ie.jsx(ie.Fragment, { children: /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ ie.jsx(
            "textarea",
            {
              id: X,
              className: `${Ye} ${On} min-h-[120px] resize-none`,
              onFocus: () => un(!0),
              name: X,
              value: me.values[X],
              onBlur: me.handleBlur,
              onChange: (he) => {
                me.setFieldValue(X, he.target.value), lt(he.target.value, V, mt), Tt("onChange", V, `${X}`);
              },
              placeholder: V.placeholder,
              disabled: jt
            }
          ),
          /* @__PURE__ */ ie.jsx("div", { className: `absolute inset-0 rounded-lg bg-gradient-to-r from-purple-400 to-indigo-400 opacity-0 transition-opacity duration-300 pointer-events-none ${A ? "opacity-20" : ""}`, style: { zIndex: -1, filter: "blur(8px)" } })
        ] }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] }) });
    case "select":
      if (V.multiple === !0) {
        const he = me.values[X];
        return /* @__PURE__ */ ie.jsx(
          GX,
          {
            field: V,
            isDisabled: jt,
            handleToggle: vn,
            detailsRef: St,
            handleKeyDown: Mt,
            valueArray: he,
            labelClasses: Ot,
            listRef: an,
            search: oe,
            filteredOptions: se,
            highlightedIndex: Yt,
            setSearch: Cn,
            formik: me,
            executeFieldMethod: Tt,
            setHighlightedIndex: et,
            handlePersist: lt,
            module_refid: mt,
            options: Gn
          }
        );
      }
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ ie.jsxs(
            "select",
            {
              className: `${Ye} ${On} appearance-none ${jt ? "" : "cursor-pointer"} pr-12`,
              onFocus: () => un(!0),
              name: X,
              id: X,
              value: me.values[X],
              onBlur: me.handleBlur,
              onChange: (he) => {
                me.setFieldValue(X, he.target.value), lt(he.target.value, V, mt), Tt("onChange", V, `${X}`);
              },
              disabled: jt,
              children: [
                /* @__PURE__ */ ie.jsx("option", { value: "", disabled: !0, children: V?.["no-option"] || `Please select ${V.label}` }),
                !WX(Gn) && Object.entries(Gn).map(([he, ue]) => /* @__PURE__ */ ie.jsx("option", { value: he, className: "py-2", children: ue }, he)),
                WX(Gn) && Object.entries(Gn).map(([he, ue]) => /* @__PURE__ */ ie.jsx("optgroup", { label: he, children: Object.entries(ue).map(([bt, cn]) => /* @__PURE__ */ ie.jsx("option", { value: bt, children: cn }, bt)) }, he))
              ]
            }
          ),
          /* @__PURE__ */ ie.jsx("div", { className: "absolute right-4 top-1/2 transform -translate-y-1/2 pointer-events-none", children: /* @__PURE__ */ ie.jsx(
            "svg",
            {
              className: "w-5 h-5 transition-colors duration-300 text-gray-400",
              fill: "none",
              stroke: "currentColor",
              viewBox: "0 0 24 24",
              children: /* @__PURE__ */ ie.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
            }
          ) })
        ] }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    case "radioList":
    case "radio":
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsx("div", { className: `flex ${U > 3 ? "flex-col" : ""} gap-2 ml-1`, children: Object.entries(Gn || {}).map(([he, ue]) => /* @__PURE__ */ ie.jsxs(
          "label",
          {
            htmlFor: `${X}-${he}`,
            className: "flex items-center gap-x-2 text-sm font-medium text-gray-700 cursor-pointer",
            children: [
              /* @__PURE__ */ ie.jsx(
                "input",
                {
                  id: `${X}-${he}`,
                  type: "radio",
                  name: X,
                  checked: me.values[X] === he,
                  value: he,
                  onChange: (bt) => {
                    me.setFieldValue(X, bt.target.value), lt(bt.target.value, V, mt), Tt("onChange", V, `${X}-${he}`);
                  },
                  onBlur: me.handleBlur,
                  disabled: jt,
                  className: `h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500
                    ${jt ? "bg-gray-100 border-gray-200 text-gray-500 cursor-not-allowed" : ""}
                    `
                }
              ),
              ue
            ]
          },
          he
        )) }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500 ml-2", children: String(me.errors[X]) })
      ] });
    case "checkbox": {
      const he = me.values[X];
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsx("div", { className: "flex flex-col gap-2 ml-1", children: Object.entries(Gn || {}).map(([ue, bt]) => /* @__PURE__ */ ie.jsxs(
          "label",
          {
            className: "flex items-center gap-x-2 text-sm font-medium text-gray-700 cursor-pointer",
            children: [
              /* @__PURE__ */ ie.jsx(
                "input",
                {
                  id: `${X}-${ue}`,
                  type: "checkbox",
                  checked: he.includes(ue),
                  onChange: (cn) => {
                    const fn = cn.target.checked ? [...he, ue] : he.filter((Fn) => Fn !== ue);
                    me.setFieldValue(X, fn), lt(fn, V, mt), Tt("onChange", V, `${X}-${ue}`);
                  },
                  onBlur: me.handleBlur,
                  disabled: jt,
                  className: `h-4 w-4 text-indigo-600 border-gray-300 rounded focus:ring-indigo-500
                    ${jt ? "bg-gray-100 border-gray-200 text-gray-500 cursor-not-allowed" : ""}
                    `
                }
              ),
              bt
            ]
          },
          ue
        )) }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500 ml-2", children: String(me.errors[X]) })
      ] });
    }
    case "tags": {
      const he = me.values[X], ue = oe.trim(), bt = Array.isArray(Gn) ? Gn : Object.entries(Gn || {}).map(([ye, He]) => ({ value: ye, label: He })), cn = (ye) => {
        if (!jt && ye && !he.includes(ye)) {
          let He = [...he, ye];
          me.setFieldValue(X, He), lt(He, V, mt), Cn("");
        }
      }, fn = (ye) => {
        let He = he.filter((P) => P !== ye);
        me.setFieldValue(
          X,
          He
        ), lt(He, V, mt);
      }, Fn = (ye) => bt.find((He) => He.value === ye)?.label ?? ye;
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs(
          "div",
          {
            className: `${Ye} 
            flex flex-wrap gap-2 min-h-[42px] max-h-[120px] overflow-y-auto items-center
            ${jt ? "pointer-events-none opacity-70" : ""}
            `,
            onClick: () => !jt && document.getElementById(`${X}-input`)?.focus(),
            children: [
              he.map((ye) => /* @__PURE__ */ ie.jsxs(
                "span",
                {
                  className: "flex items-center gap-2 px-2 py-1 rounded-full text-sm bg-indigo-50 border border-indigo-100",
                  children: [
                    /* @__PURE__ */ ie.jsx("span", { className: "text-indigo-700", children: Fn(ye) }),
                    /* @__PURE__ */ ie.jsx(
                      "button",
                      {
                        type: "button",
                        onClick: (He) => {
                          He.stopPropagation(), jt || fn(ye);
                        },
                        onMouseDown: (He) => He.preventDefault(),
                        className: "ml-1 text-indigo-500 hover:text-red-500 focus:outline-none",
                        children: "×"
                      }
                    )
                  ]
                },
                ye
              )),
              /* @__PURE__ */ ie.jsx(
                "input",
                {
                  id: `${X}-input`,
                  type: "text",
                  value: oe,
                  onChange: (ye) => Cn(ye.target.value),
                  onKeyDown: (ye) => {
                    (ye.key === "Enter" || ye.key === ",") && (ye.preventDefault(), cn(ue));
                  },
                  placeholder: he.length === 0 ? V.placeholder || "Type and press Enter" : "",
                  className: "flex-1 min-w-[120px] border-none outline-none text-sm bg-transparent p-1",
                  disabled: jt
                }
              )
            ]
          }
        ),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    }
    case "photo":
    case "avatar":
      return /* @__PURE__ */ ie.jsx(
        PQ,
        {
          formik: me,
          field: V,
          sqlOpsUrls: rt,
          module_refid: mt
        }
      );
    case "attachment":
    case "file":
      const ot = V.multiple === !0, jo = Array.isArray(me.values[X]) ? me.values[X] : me.values[X] ? [me.values[X]] : [];
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { className: "relative mb-1", children: [
          V.icon && /* @__PURE__ */ ie.jsx("div", { className: "absolute z-10 left-3 top-1/2 -translate-y-1/2 pointer-events-none", children: No(V) }),
          /* @__PURE__ */ ie.jsx(
            "input",
            {
              id: X,
              type: "file",
              className: `${Ye} ${On} ${V.icon ? "pl-9" : ""} `,
              onFocus: () => un(!0),
              name: X,
              multiple: ot,
              onChange: (he) => {
                const ue = he.currentTarget.files;
                ue && $n(ue), Tt("onChange", V, `${X}`);
              },
              onBlur: me.handleBlur,
              placeholder: V.placeholder,
              disabled: jt
            }
          ),
          /* @__PURE__ */ ie.jsx("div", { className: `absolute inset-0 rounded-lg bg-gradient-to-r from-purple-400 to-indigo-400 opacity-0 transition-opacity duration-300 pointer-events-none ${A ? "opacity-20" : ""}`, style: { zIndex: -1, filter: "blur(8px)" } })
        ] }),
        jo.map((he) => {
          const ue = he?.split("/").pop();
          return /* @__PURE__ */ ie.jsx(iJ, { sqlOpsUrls: rt, filePath: he }, ue);
        }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    case "json":
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
          /* @__PURE__ */ ie.jsx(
            "textarea",
            {
              id: X,
              name: X,
              value: me.values[X],
              onChange: (he) => {
                me.setFieldValue(X, he.target.value), lt(he.target.value, V, mt), Tt("onChange", V, `${X}`);
              },
              onBlur: me.handleBlur,
              placeholder: V.placeholder || "Enter valid JSON",
              disabled: jt,
              className: `${Ye} ${On} min-h-[200px] font-mono text-sm resize-y`
            }
          ),
          /* @__PURE__ */ ie.jsx(
            "div",
            {
              className: `absolute inset-0 rounded-lg bg-gradient-to-r from-emerald-400 to-cyan-400 opacity-0 transition-opacity duration-300 pointer-events-none ${A ? "opacity-20" : ""}`,
              style: { zIndex: -1, filter: "blur(8px)" }
            }
          )
        ] }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    case "date":
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs(
          "div",
          {
            className: "relative",
            children: [
              /* @__PURE__ */ ie.jsx("div", { className: "absolute z-10 right-3 top-1/2 -translate-y-1/2 pointer-events-none", children: /* @__PURE__ */ ie.jsx("i", { className: "fa-solid fa-calendar" }) }),
              /* @__PURE__ */ ie.jsx(
                "input",
                {
                  id: X,
                  type: "date",
                  name: X,
                  min: V.min,
                  max: V.max,
                  value: me.values[X],
                  onChange: (he) => {
                    me.setFieldValue(X, he.target.value), lt(he.target.value, V, mt), Tt("onChange", V, `${X}`);
                  },
                  onBlur: me.handleBlur,
                  placeholder: V.placeholder,
                  disabled: jt,
                  className: `${Ye} ${On} ${V.icon ? "pl-9" : ""}`
                }
              ),
              /* @__PURE__ */ ie.jsx(
                "div",
                {
                  className: `absolute inset-0 rounded-lg bg-gradient-to-r from-purple-400 to-indigo-400 opacity-0 transition-opacity duration-300 pointer-events-none ${A ? "opacity-20" : ""}`,
                  style: { zIndex: -1, filter: "blur(8px)" }
                }
              )
            ]
          }
        ),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    case "number":
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
          V.icon && /* @__PURE__ */ ie.jsx("div", { className: "absolute z-10 left-3 top-1/2 -translate-y-1/2 pointer-events-none", children: No(V) }),
          /* @__PURE__ */ ie.jsx(
            "input",
            {
              id: X,
              type: "number",
              className: `${Ye} ${On} ${V.icon ? "pl-9" : ""} `,
              onFocus: () => un(!0),
              name: X,
              value: me.values[X],
              onBlur: me.handleBlur,
              onChange: (he) => {
                me.setFieldValue(X, he.target.value), lt(he.target.value, V, mt), Tt("onChange", V, `${X}`);
              },
              step: V.step,
              placeholder: V.placeholder,
              disabled: jt,
              min: V.min ?? 1,
              max: V.max
            }
          ),
          /* @__PURE__ */ ie.jsx("div", { className: `absolute inset-0 rounded-lg bg-gradient-to-r from-purple-400 to-indigo-400 opacity-0 transition-opacity duration-300 pointer-events-none ${A ? "opacity-20" : ""}`, style: { zIndex: -1, filter: "blur(8px)" } })
        ] }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
    default:
      return /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
        /* @__PURE__ */ ie.jsxs("label", { className: Ot, children: [
          V.label,
          V.required && /* @__PURE__ */ ie.jsx("span", { className: "text-red-500 ml-1", children: "*" })
        ] }),
        /* @__PURE__ */ ie.jsxs("div", { className: "relative", children: [
          V.icon && /* @__PURE__ */ ie.jsx("div", { className: "absolute z-10 left-3 top-1/2 -translate-y-1/2 pointer-events-none", children: No(V) }),
          /* @__PURE__ */ ie.jsx(
            "input",
            {
              id: X,
              type: V.type || "text",
              className: `${Ye} ${On} ${V.icon ? "pl-9" : ""} `,
              onFocus: () => un(!0),
              name: X,
              value: me.values[X],
              onBlur: me.handleBlur,
              onChange: (he) => {
                me.setFieldValue(X, he.target.value), lt(he.target.value, V, mt), Tt("onChange", V, `${X}`);
              },
              step: V.step,
              placeholder: V.placeholder,
              disabled: jt,
              minLength: V.minlength,
              maxLength: V.maxlength
            }
          ),
          /* @__PURE__ */ ie.jsx("div", { className: `absolute inset-0 rounded-lg bg-gradient-to-r from-purple-400 to-indigo-400 opacity-0 transition-opacity duration-300 pointer-events-none ${A ? "opacity-20" : ""}`, style: { zIndex: -1, filter: "blur(8px)" } })
        ] }),
        me.touched[X] && me.errors[X] && /* @__PURE__ */ ie.jsx("span", { className: "text-xs text-red-500", children: String(me.errors[X]) })
      ] });
  }
}
function AQ({ title: V, children: me, isFirst: pt }) {
  const [rt, Nt] = qb(pt);
  return /* @__PURE__ */ ie.jsx("div", { className: "group relative mt-1", children: /* @__PURE__ */ ie.jsxs("div", { className: "relative bg-white rounded-lg border border-gray-100 shadow-xs hover:shadow-sm transition-all duration-300 overflow-hidden ", children: [
    /* @__PURE__ */ ie.jsxs(
      "button",
      {
        onClick: () => Nt(!rt),
        className: "w-full bg-gray-50 flex justify-between items-center px-6 py-3 b text-left transition-all duration-300 ",
        children: [
          /* @__PURE__ */ ie.jsxs("div", { className: "flex items-center space-x-3", children: [
            /* @__PURE__ */ ie.jsx("div", { className: `w-3 h-3 rounded-full transition-all duration-300 ${rt ? "bg-action" : "bg-gray-300"}` }),
            /* @__PURE__ */ ie.jsx("h3", { className: "text-md font-semibold bg-gradient-to-r from-gray-800 to-gray-600 bg-clip-text text-transparent", children: V })
          ] }),
          /* @__PURE__ */ ie.jsxs("div", { className: `relative transition-all duration-300 ${rt ? "rotate-180" : ""}`, children: [
            /* @__PURE__ */ ie.jsx("div", { className: `absolute inset-0 rounded-full blur-md transition-opacity duration-300 ${rt ? "bg-action opacity-30" : "bg-transparent opacity-0"}` }),
            /* @__PURE__ */ ie.jsx(
              "svg",
              {
                className: "relative w-4 h-4 text-gray-500 group-hover:text-action-500 transition-colors duration-300",
                fill: "none",
                stroke: "currentColor",
                viewBox: "0 0 24 24",
                children: /* @__PURE__ */ ie.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" })
              }
            )
          ] })
        ]
      }
    ),
    /* @__PURE__ */ ie.jsx(
      "div",
      {
        className: `transition-all duration-500 ease-in-out overflow-hidden  ${rt ? "max-h-[2000px] opacity-100" : "max-h-0 opacity-0"}`,
        children: /* @__PURE__ */ ie.jsx("div", { className: "px-6 pb-6 bg-gradient-to-br from-gray-50/50 to-white overflow-auto mb-5", children: /* @__PURE__ */ ie.jsx("div", { className: "space-y-5 pt-4", children: me }) })
      }
    )
  ] }) });
}
function h7({
  fields: V,
  formik: me,
  methods: pt = {},
  sqlOpsUrls: rt,
  refid: Nt,
  module_refid: mt,
  fieldOptions: nn,
  setFieldOptions: De
}) {
  return /* @__PURE__ */ ie.jsx("div", { className: "bg-white min-h-3/10 overflow-auto", children: /* @__PURE__ */ ie.jsxs("div", { className: "grid grid-cols-1 lg:grid-cols-12 gap-6", children: [
    /* @__PURE__ */ ie.jsx("div", { className: "lg:col-span-2 flex flex-col ", children: /* @__PURE__ */ ie.jsx("div", { className: "relative w-42 h-42 ", children: V?.filter((et) => et.type === "avatar").map((et) => /* @__PURE__ */ ie.jsx(
      PQ,
      {
        formik: me,
        field: et,
        sqlOpsUrls: rt,
        module_refid: mt
      }
    )) }) }),
    /* @__PURE__ */ ie.jsx("div", { className: "lg:col-span-10 min-h-0 max-h-40  overflow-y-auto custom-scrollbar", children: /* @__PURE__ */ ie.jsx("div", { className: "grid grid-cols-12 gap-2", children: V?.map((et, Tt) => et.type === "avatar" ? null : /* @__PURE__ */ ie.jsx("div", { className: `transition-colors duration-200 col-span-12 md:col-span-6 ${XN[QN(Number(et.width))] || "lg:col-span-4"}`, children: /* @__PURE__ */ ie.jsx(
      JN,
      {
        refid: Nt,
        module_refid: mt,
        sqlOpsUrls: rt,
        field: et,
        formik: me,
        methods: pt,
        setFieldOptions: De,
        ...nn?.[et.name] ? { optionsOverride: nn[et.name] } : {}
      },
      et?.name || Tt
    ) }, et.name)) }) })
  ] }) });
}
function DJ({
  title: V,
  groupedFields: me,
  data: pt,
  onSubmit: rt = ($n) => {
  },
  onCancel: Nt = () => {
  },
  methods: mt = {},
  components: nn = {},
  sqlOpsUrls: De,
  refid: et,
  module_refid: Tt
}) {
  const { common: $n = [], ...Mt } = me, [vn, Cn] = Xd.useState({}), pn = (lt, U) => {
    Cn((Ye) => ({
      ...Ye,
      [lt]: U
    }));
  }, { initialValues: un, validationSchema: Xe } = Xd.useMemo(() => {
    const lt = {}, U = {};
    return Object.values(me).flat().forEach((Ye) => {
      YN([Ye], lt, U, pt, Tt, De?.operation);
    }), {
      initialValues: lt,
      validationSchema: U
    };
  }, [me, pt, Tt, De?.operation]), In = f7({
    initialValues: un,
    enableReinitialize: !0,
    validationSchema: pu.object().shape(Xe),
    onSubmit: (lt) => {
      rt(lt);
    }
  });
  return /* @__PURE__ */ ie.jsx("div", { className: "relative z-10 max-w-full  m-4", children: /* @__PURE__ */ ie.jsx("div", { className: "bg-white border border-gray-100 rounded-md animate-in fade-in duration-300", children: /* @__PURE__ */ ie.jsxs("form", { onSubmit: In.handleSubmit, className: "p-4 mx-auto", children: [
    /* @__PURE__ */ ie.jsxs("div", { className: "space-y-2", children: [
      $n.length > 0 && /* @__PURE__ */ ie.jsx(AQ, { title: "Common", isFirst: !0, children: /* @__PURE__ */ ie.jsx(
        h7,
        {
          refid: et,
          module_refid: Tt,
          sqlOpsUrls: De,
          fields: $n,
          formik: In,
          methods: mt,
          setFieldOptions: pn,
          fieldOptions: vn
        }
      ) }),
      Mt && Object.entries(Mt).map(([lt, U], Ye) => /* @__PURE__ */ ie.jsx(AQ, { title: lt, isFirst: Ye === 0 && $n.length === 0, children: /* @__PURE__ */ ie.jsx("div", { className: "grid grid-cols-12 gap-4", children: U.map((On, Ot) => g7(On.hidden) || On.type === "geolocation" ? null : /* @__PURE__ */ ie.jsx(
        "div",
        {
          className: `col-span-12 md:col-span-6 ${XN[QN(Number(On.width))] || "lg:col-span-4"}`,
          children: /* @__PURE__ */ ie.jsx(
            JN,
            {
              refid: et,
              module_refid: Tt,
              sqlOpsUrls: De,
              components: nn,
              field: On,
              formik: In,
              methods: mt,
              setFieldOptions: pn,
              ...vn[On.name] ? { optionsOverride: vn[On.name] } : {}
            },
            On.name
          )
        },
        On?.name ?? `field-${Ot}`
      )) }) }, lt))
    ] }),
    /* @__PURE__ */ ie.jsxs("div", { className: "mt-8 flex justify-between space-x-3", children: [
      /* @__PURE__ */ ie.jsx("p", { className: "text-sm text-gray-700", children: "All fields marked (*) are required" }),
      /* @__PURE__ */ ie.jsxs("div", { className: "space-x-3", children: [
        /* @__PURE__ */ ie.jsx("button", { type: "button", onClick: Nt, className: "px-5 py-2 bg-white text-gray-700 font-semibold rounded-lg border-2 border-gray-200  shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 ", children: "Cancel" }),
        /* @__PURE__ */ ie.jsx("button", { type: "submit", className: "px-5 py-2 bg-action font-semibold rounded-lg border-2 border-gray-200 shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 ", children: "Save" })
      ] })
    ] })
  ] }) }) });
}
function RJ({
  title: V,
  groupedFields: me,
  data: pt,
  onSubmit: rt = (Mt) => {
  },
  onCancel: Nt = () => {
  },
  methods: mt = {},
  components: nn = {},
  sqlOpsUrls: De,
  widget: et,
  refid: Tt,
  module_refid: $n
}) {
  const { common: Mt = [], ...vn } = me, Cn = Object.keys(vn), [pn, un] = Xd.useState(0), [Xe, In] = Xd.useState({}), lt = (X, se) => {
    In((ns) => ({
      ...ns,
      [X]: se
    }));
  }, { initialValues: U, validationSchema: Ye, stepperSchemas: On } = Xd.useMemo(() => {
    const X = {}, se = {}, ns = {};
    return et ? Object.entries(me).forEach(([an, St]) => {
      const A = {};
      YN(St, X, A, pt, $n, De?.operation), ns[an] = A;
    }) : Object.entries(me).forEach(([an, St]) => {
      YN(St, X, se, pt, $n, De?.operation);
    }), {
      initialValues: X,
      validationSchema: se,
      stepperSchemas: ns
    };
  }, [me, pt, et, $n, De?.operation]), Ot = Cn[pn] ?? null, oe = et && Ot ? On[Ot] ?? {} : Ye, Yt = f7({
    initialValues: U,
    enableReinitialize: !0,
    validationSchema: pu.object().shape(oe),
    onSubmit: (X) => {
      et ? (pn < Cn.length - 1 && un((se) => se + 1), pn === Cn.length - 1 && rt(X)) : rt(X);
    }
  }), Gn = async (X) => {
    if (X.preventDefault(), !et) {
      const se = await Yt.validateForm();
      if (Object.keys(se).length > 0) {
        alert("Please fill all required fields before submitting."), Yt.setTouched(
          Object.keys(se).reduce((ns, an) => ({ ...ns, [an]: !0 }), {})
        );
        return;
      }
    }
    Yt.handleSubmit(X);
  }, jt = () => {
    un((X) => X > 0 ? X - 1 : X);
  };
  return /* @__PURE__ */ ie.jsx("div", { className: " max-w-full  m-4", children: /* @__PURE__ */ ie.jsxs("form", { onSubmit: Gn, className: "w-full mx-auto", children: [
    /* @__PURE__ */ ie.jsx("div", { className: "relative", children: /* @__PURE__ */ ie.jsxs("div", { className: "relative  rounded-t-lg px-1 pt-1  shadow-inner", children: [
      Mt.length > 0 && /* @__PURE__ */ ie.jsx("div", { className: "p-3", children: /* @__PURE__ */ ie.jsx(
        h7,
        {
          refid: Tt,
          module_refid: $n,
          sqlOpsUrls: De,
          fields: Mt,
          formik: Yt,
          methods: mt,
          setFieldOptions: lt,
          fieldOptions: Xe
        }
      ) }),
      /* @__PURE__ */ ie.jsx("nav", { className: "relative flex bg-gray-100", children: Cn.map((X, se) => /* @__PURE__ */ ie.jsx(
        "button",
        {
          type: "button",
          onClick: () => un(se),
          className: `relative cursor-pointer flex-shrink-0 py-2 px-2 sm:px-4 rounded-t-lg  text-xs sm:text-sm font-semibold transition-all duration-300 ease-out focus:outline-none whitespace-nowrap ${pn === se ? "text-action bg-white" : "text-gray-600 hover:text-gray-800 hover:bg-white/50"}`,
          children: /* @__PURE__ */ ie.jsx("span", { className: "relative z-10 flex items-center justify-center gap-2 capitalize", children: X })
        },
        X
      )) })
    ] }) }),
    /* @__PURE__ */ ie.jsxs(
      "div",
      {
        className: "bg-white  border border-gray-100 border-t-0 rounded-b-lg p-3 animate-in fade-in duration-300",
        children: [
          /* @__PURE__ */ ie.jsx("div", { className: "grid grid-cols-12 gap-4", children: Ot && vn[Ot]?.map((X, se) => g7(X.hidden) || X.type === "geolocation" ? null : /* @__PURE__ */ ie.jsx(
            "div",
            {
              className: `col-span-12  ${XN[QN(Number(X.width))] || "lg:col-span-4"}`,
              children: /* @__PURE__ */ ie.jsx(
                JN,
                {
                  refid: Tt,
                  module_refid: $n,
                  sqlOpsUrls: De,
                  field: X,
                  formik: Yt,
                  methods: mt,
                  components: nn,
                  setFieldOptions: lt,
                  ...Xe[X.name] ? { optionsOverride: Xe[X.name] } : {}
                },
                X.name
              )
            },
            X?.name ?? `field-${se}`
          )) }),
          /* @__PURE__ */ ie.jsxs("div", { className: `mt-8 flex ${pn > 0 ? "justify-between" : "justify-end"} space-x-3`, children: [
            pn > 0 && /* @__PURE__ */ ie.jsx("button", { onClick: jt, type: "button", className: "px-5 py-2 bg-white text-gray-700 font-semibold rounded-lg border-2 border-gray-200  shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 ", children: "Previous" }),
            /* @__PURE__ */ ie.jsxs("div", { className: "space-x-3", children: [
              /* @__PURE__ */ ie.jsx("button", { onClick: Nt, type: "button", className: "px-5 cursor-pointer py-2 bg-white text-gray-700 font-semibold rounded-lg border-2 border-gray-200  shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 ", children: "Cancel" }),
              /* @__PURE__ */ ie.jsx("button", { type: "submit", className: "px-5 cursor-pointer py-2 bg-action font-semibold rounded-lg border-2 border-gray-200 shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 ", children: et ? "Next" : "Save" })
            ] })
          ] }),
          /* @__PURE__ */ ie.jsx("div", { className: "mt-2 pt-3  border-t border-gray-100", children: /* @__PURE__ */ ie.jsxs("div", { className: "flex items-center justify-between text-sm text-gray-500", children: [
            /* @__PURE__ */ ie.jsxs("div", { className: "flex items-center", children: [
              /* @__PURE__ */ ie.jsxs("span", { children: [
                "Tab ",
                pn + 1,
                " of ",
                Cn.length
              ] }),
              /* @__PURE__ */ ie.jsx("p", { className: "text-sm text-gray-700 ml-3", children: "All fields marked (*) are required" })
            ] }),
            /* @__PURE__ */ ie.jsx("div", { className: "flex gap-1", children: Cn.map((X, se) => /* @__PURE__ */ ie.jsx(
              "div",
              {
                className: `w-2 h-2 rounded-full transition-all duration-300 ${se === pn ? "bg-action w-6" : "bg-gray-300"}`
              },
              se
            )) })
          ] }) })
        ]
      },
      Cn[pn]
    )
  ] }) });
}
function NJ({
  title: V,
  fields: me,
  data: pt,
  onSubmit: rt = (Tt) => {
  },
  onCancel: Nt = () => {
  },
  methods: mt = {},
  sqlOpsUrls: nn,
  refid: De,
  module_refid: et
}) {
  const Tt = QQ(me, nn?.operation), [$n, Mt] = Xd.useState({}), vn = (lt, U) => {
    Mt((Ye) => ({
      ...Ye,
      [lt]: U
    }));
  }, { commonFields: Cn, otherFields: pn } = Xd.useMemo(() => Tt.reduce(
    (lt, U) => (U.group === "common" ? lt.commonFields.push(U) : lt.otherFields.push(U), lt),
    { commonFields: [], otherFields: [] }
  ), [Tt]), { initialValues: un, validationSchema: Xe } = Xd.useMemo(() => {
    const lt = {}, U = {};
    return Tt.forEach((Ye) => {
      YN([Ye], lt, U, pt, et, nn?.operation);
    }), {
      initialValues: lt,
      validationSchema: U
    };
  }, [Tt, pt]), In = f7({
    initialValues: un,
    enableReinitialize: !0,
    validationSchema: pu.object().shape(Xe),
    onSubmit: (lt) => {
      rt(lt);
    }
  });
  return /* @__PURE__ */ ie.jsx(ie.Fragment, { children: /* @__PURE__ */ ie.jsx("div", { className: "relative z-10 max-w-full  m-4", children: /* @__PURE__ */ ie.jsx("div", { className: "bg-white border border-gray-100 rounded-md animate-in fade-in duration-300", children: /* @__PURE__ */ ie.jsxs("form", { onSubmit: In.handleSubmit, className: "p-4  mx-auto", children: [
    Cn.length > 0 && /* @__PURE__ */ ie.jsx(
      h7,
      {
        refid: De,
        module_refid: et,
        sqlOpsUrls: nn,
        fields: Cn,
        formik: In,
        methods: mt,
        setFieldOptions: vn,
        fieldOptions: $n
      }
    ),
    /* @__PURE__ */ ie.jsx("div", { className: "grid grid-cols-12 gap-4", children: pn.map((lt, U) => g7(lt.hidden) || lt.type === "geolocation" ? null : /* @__PURE__ */ ie.jsx(
      "div",
      {
        className: `col-span-12 md:col-span-6 ${XN[QN(Number(lt.width))] || "lg:col-span-4"}`,
        children: /* @__PURE__ */ ie.jsx(
          JN,
          {
            refid: De,
            module_refid: et,
            sqlOpsUrls: nn,
            field: lt,
            formik: In,
            methods: mt,
            setFieldOptions: vn,
            ...$n[lt.name] ? { optionsOverride: $n[lt.name] } : {}
          }
        )
      },
      lt?.name ?? `field-${U}`
    )) }),
    /* @__PURE__ */ ie.jsxs("div", { className: "mt-8 flex justify-between space-x-3", children: [
      /* @__PURE__ */ ie.jsx("p", { className: "text-sm text-gray-700", children: "All fields marked (*) are required" }),
      /* @__PURE__ */ ie.jsxs("div", { className: "space-x-3", children: [
        /* @__PURE__ */ ie.jsx("button", { type: "button", onClick: Nt, className: "px-5 py-2 bg-white text-gray-700 font-semibold rounded-lg border-2 border-gray-200  shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 cursor-pointer", children: "Cancel" }),
        /* @__PURE__ */ ie.jsx("button", { type: "submit", className: "px-5 py-2 bg-action font-semibold rounded-lg border-2 border-gray-200 shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 cursor-pointer", children: "Save" })
      ] })
    ] })
  ] }) }) }) });
}
function _Q({ title: V, children: me }) {
  return /* @__PURE__ */ ie.jsx("div", { className: "group relative mt-1", children: /* @__PURE__ */ ie.jsxs("div", { className: "relative bg-white rounded-lg border border-gray-100 shadow-sm hover:shadow-lg transition-all duration-300 overflow-hidden ", children: [
    /* @__PURE__ */ ie.jsx(
      "button",
      {
        className: "w-full bg-gray-50 flex justify-between items-center px-6 py-3 b text-left transition-all duration-300 ",
        children: /* @__PURE__ */ ie.jsxs("div", { className: "flex items-center space-x-3", children: [
          /* @__PURE__ */ ie.jsx("div", { className: "w-3 h-3 rounded-full transition-all duration-300 bg-action" }),
          /* @__PURE__ */ ie.jsx("h3", { className: "text-md font-semibold bg-gradient-to-r from-gray-800 to-gray-600 bg-clip-text text-transparent", children: V })
        ] })
      }
    ),
    /* @__PURE__ */ ie.jsx(
      "div",
      {
        className: `transition-all duration-500 ease-in-out overflow-hidden max-h-[2000px] opacity-100'
            }`,
        children: /* @__PURE__ */ ie.jsx("div", { className: "px-4 pb-4 bg-gradient-to-br from-gray-50/50 to-white", children: /* @__PURE__ */ ie.jsx("div", { className: "space-y-5 pt-4", children: me }) })
      }
    )
  ] }) });
}
function MJ({
  title: V,
  groupedFields: me,
  data: pt,
  onSubmit: rt = ($n) => {
  },
  onCancel: Nt = () => {
  },
  methods: mt = {},
  components: nn = {},
  sqlOpsUrls: De,
  refid: et,
  module_refid: Tt
}) {
  const { common: $n = [], ...Mt } = me, [vn, Cn] = Xd.useState({}), pn = (lt, U) => {
    Cn((Ye) => ({
      ...Ye,
      [lt]: U
    }));
  }, { initialValues: un, validationSchema: Xe } = Xd.useMemo(() => {
    const lt = {}, U = {};
    return Object.values(me).flat().forEach((Ye) => {
      YN([Ye], lt, U, pt, Tt, De?.operation);
    }), {
      initialValues: lt,
      validationSchema: U
    };
  }, [me, pt, Tt, De?.operation]), In = f7({
    initialValues: un,
    enableReinitialize: !0,
    validationSchema: pu.object().shape(Xe),
    onSubmit: (lt) => {
      rt(lt);
    }
  });
  return /* @__PURE__ */ ie.jsx("div", { className: "relative z-10 max-w-full  m-4", children: /* @__PURE__ */ ie.jsx("div", { className: "bg-white animate-in fade-in duration-300", children: /* @__PURE__ */ ie.jsxs("form", { onSubmit: In.handleSubmit, className: "p-4 mx-auto", children: [
    /* @__PURE__ */ ie.jsxs("div", { className: "space-y-2", children: [
      $n.length > 0 && /* @__PURE__ */ ie.jsx(_Q, { title: "Common", children: /* @__PURE__ */ ie.jsx(
        h7,
        {
          refid: et,
          module_refid: Tt,
          sqlOpsUrls: De,
          fields: $n,
          formik: In,
          methods: mt,
          setFieldOptions: pn,
          fieldOptions: vn
        }
      ) }),
      Mt && Object.entries(Mt).map(([lt, U], Ye) => /* @__PURE__ */ ie.jsx(_Q, { title: lt, children: /* @__PURE__ */ ie.jsx("div", { className: "grid grid-cols-12 gap-4", children: U.map((On, Ot) => g7(On.hidden) || On.type === "geolocation" ? null : /* @__PURE__ */ ie.jsx(
        "div",
        {
          className: `col-span-12 md:col-span-6 ${XN[QN(Number(On.width))] || "lg:col-span-4"}`,
          children: /* @__PURE__ */ ie.jsx(
            JN,
            {
              refid: et,
              module_refid: Tt,
              sqlOpsUrls: De,
              components: nn,
              field: On,
              formik: In,
              methods: mt,
              setFieldOptions: pn,
              ...vn[On.name] ? { optionsOverride: vn[On.name] } : {}
            },
            On.name
          )
        },
        On?.name ?? `field-${Ot}`
      )) }) }, lt))
    ] }),
    /* @__PURE__ */ ie.jsxs("div", { className: "mt-8 flex justify-between space-x-3", children: [
      /* @__PURE__ */ ie.jsx("p", { className: "px-4 pt-4 text-sm text-secondary", children: "All fields marked (*) are required" }),
      /* @__PURE__ */ ie.jsxs("div", { className: "space-x-3", children: [
        /* @__PURE__ */ ie.jsx("button", { type: "button", onClick: Nt, className: "px-5 py-2 bg-white text-gray-700 font-semibold rounded-lg border-2 border-gray-200  shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 ", children: "Cancel" }),
        /* @__PURE__ */ ie.jsx("button", { type: "submit", className: "px-5 py-2 bg-action font-semibold rounded-lg border-2 border-gray-200 shadow-sm hover:shadow-lg transform hover:scale-105 transition-all duration-300 ", children: "Save" })
      ] })
    ] })
  ] }) }) });
}
function IJ({
  formJson: V,
  methods: me = {},
  userid: pt = null,
  onCancel: rt = () => {
  },
  components: Nt = {},
  callback: mt = () => {
  },
  initialvalues: nn = {}
}) {
  let De = GQ(V);
  const et = V.endPoints, Tt = V?.source?.refid, $n = qQ(V?.fields ?? {}, et?.operation), [Mt, vn] = Xd.useState(nn), Cn = Xd.useMemo(() => XQ(V.fields), [V.fields]);
  Xd.useEffect(() => {
    let Xe = !0;
    return (async () => {
      const lt = V?.source ?? {};
      if (!lt?.type) {
        Xe && vn({});
        return;
      }
      if (lt.type === "method") {
        const U = lt.method, Ye = U ? me[U] : void 0;
        if (Ye)
          try {
            const On = await Promise.resolve(Ye());
            Xe && vn(On ?? {});
          } catch (On) {
            console.error("Method execution failed:", On), Xe && vn({});
          }
        else
          Xe && vn({});
      }
      if (lt.type === "api" && et?.operation !== "create")
        try {
          const U = await bu({
            method: lt.method || "GET",
            url: lt.url ?? "",
            data: lt.body ?? {},
            params: lt.params ?? {},
            headers: lt.headers ?? {}
          });
          Xe && vn(U.data ?? {});
        } catch (U) {
          console.error("API fetch failed:", U), Xe && vn({});
        }
      if (lt.type === "sql" && lt.refid && lt.refid !== "0" && et?.operation !== "create" || et?.operation !== "create" && lt.dbopsid) {
        if (!et) {
          console.error("SQL source requires formJson.endPoints but it is missing");
          return;
        }
        try {
          const U = await rJ.fetch(et, {
            source: {
              ...lt,
              table: lt.table,
              columns: lt.columns,
              where: Kb(lt.where, {
                refid: Tt
              })
            },
            fields: jX(V.fields, et.operation)
          }, lt?.dbopsid, V?.module_refid);
          Xe && vn(U);
        } catch (U) {
          console.error("API fetch failed:", U);
        }
      }
    })(), () => {
      Xe = !1;
    };
  }, [
    pt,
    V?.source?.type || "",
    V?.source?.method || "",
    V?.source?.url || "",
    JSON.stringify(V?.source?.params ?? {}),
    JSON.stringify(V?.source?.body ?? {}),
    JSON.stringify(V?.source?.headers ?? {})
  ]);
  const pn = async (Xe) => {
    const In = V?.source ?? {};
    let lt = null;
    if (Cn.length > 0)
      try {
        lt = await YQ();
      } catch (Ye) {
        console.error("catch fetchGeolocation", Ye), lt = null;
      }
    const U = {
      ...Xe,
      ...Object.fromEntries(
        Cn.map((Ye) => [Ye, lt])
      )
    };
    if (In.type === "method") {
      const Ye = In.method, On = Ye ? me[Ye] : void 0;
      if (On)
        try {
          const Ot = await Promise.resolve(On(U));
          if (mt?.(Ot), me?.handleActions) {
            let oe = et?.operation === "update" ? Tt : Ot?.data?.refid;
            const Yt = V?.gotolink?.replace(
              "{hashid}",
              String(oe)
            );
            me.handleActions(Yt);
          }
        } catch (Ot) {
          mt?.(Ot), console.error("Method execution failed:", Ot);
        }
    }
    if (In.type === "api") {
      if (!et) {
        console.error("SQL source requires formJson.endPoints but it is missing");
        return;
      }
      try {
        const Ye = await bu({
          method: In.method || "POST",
          url: et.baseURL + In.endpoint,
          data: U ?? {},
          headers: {
            Authorization: `Bearer ${et?.accessToken}`
          }
        });
        if (mt?.(Ye), me?.handleActions) {
          let On = et.operation === "update" ? Tt : Ye?.data?.refid;
          const Ot = V?.gotolink?.replace(
            "{hashid}",
            String(On)
          );
          me.handleActions(Ot);
        }
      } catch (Ye) {
        mt?.(Ye), console.error("API fetch failed:", Ye);
      }
    }
    if (In.type === "sql") {
      const Ye = V.endPoints;
      if (!Ye) {
        console.error("SQL source requires formJson.endPoints but it is missing");
        return;
      }
      try {
        let On = !1, Ot;
        In?.dbopsid && (On = !0, Ot = In?.dbopsid);
        const oe = await bu({
          method: "GET",
          url: Ye.baseURL + Ye.dbopsGetHash,
          headers: {
            Authorization: `Bearer ${Ye?.accessToken}`
          }
        });
        if (!On) {
          let Gn = {
            ...In
          };
          In.where && (Gn = {
            ...In,
            where: Kb(In.where, {
              refid: Tt
            })
          }), Ot = (await bu({
            method: "POST",
            url: Ye.baseURL + Ye.dbopsGetRefId,
            data: {
              operation: Ye.operation,
              source: Gn,
              fields: jX(V.fields, Ye.operation),
              forcefill: V.forcefill,
              datahash: oe.data.refhash,
              srcid: V?.module_refid
            },
            headers: {
              Authorization: `Bearer ${Ye?.accessToken}`
            }
          }))?.data.refid;
        }
        const Yt = await bu({
          method: "POST",
          url: Ye.baseURL + Ye[Ye.operation === "update" ? "dbopsUpdate" : "dbopsCreate"],
          data: {
            refid: Ot,
            fields: U,
            datahash: oe.data.refhash
          },
          headers: {
            Authorization: `Bearer ${Ye?.accessToken}`
          }
        });
        if (mt?.(Yt), me?.handleActions) {
          let Gn = Ye.operation === "update" ? Tt : Yt?.data?.refid;
          const jt = V?.gotolink?.replace(
            "{hashid}",
            String(Gn)
          );
          me.handleActions(jt);
        }
      } catch (On) {
        mt?.(On), console.error("API fetch failed:", On);
      }
    }
  }, un = {
    accordion: /* @__PURE__ */ ie.jsx(
      DJ,
      {
        title: V?.title ?? "",
        groupedFields: $n,
        data: Mt,
        onSubmit: pn,
        onCancel: rt,
        methods: me,
        components: Nt,
        sqlOpsUrls: et,
        refid: Tt,
        module_refid: V?.module_refid
      }
    ),
    cards: /* @__PURE__ */ ie.jsx(
      MJ,
      {
        title: V?.title ?? "",
        groupedFields: $n,
        data: Mt,
        onSubmit: pn,
        onCancel: rt,
        methods: me,
        components: Nt,
        sqlOpsUrls: et,
        refid: Tt,
        module_refid: V?.module_refid
      }
    ),
    tab: /* @__PURE__ */ ie.jsx(
      RJ,
      {
        title: V?.title ?? "",
        groupedFields: $n,
        data: Mt,
        onSubmit: pn,
        onCancel: rt,
        methods: me,
        components: Nt,
        widget: V?.widget,
        sqlOpsUrls: et,
        refid: Tt,
        module_refid: V?.module_refid
      }
    ),
    simple: /* @__PURE__ */ ie.jsx(
      NJ,
      {
        title: V?.title ?? "",
        fields: V.fields,
        data: Mt,
        onSubmit: pn,
        onCancel: rt,
        methods: me,
        components: Nt,
        sqlOpsUrls: et,
        refid: Tt,
        module_refid: V?.module_refid
      }
    )
  };
  return /* @__PURE__ */ ie.jsx("div", { className: "relative", children: un[De] });
}
export {
  IJ as LogiksForm
};
